{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ArchiPy Documentation","text":"<p>ArchiPy is a Python framework designed to provide a standardized, scalable, and maintainable architecture for modern applications. Built with Python 3.13+, it offers a suite of tools, utilities, and best practices to streamline development workflows while adhering to clean architecture principles and modern Python practices.</p>"},{"location":"#goals","title":"Goals","text":"<p>ArchiPy is built with the following objectives in mind:</p> <ol> <li>Database Integration - Provide robust, type-safe database adapters for PostgreSQL, SQLite, and StarRocks</li> <li>Configuration Management - Simplify and standardize configuration handling with validation</li> <li>Service Integration - Offer ready-to-use adapters for common services (Redis, Email, Keycloak, MinIO, Kafka)</li> <li>Data Standardization - Enforce consistency in data modeling with modern type hints</li> <li>Development Efficiency - Provide comprehensive utilities and helpers for common tasks</li> <li>Quality Assurance - Enable robust testing and code quality enforcement</li> </ol>"},{"location":"#features","title":"Features","text":"<ul> <li>Database Integration: Dedicated adapters for PostgreSQL, SQLite, and StarRocks with SQLAlchemy integration</li> <li>Configuration Management: Type-safe configuration with environment variable support</li> <li>Service Adapters: Pre-built adapters for Redis, Email, Keycloak, MinIO, and Kafka</li> <li>Payment Processing: Payment gateway adapters for online transaction processing</li> <li>Data Standardization: Base entities, DTOs, and modern type hints</li> <li>Helper Utilities: Decorators, interceptors, and security utilities</li> <li>Testing &amp; Quality: BDD testing and automated code quality tools</li> <li>Performance &amp; Scalability: Connection pooling, caching, and async support</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation Guide</li> <li>Architecture Overview</li> <li>API Reference</li> <li>Examples</li> <li>Contributing</li> </ul>"},{"location":"architecture/","title":"ArchiPy Architecture","text":""},{"location":"architecture/#overview","title":"Overview","text":"<p>ArchiPy is organized into four main modules, each serving a specific purpose in creating structured, maintainable Python applications:</p> <ol> <li>Adapters: External service integrations</li> <li>Configs: Configuration management</li> <li>Helpers: Utility functions and support classes</li> <li>Models: Core data structures</li> </ol> <p>This architecture follows clean architecture principles, separating concerns and ensuring that dependencies point inward toward the domain core.</p>"},{"location":"architecture/#modules","title":"Modules","text":""},{"location":"architecture/#adapters","title":"Adapters","text":"<p>The <code>adapters</code> module provides implementations for external service integrations, following the Ports and Adapters pattern (Hexagonal Architecture). This module includes:</p> <ul> <li> <p>Base Adapters: Core implementations and interfaces</p> <ul> <li>SQLAlchemy base components</li> <li>Common adapter patterns</li> <li>Base session management</li> </ul> </li> <li> <p>Database Adapters: Database-specific implementations</p> <ul> <li>PostgreSQL</li> <li>SQLite</li> <li>StarRocks</li> <li>Each with their own SQLAlchemy integration</li> </ul> </li> <li> <p>Service Adapters: External service integrations</p> <ul> <li>Email service adapters</li> <li>External API clients</li> <li>File storage adapters (MinIO)</li> <li>Message brokers (Kafka)</li> <li>Caching systems (Redis)</li> </ul> </li> </ul> <p>Each adapter includes both concrete implementations and corresponding mocks for testing.</p>"},{"location":"architecture/#configs","title":"Configs","text":"<p>The <code>configs</code> module manages configuration loading, validation, and injection. It provides:</p> <ul> <li>Environment-based configuration</li> <li>Type-safe configuration through Pydantic models</li> <li>Centralized access to configuration values</li> <li>Support for various configuration sources (environment variables, files, etc.)</li> </ul>"},{"location":"architecture/#helpers","title":"Helpers","text":"<p>The <code>helpers</code> module contains utility functions and classes to simplify common development tasks. It includes several subgroups:</p> <ul> <li>Utils: General utility functions for dates, strings, errors, files, etc.</li> <li>Decorators: Function and class decorators for aspects like logging, timing, and deprecation</li> <li>Interceptors: Classes for cross-cutting concerns like logging, tracing, and validation</li> <li>Validators: Data validation utilities</li> </ul>"},{"location":"architecture/#models","title":"Models","text":"<p>The <code>models</code> module defines the core data structures used throughout the application:</p> <ul> <li>Entities: Domain model objects</li> <li>DTOs: Data Transfer Objects for API input/output</li> <li>Errors: Custom exception classes</li> <li>Types: Type definitions and enumerations</li> </ul>"},{"location":"architecture/#architectural-flow","title":"Architectural Flow","text":"<p>ArchiPy applications follow a clean architecture approach where:</p> <ol> <li>The Models module forms the core domain layer</li> <li>The Helpers module provides supporting functionality</li> <li>The Configs module manages application configuration</li> <li>The Adapters module interfaces with external systems</li> </ol> <p>This modular organization promotes separation of concerns, making ArchiPy applications easier to test, maintain, and extend over time.</p>"},{"location":"architecture/#design-philosophy","title":"Design Philosophy","text":"<p>ArchiPy is designed to standardize and simplify Python application development by providing a flexible set of building blocks that work across different architectural approaches. Rather than enforcing a single architectural pattern, ArchiPy offers components that can be applied to:</p> <ul> <li>Layered Architecture</li> <li>Hexagonal Architecture (Ports &amp; Adapters)</li> <li>Clean Architecture</li> <li>Domain-Driven Design</li> <li>Service-Oriented Architecture</li> <li>And more...</li> </ul> <p>These building blocks help maintain consistency, testability, and maintainability regardless of the specific architectural style chosen for your project.</p>"},{"location":"architecture/#core-building-blocks","title":"Core Building Blocks","text":""},{"location":"architecture/#configuration-management","title":"Configuration Management","text":"<p>ArchiPy provides a standardized way to manage configuration across your application:</p> <pre><code>from archipy.configs.base_config import BaseConfig\n\nclass AppConfig(BaseConfig):\n    DATABASE = {\n        \"HOST\": \"localhost\",\n        \"PORT\": 5432,\n        \"USERNAME\": \"user\",\n        \"PASSWORD\": \"password\"\n    }\n\n    DEBUG = True\n\n# Set global configuration\nconfig = AppConfig()\nBaseConfig.set_global(config)\n</code></pre>"},{"location":"architecture/#adapters-ports","title":"Adapters &amp; Ports","text":"<p>ArchiPy implements the ports and adapters pattern to isolate the application core from external dependencies:</p> <pre><code># Port: defines an interface (contract)\nfrom typing import Protocol\n\nclass UserRepositoryPort(Protocol):\n    def get_by_id(self, user_id: str) -&gt; User: ...\n    def create(self, user: User) -&gt; User: ...\n\n# Adapter: implements the interface for a specific technology\nclass SqlAlchemyUserRepository:\n    def __init__(self, db_adapter: SqlAlchemyAdapter):\n        self.db_adapter = db_adapter\n\n    def get_by_id(self, user_id: str) -&gt; User:\n        return self.db_adapter.get_by_uuid(User, user_id)\n\n    def create(self, user: User) -&gt; User:\n        return self.db_adapter.create(user)\n\n# Application core uses the port, not the adapter\nclass UserService:\n    def __init__(self, repository: UserRepositoryPort):\n        self.repository = repository\n\n    def get_user(self, user_id: str) -&gt; User:\n        return self.repository.get_by_id(user_id)\n</code></pre>"},{"location":"architecture/#entity-models","title":"Entity Models","text":"<p>Standardized entity models provide a consistent approach to domain modeling:</p> <pre><code>from sqlalchemy import Column, String\nfrom archipy.models.entities import BaseEntity\n\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n\n    name = Column(String(100))\n    email = Column(String(255), unique=True)\n</code></pre>"},{"location":"architecture/#data-transfer-objects-dtos","title":"Data Transfer Objects (DTOs)","text":"<p>Define consistent data structures for transferring data between layers:</p> <pre><code>from pydantic import BaseModel, EmailStr\nfrom archipy.models.dtos import BaseDTO\n\nclass UserCreateDTO(BaseDTO):\n    name: str\n    email: EmailStr\n\nclass UserResponseDTO(BaseDTO):\n    id: str\n    name: str\n    email: EmailStr\n    created_at: datetime\n</code></pre>"},{"location":"architecture/#example-architectures","title":"Example Architectures","text":""},{"location":"architecture/#layered-architecture","title":"Layered Architecture","text":"<p>ArchiPy can be used with a traditional layered architecture approach:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     Presentation      \u2502  API, UI, CLI\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     Application       \u2502  Services, Workflows\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502       Domain          \u2502  Business Logic, Entities\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    Infrastructure     \u2502  Adapters, Repositories, External Services\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#clean-architecture","title":"Clean Architecture","text":"<p>ArchiPy supports Clean Architecture principles:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Entities                    \u2502\n\u2502     Domain models, business rules            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                  Use Cases                   \u2502\n\u2502     Application services, business workflows \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                 Interfaces                   \u2502\n\u2502     Controllers, presenters, gateways        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                Frameworks                    \u2502\n\u2502     External libraries, UI, DB, devices      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#hexagonal-architecture","title":"Hexagonal Architecture","text":"<p>For projects using a Hexagonal (Ports &amp; Adapters) approach:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                                   \u2502\n\u2502                 Application Core                  \u2502\n\u2502                                                   \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502                                             \u2502  \u2502\n\u2502  \u2502           Domain Logic / Models             \u2502  \u2502\n\u2502  \u2502                                             \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                                   \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502             \u2502         \u2502                     \u2502  \u2502\n\u2502  \u2502  Input      \u2502         \u2502  Output Ports       \u2502  \u2502\n\u2502  \u2502  Ports      \u2502         \u2502                     \u2502  \u2502\n\u2502  \u2502             \u2502         \u2502                     \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u25b2                           \u25b2\n        \u2502                           \u2502\n        \u2502                           \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  \u2502      \u2502                     \u2502\n\u2502  Input Adapters  \u2502      \u2502  Output Adapters    \u2502\n\u2502  (Controllers)   \u2502      \u2502  (Repositories,     \u2502\n\u2502                  \u2502      \u2502   Clients, etc.)    \u2502\n\u2502                  \u2502      \u2502                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#practical-implementation","title":"Practical Implementation","text":"<p>Let's see how a complete application might be structured using ArchiPy:</p> <pre><code>my_app/\n\u251c\u2500\u2500 configs/\n\u2502   \u2514\u2500\u2500 app_config.py          # Application configuration\n\u251c\u2500\u2500 adapters/\n\u2502   \u251c\u2500\u2500 db/                    # Database adapters\n\u2502   \u2514\u2500\u2500 api/                   # API adapters\n\u251c\u2500\u2500 core/\n\u2502   \u251c\u2500\u2500 models/                # Domain models\n\u2502   \u251c\u2500\u2500 ports/                 # Interface definitions\n\u2502   \u2514\u2500\u2500 services/              # Business logic\n\u251c\u2500\u2500 repositories/              # Data access\n\u251c\u2500\u2500 api/                       # API routes\n\u2514\u2500\u2500 main.py                    # Application entry point\n</code></pre>"},{"location":"architecture/#code-example","title":"Code Example","text":"<p>Here's how you might structure a FastAPI application using ArchiPy:</p> <pre><code># adapters/db/user_repository.py\nfrom archipy.adapters.postgres.sqlalchemy.adapters import SQLAlchemyAdapter\nfrom core.models.user import User\n\n\nclass UserRepository:\n    def __init__(self, db_adapter: SQLAlchemyAdapter):\n        self.db_adapter = db_adapter\n\n    def get_user_by_id(self, user_id: str) -&gt; User:\n        return self.db_adapter.get_by_uuid(User, user_id)\n\n    def create_user(self, user: User) -&gt; User:\n        return self.db_adapter.create(user)\n\n\n# core/services/user_service.py\nfrom core.models.user import User\nfrom adapters.db.user_repository import UserRepository\n\n\nclass UserService:\n    def __init__(self, user_repository: UserRepository):\n        self.user_repository = user_repository\n\n    def register_user(self, name: str, email: str) -&gt; User:\n        # Business logic and validation here\n        user = User(name=name, email=email)\n        return self.user_repository.create_user(user)\n\n\n# api/users.py\nfrom fastapi import APIRouter, Depends\nfrom core.services.user_service import UserService\nfrom archipy.models.dtos import BaseDTO\n\nrouter = APIRouter()\n\n\nclass UserCreateDTO(BaseDTO):\n    name: str\n    email: str\n\n\n@router.post(\"/users/\")\ndef create_user(\n        data: UserCreateDTO,\n        user_service: UserService = Depends(get_user_service)\n):\n    user = user_service.register_user(data.name, data.email)\n    return {\"id\": str(user.test_uuid), \"name\": user.name, \"email\": user.email}\n\n\n# main.py\nfrom fastapi import FastAPI\nfrom archipy.helpers.utils.app_utils import AppUtils\nfrom archipy.configs.base_config import BaseConfig\n\napp = AppUtils.create_fastapi_app(BaseConfig.global_config())\napp.include_router(users_router)\n</code></pre> <p>By providing standardized building blocks rather than enforcing a specific architecture, ArchiPy helps teams maintain consistent development practices while allowing flexibility to choose the architectural pattern that best fits their needs.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to ArchiPy are documented in this changelog, organized by version.</p>"},{"location":"changelog/#3111-2025-09-06","title":"[3.11.1] - 2025-09-06","text":""},{"location":"changelog/#added","title":"Added","text":""},{"location":"changelog/#temporal-worker-management-enhancement","title":"Temporal Worker Management Enhancement","text":"<ul> <li>Wait Until Stopped Method - Added <code>wait_until_stopped()</code> method to Temporal WorkerHandle class<ul> <li>Enhanced worker lifecycle management with ability to wait for worker completion</li> <li>Improved synchronization capabilities for worker shutdown scenarios</li> <li>Better control over worker background task lifecycle in long-running applications</li> <li>Enhanced debugging and monitoring capabilities for Temporal worker operations</li> </ul> </li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":""},{"location":"changelog/#cicd-infrastructure","title":"CI/CD Infrastructure","text":"<ul> <li>GitHub Actions Updates - Updated Python setup action across all workflows for improved CI/CD reliability<ul> <li>Updated actions/setup-python from version 5 to 6 in all GitHub Actions workflows</li> <li>Enhanced Python environment setup with latest action features and security improvements</li> <li>Improved workflow performance and compatibility with latest GitHub Actions infrastructure</li> <li>Updated workflows: deploy-docs.yml, lint.yml, publish.yml, and tests.yml</li> </ul> </li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>Documentation Build Fixes - Resolved documentation generation and deployment issues<ul> <li>Fixed documentation builds for improved reliability and consistency</li> <li>Enhanced documentation index organization and navigation</li> <li>Improved documentation deployment pipeline stability</li> </ul> </li> </ul>"},{"location":"changelog/#3110-2025-09-04","title":"[3.11.0] - 2025-09-04","text":""},{"location":"changelog/#added_1","title":"Added","text":""},{"location":"changelog/#temporal-workflow-orchestration","title":"Temporal Workflow Orchestration","text":"<ul> <li>Comprehensive Temporal Integration - Added complete Temporal workflow orchestration support<ul> <li>Full Temporal integration with atomic transaction support for activities</li> <li>Comprehensive configuration management for Temporal workflow execution</li> <li>Clean architecture separation between workflow orchestration and activity execution</li> <li>Support for distributed workflow patterns with reliable activity execution</li> <li>Enhanced error handling and transaction management for Temporal workflows</li> </ul> </li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":""},{"location":"changelog/#documentation-assets","title":"Documentation Assets","text":"<ul> <li>Logo Path Update - Updated logo path reference for improved asset management<ul> <li>Enhanced documentation asset organization</li> <li>Improved logo accessibility and display consistency</li> </ul> </li> </ul>"},{"location":"changelog/#3100-2025-09-04","title":"[3.10.0] - 2025-09-04","text":""},{"location":"changelog/#added_2","title":"Added","text":""},{"location":"changelog/#grpc-interceptor-enhancements","title":"gRPC Interceptor Enhancements","text":"<ul> <li>Sentry Support in gRPC Trace Interceptors - Enhanced gRPC trace interceptors with dual APM support<ul> <li>Added Sentry span creation for both sync and async gRPC client interceptors</li> <li>Added Sentry transaction creation for both sync and async gRPC server interceptors</li> <li>Maintained backward compatibility with existing Elastic APM functionality</li> <li>Support for simultaneous Elastic APM and Sentry tracing in gRPC services</li> <li>Proper error handling and span status management for both APM systems</li> <li>Configuration-driven tracing with graceful degradation when APM systems are unavailable</li> </ul> </li> </ul>"},{"location":"changelog/#390-2025-09-04","title":"[3.9.0] - 2025-09-04","text":""},{"location":"changelog/#added_3","title":"Added","text":""},{"location":"changelog/#tracing-decorators","title":"Tracing Decorators","text":"<ul> <li>Pure Python APM Tracing - Added <code>@capture_transaction</code> and <code>@capture_span</code> decorators for pure Python applications<ul> <li><code>@capture_transaction</code> decorator for top-level transaction tracing without FastAPI/gRPC dependencies</li> <li><code>@capture_span</code> decorator for nested span tracking within existing transactions</li> <li>Seamless integration with existing Sentry and Elastic APM configuration system</li> <li>Conditional tracing based on <code>config.SENTRY.IS_ENABLED</code> and <code>config.ELASTIC_APM.IS_ENABLED</code> settings</li> <li>Proper error handling and graceful fallbacks when APM libraries are unavailable</li> <li>Automatic initialization of Sentry with full config parameters for transactions</li> <li>Uses existing APM clients for spans to work within transaction context</li> </ul> </li> </ul>"},{"location":"changelog/#developer-experience","title":"Developer Experience","text":"<ul> <li>Comprehensive Decorator Exports - Enhanced <code>archipy.helpers.decorators</code> module accessibility<ul> <li>Exported all 17 decorators in <code>__init__.py</code> for easy discovery and import</li> <li>Includes tracing, caching, retry, database atomic operations, deprecation, and utility decorators</li> <li>Simplified import syntax for all decorator functionality</li> </ul> </li> </ul>"},{"location":"changelog/#381-2025-09-04","title":"[3.8.1] - 2025-09-04","text":""},{"location":"changelog/#changed_2","title":"Changed","text":""},{"location":"changelog/#dependency-updates","title":"Dependency Updates","text":"<ul> <li>Elasticsearch Version Bump - Updated Elasticsearch Docker image from 9.1.2 to 9.1.3 in test configuration<ul> <li>Enhanced test reliability with latest Elasticsearch stable version</li> <li>Improved test container compatibility and performance</li> </ul> </li> </ul>"},{"location":"changelog/#code-quality-improvements","title":"Code Quality Improvements","text":"<ul> <li>Enhanced Keycloak Utils Type Safety - Improved type handling in Keycloak utilities for gRPC metadata<ul> <li>Fixed handling of both bytes and string metadata values in gRPC authentication</li> <li>Enhanced type conversion safety with proper string/bytes compatibility</li> <li>Improved authentication reliability across different gRPC implementations</li> </ul> </li> <li>MyPy Configuration Enhancements - Expanded MyPy overrides for better type checking coverage<ul> <li>Added comprehensive overrides for Keycloak utilities, MinIO, Kafka, and payment gateway adapters</li> <li>Enhanced type checking for optional imports with proper type placeholders</li> <li>Improved development experience with more accurate type checking</li> </ul> </li> </ul>"},{"location":"changelog/#library-updates","title":"Library Updates","text":"<ul> <li>Development Tools - Updated multiple development dependencies for improved tooling<ul> <li>Updated Ruff from 0.7.4 to 0.12.11 for enhanced linting capabilities</li> <li>Updated various type stubs packages for better IDE support and type checking</li> <li>Enhanced MkDocs Material theme from 9.6.7 to 9.6.18 for improved documentation</li> </ul> </li> <li>Core Dependencies - Updated runtime dependencies for better performance and security<ul> <li>Updated fakeredis from 2.30.1 to 2.31.1 for improved Redis mocking</li> <li>Updated sentry-sdk from 2.33.0 to 2.36.0 for better error tracking</li> <li>Updated pymysql from 1.1.1 to 1.1.2 for enhanced MySQL compatibility</li> <li>Updated behave from 1.3.1 to 1.3.2 for improved BDD testing</li> </ul> </li> </ul>"},{"location":"changelog/#documentation-and-code-structure","title":"Documentation and Code Structure","text":"<ul> <li>Enhanced CLAUDE.md - Comprehensive documentation improvements for Claude Code integration<ul> <li>Added detailed architecture overview with module descriptions</li> <li>Enhanced code style guidelines with Python 3.13+ requirements</li> <li>Improved command reference with complete development workflow</li> <li>Added comprehensive MyPy configuration documentation</li> </ul> </li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":""},{"location":"changelog/#type-safety","title":"Type Safety","text":"<ul> <li>Optional Import Handling - Fixed type assignments for optional gRPC imports<ul> <li>Resolved type compatibility issues when gRPC dependencies are not available</li> <li>Enhanced graceful degradation with proper type placeholders</li> <li>Improved development experience with better error messages</li> </ul> </li> </ul>"},{"location":"changelog/#configuration","title":"Configuration","text":"<ul> <li>Workflow Permissions - Fixed potential security issues in GitHub Actions workflows<ul> <li>Added proper permissions configuration to prevent unauthorized access</li> <li>Enhanced CI/CD security with explicit permission declarations</li> <li>Resolved code scanning alerts for workflow security best practices</li> </ul> </li> </ul>"},{"location":"changelog/#380-2025-08-21","title":"[3.8.0] - 2025-08-21","text":""},{"location":"changelog/#changed_3","title":"Changed","text":""},{"location":"changelog/#build-system-migration","title":"Build System Migration","text":"<ul> <li>Poetry to UV Migration - Migrated from Poetry to UV for improved performance and modern toolchain<ul> <li>Replaced Poetry with UV for dependency management and virtual environment handling</li> <li>Updated all GitHub Actions workflows to use <code>astral-sh/setup-uv@v4</code></li> <li>Converted <code>pyproject.toml</code> to use standard <code>[project]</code> format with UV-compatible optional dependencies</li> <li>Updated Makefile commands to use UV equivalents (<code>uv sync</code>, <code>uv run</code>, <code>uv build</code>)</li> <li>Updated pre-commit hooks to use UV for tool execution</li> <li>Migrated from Poetry build backend to Hatchling for better flexibility</li> <li>Updated all documentation to reflect UV usage instead of Poetry</li> <li>Significant performance improvements in dependency resolution and installation</li> </ul> </li> </ul>"},{"location":"changelog/#python-313-compatibility","title":"Python 3.13 Compatibility","text":"<ul> <li>Modern Type Hints - Updated codebase to use Python 3.13 generic syntax and modern type annotations<ul> <li>Migrated from <code>Union[T, None]</code> to <code>T | None</code> syntax throughout the codebase</li> <li>Updated Generic syntax to use modern Python 3.13 patterns (UP046, UP047)</li> <li>Enhanced type safety with improved generic type operations and Comparable protocol</li> <li>Fixed type assignment issues in error classes and DTO implementations</li> <li>Added comprehensive mypy overrides for flexible data dictionary assignments</li> </ul> </li> </ul>"},{"location":"changelog/#code-quality-improvements_1","title":"Code Quality Improvements","text":"<ul> <li>Linting and Type Checking - Resolved all ruff and mypy issues across the codebase<ul> <li>Fixed type annotations and imports across configs, models, and decorators</li> <li>Added missing error classes (DeadlineExceededError, DeprecationError)</li> <li>Enhanced SQLAlchemy column type compatibility with mapped_column</li> <li>Resolved import conflicts and improved code organization</li> <li>Added missing docstrings and type hints for better code documentation</li> </ul> </li> <li>Test Infrastructure Cleanup - Streamlined test helper functions for better maintainability<ul> <li>Removed unused imports and dependencies from test_helpers.py</li> <li>Cleaned up test infrastructure to reduce code duplication</li> <li>Improved test execution efficiency and maintainability</li> </ul> </li> </ul>"},{"location":"changelog/#cicd-enhancements","title":"CI/CD Enhancements","text":"<ul> <li>GitHub Actions Updates - Updated all GitHub Actions workflows to latest versions<ul> <li>Bumped actions/setup-python from 4 to 5 for improved Python support</li> <li>Bumped actions/cache from 3 to 4 for enhanced caching capabilities</li> <li>Bumped actions/checkout from 4 to 5 for better repository access</li> <li>Improved workflow reliability and performance across all CI/CD pipelines</li> </ul> </li> </ul>"},{"location":"changelog/#testing-framework-updates","title":"Testing Framework Updates","text":"<ul> <li>Behave Version Upgrade - Updated Behave testing framework to version 1.3.1<ul> <li>Enhanced test execution capabilities with latest Behave features</li> <li>Improved test reliability and performance across all test suites</li> <li>Better compatibility with modern Python development practices</li> </ul> </li> <li>MyPy Version Upgrade - Updated MyPy type checker to version 1.17.1<ul> <li>Enhanced type checking capabilities with latest MyPy features</li> <li>Improved type safety and error detection across the codebase</li> <li>Better support for Python 3.13 type annotations and modern type patterns</li> </ul> </li> </ul>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":""},{"location":"changelog/#type-system","title":"Type System","text":"<ul> <li>Generic Type Operations - Fixed generic type operations with Comparable protocol in DTO classes</li> <li>SQLAlchemy Compatibility - Resolved SQLAlchemy column type compatibility issues with mapped_column</li> <li>Error Class Initialization - Fixed type assignment issues in error classes for better type safety</li> </ul>"},{"location":"changelog/#configuration_1","title":"Configuration","text":"<ul> <li>Type Annotations - Resolved type annotation and inheritance issues in configuration classes</li> <li>Validator Documentation - Added missing docstrings to validators for better code documentation</li> </ul>"},{"location":"changelog/#known-issues","title":"Known Issues","text":"<ul> <li>Remaining Linting Issues - Some minor linting issues remain that are planned for future releases<ul> <li>13 ANN401 (any-type) violations for flexible data handling</li> <li>11 ANN201 (missing return type annotations) for public functions</li> <li>8 D415 (missing terminal punctuation) for docstrings</li> <li>These issues are intentionally allowed for specific use cases and will be addressed incrementally</li> </ul> </li> </ul>"},{"location":"changelog/#370-2025-08-16","title":"[3.7.0] - 2025-08-16","text":""},{"location":"changelog/#new-features","title":"New Features","text":""},{"location":"changelog/#elasticsearch-index-management","title":"Elasticsearch Index Management","text":"<ul> <li>Index Existence Check - Added <code>index_exists</code> method to Elasticsearch adapters for improved index management<ul> <li>New <code>index_exists()</code> method in both synchronous and asynchronous Elasticsearch ports</li> <li>Enhanced index lifecycle management with proper existence validation</li> <li>Improved error handling and index operation safety</li> <li>Better support for index-dependent operations and workflows</li> </ul> </li> </ul>"},{"location":"changelog/#cicd-pipeline-enhancement","title":"CI/CD Pipeline Enhancement","text":"<ul> <li>Dedicated Test Workflow - Implemented comprehensive CI/CD pipeline for automated testing<ul> <li>Added dedicated GitHub Actions workflow for Behave BDD tests</li> <li>Automated test execution on push to main branch and pull requests</li> <li>Python 3.13 matrix testing with Poetry dependency management</li> <li>Enhanced test reliability and continuous integration capabilities</li> </ul> </li> </ul>"},{"location":"changelog/#improvements","title":"Improvements","text":""},{"location":"changelog/#testing-framework","title":"Testing Framework","text":"<ul> <li>Kafka Test Reliability - Enhanced Kafka adapter tests with retry mechanism for improved stability<ul> <li>Implemented retry logic for Kafka connection tests to handle transient network issues</li> <li>Improved test reliability in CI/CD environments with better error handling</li> <li>Enhanced test coverage for Kafka adapter functionality</li> </ul> </li> </ul>"},{"location":"changelog/#configuration-management","title":"Configuration Management","text":"<ul> <li>PostgreSQL DSN Type Safety - Fixed PostgresDsn type instantiation for improved configuration validation<ul> <li>Corrected PostgresDsn type handling in configuration templates</li> <li>Enhanced type safety for database connection string validation</li> <li>Improved configuration error handling and validation</li> </ul> </li> </ul>"},{"location":"changelog/#development-tools","title":"Development Tools","text":"<ul> <li>Dependency Updates - Updated development dependencies for improved tooling and security<ul> <li>Enhanced Poetry dependency management with latest package versions</li> <li>Improved development environment setup and tooling</li> <li>Better compatibility with Python 3.13 and modern development practices</li> </ul> </li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":""},{"location":"changelog/#test-infrastructure","title":"Test Infrastructure","text":"<ul> <li>Image Version Compatibility - Fixed test container image versions for improved test reliability<ul> <li>Updated Elasticsearch, Keycloak, and Kafka test container images</li> <li>Resolved test environment compatibility issues</li> <li>Enhanced test stability across different environments</li> </ul> </li> </ul>"},{"location":"changelog/#error-handling","title":"Error Handling","text":"<ul> <li>Exception Utility Assertions - Fixed error assertion logic in exception utilities<ul> <li>Corrected error handling in test scenarios for better validation</li> <li>Improved error message consistency and debugging capabilities</li> </ul> </li> </ul>"},{"location":"changelog/#dependencies","title":"Dependencies","text":"<ul> <li>Development Tools - Updated development dependencies for improved tooling and security</li> <li>Test Containers - Enhanced test container configurations for better test reliability</li> <li>CI/CD Tools - Improved GitHub Actions workflow for automated testing</li> </ul>"},{"location":"changelog/#community-contributions","title":"Community Contributions","text":"<ul> <li>@heysaeid - Fixed PostgresDsn type instantiation for improved configuration validation</li> <li>@negatic - Enhanced Kafka adapter tests with retry mechanism and improved test infrastructure</li> <li>@s.kazemi - Added index_exists method to Elasticsearch adapters and implemented CI/CD test workflow</li> </ul>"},{"location":"changelog/#361-2025-08-11","title":"[3.6.1] - 2025-08-11","text":""},{"location":"changelog/#new-features_1","title":"New Features","text":""},{"location":"changelog/#security-scanning-integration","title":"Security Scanning Integration","text":"<ul> <li>Bandit Security Tool - Added comprehensive security vulnerability scanning to the development workflow<ul> <li>Integrated Bandit 1.7.8 for automated security analysis of Python code</li> <li>Added security scanning to CI/CD pipeline with configurable rules and exclusions</li> <li>Enhanced security posture with automated detection of common security issues</li> <li>Improved code quality through proactive security vulnerability identification</li> </ul> </li> </ul>"},{"location":"changelog/#enhanced-testing-framework","title":"Enhanced Testing Framework","text":"<ul> <li>Behave 1.3.0 Upgrade - Updated BDD testing framework to latest version with improved async support<ul> <li>Enhanced async test handling capabilities for better performance and reliability</li> <li>Improved test execution efficiency with optimized async context management</li> <li>Streamlined test infrastructure with cleaner step definitions and scenario management</li> <li>Enhanced test coverage and reliability across all adapter test suites</li> </ul> </li> </ul>"},{"location":"changelog/#improvements_1","title":"Improvements","text":""},{"location":"changelog/#sqlalchemy-type-safety","title":"SQLAlchemy Type Safety","text":"<ul> <li>Generic TypeVar Support - Enhanced SQLAlchemy adapters with improved generic type preservation<ul> <li>Added TypeVar support to preserve concrete entity types in adapter operations</li> <li>Improved type safety for database operations with better generic type handling</li> <li>Enhanced IDE support and type checking for database adapter usage</li> <li>Maintained backward compatibility while improving type inference capabilities</li> </ul> </li> </ul>"},{"location":"changelog/#test-infrastructure_1","title":"Test Infrastructure","text":"<ul> <li>Streamlined Test Helpers - Refactored and optimized test infrastructure for better maintainability<ul> <li>Removed redundant test helper functions to reduce code duplication</li> <li>Enhanced step definitions with cleaner, more focused implementations</li> <li>Improved test scenario context management for better test isolation</li> <li>Optimized test execution with reduced overhead and improved performance</li> </ul> </li> </ul>"},{"location":"changelog/#code-quality","title":"Code Quality","text":""},{"location":"changelog/#security-enhancements","title":"Security Enhancements","text":"<ul> <li>Automated Security Checks - Integrated security scanning into development workflow<ul> <li>Added Bandit configuration with customizable security rules and exclusions</li> <li>Enhanced CI/CD pipeline with automated security vulnerability detection</li> <li>Improved security posture through proactive code analysis</li> <li>Standardized security practices across development team</li> </ul> </li> </ul>"},{"location":"changelog/#testing-improvements","title":"Testing Improvements","text":"<ul> <li>Enhanced Test Coverage - Improved test reliability and maintainability<ul> <li>Updated all adapter test suites to work with Behave 1.3.0</li> <li>Streamlined test step definitions for better readability and maintenance</li> <li>Enhanced test context management for improved test isolation</li> <li>Optimized test execution performance and reliability</li> </ul> </li> </ul>"},{"location":"changelog/#dependencies_1","title":"Dependencies","text":"<ul> <li>Security Tools - Added Bandit 1.7.8 for automated security scanning</li> <li>Testing Framework - Updated Behave to version 1.3.0 for improved async support</li> <li>Development Tools - Enhanced development workflow with security and testing improvements</li> </ul>"},{"location":"changelog/#community-contributions_1","title":"Community Contributions","text":"<ul> <li>@younesious - Enhanced SQLAlchemy adapters with generic TypeVar support for improved type safety</li> <li>@itsnegaar - Upgraded Behave testing framework to version 1.3.0 with enhanced async support</li> </ul>"},{"location":"changelog/#360-2025-07-29","title":"[3.6.0] - 2025-07-29","text":""},{"location":"changelog/#new-features_2","title":"New Features","text":""},{"location":"changelog/#grpc-exception-interceptor-system","title":"gRPC Exception Interceptor System","text":"<ul> <li>Centralized Exception Handling - Implemented comprehensive gRPC server exception interceptors for both synchronous   and asynchronous operations<ul> <li>Added <code>GrpcServerExceptionInterceptor</code> for synchronous gRPC services with automatic exception conversion</li> <li>Added <code>AsyncGrpcServerExceptionInterceptor</code> for asynchronous gRPC services with async exception handling</li> <li>Eliminated the need for repetitive try-catch blocks in individual gRPC service methods</li> <li>Automatic conversion of exceptions to appropriate gRPC error responses with proper status codes</li> </ul> </li> </ul>"},{"location":"changelog/#enhanced-error-handling","title":"Enhanced Error Handling","text":"<ul> <li>Pydantic Validation Error Handling - Integrated automatic Pydantic validation error processing in gRPC   interceptors<ul> <li>Automatic conversion of ValidationError to InvalidArgumentError with detailed error information</li> <li>Structured validation error formatting with field-level error details</li> <li>Enhanced debugging capabilities with comprehensive validation error reporting</li> </ul> </li> </ul>"},{"location":"changelog/#language-configuration-system","title":"Language Configuration System","text":"<ul> <li>Global Language Configuration - Added LANGUAGE configuration to BaseConfig for consistent language handling<ul> <li>Introduced LANGUAGE attribute in BaseConfig with default Persian (FA) language support</li> <li>Standardized language type constants to uppercase for ISO compliance</li> <li>Improved language handling across error messages and user interfaces</li> </ul> </li> </ul>"},{"location":"changelog/#improvements_2","title":"Improvements","text":""},{"location":"changelog/#grpc-status-code-management","title":"gRPC Status Code Management","text":"<ul> <li>Enhanced Status Code Handling - Improved gRPC status code conversion and management in BaseError<ul> <li>Added static method for converting integer status codes to gRPC StatusCode enums</li> <li>Enhanced metadata handling in gRPC abort methods with conditional additional data inclusion</li> <li>Refined type hints for context parameters in abort methods for better clarity</li> <li>Improved error context preservation and debugging capabilities</li> </ul> </li> </ul>"},{"location":"changelog/#error-system-refactoring","title":"Error System Refactoring","text":"<ul> <li>Optional Language Parameters - Refactored error handling classes to use optional language parameters<ul> <li>Removed mandatory language parameter requirements for improved flexibility</li> <li>Enhanced error initialization with automatic language detection from global configuration</li> <li>Improved error message consistency and localization support</li> <li>Maintained backward compatibility while improving developer experience</li> </ul> </li> </ul>"},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":""},{"location":"changelog/#error-initialization","title":"Error Initialization","text":"<ul> <li>Language Configuration Fix - Fixed language initialization in BaseError to use global configuration<ul> <li>Ensured language is set correctly from global configuration when not provided during initialization</li> <li>Improved error message consistency across different initialization scenarios</li> <li>Enhanced code readability and maintainability</li> </ul> </li> </ul>"},{"location":"changelog/#type-safety-improvements","title":"Type Safety Improvements","text":"<ul> <li>Enhanced Type Hints - Improved type hints for gRPC status codes and error handling<ul> <li>Refined type annotations for better IDE support and code reliability</li> <li>Enhanced type safety across error handling components</li> <li>Improved developer experience with better autocomplete and error detection</li> </ul> </li> </ul>"},{"location":"changelog/#code-quality_1","title":"Code Quality","text":"<ul> <li>Comprehensive Error Coverage - Updated all error classes to support the new language and gRPC handling system<ul> <li>Enhanced auth_errors, business_errors, database_errors, network_errors, resource_errors, system_errors, and   validation_errors</li> <li>Improved error categorization and handling consistency</li> <li>Enhanced error reporting and debugging capabilities across all error types</li> </ul> </li> </ul>"},{"location":"changelog/#352-2025-07-28","title":"[3.5.2] - 2025-07-28","text":""},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":""},{"location":"changelog/#elasticsearch-authentication","title":"Elasticsearch Authentication","text":"<ul> <li>Password Secret Value Extraction - Fixed critical authentication issue in Elasticsearch adapters where password   secret values were not being properly extracted<ul> <li>Updated both synchronous and asynchronous Elasticsearch adapters to use <code>get_secret_value()</code> method for   HTTP_PASSWORD</li> <li>Resolved authentication failures when using SecretStr password configuration</li> <li>Improved security by properly handling encrypted password fields in Elasticsearch configuration</li> </ul> </li> </ul>"},{"location":"changelog/#dependencies_2","title":"Dependencies","text":"<ul> <li>Poetry Lock Update - Updated poetry.lock file to Poetry 2.1.2 for improved dependency management<ul> <li>Enhanced dependency resolution with latest Poetry version</li> <li>Updated platform-specific package markers for better cross-platform compatibility</li> <li>Improved package hash verification and security</li> </ul> </li> </ul>"},{"location":"changelog/#code-quality_2","title":"Code Quality","text":"<ul> <li>Authentication Consistency - Standardized password handling across Elasticsearch adapters<ul> <li>Ensured consistent secret value extraction in both sync and async adapters</li> <li>Maintained backward compatibility while improving security practices</li> <li>Enhanced error handling for authentication configuration</li> </ul> </li> </ul>"},{"location":"changelog/#351-2025-07-28","title":"[3.5.1] - 2025-07-28","text":""},{"location":"changelog/#bug-fixes_5","title":"Bug Fixes","text":""},{"location":"changelog/#http-status-code-handling","title":"HTTP Status Code Handling","text":"<ul> <li>Status Code Name Mismatch - Fixed critical issue in FastAPIExceptionHandler where <code>http_status_code</code> was   incorrectly referenced<ul> <li>Changed from <code>exception.http_status_code</code> to <code>exception.http_status_code_value</code> for proper status code retrieval</li> <li>Resolved HTTP status code name mismatch that was causing incorrect error responses</li> <li>Improved error handling consistency in FastAPI exception processing</li> </ul> </li> </ul>"},{"location":"changelog/#improvements_3","title":"Improvements","text":""},{"location":"changelog/#protobuf-dto-runtime-type-safety","title":"Protobuf DTO Runtime Type Safety","text":"<ul> <li>Runtime Type Checking - Enhanced BaseProtobufDTO with comprehensive runtime type validation<ul> <li>Added runtime type checking in <code>from_proto()</code> method to validate input parameter types</li> <li>Implemented proper type validation before protobuf message processing</li> <li>Enhanced error messages with clear type mismatch information</li> </ul> </li> </ul>"},{"location":"changelog/#custom-exception-integration","title":"Custom Exception Integration","text":"<ul> <li>Custom Exception Handling - Replaced generic TypeError with domain-specific InvalidEntityTypeError<ul> <li>Updated protobuf DTO type validation to use <code>InvalidEntityTypeError</code> for better error categorization</li> <li>Improved error context with expected and actual type information</li> <li>Enhanced error handling consistency across the protobuf DTO system</li> </ul> </li> </ul>"},{"location":"changelog/#code-quality-enhancements","title":"Code Quality Enhancements","text":"<ul> <li>Error Handling Consistency - Standardized error handling patterns across protobuf DTO operations<ul> <li>Improved error message clarity and debugging capabilities</li> <li>Enhanced type safety with proper exception chaining</li> <li>Maintained backward compatibility while improving error reporting</li> </ul> </li> </ul>"},{"location":"changelog/#350-2025-07-26","title":"[3.5.0] - 2025-07-26","text":""},{"location":"changelog/#new-features_3","title":"New Features","text":""},{"location":"changelog/#protobuf-dto-support","title":"Protobuf DTO Support","text":"<ul> <li>BaseProtobufDTO - Added new base class for Data Transfer Objects that can be converted to and from Protobuf   messages<ul> <li>Provides seamless integration between Pydantic DTOs and Google Protocol Buffers</li> <li>Supports bidirectional conversion with <code>from_proto()</code> and <code>to_proto()</code> methods</li> <li>Includes runtime dependency checking for protobuf availability</li> <li>Maintains type safety with proper error handling for missing protobuf dependencies</li> </ul> </li> </ul>"},{"location":"changelog/#bug-fixes_6","title":"Bug Fixes","text":""},{"location":"changelog/#type-safety-improvements_1","title":"Type Safety Improvements","text":"<ul> <li>ClassVar Type Variable Issue - Fixed critical type annotation issue in BaseProtobufDTO where ClassVar contained   type variables<ul> <li>Resolved <code>ClassVar</code> parameter cannot include type variables error</li> <li>Updated type annotations to use concrete <code>Message</code> type instead of type variables</li> <li>Improved type safety by using proper concrete types for class variables</li> <li>Added comprehensive type annotations for all methods and parameters</li> </ul> </li> </ul>"},{"location":"changelog/#code-quality-enhancements_1","title":"Code Quality Enhancements","text":"<ul> <li>Import Cleanup - Removed invalid Unicode characters and simplified import structure<ul> <li>Fixed invisible Unicode character <code>\\uab</code> that was causing linter errors</li> <li>Streamlined protobuf import logic by removing unnecessary type variables</li> <li>Enhanced code readability and maintainability</li> <li>Added proper docstring formatting with Google-style documentation</li> </ul> </li> </ul>"},{"location":"changelog/#linting-configuration","title":"Linting Configuration","text":"<ul> <li>Ruff Configuration - Updated linting rules to accommodate protobuf DTO patterns<ul> <li>Added <code>ANN401</code> exception for <code>base_protobuf_dto.py</code> to allow <code>Any</code> types in <code>*args</code> and <code>**kwargs</code></li> <li>Maintained strict type checking while allowing necessary flexibility for DTO inheritance patterns</li> <li>Ensured all pre-commit hooks pass without compromising code quality standards</li> </ul> </li> </ul>"},{"location":"changelog/#345-2025-07-24","title":"[3.4.5] - 2025-07-24","text":""},{"location":"changelog/#improvements_4","title":"Improvements","text":""},{"location":"changelog/#configuration-template-enhancements","title":"Configuration Template Enhancements","text":"<ul> <li>Improved Readability - Enhanced ElasticsearchAPMConfig size fields to use human-readable string values instead of   raw bytes<ul> <li>Changed <code>API_REQUEST_SIZE</code> from <code>768 * 1024</code> to <code>\"768kb\"</code> for better configuration clarity</li> <li>Changed <code>LOG_FILE_SIZE</code> from <code>50 * 1024 * 1024</code> to <code>\"50mb\"</code> for improved readability</li> </ul> </li> <li>Configuration Clarity - Updated size-related configuration fields to use standard size notation (kb, mb) making   configuration files more intuitive and easier to understand</li> </ul>"},{"location":"changelog/#bug-fixes_7","title":"Bug Fixes","text":"<ul> <li>Code Cleanup - Removed redundant files to improve project structure and reduce maintenance overhead</li> </ul>"},{"location":"changelog/#344-2025-07-17","title":"[3.4.4] - 2025-07-17","text":""},{"location":"changelog/#improvements_5","title":"Improvements","text":""},{"location":"changelog/#grpc-integration-improvements","title":"gRPC Integration Improvements","text":"<ul> <li>Import Safety - Added robust gRPC import handling with try/except blocks to prevent import errors when gRPC is not   available</li> <li>Type Safety - Enhanced type annotations for gRPC context handling with improved error type definitions</li> <li>Error Handling - Improved gRPC error handling with better type safety and context management</li> </ul>"},{"location":"changelog/#dependency-updates_1","title":"Dependency Updates","text":"<ul> <li>Kafka - Updated confluent-kafka to version 2.11.0+ for improved stability and performance</li> <li>Keycloak - Updated python-keycloak to version 5.7.0+ for enhanced security and features</li> <li>Sentry - Updated sentry-sdk to version 2.33.0+ for better error tracking capabilities</li> <li>MyPy - Updated MyPy to version 1.17.0+ for improved type checking and Python 3.13 support</li> </ul>"},{"location":"changelog/#343-2025-07-17","title":"[3.4.3] - 2025-07-17","text":""},{"location":"changelog/#improvements_6","title":"Improvements","text":""},{"location":"changelog/#keycloak-security-enhancements","title":"Keycloak Security Enhancements","text":"<ul> <li>Admin Mode Control - Implemented <code>IS_ADMIN_MODE_ENABLED</code> configuration flag to control Keycloak admin operations</li> <li>Enhanced Security - Added granular control over admin capabilities allowing authentication-only mode without admin   privileges</li> <li>Principle of Least Privilege - Updated both synchronous and asynchronous Keycloak adapters to respect admin mode   configuration</li> <li>Test Coverage - Updated BDD test steps to properly handle admin mode configuration for comprehensive testing</li> </ul>"},{"location":"changelog/#security","title":"Security","text":"<ul> <li>Reduced Attack Surface - Admin operations can now be disabled while maintaining authentication capabilities</li> <li>Environment Isolation - Different environments can have different admin capabilities based on configuration</li> <li>Audit Trail - Clear separation between authentication and administrative operations for better security monitoring</li> </ul>"},{"location":"changelog/#342-2025-07-17","title":"[3.4.2] - 2025-07-17","text":""},{"location":"changelog/#bug-fixes_8","title":"Bug Fixes","text":"<ul> <li>Import Error Resolution - Fixed critical import errors that were preventing proper module initialization and   functionality</li> </ul>"},{"location":"changelog/#341-2025-07-07","title":"[3.4.1] - 2025-07-07","text":""},{"location":"changelog/#bug-fixes_9","title":"Bug Fixes","text":"<ul> <li>Import Error Fix - Resolved import error issues that were affecting module loading and dependency resolution</li> </ul>"},{"location":"changelog/#340-2025-06-29","title":"[3.4.0] - 2025-06-29","text":""},{"location":"changelog/#new-features_4","title":"New Features","text":""},{"location":"changelog/#grpc-integration-enhancements","title":"gRPC Integration Enhancements","text":"<ul> <li>Async gRPC Server Interceptors - Added comprehensive async gRPC server interceptors with enhanced tracing   capabilities and metric collection for better observability</li> <li>Enhanced Authentication Context - Implemented advanced authentication context management with gRPC decorators for   seamless integration</li> <li>Improved Error Handling - Enhanced gRPC error handling and context management with better type annotations and   error propagation</li> </ul>"},{"location":"changelog/#keycloak-grpc-authentication","title":"Keycloak gRPC Authentication","text":"<ul> <li>gRPC Authentication Enhancement - Added token extraction and role validation capabilities for gRPC services with   Keycloak integration</li> <li>Composite Role Management - Implemented composite role management methods in both KeycloakAdapter and   AsyncKeycloakAdapter for advanced authorization scenarios</li> <li>Streamlined Role Checks - Enhanced role checking and error handling in KeycloakAdapter for better performance and   reliability</li> </ul>"},{"location":"changelog/#improvements_7","title":"Improvements","text":""},{"location":"changelog/#error-handling-type-safety","title":"Error Handling &amp; Type Safety","text":"<ul> <li>Enhanced Type Annotations - Updated type annotations in BaseError class for improved gRPC context handling and   better type safety</li> <li>Refined Interceptors - Improved gRPC server interceptors with better error handling and method name context   support</li> </ul>"},{"location":"changelog/#code-quality-performance","title":"Code Quality &amp; Performance","text":"<ul> <li>DateTime Optimization - Refactored BaseUtils and UpdatableMixin to use naive local datetime for improved   performance and consistency</li> <li>Library Updates - Updated dependencies and libraries for better compatibility and security</li> </ul>"},{"location":"changelog/#community-contributions_2","title":"Community Contributions","text":"<ul> <li>Collaborative Development - Merged contributions from @Mohammadreza-kh94 for Keycloak gRPC authentication   enhancements</li> <li>Code Refactoring - Integrated improvements from @heysaeid for datetime handling optimizations</li> </ul>"},{"location":"changelog/#v331-2025-06-12","title":"[v3.3.1] - 2025-06-12","text":""},{"location":"changelog/#improvements_8","title":"Improvements","text":""},{"location":"changelog/#keycloak-integration-enhancements","title":"Keycloak Integration Enhancements","text":"<ul> <li>Enhanced error handling - Added comprehensive custom error classes and centralized exception handling for better   Keycloak error management and debugging</li> <li>Improved error messaging - Introduced <code>KeycloakErrorMessageType</code> enum for standardized error handling and clearer   error messages</li> <li>Extended functionality - Added <code>get_realm</code> method to both synchronous and asynchronous Keycloak ports for better   realm management</li> <li>Optimized caching - Updated cache clearing methods in Keycloak adapters for improved performance and reliability</li> </ul>"},{"location":"changelog/#datetime-utilities-enhancement","title":"Datetime Utilities Enhancement","text":"<ul> <li>Enhanced datetime handling - Significantly improved datetime utility functions with better timezone support, date   parsing capabilities, and comprehensive validation for more robust date and time operations</li> <li>Extended functionality - Added new datetime manipulation methods and improved existing functions for better   developer experience</li> </ul>"},{"location":"changelog/#elasticsearch-adapter-refinements","title":"Elasticsearch Adapter Refinements","text":"<ul> <li>Improved adapter implementation - Enhanced Elasticsearch adapter with better error handling, improved connection   management, and optimized query performance</li> <li>Configuration enhancements - Refined Elasticsearch configuration options for more flexible deployment scenarios   and better SSL/TLS support</li> </ul>"},{"location":"changelog/#configuration-management_1","title":"Configuration Management","text":"<ul> <li>Enhanced configuration templates - Updated configuration templates with improved validation, better default   values, and comprehensive documentation</li> <li>Streamlined setup process - Simplified configuration management for various adapters and services with clearer   parameter definitions</li> </ul>"},{"location":"changelog/#testing-quality-assurance","title":"Testing &amp; Quality Assurance","text":"<ul> <li>Enhanced test coverage - Significantly improved Keycloak adapter feature tests and datetime utilities with   comprehensive feature tests and better validation scenarios</li> <li>Development environment - Updated Keycloak and development configuration in test environment for improved local   development experience</li> <li>Documentation updates - Enhanced API reference documentation and configuration guides for better developer   onboarding</li> </ul>"},{"location":"changelog/#code-quality-maintenance","title":"Code Quality &amp; Maintenance","text":"<ul> <li>Code organization - Improved code structure and organization across multiple modules for better maintainability</li> <li>Enhanced validation - Added better input validation and error handling throughout the codebase</li> </ul>"},{"location":"changelog/#bug-fixes_10","title":"Bug Fixes","text":"<ul> <li>Configuration cleanup - Removed invalid imports and unused Elasticsearch configuration references to prevent   import errors</li> <li>Code optimization - Removed redundant error handling code for cleaner and more maintainable codebase</li> </ul>"},{"location":"changelog/#community-contributions_3","title":"Community Contributions","text":"<ul> <li>Collaborative improvements - Merged contributions from @Mohammadreza-kh94 for Keycloak enhancements and @heysaeid   for configuration fixes</li> </ul>"},{"location":"changelog/#v330-2025-06-09","title":"[v3.3.0] - 2025-06-09","text":""},{"location":"changelog/#new-features_5","title":"New Features","text":""},{"location":"changelog/#elasticsearch-integration","title":"Elasticsearch Integration","text":"<ul> <li>New Elasticsearch adapter - Added comprehensive Elasticsearch integration with full search and indexing   capabilities, enabling powerful full-text search and analytics functionality for your applications</li> <li>Enhanced search capabilities - Integrated advanced search features with Elasticsearch 9.0.2 support for improved   performance and modern search functionality</li> </ul>"},{"location":"changelog/#improvements_9","title":"Improvements","text":""},{"location":"changelog/#configuration-testing","title":"Configuration &amp; Testing","text":"<ul> <li>Improved Elasticsearch configuration - Enhanced configuration management with better validation and streamlined   setup process</li> <li>Comprehensive test coverage - Added extensive test suite for Elasticsearch functionality to ensure reliability and   stability</li> </ul>"},{"location":"changelog/#bug-fixes_11","title":"Bug Fixes","text":"<ul> <li>Configuration validation - Removed unnecessary authentication validation in Elasticsearch configuration for   improved flexibility</li> <li>Adapter initialization - Fixed Elasticsearch adapter initialization issues for smoother integration</li> </ul>"},{"location":"changelog/#collaboration","title":"Collaboration","text":"<ul> <li>Community contributions - Merged contributions from @alireza-shirmohammadi improving Elasticsearch functionality   and resolving upstream conflicts</li> </ul>"},{"location":"changelog/#v327-2025-01-06","title":"[v3.2.7] - 2025-01-06","text":""},{"location":"changelog/#improvements_10","title":"Improvements","text":""},{"location":"changelog/#database-query-flexibility","title":"Database Query Flexibility","text":"<ul> <li>Enhanced query result handling - Added <code>has_multiple_entities</code> parameter to search query methods in both   synchronous and asynchronous SQLAlchemy adapters and ports. This new parameter provides flexible control over query   result processing, allowing developers to choose between <code>fetchall()</code> for multiple entities or <code>scalars().all()</code> for   single entity queries, optimizing performance based on query requirements.</li> </ul>"},{"location":"changelog/#database-performance","title":"Database Performance","text":"<ul> <li>Optimized search query execution - Refactored SQLAlchemy query execution method to use <code>fetchall()</code> instead of   <code>scalars().all()</code> for improved performance and memory efficiency in both synchronous and asynchronous adapters</li> </ul>"},{"location":"changelog/#v326-2025-01-06","title":"[v3.2.6] - 2025-01-06","text":""},{"location":"changelog/#improvements_11","title":"Improvements","text":""},{"location":"changelog/#database-performance_1","title":"Database Performance","text":"<ul> <li>Optimized search query execution - Refactored SQLAlchemy query execution method to use <code>fetchall()</code> instead of   <code>scalars().all()</code> for improved performance and memory efficiency in both synchronous and asynchronous adapters</li> </ul>"},{"location":"changelog/#v325-2025-01-06","title":"[v3.2.5] - 2025-01-06","text":""},{"location":"changelog/#improvements_12","title":"Improvements","text":""},{"location":"changelog/#developer-experience_1","title":"Developer Experience","text":"<ul> <li>Enhanced changelog generation script - Significantly improved the changelog generation process with comprehensive   type hints, better error handling, and enhanced Conventional Commits support for more accurate categorization of   changes</li> <li>Updated development guidelines - Added new coding standards and architectural rules to improve code quality and   maintainability</li> </ul>"},{"location":"changelog/#technical-enhancements","title":"Technical Enhancements","text":"<ul> <li>Type Safety - Added Python 3.13 type hints throughout the changelog generation script for better IDE support and   code reliability</li> <li>Error Handling - Implemented proper exception chaining and more robust error reporting</li> <li>Code Organization - Refactored script structure for better modularity and maintainability</li> </ul>"},{"location":"changelog/#324-2025-01-27","title":"[3.2.4] - 2025-01-27","text":""},{"location":"changelog/#fixed","title":"Fixed","text":""},{"location":"changelog/#testing","title":"Testing","text":"<ul> <li>Fixed atomic transactions feature test error handling expectations:</li> <li>Corrected test to expect <code>InternalError</code> instead of <code>DatabaseError</code> for normal exceptions</li> <li>Aligned test expectations with the correct exception wrapping behavior in atomic decorators</li> <li>Normal exceptions (like <code>ValueError</code>) are now correctly expected to be wrapped as <code>InternalError</code></li> <li>Database-specific exceptions continue to be wrapped as appropriate <code>DatabaseError</code> subclasses</li> </ul>"},{"location":"changelog/#323-2025-01-24","title":"[3.2.3] - 2025-01-24","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Fix using \"IS_ENABLED\" instead wrong variable \"ENABLED\" in elastic ap\u2026 by @majasemzadeh in #45</li> </ul>"},{"location":"changelog/#322-2025-05-24","title":"[3.2.2] - 2025-05-24","text":""},{"location":"changelog/#changed_4","title":"Changed","text":""},{"location":"changelog/#database-entities","title":"Database Entities","text":"<ul> <li>Enhanced timestamp handling in SQLAlchemy base entities:</li> <li>Improved timezone-aware datetime handling in UpdatableMixin</li> <li>Updated <code>updated_at</code> field to use server-side default timestamp</li> <li>Added helper method <code>_make_naive()</code> for timezone conversion</li> <li>Optimized update timestamp behavior for better database compatibility</li> </ul>"},{"location":"changelog/#321-2025-05-20","title":"[3.2.1] - 2025-05-20","text":""},{"location":"changelog/#changed_5","title":"Changed","text":""},{"location":"changelog/#elastic-apm-configuration","title":"Elastic APM Configuration","text":"<ul> <li>Enhanced Elastic APM configuration and integration:</li> <li>Refactored configuration logic for improved maintainability</li> <li>Updated configuration templates for greater flexibility</li> <li>Improved gRPC tracing interceptor for better observability</li> <li>Refined application utility functions related to APM</li> </ul>"},{"location":"changelog/#320-2025-05-20","title":"[3.2.0] - 2025-05-20","text":""},{"location":"changelog/#added_4","title":"Added","text":""},{"location":"changelog/#keycloak-integration","title":"Keycloak Integration","text":"<ul> <li>Added and refactored methods for creating realms, clients, and client roles in Keycloak adapters (sync and async)</li> <li>Improved admin credential support and configuration for Keycloak</li> <li>Enhanced type hints and readability in Keycloak step definitions</li> </ul>"},{"location":"changelog/#utilities","title":"Utilities","text":"<ul> <li>Introduced string utility functions for case conversion (snake_case \u2194 camelCase)</li> </ul>"},{"location":"changelog/#configuration_2","title":"Configuration","text":"<ul> <li>Expanded .env.example with more detailed configuration options for services</li> <li>Improved KeycloakConfig with admin fields for easier testing and setup</li> </ul>"},{"location":"changelog/#documentation-code-quality","title":"Documentation &amp; Code Quality","text":"<ul> <li>Improved and clarified usage examples and step definitions</li> <li>Reformatted Python files to comply with Ruff checks</li> <li>Minor refactoring for better code clarity and maintainability</li> </ul>"},{"location":"changelog/#311-2025-05-17","title":"[3.1.1] - 2025-05-17","text":""},{"location":"changelog/#documentation_1","title":"Documentation","text":"<ul> <li>Enhanced project documentation</li> <li>Improved usage examples</li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":""},{"location":"changelog/#configuration_3","title":"Configuration","text":"<ul> <li>Updated configuration templates</li> <li>Enhanced Kafka configuration template with improved settings</li> <li>Optimized template structure for better usability</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Resolved merge conflicts</li> <li>Streamlined codebase integration</li> </ul>"},{"location":"changelog/#310-2025-05-15","title":"[3.1.0] - 2025-05-15","text":""},{"location":"changelog/#added_5","title":"Added","text":""},{"location":"changelog/#payment-gateway","title":"Payment Gateway","text":"<ul> <li>Implemented Parsian Internet Payment Gateway adapter</li> <li>Added comprehensive IPG integration support</li> <li>Enhanced payment processing capabilities</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":""},{"location":"changelog/#documentation_2","title":"Documentation","text":"<ul> <li>Updated adapter documentation</li> <li>Improved IPG integration examples</li> <li>Refactored Parsian adapter code structure</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Eliminated redundant error messages</li> <li>Streamlined error handling</li> </ul>"},{"location":"changelog/#301-2025-04-27","title":"[3.0.1] - 2025-04-27","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":""},{"location":"changelog/#code-quality_3","title":"Code Quality","text":"<ul> <li>Fixed import error in module dependencies</li> </ul>"},{"location":"changelog/#300-2025-04-27","title":"[3.0.0] - 2025-04-27","text":""},{"location":"changelog/#changed_8","title":"Changed","text":""},{"location":"changelog/#database-adapters","title":"Database Adapters","text":"<ul> <li>Refactor StarRocks driver integration</li> <li>Refactor SQLite driver integration</li> <li>Enhanced database adapter support</li> <li>Updated dependencies for StarRocks compatibility</li> </ul>"},{"location":"changelog/#configuration_4","title":"Configuration","text":"<ul> <li>Updated Elasticsearch Config Template</li> <li>Enhanced configuration management</li> <li>Improved dependency handling</li> </ul>"},{"location":"changelog/#code-quality_4","title":"Code Quality","text":"<ul> <li>Improved type safety across adapters</li> <li>Enhanced error handling</li> <li>Optimized connection management</li> </ul>"},{"location":"changelog/#201-2025-04-27","title":"[2.0.1] - 2025-04-27","text":""},{"location":"changelog/#added_6","title":"Added","text":""},{"location":"changelog/#starrocks","title":"StarRocks","text":"<ul> <li>Added StarRocks driver integration</li> <li>Enhanced database adapter support</li> <li>Updated dependencies for StarRocks compatibility</li> </ul>"},{"location":"changelog/#changed_9","title":"Changed","text":""},{"location":"changelog/#dependencies_3","title":"Dependencies","text":"<ul> <li>Updated poetry.lock with new dependencies</li> <li>Enhanced package compatibility</li> <li>Updated Elasticsearch Config Template</li> </ul>"},{"location":"changelog/#200-2025-04-27","title":"[2.0.0] - 2025-04-27","text":""},{"location":"changelog/#changed_10","title":"Changed","text":""},{"location":"changelog/#models","title":"Models","text":"<ul> <li>Refactored range DTOs for better type safety and validation</li> <li>Enhanced pagination DTO implementation</li> <li>Added time interval unit type support</li> </ul>"},{"location":"changelog/#code-quality_5","title":"Code Quality","text":"<ul> <li>Improved type hints in DTO implementations</li> <li>Enhanced validation in range operations</li> <li>Optimized DTO serialization</li> </ul>"},{"location":"changelog/#103-2025-04-20","title":"[1.0.3] - 2025-04-20","text":""},{"location":"changelog/#documentation_3","title":"Documentation","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Updated atomic transaction documentation with detailed examples</li> <li>Enhanced feature documentation with clear scenarios</li> <li>Added comprehensive step definitions for BDD tests</li> </ul>"},{"location":"changelog/#code-quality_6","title":"Code Quality","text":"<ul> <li>Improved SQLAlchemy atomic decorator implementation</li> <li>Enhanced test coverage for atomic transactions</li> <li>Updated BDD test scenarios for better clarity</li> </ul>"},{"location":"changelog/#102-2025-04-20","title":"[1.0.2] - 2025-04-20","text":""},{"location":"changelog/#documentation_4","title":"Documentation","text":""},{"location":"changelog/#api-reference","title":"API Reference","text":"<ul> <li>Updated adapter documentation with new architecture details</li> <li>Enhanced API reference structure and organization</li> <li>Added comprehensive usage examples</li> </ul>"},{"location":"changelog/#general-documentation","title":"General Documentation","text":"<ul> <li>Improved installation guide with detailed setup instructions</li> <li>Enhanced feature documentation with clear examples</li> <li>Updated usage guide with new architecture patterns</li> </ul>"},{"location":"changelog/#code-quality_7","title":"Code Quality","text":"<ul> <li>Updated dependencies in poetry.lock and pyproject.toml</li> <li>Enhanced documentation consistency and clarity</li> </ul>"},{"location":"changelog/#101-2025-04-20","title":"[1.0.1] - 2025-04-20","text":""},{"location":"changelog/#fixed_4","title":"Fixed","text":""},{"location":"changelog/#error-handling_1","title":"Error Handling","text":"<ul> <li>Enhanced exception capture in all scenarios</li> <li>Improved error handling robustness across components</li> <li>Added comprehensive error logging</li> </ul>"},{"location":"changelog/#code-quality_8","title":"Code Quality","text":"<ul> <li>Strengthened error recovery mechanisms</li> <li>Enhanced error reporting and debugging capabilities</li> </ul>"},{"location":"changelog/#100-2025-04-20","title":"[1.0.0] - 2025-04-20","text":""},{"location":"changelog/#architecture","title":"Architecture","text":""},{"location":"changelog/#database-adapters_1","title":"Database Adapters","text":"<ul> <li>Refactored database adapter architecture for better modularity</li> <li>Separated base SQLAlchemy functionality from specific database implementations</li> <li>Introduced dedicated adapters for PostgreSQL, SQLite, and StarRocks</li> <li>Enhanced session management with improved registry system</li> </ul>"},{"location":"changelog/#added_7","title":"Added","text":""},{"location":"changelog/#postgresql-support","title":"PostgreSQL Support","text":"<ul> <li>Implemented dedicated PostgreSQL adapter with optimized connection handling</li> <li>Added PostgreSQL-specific session management</li> <li>Enhanced configuration options for PostgreSQL connections</li> </ul>"},{"location":"changelog/#sqlite-support","title":"SQLite Support","text":"<ul> <li>Added dedicated SQLite adapter with improved transaction handling</li> <li>Implemented SQLite-specific session management</li> <li>Enhanced mock testing capabilities for SQLite</li> </ul>"},{"location":"changelog/#starrocks-support","title":"StarRocks Support","text":"<ul> <li>Introduced StarRocks database adapter</li> <li>Implemented StarRocks-specific session management</li> <li>Added configuration support for StarRocks connections</li> </ul>"},{"location":"changelog/#changed_11","title":"Changed","text":""},{"location":"changelog/#core-architecture","title":"Core Architecture","text":"<ul> <li>Moved base SQLAlchemy functionality to <code>adapters/base/sqlalchemy</code></li> <li>Refactored session management system for better extensibility</li> <li>Improved atomic transaction decorator implementation</li> </ul>"},{"location":"changelog/#documentation_5","title":"Documentation","text":"<ul> <li>Updated API reference for new adapter structure</li> <li>Enhanced configuration documentation</li> <li>Added examples for new database adapters</li> </ul>"},{"location":"changelog/#code-quality_9","title":"Code Quality","text":"<ul> <li>Improved type safety across database adapters</li> <li>Enhanced error handling in session management</li> <li>Optimized connection pooling implementation</li> </ul>"},{"location":"changelog/#0143-2025-04-26","title":"[0.14.3] - 2025-04-26","text":""},{"location":"changelog/#added_8","title":"Added","text":""},{"location":"changelog/#adapters","title":"Adapters","text":"<ul> <li>Major database adapter refactoring</li> </ul>"},{"location":"changelog/#changed_12","title":"Changed","text":"<ul> <li>Update dependencies</li> </ul>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Fix capture exeptrioin in all senario</li> </ul>"},{"location":"changelog/#0142-2025-04-20","title":"[0.14.2] - 2025-04-20","text":""},{"location":"changelog/#fixed_6","title":"Fixed","text":""},{"location":"changelog/#keycloak","title":"Keycloak","text":"<ul> <li>Resolved linter errors in Keycloak integration</li> <li>Enhanced code quality in authentication components</li> </ul>"},{"location":"changelog/#code-quality_10","title":"Code Quality","text":"<ul> <li>Improved type safety in Keycloak adapters</li> <li>Enhanced error handling in authentication flows</li> </ul>"},{"location":"changelog/#0141-2025-04-20","title":"[0.14.1] - 2025-04-20","text":""},{"location":"changelog/#fixed_7","title":"Fixed","text":""},{"location":"changelog/#database","title":"Database","text":"<ul> <li>Resolved \"DEFAULT\" server_default value issue in BaseEntity timestamps</li> <li>Enhanced timestamp handling in database entities</li> </ul>"},{"location":"changelog/#code-quality_11","title":"Code Quality","text":"<ul> <li>Improved database entity configuration</li> <li>Enhanced type safety in entity definitions</li> </ul>"},{"location":"changelog/#0140-2025-04-16","title":"[0.14.0] - 2025-04-16","text":""},{"location":"changelog/#added_9","title":"Added","text":""},{"location":"changelog/#kafka-integration","title":"Kafka Integration","text":"<ul> <li>Implemented comprehensive Kafka adapter system with ports and adapters</li> <li>Added test suite for Kafka adapters</li> <li>Enhanced Kafka documentation with detailed usage examples</li> </ul>"},{"location":"changelog/#documentation_6","title":"Documentation","text":"<ul> <li>Refactored and improved documentation structure</li> <li>Added comprehensive Kafka integration guides</li> <li>Enhanced docstrings for better code understanding</li> </ul>"},{"location":"changelog/#fixed_8","title":"Fixed","text":""},{"location":"changelog/#code-quality_12","title":"Code Quality","text":"<ul> <li>Resolved linting issues in configuration templates</li> <li>Fixed lint errors in Keycloak adapters and ports</li> </ul>"},{"location":"changelog/#0135-2025-04-16","title":"[0.13.5] - 2025-04-16","text":""},{"location":"changelog/#fixed_9","title":"Fixed","text":""},{"location":"changelog/#sqlalchemy","title":"SQLAlchemy","text":"<ul> <li>Resolved sorting functionality in SQLAlchemy mixin</li> <li>Enhanced query sorting capabilities with improved error handling</li> </ul>"},{"location":"changelog/#code-quality_13","title":"Code Quality","text":"<ul> <li>Applied ruff formatter to config_template.py for consistent code style</li> <li>Updated AsyncContextManager to AbstractAsyncContextManager to resolve UP035 lint error</li> </ul>"},{"location":"changelog/#0134-2025-04-15","title":"[0.13.4] - 2025-04-15","text":""},{"location":"changelog/#added_10","title":"Added","text":""},{"location":"changelog/#fastapi-integration","title":"FastAPI Integration","text":"<ul> <li>Implemented lifespan support for FastAPI applications</li> <li>Enhanced application lifecycle management with proper startup and shutdown handlers</li> </ul>"},{"location":"changelog/#database-configuration","title":"Database Configuration","text":"<ul> <li>Added automatic database URL generation with validation in SqlAlchemyConfig</li> <li>Improved database connection configuration with enhanced error handling</li> </ul>"},{"location":"changelog/#code-quality_14","title":"Code Quality","text":"<ul> <li>Integrated new features with comprehensive test coverage</li> <li>Enhanced configuration validation and error reporting</li> </ul>"},{"location":"changelog/#changed_13","title":"Changed","text":"<ul> <li>Update changelogs</li> </ul>"},{"location":"changelog/#fixed_10","title":"Fixed","text":""},{"location":"changelog/#configs","title":"Configs","text":"<ul> <li>Run ruff format on config_template.py to resolve formatting issues</li> <li>Replace AsyncContextManager with AbstractAsyncContextManager to fix UP035 lint error</li> </ul>"},{"location":"changelog/#0133-2025-04-15","title":"[0.13.3] - 2025-04-15","text":""},{"location":"changelog/#added_11","title":"Added","text":""},{"location":"changelog/#cicd","title":"CI/CD","text":"<ul> <li>Implemented comprehensive linting workflow for improved code quality</li> <li>Enhanced GitHub Actions with updated tj-actions/changed-files for better change tracking</li> </ul>"},{"location":"changelog/#documentation_7","title":"Documentation","text":"<ul> <li>Added detailed documentation for range DTOs and their usage patterns</li> <li>Improved API reference documentation with new examples</li> </ul>"},{"location":"changelog/#changed_14","title":"Changed","text":""},{"location":"changelog/#models_1","title":"Models","text":"<ul> <li>Enhanced range DTOs with improved type safety and validation</li> <li>Updated range DTOs to support more flexible boundary conditions</li> </ul>"},{"location":"changelog/#code-quality_15","title":"Code Quality","text":"<ul> <li>Integrated automated linting for consistent code style</li> <li>Improved code formatting and documentation standards</li> </ul>"},{"location":"changelog/#0132-2025-04-10","title":"[0.13.2] - 2025-04-10","text":""},{"location":"changelog/#documentation_8","title":"Documentation","text":"<ul> <li>Enhanced Redis adapter documentation with comprehensive docstrings</li> <li>Added MinIO adapter to API reference documentation</li> </ul>"},{"location":"changelog/#code-quality_16","title":"Code Quality","text":"<ul> <li>Improved code quality with linter fixes across Redis adapter and ORM components</li> <li>Fixed file utilities test suite</li> <li>Cleaned up redundant changelog files</li> </ul>"},{"location":"changelog/#0131-2025-04-08","title":"[0.13.1] - 2025-04-08","text":""},{"location":"changelog/#security_1","title":"Security","text":"<ul> <li>Enhanced cryptographic security by replacing <code>random</code> with <code>secrets</code> module</li> <li>Strengthened TOTP implementation with improved security practices</li> <li>Upgraded password utilities with robust validation and generation</li> </ul>"},{"location":"changelog/#code-quality_17","title":"Code Quality","text":"<ul> <li>Improved type safety with explicit typing and modern type hints</li> <li>Enhanced error handling with domain-specific exception types</li> <li>Standardized parameter naming and module consistency</li> </ul>"},{"location":"changelog/#documentation_9","title":"Documentation","text":"<ul> <li>Added comprehensive docstrings to configuration classes</li> <li>Expanded utility function documentation</li> <li>Improved error handling documentation</li> </ul>"},{"location":"changelog/#0130-2025-04-08","title":"[0.13.0] - 2025-04-08","text":""},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>MinIO Integration: Full S3-compatible object storage adapter with:<ul> <li>Comprehensive S3 operation support (12 standardized methods)</li> <li>Built-in TTL caching for performance optimization</li> <li>Flexible configuration with endpoint and credential management</li> <li>Clear cache management through <code>clear_all_caches</code></li> </ul> </li> </ul>"},{"location":"changelog/#testing_1","title":"Testing","text":"<ul> <li>Added complete BDD test suite for MinIO adapter:<ul> <li>Bucket and object operation validation</li> <li>Presigned URL generation testing</li> <li>Bucket policy management verification</li> </ul> </li> </ul>"},{"location":"changelog/#documentation_10","title":"Documentation","text":"<ul> <li>Added extensive MinIO adapter examples and usage guides</li> <li>Improved error handling documentation</li> <li>Updated configuration documentation with new MinIO settings</li> </ul>"},{"location":"changelog/#usage-example","title":"Usage Example","text":"<pre><code># Initialize the MinIO adapter\nfrom archipy.adapters.minio.adapters import MinioAdapter\n\nminio = MinioAdapter()\n\n# Create a bucket and upload a file\nminio.make_bucket(\"my-bucket\")\nminio.put_object(\"my-bucket\", \"document.pdf\", \"/path/to/document.pdf\")\n\n# Generate a presigned URL for temporary access\ndownload_url = minio.presigned_get_object(\"my-bucket\", \"document.pdf\", expires=3600)\n</code></pre>"},{"location":"changelog/#0120-2025-03-29","title":"[0.12.0] - 2025-03-29","text":""},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>Keycloak Integration: Comprehensive authentication and authorization for FastAPI:<ul> <li>Role-based access control with customizable requirements</li> <li>Resource-based authorization for fine-grained access control</li> <li>Both synchronous and asynchronous authentication flows</li> <li>Token validation and introspection</li> <li>User info extraction capabilities</li> </ul> </li> </ul>"},{"location":"changelog/#code-quality_18","title":"Code Quality","text":"<ul> <li>Improved error handling clarity by renaming <code>ExceptionMessageType</code> to <code>ErrorMessageType</code></li> <li>Enhanced error documentation with detailed descriptions</li> <li>Updated error handling implementation with new message types</li> </ul>"},{"location":"changelog/#usage-example_1","title":"Usage Example","text":"<pre><code>from fastapi import FastAPI, Depends\nfrom archipy.helpers.utils.keycloak_utils import KeycloakUtils\n\napp = FastAPI()\n\n\n@app.get(\"/api/profile\")\ndef get_profile(user: dict = Depends(KeycloakUtils.fastapi_auth(\n    required_roles={\"user\"},\n    admin_roles={\"admin\"}\n))):\n    return {\n        \"user_id\": user.get(\"sub\"),\n        \"username\": user.get(\"preferred_username\")\n    }\n</code></pre>"},{"location":"changelog/#0112-2025-03-21","title":"[0.11.2] - 2025-03-21","text":""},{"location":"changelog/#error-handling_2","title":"Error Handling","text":"<ul> <li>Enhanced exception management with improved error reporting</li> <li>Streamlined error messaging for better debugging</li> <li>Fixed various error handling edge cases</li> </ul>"},{"location":"changelog/#0111-2025-03-15","title":"[0.11.1] - 2025-03-15","text":""},{"location":"changelog/#performance","title":"Performance","text":"<ul> <li>Optimized resource usage across core components</li> <li>Enhanced caching mechanisms for improved performance</li> <li>Improved memory utilization in key operations</li> </ul>"},{"location":"changelog/#0110-2025-03-10","title":"[0.11.0] - 2025-03-10","text":""},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>Keycloak Adapter: New authentication and authorization system:<ul> <li>Asynchronous operations support</li> <li>Token management and validation</li> <li>User information retrieval</li> <li>Comprehensive security features</li> </ul> </li> </ul>"},{"location":"changelog/#performance_1","title":"Performance","text":"<ul> <li>Added TTL cache decorator for optimized performance</li> <li>Improved Keycloak adapter efficiency</li> </ul>"},{"location":"changelog/#documentation_11","title":"Documentation","text":"<ul> <li>Added detailed Keycloak integration guides</li> <li>Included comprehensive usage examples</li> </ul>"},{"location":"changelog/#usage-example_2","title":"Usage Example","text":"<pre><code>from archipy.adapters.keycloak.adapters import KeycloakAdapter\n\n# Initialize adapter with configuration from global config\nkeycloak = KeycloakAdapter()\n\n# Authenticate and get access token\ntoken = keycloak.get_token(\"username\", \"password\")\n\n# Get user information\nuser_info = keycloak.get_userinfo(token)\n\n# Verify token validity\nis_valid = keycloak.validate_token(token)\n</code></pre>"},{"location":"changelog/#0102-2025-03-05","title":"[0.10.2] - 2025-03-05","text":""},{"location":"changelog/#stability","title":"Stability","text":"<ul> <li>Improved Redis connection pool stability and management</li> <li>Enhanced error recovery mechanisms</li> <li>Fixed various edge cases in Redis operations</li> </ul>"},{"location":"changelog/#0101-2025-03-01","title":"[0.10.1] - 2025-03-01","text":""},{"location":"changelog/#documentation_12","title":"Documentation","text":"<ul> <li>Enhanced Redis and email adapter documentation</li> <li>Added comprehensive API reference</li> <li>Improved usage examples for common operations</li> </ul>"},{"location":"changelog/#0100-2025-02-25","title":"[0.10.0] - 2025-02-25","text":""},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li> <p>Redis Integration: New caching and key-value storage system:</p> <ul> <li>Flexible key-value operations</li> <li>Built-in TTL support</li> <li>Connection pooling</li> <li>Comprehensive error handling</li> </ul> </li> <li> <p>Email Service: New email integration system:</p> <ul> <li>Multiple email provider support</li> <li>Template-based email sending</li> <li>Attachment handling</li> <li>Async operation support</li> </ul> </li> </ul>"},{"location":"changelog/#configuration_5","title":"Configuration","text":"<ul> <li>Enhanced configuration management system</li> <li>Added support for Redis and email settings</li> <li>Improved environment variable handling</li> </ul>"},{"location":"changelog/#usage-example_3","title":"Usage Example","text":"<pre><code># Initialize the Redis adapter\nfrom archipy.adapters.redis.adapters import RedisAdapter\n\nredis = RedisAdapter()\n\n# Basic operations\nredis.set(\"user:1:name\", \"John Doe\")\nname = redis.get(\"user:1:name\")\n\n# Using with TTL\nredis.set(\"session:token\", \"abc123\", ttl=3600)  # Expires in 1 hour\n</code></pre>"},{"location":"changelog/#090-2025-02-20","title":"[0.9.0] - 2025-02-20","text":""},{"location":"changelog/#security_2","title":"Security","text":"<ul> <li> <p>TOTP System: Comprehensive Time-based One-Time Password implementation:</p> <ul> <li>Secure token generation and validation</li> <li>Configurable time windows</li> <li>Built-in expiration handling</li> <li>RFC compliance</li> </ul> </li> <li> <p>Multi-Factor Authentication: Enhanced security framework:</p> <ul> <li>Multiple authentication factor support</li> <li>Flexible factor configuration</li> <li>Integration with existing auth systems</li> </ul> </li> </ul>"},{"location":"changelog/#usage-example_4","title":"Usage Example","text":"<pre><code>from archipy.helpers.utils.totp_utils import TOTPUtils\nfrom uuid import uuid4\n\n# Generate a TOTP code\nuser_id = uuid4()\ntotp_code, expires_at = TOTPUtils.generate_totp(user_id)\n\n# Verify a TOTP code\nis_valid = TOTPUtils.verify_totp(user_id, totp_code)\n\n# Generate a secure key for TOTP initialization\nsecret_key = TOTPUtils.generate_secret_key_for_totp()\n</code></pre>"},{"location":"changelog/#080-2025-02-15","title":"[0.8.0] - 2025-02-15","text":""},{"location":"changelog/#features_5","title":"Features","text":"<ul> <li>Redis Integration: Comprehensive key-value store and caching system:<ul> <li>Full Redis API implementation</li> <li>Built-in caching functionality</li> <li>Performance-optimized operations</li> <li>Connection pooling support</li> </ul> </li> </ul>"},{"location":"changelog/#testing_2","title":"Testing","text":"<ul> <li>Mock Redis Implementation:<ul> <li>Complete test coverage for Redis operations</li> <li>Simulated Redis environment for testing</li> <li>Configurable mock behaviors</li> </ul> </li> </ul>"},{"location":"changelog/#documentation_13","title":"Documentation","text":"<ul> <li>Added Redis integration guides</li> <li>Included mock testing examples</li> <li>Updated configuration documentation</li> </ul>"},{"location":"changelog/#072-2025-02-10","title":"[0.7.2] - 2025-02-10","text":""},{"location":"changelog/#database_1","title":"Database","text":"<ul> <li>Enhanced connection pool stability and management</li> <li>Improved transaction isolation and handling</li> <li>Optimized error reporting for database operations</li> <li>Added connection lifecycle management</li> </ul>"},{"location":"changelog/#071-2025-02-05","title":"[0.7.1] - 2025-02-05","text":""},{"location":"changelog/#performance_2","title":"Performance","text":"<ul> <li>Optimized query execution and planning</li> <li>Reduced memory footprint for ORM operations</li> <li>Enhanced connection pool efficiency</li> <li>Improved cache utilization</li> </ul>"},{"location":"changelog/#070-2025-02-01","title":"[0.7.0] - 2025-02-01","text":""},{"location":"changelog/#features_6","title":"Features","text":"<ul> <li>SQLAlchemy Integration: Complete ORM implementation:<ul> <li>Robust entity model system</li> <li>Transaction management with ACID compliance</li> <li>Connection pooling with configurable settings</li> <li>Comprehensive database operations support</li> </ul> </li> </ul>"},{"location":"changelog/#usage-example_5","title":"Usage Example","text":"<pre><code>from archipy.adapters.postgres.sqlalchemy.adapters import SQLAlchemyAdapter\nfrom archipy.models.entities.sqlalchemy.base_entities import BaseEntity\nfrom sqlalchemy import Column, String\n\n\n# Define a model\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n    name = Column(String(100))\n    email = Column(String(100), unique=True)\n\n\n# Use the ORM\norm = SQLAlchemyAdapter()\nwith orm.session() as session:\n    # Create and read operations\n    new_user = User(name=\"John Doe\", email=\"john@example.com\")\n    session.add(new_user)\n    session.commit()\n\n    user = session.query(User).filter_by(email=\"john@example.com\").first()\n</code></pre>"},{"location":"changelog/#061-2025-01-25","title":"[0.6.1] - 2025-01-25","text":""},{"location":"changelog/#stability_1","title":"Stability","text":"<ul> <li>Fixed memory leaks in gRPC interceptors</li> <li>Improved interceptor performance and efficiency</li> <li>Enhanced request/response handling reliability</li> <li>Optimized resource cleanup</li> </ul>"},{"location":"changelog/#060-2025-01-20","title":"[0.6.0] - 2025-01-20","text":""},{"location":"changelog/#features_7","title":"Features","text":"<ul> <li>gRPC Integration: Comprehensive interceptor system:<ul> <li>Client and server-side interceptors</li> <li>Request/response monitoring</li> <li>Performance tracing capabilities</li> <li>Enhanced error management</li> </ul> </li> </ul>"},{"location":"changelog/#documentation_14","title":"Documentation","text":"<ul> <li>Added gRPC integration guides</li> <li>Included interceptor configuration examples</li> <li>Updated troubleshooting documentation</li> </ul>"},{"location":"changelog/#051-2025-01-15","title":"[0.5.1] - 2025-01-15","text":""},{"location":"changelog/#stability_2","title":"Stability","text":"<ul> <li>Enhanced FastAPI middleware reliability</li> <li>Improved response processing efficiency</li> <li>Optimized request handling performance</li> <li>Fixed edge cases in error management</li> </ul>"},{"location":"changelog/#050-2025-01-10","title":"[0.5.0] - 2025-01-10","text":""},{"location":"changelog/#features_8","title":"Features","text":"<ul> <li>FastAPI Integration: Complete web framework support:<ul> <li>Custom middleware components</li> <li>Request/response processors</li> <li>Standardized error handling</li> <li>Response formatting utilities</li> </ul> </li> </ul>"},{"location":"changelog/#documentation_15","title":"Documentation","text":"<ul> <li>Added FastAPI integration guides</li> <li>Included middleware configuration examples</li> <li>Updated API documentation</li> </ul>"},{"location":"changelog/#040-2025-01-05","title":"[0.4.0] - 2025-01-05","text":""},{"location":"changelog/#features_9","title":"Features","text":"<ul> <li>Configuration System: Flexible environment management:<ul> <li>Environment variable support</li> <li>Type-safe configuration validation</li> <li>Default value management</li> <li>Override capabilities</li> </ul> </li> </ul>"},{"location":"changelog/#documentation_16","title":"Documentation","text":"<ul> <li>Added configuration system guides</li> <li>Included environment setup examples</li> <li>Updated validation documentation</li> </ul>"},{"location":"changelog/#030-2024-12-25","title":"[0.3.0] - 2024-12-25","text":""},{"location":"changelog/#features_10","title":"Features","text":"<ul> <li>Core Utilities: Comprehensive helper functions:<ul> <li>Date/time manipulation with timezone support</li> <li>String processing and formatting</li> <li>Common development utilities</li> <li>Type conversion helpers</li> </ul> </li> </ul>"},{"location":"changelog/#documentation_17","title":"Documentation","text":"<ul> <li>Added utility function reference</li> <li>Included usage examples</li> <li>Updated API documentation</li> </ul>"},{"location":"changelog/#020-2024-12-20","title":"[0.2.0] - 2024-12-20","text":""},{"location":"changelog/#architecture_1","title":"Architecture","text":"<ul> <li>Hexagonal Architecture: Core implementation:<ul> <li>Ports and adapters pattern</li> <li>Clean architecture principles</li> <li>Domain-driven design</li> <li>Base entity models</li> </ul> </li> </ul>"},{"location":"changelog/#documentation_18","title":"Documentation","text":"<ul> <li>Added architecture overview</li> <li>Included design pattern guides</li> <li>Updated component documentation</li> </ul>"},{"location":"changelog/#010-2025-02-21","title":"[0.1.0] - 2025-02-21","text":""},{"location":"changelog/#features_11","title":"Features","text":"<ul> <li>Initial Release: Project foundation:<ul> <li>Core project structure</li> <li>Basic framework components</li> <li>Configuration system</li> <li>CI/CD pipeline with GitHub Actions</li> </ul> </li> </ul>"},{"location":"changelog/#documentation_19","title":"Documentation","text":"<ul> <li>Added initial documentation</li> <li>Included getting started guide</li> <li>Created contribution guidelines</li> </ul>"},{"location":"contributing-docs/","title":"ArchiPy Documentation Guidelines","text":"<p>This document outlines the standards and practices for ArchiPy documentation.</p>"},{"location":"contributing-docs/#documentation-structure","title":"Documentation Structure","text":"<ul> <li><code>mkdocs.yml</code> - Main configuration file for MkDocs</li> <li><code>docs/</code> - Markdown documentation files<ul> <li><code>index.md</code> - Home page</li> <li><code>api_reference/</code> - API documentation</li> <li><code>examples/</code> - Usage examples</li> <li><code>assets/</code> - Images and other static assets</li> </ul> </li> </ul>"},{"location":"contributing-docs/#writing-documentation","title":"Writing Documentation","text":""},{"location":"contributing-docs/#format-and-style","title":"Format and Style","text":"<ul> <li>Use Markdown syntax for all documentation files</li> <li>Follow the Google Python style for code examples</li> <li>Include type hints in code samples (using Python 3.13 syntax)</li> <li>Include proper exception handling with <code>raise ... from e</code> pattern</li> <li>Group related documentation in directories</li> <li>Link between documentation pages using relative links</li> </ul>"},{"location":"contributing-docs/#code-examples","title":"Code Examples","text":"<p>When including code examples:</p> <ol> <li>Include proper type hints using Python 3.13 syntax (<code>x: list[str]</code> not <code>List[str]</code>)</li> <li>Demonstrate proper error handling with exception chaining</li> <li>Include docstrings with Args, Returns, and Raises sections</li> <li>Show realistic use cases that align with ArchiPy's patterns</li> <li>Keep examples concise but complete enough to understand usage</li> </ol>"},{"location":"contributing-docs/#admonitions","title":"Admonitions","text":"<p>Use Material for MkDocs admonitions to highlight important information:</p> <pre><code>!!! note\n    This is a note.\n\n!!! warning\n    This is a warning.\n\n!!! tip\n    This is a tip.\n</code></pre>"},{"location":"contributing-docs/#building-and-previewing-documentation","title":"Building and Previewing Documentation","text":"<p>Preview the documentation locally: <pre><code>make docs-serve\n</code></pre></p> <p>Build the documentation: <pre><code>make docs-build\n</code></pre></p> <p>Deploy to GitHub Pages: <pre><code>make docs-deploy\n</code></pre></p>"},{"location":"contributing-docs/#documentation-improvement-guidelines","title":"Documentation Improvement Guidelines","text":"<p>When improving documentation:</p> <ol> <li>Ensure clarity and conciseness</li> <li>Include practical, runnable examples</li> <li>Explain \"why\" not just \"how\"</li> <li>Maintain logical navigation</li> <li>Use diagrams for complex concepts</li> <li>Validate that examples match the current API</li> <li>Test code examples to ensure they work correctly</li> </ol>"},{"location":"contributing/","title":"Contributing","text":"<p>Welcome to ArchiPy! We're excited that you're interested in contributing. This document outlines the process for contributing to ArchiPy.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the Repository</li> </ol> <p>Fork the ArchiPy repository on GitHub.</p> <ol> <li>Clone Your Fork</li> </ol> <pre><code>git clone https://github.com/YOUR-USERNAME/ArchiPy.git\ncd ArchiPy\n</code></pre> <ol> <li>Set Up Development Environment</li> </ol> <pre><code>make setup\nmake install\nmake install-dev\n</code></pre> <ol> <li>Create a Branch</li> </ol> <p>Create a branch for your feature or bugfix:</p> <pre><code>git checkout -b feature/your-feature-name\n</code></pre>"},{"location":"contributing/#contribution-guidelines","title":"Contribution Guidelines","text":""},{"location":"contributing/#code-style","title":"Code Style","text":"<p>ArchiPy follows a strict code style to maintain consistency across the codebase:</p> <ul> <li>Black: For code formatting</li> <li>Ruff: For linting</li> <li>Mypy: For type checking</li> </ul> <p>All code must pass these checks before being merged:</p> <pre><code>make check\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":"<p>All contributions should include appropriate tests:</p> <ul> <li>Unit Tests: For testing individual components</li> <li>Integration Tests: For testing component interactions</li> <li>BDD Tests: For behavior-driven development</li> </ul> <p>Run the tests to ensure your changes don't break existing functionality:</p> <pre><code>make test\nmake behave\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>All new features or changes should be documented:</p> <ul> <li>Docstrings: Update or add docstrings to document functions, classes, and methods</li> <li>Type Annotations: Include type annotations for all functions and methods</li> <li>Documentation Files: Update relevant documentation files if necessary</li> </ul> <p>Building the documentation locally:</p> <pre><code>cd docs\nmake html\n</code></pre>"},{"location":"contributing/#commit-messages","title":"Commit Messages","text":"<p>ArchiPy follows the Conventional Commits specification for commit messages:</p> <pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;description&gt;\n</code></pre> <p>Common types:</p> <ul> <li><code>feat</code>: New feature</li> <li><code>fix</code>: Bug fix</li> <li><code>docs</code>: Documentation changes</li> <li><code>style</code>: Formatting changes</li> <li><code>refactor</code>: Code refactoring</li> <li><code>test</code>: Adding or modifying tests</li> <li><code>chore</code>: Maintenance tasks</li> </ul>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Update Your Branch</li> </ol> <p>Before submitting a pull request, make sure your branch is up to date with the main branch:</p> <pre><code>git checkout main\ngit pull origin main\ngit checkout your-branch\ngit rebase main\n</code></pre> <ol> <li>Run All Checks</li> </ol> <p>Ensure all checks pass:</p> <pre><code>make check\nmake test\n</code></pre> <ol> <li>Submit Your Pull Request</li> </ol> <p>Push your branch to your fork and create a pull request:</p> <pre><code>git push origin your-branch\n</code></pre> <ol> <li>Code Review</li> </ol> <p>Your pull request will be reviewed by the maintainers. They may suggest changes or improvements.</p> <ol> <li>Merge</li> </ol> <p>Once your pull request is approved, it will be merged into the main branch.</p>"},{"location":"contributing/#bug-reports-and-feature-requests","title":"Bug Reports and Feature Requests","text":"<p>If you find a bug or have a feature request, please create an issue on the GitHub issues page.</p> <p>When reporting a bug, please include:</p> <ul> <li>A clear and descriptive title</li> <li>A detailed description of the bug</li> <li>Steps to reproduce the bug</li> <li>Expected behavior</li> <li>Actual behavior</li> <li>Any relevant logs or error messages</li> </ul> <p>When submitting a feature request, please include:</p> <ul> <li>A clear and descriptive title</li> <li>A detailed description of the feature</li> <li>Any relevant use cases</li> <li>If possible, a sketch of how the feature might be implemented</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please note that ArchiPy has a code of conduct. By participating in this project, you agree to abide by its terms.</p>"},{"location":"contributing/#thank-you","title":"Thank You","text":"<p>Thank you for contributing to ArchiPy! Your efforts help make the project better for everyone.</p>"},{"location":"development/","title":"Development","text":""},{"location":"development/#development-environment","title":"Development Environment","text":""},{"location":"development/#set-up","title":"Set Up","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/SyntaxArc/ArchiPy.git\ncd ArchiPy\n</code></pre> <ol> <li>Initialize the project:</li> </ol> <pre><code>make setup\n</code></pre> <ol> <li>Install dependencies:</li> </ol> <pre><code>make install      # Core dependencies\nmake install-dev  # All dependencies including dev tools\n</code></pre>"},{"location":"development/#workflow","title":"Workflow","text":""},{"location":"development/#code-quality","title":"Code Quality","text":"<p>Run checks:</p> <pre><code>make check  # Runs ruff, black, mypy\n</code></pre>"},{"location":"development/#testing","title":"Testing","text":"<p>Run tests:</p> <pre><code>make behave    # BDD tests\nmake ci        # Full pipeline\n</code></pre> <p>BDD tests use <code>behave</code> with feature files in <code>features/</code> and steps in <code>features/steps/</code>.</p>"},{"location":"development/#versioning","title":"Versioning","text":"<p>Follow Semantic Versioning:</p> <pre><code>make bump-patch  # Bug fixes\nmake bump-minor  # New features\nmake bump-major  # Breaking changes\n</code></pre> <p>Add a message:</p> <pre><code>make bump-minor message=\"Added new utility\"\n</code></pre>"},{"location":"development/#build-docs","title":"Build &amp; Docs","text":"<p>Build the package:</p> <pre><code>make build\nmake clean  # Remove artifacts\n</code></pre> <p>Build docs:</p> <pre><code>cd docs\nmake html\n</code></pre> <p>Update dependencies:</p> <pre><code>make update  # Updates uv.lock with latest versions\n</code></pre>"},{"location":"features/","title":"Features","text":"<p>ArchiPy provides a robust framework for structured Python development, focusing on standardization, testability, and productivity.</p>"},{"location":"features/#database-integration","title":"Database Integration","text":"<ul> <li>Multi-Database Support: Dedicated adapters for PostgreSQL, SQLite, and StarRocks</li> <li>SQLAlchemy Integration: Standardized ORM implementation with:<ul> <li>Base SQLAlchemy components for common functionality</li> <li>Database-specific session management</li> <li>Enhanced transaction handling with atomic decorators</li> <li>Connection pooling and lifecycle management</li> </ul> </li> </ul>"},{"location":"features/#configuration-management","title":"Configuration Management","text":"<ul> <li>Standardized Configs: Use <code>base_config</code> and <code>config_template</code> for consistent setup</li> <li>Injection: Seamlessly inject configurations into components</li> <li>Environment Management: Flexible environment variable handling with validation</li> <li>Type Safety: Configuration validation with Pydantic models</li> </ul>"},{"location":"features/#adapters-mocks","title":"Adapters &amp; Mocks","text":"<ul> <li>Database Adapters: Dedicated implementations for PostgreSQL, SQLite, and StarRocks</li> <li>Service Adapters: Pre-built for Redis, Email, Keycloak, MinIO, and Kafka</li> <li>Mocks: Testable mocks for isolated testing</li> <li>Async Support: Synchronous and asynchronous implementations</li> <li>Ports &amp; Adapters Pattern: Clean architecture with dependency inversion</li> </ul>"},{"location":"features/#data-standardization","title":"Data Standardization","text":"<ul> <li>Base Entities: Standardized SQLAlchemy entities with timestamp handling</li> <li>DTOs: Pydantic-based DTOs for data transfer:<ul> <li>Pagination and sorting</li> <li>Error handling</li> <li>Search and range operations</li> <li>Email and attachment handling</li> </ul> </li> <li>Type Safety: Enforced via Pydantic and modern Python type hints</li> </ul>"},{"location":"features/#helper-utilities","title":"Helper Utilities","text":"<ul> <li>Decorators:<ul> <li>Retry mechanism for resilient operations</li> <li>Singleton pattern implementation</li> <li>SQLAlchemy atomic transactions</li> <li>TTL caching for performance optimization</li> </ul> </li> <li>Interceptors:<ul> <li>FastAPI rate limiting</li> <li>gRPC tracing and monitoring</li> </ul> </li> <li>Security:<ul> <li>Keycloak integration for authentication</li> <li>TOTP implementation</li> <li>Password utilities with secure hashing</li> <li>JWT handling</li> </ul> </li> <li>Type Safety: Consistent type checking and casting</li> </ul>"},{"location":"features/#testing-quality","title":"Testing &amp; Quality","text":"<ul> <li>BDD Testing:<ul> <li>Behave integration for sync/async scenarios</li> <li>Comprehensive feature files</li> <li>Step definitions for common operations</li> </ul> </li> <li>Code Quality:<ul> <li>Automated linting with ruff</li> <li>Type checking with mypy</li> <li>Code formatting with black</li> <li>Pre-commit hooks for quality assurance</li> </ul> </li> </ul>"},{"location":"features/#best-practices-tooling","title":"Best Practices &amp; Tooling","text":"<ul> <li>UV: Fast Python package installer and resolver</li> <li>Pre-commit: Automated code quality checks</li> <li>Clean Architecture: Hexagonal design pattern</li> <li>Modular Design: Optional dependencies for flexibility</li> <li>Comprehensive Documentation: API reference and usage examples</li> </ul>"},{"location":"features/#performance-scalability","title":"Performance &amp; Scalability","text":"<ul> <li>Connection Pooling: Optimized database connections</li> <li>Caching: Redis integration for performance</li> <li>Async Support: Non-blocking operations</li> <li>Resource Management: Proper cleanup and lifecycle handling</li> <li>Error Recovery: Robust error handling and retry mechanisms</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li>Python 3.13 or higher</li> </ul> <p>ArchiPy requires Python 3.13+. Check your version with:</p> <pre><code>```bash\npython --version\n```\n</code></pre> <p>If needed, download Python 3.13+.</p> <ul> <li>UV (for dependency management)</li> </ul> <p>UV is a fast Python package installer and resolver. Install it via the official guide.</p>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#using-pip","title":"Using pip","text":"<p>Install the core library:</p> <pre><code>pip install archipy\n</code></pre> <p>With optional dependencies (e.g., database adapters, services):</p> <pre><code>pip install archipy[postgres,sqlite,starrocks,redis,keycloak,minio,kafka]\n</code></pre>"},{"location":"installation/#using-uv","title":"Using UV","text":"<p>Add the core library:</p> <pre><code>uv add archipy\n</code></pre> <p>With optional dependencies:</p> <pre><code>uv add \"archipy[postgres,sqlite,starrocks,redis,keycloak,minio,kafka]\"\n</code></pre>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>ArchiPy supports modular features through optional dependencies:</p>"},{"location":"installation/#database-adapters","title":"Database Adapters","text":"Feature Installation Command Description PostgreSQL <code>archipy[postgres]</code> PostgreSQL database adapter with SQLAlchemy integration SQLite <code>archipy[sqlite]</code> SQLite database adapter with SQLAlchemy integration StarRocks <code>archipy[starrocks]</code> StarRocks database adapter with SQLAlchemy integration"},{"location":"installation/#service-adapters","title":"Service Adapters","text":"Feature Installation Command Description Redis <code>archipy[redis]</code> Redis caching and key-value storage Keycloak <code>archipy[keycloak]</code> Authentication and authorization services MinIO <code>archipy[minio]</code> S3-compatible object storage Kafka <code>archipy[kafka]</code> Message streaming and event processing"},{"location":"installation/#web-framework-support","title":"Web Framework Support","text":"Feature Installation Command Description FastAPI <code>archipy[fastapi]</code> FastAPI integration with middleware and utilities gRPC <code>archipy[grpc]</code> gRPC integration with interceptors"},{"location":"installation/#additional-features","title":"Additional Features","text":"Feature Installation Command Description JWT <code>archipy[jwt]</code> JSON Web Token utilities Prometheus <code>archipy[prometheus]</code> Metrics and monitoring Sentry <code>archipy[sentry]</code> Error tracking and monitoring Scheduler <code>archipy[scheduler]</code> Task scheduling utilities"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For contributors:</p> <pre><code># Clone the repository\ngit clone https://github.com/SyntaxArc/ArchiPy.git\ncd ArchiPy\n\n# Set up the project (installs UV)\nmake setup\n\n# Install dependencies\nmake install\n\n# Install all development tools and optional dependencies\nmake install-dev\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":"<p>If issues arise, verify:</p> <ol> <li>Python version is 3.13+</li> <li><code>pip</code> or <code>uv</code> is updated (e.g., <code>pip install --upgrade pip</code> or <code>uv self update</code>)</li> <li>Build tools are available (UV handles this automatically)</li> <li>Database-specific dependencies are installed if using database adapters</li> </ol> <p>IDE Integration</p> <p>For the best development experience, use an IDE that supports Python type hints, such as PyCharm or VS Code with the Python extension. The project uses modern Python type hints and benefits from IDE support for type checking and autocompletion.</p>"},{"location":"license/","title":"License","text":"<p>ArchiPy is licensed under the terms of the license file included in the repository.</p> <p>For more details, see the LICENSE file.</p>"},{"location":"usage/","title":"Getting Started","text":"<p>This guide will help you start building applications with ArchiPy.</p>"},{"location":"usage/#basic-setup","title":"Basic Setup","text":"<ol> <li>First, initialize your application with a configuration:</li> </ol> <pre><code>from archipy.configs.base_config import BaseConfig\n\nclass AppConfig(BaseConfig):\n    # Custom configuration\n    pass\n\n# Set as global config\nconfig = AppConfig()\nBaseConfig.set_global(config)\n</code></pre> <ol> <li>Define your domain models:</li> </ol> <pre><code>from uuid import uuid4\nfrom sqlalchemy import Column, String, ForeignKey\nfrom sqlalchemy.orm import relationship\nfrom archipy.models.entities.sqlalchemy.base_entities import BaseEntity\n\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n\n    username = Column(String(100), unique=True)\n    email = Column(String(255), unique=True)\n\n    # Relationships\n    posts = relationship(\"Post\", back_populates=\"author\")\n\nclass Post(BaseEntity):\n    __tablename__ = \"posts\"\n\n    title = Column(String(255))\n    content = Column(String(1000))\n\n    # Foreign keys\n    author_id = Column(UUID, ForeignKey(\"users.test_uuid\"))\n\n    # Relationships\n    author = relationship(\"User\", back_populates=\"posts\")\n</code></pre> <ol> <li>Set up your database adapter:</li> </ol> <pre><code># For PostgreSQL\nfrom archipy.adapters.postgres.sqlalchemy.adapters import PostgresSQLAlchemyAdapter, AsyncPostgresSQLAlchemyAdapter\n\n# For SQLite\nfrom archipy.adapters.sqlite.sqlalchemy.adapters import SQLiteSQLAlchemyAdapter, AsyncSQLiteSQLAlchemyAdapter\n\n# For StarRocks\nfrom archipy.adapters.starrocks.sqlalchemy.adapters import StarrocksSQLAlchemyAdapter, AsyncStarrocksSQLAlchemyAdapter\n\n# Create adapter (uses global config)\ndb_adapter = PostgresSQLAlchemyAdapter()\n\n# Create tables (development only)\nBaseEntity.metadata.create_all(db_adapter.session_manager.engine)\n</code></pre> <ol> <li>Implement your repositories:</li> </ol> <pre><code>from sqlalchemy import select\nfrom archipy.models.dtos.pagination_dto import PaginationDTO\nfrom archipy.models.dtos.sort_dto import SortDTO\n\nclass UserRepository:\n    def __init__(self, db_adapter):\n        self.db_adapter = db_adapter\n\n    def create(self, username, email):\n        user = User(test_uuid=uuid4(), username=username, email=email)\n        return self.db_adapter.create(user)\n\n    def get_by_username(self, username):\n        query = select(User).where(User.username == username)\n        users, _ = self.db_adapter.execute_search_query(User, query)\n        return users[0] if users else None\n\n    def search_users(self, search_term: str | None = None,\n                    pagination: PaginationDTO | None = None,\n                    sort: SortDTO | None = None):\n        query = select(User)\n        if search_term:\n            query = query.where(User.username.ilike(f\"%{search_term}%\"))\n        return self.db_adapter.execute_search_query(User, query, pagination, sort)\n</code></pre> <ol> <li>Implement your business logic:</li> </ol> <pre><code>from archipy.models.errors import AlreadyExistsError\n\nclass UserService:\n    def __init__(self, user_repository):\n        self.user_repository = user_repository\n\n    def register_user(self, username, email):\n        # Check if user exists\n        existing_user = self.user_repository.get_by_username(username)\n        if existing_user:\n            raise AlreadyExistsError(\n                resource_type=\"user\",\n                additional_data={\"username\": username}\n            )\n\n        # Create new user\n        return self.user_repository.create(username, email)\n</code></pre>"},{"location":"usage/#working-with-redis","title":"Working with Redis","text":"<p>For caching or other Redis operations:</p> <pre><code>from archipy.adapters.redis.adapters import RedisAdapter, AsyncRedisAdapter\n\n# Create Redis adapter (uses global config)\nredis_adapter = RedisAdapter()\n\n# Cache user data\ndef cache_user(user):\n    user_data = {\n        \"username\": user.username,\n        \"email\": user.email\n    }\n    redis_adapter.set(f\"user:{user.test_uuid}\", json.dumps(user_data), ex=3600)\n\n# Get cached user\ndef get_cached_user(user_id):\n    data = redis_adapter.get(f\"user:{user_id}\")\n    return json.loads(data) if data else None\n</code></pre>"},{"location":"usage/#working-with-keycloak","title":"Working with Keycloak","text":"<p>For authentication and authorization:</p> <pre><code>from archipy.adapters.keycloak.adapters import KeycloakAdapter, AsyncKeycloakAdapter\n\n# Create Keycloak adapter (uses global config)\nkeycloak = KeycloakAdapter()\n\n# Authenticate user\ntoken = keycloak.get_token(\"username\", \"password\")\n\n# Validate token\nis_valid = keycloak.validate_token(token[\"access_token\"])\n\n# Get user info\nuser_info = keycloak.get_userinfo(token[\"access_token\"])\n</code></pre>"},{"location":"usage/#working-with-minio","title":"Working with MinIO","text":"<p>For object storage operations:</p> <pre><code>from archipy.adapters.minio.adapters import MinioAdapter\n\n# Create MinIO adapter (uses global config)\nminio = MinioAdapter()\n\n# Create bucket\nif not minio.bucket_exists(\"my-bucket\"):\n    minio.make_bucket(\"my-bucket\")\n\n# Upload file\nminio.put_object(\"my-bucket\", \"document.pdf\", \"/path/to/file.pdf\")\n\n# Generate download URL\ndownload_url = minio.presigned_get_object(\"my-bucket\", \"document.pdf\", expires=3600)\n</code></pre>"},{"location":"api_reference/","title":"API Reference","text":"<p>Welcome to the ArchiPy API reference documentation. This section provides detailed information about all modules, classes, and functions in ArchiPy.</p>"},{"location":"api_reference/#core-modules","title":"Core Modules","text":""},{"location":"api_reference/#adapters","title":"Adapters","text":"<p>The adapters module provides standardized interfaces to external systems:</p> <ul> <li>Adapters Documentation</li> <li>Database Adapters<ul> <li>PostgreSQL</li> <li>SQLite</li> <li>StarRocks</li> </ul> </li> <li>Redis Adapters</li> <li>Email Adapters</li> <li>Keycloak Adapters</li> <li>MinIO Adapters</li> <li>Kafka Adapters</li> <li>Temporal Adapters</li> <li>Payment Gateway Adapters<ul> <li>Parsian Shaparak</li> </ul> </li> </ul>"},{"location":"api_reference/#configs","title":"Configs","text":"<p>Configuration management and injection tools:</p> <ul> <li>Configs Documentation</li> <li>Base Config</li> <li>Config Templates</li> </ul>"},{"location":"api_reference/#helpers","title":"Helpers","text":"<p>Utility functions and support classes:</p> <ul> <li>Helpers Documentation</li> <li>Decorators</li> <li>Utils</li> <li>Metaclasses</li> <li>Interceptors</li> </ul>"},{"location":"api_reference/#models","title":"Models","text":"<p>Core data structures and types:</p> <ul> <li>Models Documentation</li> <li>Entities</li> <li>DTOs</li> <li>Errors</li> <li>Types</li> </ul>"},{"location":"api_reference/#source-code-organization","title":"Source Code Organization","text":"<p>The ArchiPy source code is organized into the following structure:</p> <pre><code>archipy/\n\u251c\u2500\u2500 adapters/           # External system integrations\n\u2502   \u251c\u2500\u2500 base/          # Base adapter implementations\n\u2502   \u2502   \u2514\u2500\u2500 sqlalchemy/  # Base SQLAlchemy components\n\u2502   \u251c\u2500\u2500 email/         # Email service adapters\n\u2502   \u251c\u2500\u2500 internet_payment_gateways/ # Payment gateway adapters\n\u2502   \u2502   \u2514\u2500\u2500 ir/        # Country-specific implementations\n\u2502   \u2502       \u2514\u2500\u2500 parsian/  # Parsian Shaparak gateway adapter\n\u2502   \u251c\u2500\u2500 keycloak/      # Keycloak authentication adapters\n\u2502   \u251c\u2500\u2500 kafka/         # Kafka message streaming adapters\n\u2502   \u251c\u2500\u2500 minio/         # MinIO object storage adapters\n\u2502   \u251c\u2500\u2500 postgres/      # PostgreSQL database adapters\n\u2502   \u2502   \u2514\u2500\u2500 sqlalchemy/  # PostgreSQL SQLAlchemy components\n\u2502   \u251c\u2500\u2500 redis/         # Redis adapters\n\u2502   \u251c\u2500\u2500 sqlite/        # SQLite database adapters\n\u2502   \u2502   \u2514\u2500\u2500 sqlalchemy/  # SQLite SQLAlchemy components\n\u2502   \u251c\u2500\u2500 starrocks/     # StarRocks database adapters\n\u2502   \u2502   \u2514\u2500\u2500 sqlalchemy/  # StarRocks SQLAlchemy components\n\u2502   \u2514\u2500\u2500 temporal/      # Temporal workflow orchestration adapters\n\u251c\u2500\u2500 configs/           # Configuration management\n\u2502   \u251c\u2500\u2500 base_config.py\n\u2502   \u2514\u2500\u2500 templates/\n\u251c\u2500\u2500 helpers/           # Utility functions\n\u2502   \u251c\u2500\u2500 decorators/\n\u2502   \u251c\u2500\u2500 interceptors/\n\u2502   \u251c\u2500\u2500 metaclasses/\n\u2502   \u2514\u2500\u2500 utils/\n\u2514\u2500\u2500 models/            # Core data structures\n    \u251c\u2500\u2500 dtos/\n    \u251c\u2500\u2500 entities/\n    \u251c\u2500\u2500 errors/\n    \u2514\u2500\u2500 types/\n</code></pre>"},{"location":"api_reference/#api-stability","title":"API Stability","text":"<p>ArchiPy follows semantic versioning and marks API stability as follows:</p> <ul> <li>\ud83d\udfe2 Stable: Production-ready APIs, covered by semantic versioning</li> <li>\ud83d\udfe1 Beta: APIs that are stabilizing but may have breaking changes</li> <li>\ud83d\udd34 Alpha: Experimental APIs that may change significantly</li> </ul> <p>See the Changelog for version history and breaking changes.</p>"},{"location":"api_reference/#contributing","title":"Contributing","text":"<p>For information about contributing to ArchiPy's development, please see:</p> <ul> <li>Contributing Guide</li> <li>Development Guide</li> <li>Documentation Guide</li> </ul>"},{"location":"api_reference/adapters/","title":"Adapters","text":"<p>The <code>adapters</code> module provides standardized interfaces to external systems and services. It follows the ports and adapters pattern (also known as hexagonal architecture) to decouple application logic from external dependencies.</p>"},{"location":"api_reference/adapters/#key-features","title":"Key Features","text":"<ul> <li>Consistent interfaces for all external services</li> <li>Built-in mock implementations for testing</li> <li>Port definitions for dependency inversion</li> <li>Ready-to-use implementations for common services</li> </ul>"},{"location":"api_reference/adapters/#available-adapters","title":"Available Adapters","text":""},{"location":"api_reference/adapters/#database-adapters","title":"Database Adapters","text":"<p>The database adapters provide standardized interfaces for different database systems using SQLAlchemy. Each database type has its own dedicated adapter implementation.</p>"},{"location":"api_reference/adapters/#base-sqlalchemy-components","title":"Base SQLAlchemy Components","text":"<p>The base SQLAlchemy components provide the core functionality used by all database-specific adapters:</p> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.SQLAlchemyExceptionHandlerMixin","title":"<code>archipy.adapters.base.sqlalchemy.adapters.SQLAlchemyExceptionHandlerMixin</code>","text":"<p>Mixin providing centralized exception handling for SQLAlchemy operations.</p> <p>This mixin provides a standard method for handling database exceptions and converting them to appropriate application-specific exceptions.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>class SQLAlchemyExceptionHandlerMixin:\n    \"\"\"Mixin providing centralized exception handling for SQLAlchemy operations.\n\n    This mixin provides a standard method for handling database exceptions and\n    converting them to appropriate application-specific exceptions.\n    \"\"\"\n\n    @classmethod\n    def _handle_db_exception(cls, exception: Exception, db_name: str | None = None) -&gt; None:\n        \"\"\"Handle database exceptions and raise appropriate errors.\n\n        Args:\n            exception: The exception to handle.\n            db_name: Optional database name for error context.\n\n        Raises:\n            DatabaseTimeoutError: If a timeout is detected.\n            DatabaseConnectionError: If a connection error is detected.\n            DatabaseTransactionError: If a transaction error is detected.\n            DatabaseIntegrityError: If an integrity violation is detected.\n            DatabaseConstraintError: If a constraint violation is detected.\n            DatabaseQueryError: For other database errors.\n        \"\"\"\n        if \"timeout\" in str(exception).lower():\n            raise DatabaseTimeoutError(database=db_name) from exception\n        if \"integrity\" in str(exception).lower():\n            raise DatabaseIntegrityError(database=db_name) from exception\n        if \"constraint\" in str(exception).lower():\n            raise DatabaseConstraintError(database=db_name) from exception\n        if \"connection\" in str(exception).lower():\n            raise DatabaseConnectionError(database=db_name) from exception\n        if \"transaction\" in str(exception).lower():\n            raise DatabaseTransactionError(database=db_name) from exception\n\n        # Default error if no specific error is detected\n        raise DatabaseQueryError(database=db_name) from exception\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.SQLAlchemyFilterMixin","title":"<code>archipy.adapters.base.sqlalchemy.adapters.SQLAlchemyFilterMixin</code>","text":"<p>Mixin providing filtering capabilities for SQLAlchemy queries.</p> <p>Supports equality, inequality, string operations, list operations, and NULL checks.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>class SQLAlchemyFilterMixin:\n    \"\"\"Mixin providing filtering capabilities for SQLAlchemy queries.\n\n    Supports equality, inequality, string operations, list operations, and NULL checks.\n    \"\"\"\n\n    @staticmethod\n    def _apply_filter(\n        query: Select | Update | Delete,\n        field: InstrumentedAttribute,\n        value: str | int | float | bool | list | None,\n        operation: FilterOperationType,\n    ) -&gt; Select | Update | Delete:\n        \"\"\"Apply a filter to a SQLAlchemy query based on the specified operation.\n\n        Args:\n            query: The SQLAlchemy query to apply the filter to.\n            field: The model attribute/column to filter on.\n            value: The value to compare against.\n            operation: The type of filter operation to apply.\n\n        Returns:\n            The updated query with the filter applied.\n        \"\"\"\n        if value is not None or operation in [FilterOperationType.IS_NULL, FilterOperationType.IS_NOT_NULL]:\n            match operation:\n                case FilterOperationType.EQUAL:\n                    return query.where(field == value)\n                case FilterOperationType.NOT_EQUAL:\n                    return query.where(field != value)\n                case FilterOperationType.LESS_THAN:\n                    return query.where(field &lt; value)\n                case FilterOperationType.LESS_THAN_OR_EQUAL:\n                    return query.where(field &lt;= value)\n                case FilterOperationType.GREATER_THAN:\n                    return query.where(field &gt; value)\n                case FilterOperationType.GREATER_THAN_OR_EQUAL:\n                    return query.where(field &gt;= value)\n                case FilterOperationType.IN_LIST:\n                    if not isinstance(value, list):\n                        raise InvalidArgumentError(f\"IN_LIST operation requires a list, got {type(value)}\")\n                    return query.where(field.in_(value))\n                case FilterOperationType.NOT_IN_LIST:\n                    if not isinstance(value, list):\n                        raise InvalidArgumentError(f\"NOT_IN_LIST operation requires a list, got {type(value)}\")\n                    return query.where(~field.in_(value))\n                case FilterOperationType.LIKE:\n                    return query.where(field.like(f\"%{value}%\"))\n                case FilterOperationType.ILIKE:\n                    return query.where(field.ilike(f\"%{value}%\"))\n                case FilterOperationType.STARTS_WITH:\n                    return query.where(field.startswith(value))\n                case FilterOperationType.ENDS_WITH:\n                    return query.where(field.endswith(value))\n                case FilterOperationType.CONTAINS:\n                    return query.where(field.contains(value))\n                case FilterOperationType.IS_NULL:\n                    return query.where(field.is_(None))\n                case FilterOperationType.IS_NOT_NULL:\n                    return query.where(field.isnot(None))\n        return query\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.SQLAlchemyPaginationMixin","title":"<code>archipy.adapters.base.sqlalchemy.adapters.SQLAlchemyPaginationMixin</code>","text":"<p>Mixin providing pagination capabilities for SQLAlchemy queries.</p> <p>Supports limiting results and applying offsets for paginated queries.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>class SQLAlchemyPaginationMixin:\n    \"\"\"Mixin providing pagination capabilities for SQLAlchemy queries.\n\n    Supports limiting results and applying offsets for paginated queries.\n    \"\"\"\n\n    @staticmethod\n    def _apply_pagination(query: Select, pagination: PaginationDTO | None) -&gt; Select:\n        \"\"\"Apply pagination to a SQLAlchemy query.\n\n        Args:\n            query: The SQLAlchemy query to paginate.\n            pagination: Pagination settings (page size and offset).\n\n        Returns:\n            The paginated query.\n        \"\"\"\n        if pagination is None:\n            return query\n        return query.limit(pagination.page_size).offset(pagination.offset)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.SQLAlchemySortMixin","title":"<code>archipy.adapters.base.sqlalchemy.adapters.SQLAlchemySortMixin</code>","text":"<p>Mixin providing sorting capabilities for SQLAlchemy queries.</p> <p>Supports dynamic column selection and ascending/descending order.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>class SQLAlchemySortMixin:\n    \"\"\"Mixin providing sorting capabilities for SQLAlchemy queries.\n\n    Supports dynamic column selection and ascending/descending order.\n    \"\"\"\n\n    @staticmethod\n    def _apply_sorting(entity: type[BaseEntity], query: Select, sort_info: SortDTO | None) -&gt; Select:\n        \"\"\"Apply sorting to a SQLAlchemy query.\n\n        Args:\n            entity: The entity class to query.\n            query: The SQLAlchemy query to sort.\n            sort_info: Sorting information (column and direction).\n\n        Returns:\n            The sorted query.\n\n        Raises:\n            InvalidArgumentError: If the sort order is invalid.\n        \"\"\"\n        if sort_info is None:\n            return query\n        if isinstance(sort_info.column, str):\n            sort_column = getattr(entity, sort_info.column)\n        elif isinstance(sort_info.column, Enum):\n            sort_column = getattr(entity, sort_info.column.name.lower())\n        else:\n            sort_column = sort_info.column\n\n        order_value = sort_info.order.value if isinstance(sort_info.order, Enum) else sort_info.order\n        match order_value:\n            case SortOrderType.ASCENDING.value:\n                return query.order_by(sort_column.asc())\n            case SortOrderType.DESCENDING.value:\n                return query.order_by(sort_column.desc())\n            case _:\n                raise InvalidArgumentError(argument_name=\"sort_info.order\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter","title":"<code>archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter</code>","text":"<p>               Bases: <code>SQLAlchemyPort</code>, <code>SQLAlchemyPaginationMixin</code>, <code>SQLAlchemySortMixin</code>, <code>SQLAlchemyFilterMixin</code>, <code>SQLAlchemyExceptionHandlerMixin</code></p> <p>Base synchronous SQLAlchemy adapter for ORM operations.</p> <p>Provides a standardized interface for CRUD operations, pagination, sorting, and filtering. Specific database adapters should inherit from this class and provide their own session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>ConfigT | None</code> <p>Configuration for SQLAlchemy. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>class BaseSQLAlchemyAdapter[ConfigT: SQLAlchemyConfig](\n    SQLAlchemyPort,\n    SQLAlchemyPaginationMixin,\n    SQLAlchemySortMixin,\n    SQLAlchemyFilterMixin,\n    SQLAlchemyExceptionHandlerMixin,\n):\n    \"\"\"Base synchronous SQLAlchemy adapter for ORM operations.\n\n    Provides a standardized interface for CRUD operations, pagination, sorting, and filtering.\n    Specific database adapters should inherit from this class and provide their own session manager.\n\n    Args:\n        orm_config: Configuration for SQLAlchemy. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: ConfigT | None = None) -&gt; None:\n        \"\"\"Initialize the base adapter with a session manager.\n\n        Args:\n            orm_config: Configuration for SQLAlchemy. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().SQLALCHEMY if orm_config is None else orm_config\n        # Cast to ConfigT since subclasses will ensure the proper type\n        self.session_manager: BaseSQLAlchemySessionManager[ConfigT] = self._create_session_manager(configs)  # type: ignore[arg-type]\n\n    def _create_session_manager(self, configs: ConfigT) -&gt; BaseSQLAlchemySessionManager[ConfigT]:\n        \"\"\"Create a session manager for the specific database.\n\n        Args:\n            configs: SQLAlchemy configuration.\n\n        Returns:\n            A session manager instance.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement _create_session_manager\")\n\n    @override\n    def execute_search_query(\n        self,\n        entity: type[BaseEntity],\n        query: Select,\n        pagination: PaginationDTO | None = None,\n        sort_info: SortDTO | None = None,\n        has_multiple_entities: bool = False,\n    ) -&gt; tuple[list[BaseEntity], int]:\n        \"\"\"Execute a search query with pagination and sorting.\n\n        Args:\n            entity: The entity class to query.\n            query: The SQLAlchemy SELECT query.\n            pagination: Optional pagination settings.\n            sort_info: Optional sorting information.\n            has_multiple_entities: Optional bool.\n\n        Returns:\n            Tuple of the list of entities and the total count.\n\n        Raises:\n            DatabaseQueryError: If the database query fails.\n            DatabaseTimeoutError: If the query times out.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        try:\n            sort_info = sort_info or SortDTO.default()\n            session = self.get_session()\n            sorted_query = self._apply_sorting(entity, query, sort_info)\n            paginated_query = self._apply_pagination(sorted_query, pagination)\n            result_set = session.execute(paginated_query)\n            if has_multiple_entities:\n                results = list(result_set.fetchall())\n            else:\n                results = list(result_set.scalars().all())\n            count_query = select(func.count()).select_from(query.subquery())\n            total_count = session.execute(count_query).scalar_one()\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n            raise  # This will never be reached, but satisfies MyPy\n        else:\n            return results, total_count  # type: ignore[return-value]\n\n    @override\n    def get_session(self) -&gt; Session:\n        \"\"\"Get a database session.\n\n        Returns:\n            Session: A SQLAlchemy session.\n\n        Raises:\n            DatabaseConnectionError: If there's an error getting the session.\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        return self.session_manager.get_session()\n\n    @override\n    def create(self, entity: T) -&gt; T | None:\n        \"\"\"Create a new entity in the database.\n\n        Args:\n            entity: The entity to create.\n\n        Returns:\n            The created entity with updated attributes, preserving the original type.\n\n        Raises:\n            InvalidEntityTypeError: If the entity type is not a valid SQLAlchemy model.\n            DatabaseQueryError: If the database operation fails.\n            DatabaseIntegrityError: If there's an integrity constraint violation.\n            DatabaseConstraintError: If there's a constraint violation.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        if not isinstance(entity, BaseEntity):\n            raise InvalidEntityTypeError(\n                message=f\"Expected BaseEntity subclass, got {type(entity).__name__}\",\n                expected_type=\"BaseEntity\",\n                actual_type=type(entity).__name__,\n            )\n\n        try:\n            session = self.get_session()\n            session.add(entity)\n            session.flush()\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n            raise  # This will never be reached, but satisfies MyPy\n        else:\n            return entity\n\n    @override\n    def bulk_create(self, entities: list[T]) -&gt; list[T] | None:\n        \"\"\"Creates multiple entities in a single database operation.\n\n        Args:\n            entities: List of entities to create.\n\n        Returns:\n            List of created entities with updated attributes, preserving original types.\n\n        Raises:\n            InvalidEntityTypeError: If any entity is not a valid SQLAlchemy model.\n            DatabaseQueryError: If the database operation fails.\n            DatabaseIntegrityError: If there's an integrity constraint violation.\n            DatabaseConstraintError: If there's a constraint violation.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        if not all(isinstance(entity, BaseEntity) for entity in entities):\n            raise InvalidEntityTypeError(\n                message=\"All entities must be BaseEntity subclasses\",\n                expected_type=\"BaseEntity\",\n                actual_type=\"mixed\",\n            )\n\n        try:\n            session = self.get_session()\n            session.add_all(entities)\n            session.flush()\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n            raise  # This will never be reached, but satisfies MyPy\n        else:\n            return entities\n\n    @override\n    def get_by_uuid(self, entity_type: type[T], entity_uuid: UUID) -&gt; T | None:\n        \"\"\"Retrieve an entity by its UUID.\n\n        Args:\n            entity_type: The type of entity to retrieve.\n            entity_uuid: The UUID of the entity.\n\n        Returns:\n            The entity if found, None otherwise.\n\n        Raises:\n            InvalidEntityTypeError: If the entity type is not a valid SQLAlchemy model.\n            DatabaseQueryError: If the database operation fails.\n            DatabaseTimeoutError: If the query times out.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        if not issubclass(entity_type, BaseEntity):\n            raise InvalidEntityTypeError(\n                message=f\"Expected BaseEntity subclass, got {entity_type.__name__}\",\n                expected_type=\"BaseEntity\",\n                actual_type=entity_type.__name__,\n            )\n\n        try:\n            session = self.get_session()\n            result = session.get(entity_type, entity_uuid)\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n            raise  # This will never be reached, but satisfies MyPy\n        else:\n            return result\n\n    @override\n    def delete(self, entity: BaseEntity) -&gt; None:\n        \"\"\"Delete an entity from the database.\n\n        Args:\n            entity: The entity to delete.\n\n        Raises:\n            InvalidEntityTypeError: If the entity is not a valid SQLAlchemy model.\n            DatabaseQueryError: If the database operation fails.\n            DatabaseIntegrityError: If there's an integrity constraint violation.\n            DatabaseConstraintError: If there's a constraint violation.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        if not isinstance(entity, BaseEntity):\n            raise InvalidEntityTypeError(\n                message=f\"Expected BaseEntity subclass, got {type(entity).__name__}\",\n                expected_type=\"BaseEntity\",\n                actual_type=type(entity).__name__,\n            )\n\n        try:\n            session = self.get_session()\n            session.delete(entity)\n            session.flush()\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n\n    @override\n    def bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n        \"\"\"Delete multiple entities from the database.\n\n        Args:\n            entities: List of entities to delete.\n\n        Raises:\n            InvalidEntityTypeError: If any entity is not a valid SQLAlchemy model.\n            DatabaseQueryError: If the database operation fails.\n            DatabaseIntegrityError: If there's an integrity constraint violation.\n            DatabaseConstraintError: If there's a constraint violation.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        if not all(isinstance(entity, BaseEntity) for entity in entities):\n            raise InvalidEntityTypeError(\n                message=\"All entities must be BaseEntity subclasses\",\n                expected_type=\"BaseEntity\",\n                actual_type=\"mixed\",\n            )\n\n        try:\n            session = self.get_session()\n            for entity in entities:\n                session.delete(entity)\n            session.flush()\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n\n    @override\n    def execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Result[Any]:\n        \"\"\"Execute a SQLAlchemy statement.\n\n        Args:\n            statement: The SQLAlchemy statement to execute.\n            params: Optional parameters for the statement.\n\n        Returns:\n            The result of the execution.\n\n        Raises:\n            DatabaseQueryError: If the database operation fails.\n            DatabaseTimeoutError: If the query times out.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        try:\n            session = self.get_session()\n            result = session.execute(statement, params or {})\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n            raise  # This will never be reached, but satisfies MyPy\n        else:\n            return result\n\n    @override\n    def scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; ScalarResult[Any]:\n        \"\"\"Execute a SQLAlchemy statement and return scalar results.\n\n        Args:\n            statement: The SQLAlchemy statement to execute.\n            params: Optional parameters for the statement.\n\n        Returns:\n            The scalar results of the execution.\n\n        Raises:\n            DatabaseQueryError: If the database operation fails.\n            DatabaseTimeoutError: If the query times out.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        try:\n            session = self.get_session()\n            result = session.scalars(statement, params or {})\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n            raise  # This will never be reached, but satisfies MyPy\n        else:\n            return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.__init__","title":"<code>archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.__init__(orm_config=None)</code>","text":"<p>Initialize the base adapter with a session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>ConfigT | None</code> <p>Configuration for SQLAlchemy. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>def __init__(self, orm_config: ConfigT | None = None) -&gt; None:\n    \"\"\"Initialize the base adapter with a session manager.\n\n    Args:\n        orm_config: Configuration for SQLAlchemy. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().SQLALCHEMY if orm_config is None else orm_config\n    # Cast to ConfigT since subclasses will ensure the proper type\n    self.session_manager: BaseSQLAlchemySessionManager[ConfigT] = self._create_session_manager(configs)  # type: ignore[arg-type]\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.execute_search_query","title":"<code>archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.execute_search_query(entity, query, pagination=None, sort_info=None, has_multiple_entities=False)</code>","text":"<p>Execute a search query with pagination and sorting.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>type[BaseEntity]</code> <p>The entity class to query.</p> required <code>query</code> <code>Select</code> <p>The SQLAlchemy SELECT query.</p> required <code>pagination</code> <code>PaginationDTO | None</code> <p>Optional pagination settings.</p> <code>None</code> <code>sort_info</code> <code>SortDTO | None</code> <p>Optional sorting information.</p> <code>None</code> <code>has_multiple_entities</code> <code>bool</code> <p>Optional bool.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[list[BaseEntity], int]</code> <p>Tuple of the list of entities and the total count.</p> <p>Raises:</p> Type Description <code>DatabaseQueryError</code> <p>If the database query fails.</p> <code>DatabaseTimeoutError</code> <p>If the query times out.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\ndef execute_search_query(\n    self,\n    entity: type[BaseEntity],\n    query: Select,\n    pagination: PaginationDTO | None = None,\n    sort_info: SortDTO | None = None,\n    has_multiple_entities: bool = False,\n) -&gt; tuple[list[BaseEntity], int]:\n    \"\"\"Execute a search query with pagination and sorting.\n\n    Args:\n        entity: The entity class to query.\n        query: The SQLAlchemy SELECT query.\n        pagination: Optional pagination settings.\n        sort_info: Optional sorting information.\n        has_multiple_entities: Optional bool.\n\n    Returns:\n        Tuple of the list of entities and the total count.\n\n    Raises:\n        DatabaseQueryError: If the database query fails.\n        DatabaseTimeoutError: If the query times out.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    try:\n        sort_info = sort_info or SortDTO.default()\n        session = self.get_session()\n        sorted_query = self._apply_sorting(entity, query, sort_info)\n        paginated_query = self._apply_pagination(sorted_query, pagination)\n        result_set = session.execute(paginated_query)\n        if has_multiple_entities:\n            results = list(result_set.fetchall())\n        else:\n            results = list(result_set.scalars().all())\n        count_query = select(func.count()).select_from(query.subquery())\n        total_count = session.execute(count_query).scalar_one()\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n        raise  # This will never be reached, but satisfies MyPy\n    else:\n        return results, total_count  # type: ignore[return-value]\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.get_session","title":"<code>archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.get_session()</code>","text":"<p>Get a database session.</p> <p>Returns:</p> Name Type Description <code>Session</code> <code>Session</code> <p>A SQLAlchemy session.</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error getting the session.</p> <code>DatabaseConfigurationError</code> <p>If there's an error in the database configuration.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\ndef get_session(self) -&gt; Session:\n    \"\"\"Get a database session.\n\n    Returns:\n        Session: A SQLAlchemy session.\n\n    Raises:\n        DatabaseConnectionError: If there's an error getting the session.\n        DatabaseConfigurationError: If there's an error in the database configuration.\n    \"\"\"\n    return self.session_manager.get_session()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.create","title":"<code>archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.create(entity)</code>","text":"<p>Create a new entity in the database.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>T</code> <p>The entity to create.</p> required <p>Returns:</p> Type Description <code>T | None</code> <p>The created entity with updated attributes, preserving the original type.</p> <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If the entity type is not a valid SQLAlchemy model.</p> <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseIntegrityError</code> <p>If there's an integrity constraint violation.</p> <code>DatabaseConstraintError</code> <p>If there's a constraint violation.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\ndef create(self, entity: T) -&gt; T | None:\n    \"\"\"Create a new entity in the database.\n\n    Args:\n        entity: The entity to create.\n\n    Returns:\n        The created entity with updated attributes, preserving the original type.\n\n    Raises:\n        InvalidEntityTypeError: If the entity type is not a valid SQLAlchemy model.\n        DatabaseQueryError: If the database operation fails.\n        DatabaseIntegrityError: If there's an integrity constraint violation.\n        DatabaseConstraintError: If there's a constraint violation.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    if not isinstance(entity, BaseEntity):\n        raise InvalidEntityTypeError(\n            message=f\"Expected BaseEntity subclass, got {type(entity).__name__}\",\n            expected_type=\"BaseEntity\",\n            actual_type=type(entity).__name__,\n        )\n\n    try:\n        session = self.get_session()\n        session.add(entity)\n        session.flush()\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n        raise  # This will never be reached, but satisfies MyPy\n    else:\n        return entity\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.bulk_create","title":"<code>archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.bulk_create(entities)</code>","text":"<p>Creates multiple entities in a single database operation.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[T]</code> <p>List of entities to create.</p> required <p>Returns:</p> Type Description <code>list[T] | None</code> <p>List of created entities with updated attributes, preserving original types.</p> <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If any entity is not a valid SQLAlchemy model.</p> <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseIntegrityError</code> <p>If there's an integrity constraint violation.</p> <code>DatabaseConstraintError</code> <p>If there's a constraint violation.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\ndef bulk_create(self, entities: list[T]) -&gt; list[T] | None:\n    \"\"\"Creates multiple entities in a single database operation.\n\n    Args:\n        entities: List of entities to create.\n\n    Returns:\n        List of created entities with updated attributes, preserving original types.\n\n    Raises:\n        InvalidEntityTypeError: If any entity is not a valid SQLAlchemy model.\n        DatabaseQueryError: If the database operation fails.\n        DatabaseIntegrityError: If there's an integrity constraint violation.\n        DatabaseConstraintError: If there's a constraint violation.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    if not all(isinstance(entity, BaseEntity) for entity in entities):\n        raise InvalidEntityTypeError(\n            message=\"All entities must be BaseEntity subclasses\",\n            expected_type=\"BaseEntity\",\n            actual_type=\"mixed\",\n        )\n\n    try:\n        session = self.get_session()\n        session.add_all(entities)\n        session.flush()\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n        raise  # This will never be reached, but satisfies MyPy\n    else:\n        return entities\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.get_by_uuid","title":"<code>archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.get_by_uuid(entity_type, entity_uuid)</code>","text":"<p>Retrieve an entity by its UUID.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type[T]</code> <p>The type of entity to retrieve.</p> required <code>entity_uuid</code> <code>UUID</code> <p>The UUID of the entity.</p> required <p>Returns:</p> Type Description <code>T | None</code> <p>The entity if found, None otherwise.</p> <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If the entity type is not a valid SQLAlchemy model.</p> <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseTimeoutError</code> <p>If the query times out.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\ndef get_by_uuid(self, entity_type: type[T], entity_uuid: UUID) -&gt; T | None:\n    \"\"\"Retrieve an entity by its UUID.\n\n    Args:\n        entity_type: The type of entity to retrieve.\n        entity_uuid: The UUID of the entity.\n\n    Returns:\n        The entity if found, None otherwise.\n\n    Raises:\n        InvalidEntityTypeError: If the entity type is not a valid SQLAlchemy model.\n        DatabaseQueryError: If the database operation fails.\n        DatabaseTimeoutError: If the query times out.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    if not issubclass(entity_type, BaseEntity):\n        raise InvalidEntityTypeError(\n            message=f\"Expected BaseEntity subclass, got {entity_type.__name__}\",\n            expected_type=\"BaseEntity\",\n            actual_type=entity_type.__name__,\n        )\n\n    try:\n        session = self.get_session()\n        result = session.get(entity_type, entity_uuid)\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n        raise  # This will never be reached, but satisfies MyPy\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.delete","title":"<code>archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.delete(entity)</code>","text":"<p>Delete an entity from the database.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>BaseEntity</code> <p>The entity to delete.</p> required <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If the entity is not a valid SQLAlchemy model.</p> <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseIntegrityError</code> <p>If there's an integrity constraint violation.</p> <code>DatabaseConstraintError</code> <p>If there's a constraint violation.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\ndef delete(self, entity: BaseEntity) -&gt; None:\n    \"\"\"Delete an entity from the database.\n\n    Args:\n        entity: The entity to delete.\n\n    Raises:\n        InvalidEntityTypeError: If the entity is not a valid SQLAlchemy model.\n        DatabaseQueryError: If the database operation fails.\n        DatabaseIntegrityError: If there's an integrity constraint violation.\n        DatabaseConstraintError: If there's a constraint violation.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    if not isinstance(entity, BaseEntity):\n        raise InvalidEntityTypeError(\n            message=f\"Expected BaseEntity subclass, got {type(entity).__name__}\",\n            expected_type=\"BaseEntity\",\n            actual_type=type(entity).__name__,\n        )\n\n    try:\n        session = self.get_session()\n        session.delete(entity)\n        session.flush()\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.bulk_delete","title":"<code>archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.bulk_delete(entities)</code>","text":"<p>Delete multiple entities from the database.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[BaseEntity]</code> <p>List of entities to delete.</p> required <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If any entity is not a valid SQLAlchemy model.</p> <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseIntegrityError</code> <p>If there's an integrity constraint violation.</p> <code>DatabaseConstraintError</code> <p>If there's a constraint violation.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\ndef bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n    \"\"\"Delete multiple entities from the database.\n\n    Args:\n        entities: List of entities to delete.\n\n    Raises:\n        InvalidEntityTypeError: If any entity is not a valid SQLAlchemy model.\n        DatabaseQueryError: If the database operation fails.\n        DatabaseIntegrityError: If there's an integrity constraint violation.\n        DatabaseConstraintError: If there's a constraint violation.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    if not all(isinstance(entity, BaseEntity) for entity in entities):\n        raise InvalidEntityTypeError(\n            message=\"All entities must be BaseEntity subclasses\",\n            expected_type=\"BaseEntity\",\n            actual_type=\"mixed\",\n        )\n\n    try:\n        session = self.get_session()\n        for entity in entities:\n            session.delete(entity)\n        session.flush()\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.execute","title":"<code>archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.execute(statement, params=None)</code>","text":"<p>Execute a SQLAlchemy statement.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQLAlchemy statement to execute.</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the statement.</p> <code>None</code> <p>Returns:</p> Type Description <code>Result[Any]</code> <p>The result of the execution.</p> <p>Raises:</p> Type Description <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseTimeoutError</code> <p>If the query times out.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\ndef execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Result[Any]:\n    \"\"\"Execute a SQLAlchemy statement.\n\n    Args:\n        statement: The SQLAlchemy statement to execute.\n        params: Optional parameters for the statement.\n\n    Returns:\n        The result of the execution.\n\n    Raises:\n        DatabaseQueryError: If the database operation fails.\n        DatabaseTimeoutError: If the query times out.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    try:\n        session = self.get_session()\n        result = session.execute(statement, params or {})\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n        raise  # This will never be reached, but satisfies MyPy\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.scalars","title":"<code>archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.scalars(statement, params=None)</code>","text":"<p>Execute a SQLAlchemy statement and return scalar results.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQLAlchemy statement to execute.</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the statement.</p> <code>None</code> <p>Returns:</p> Type Description <code>ScalarResult[Any]</code> <p>The scalar results of the execution.</p> <p>Raises:</p> Type Description <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseTimeoutError</code> <p>If the query times out.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\ndef scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; ScalarResult[Any]:\n    \"\"\"Execute a SQLAlchemy statement and return scalar results.\n\n    Args:\n        statement: The SQLAlchemy statement to execute.\n        params: Optional parameters for the statement.\n\n    Returns:\n        The scalar results of the execution.\n\n    Raises:\n        DatabaseQueryError: If the database operation fails.\n        DatabaseTimeoutError: If the query times out.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    try:\n        session = self.get_session()\n        result = session.scalars(statement, params or {})\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n        raise  # This will never be reached, but satisfies MyPy\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter","title":"<code>archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter</code>","text":"<p>               Bases: <code>AsyncSQLAlchemyPort</code>, <code>SQLAlchemyPaginationMixin</code>, <code>SQLAlchemySortMixin</code>, <code>SQLAlchemyFilterMixin</code>, <code>SQLAlchemyExceptionHandlerMixin</code></p> <p>Base asynchronous SQLAlchemy adapter for ORM operations.</p> <p>Provides a standardized interface for CRUD operations, pagination, sorting, and filtering. Specific database adapters should inherit from this class and provide their own session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>ConfigT | None</code> <p>Configuration for SQLAlchemy. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>class AsyncBaseSQLAlchemyAdapter[ConfigT: SQLAlchemyConfig](\n    AsyncSQLAlchemyPort,\n    SQLAlchemyPaginationMixin,\n    SQLAlchemySortMixin,\n    SQLAlchemyFilterMixin,\n    SQLAlchemyExceptionHandlerMixin,\n):\n    \"\"\"Base asynchronous SQLAlchemy adapter for ORM operations.\n\n    Provides a standardized interface for CRUD operations, pagination, sorting, and filtering.\n    Specific database adapters should inherit from this class and provide their own session manager.\n\n    Args:\n        orm_config: Configuration for SQLAlchemy. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: ConfigT | None = None) -&gt; None:\n        \"\"\"Initialize the base async adapter with a session manager.\n\n        Args:\n            orm_config: Configuration for SQLAlchemy. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().SQLALCHEMY if orm_config is None else orm_config\n        # Cast to ConfigT since subclasses will ensure the proper type\n        self.session_manager: AsyncBaseSQLAlchemySessionManager[ConfigT] = self._create_async_session_manager(configs)  # type: ignore[arg-type]\n\n    def _create_async_session_manager(self, configs: ConfigT) -&gt; AsyncBaseSQLAlchemySessionManager[ConfigT]:\n        \"\"\"Create an async session manager for the specific database.\n\n        Args:\n            configs: SQLAlchemy configuration.\n\n        Returns:\n            An async session manager instance.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement _create_async_session_manager\")\n\n    @override\n    async def execute_search_query(\n        self,\n        entity: type[BaseEntity],\n        query: Select,\n        pagination: PaginationDTO | None,\n        sort_info: SortDTO | None = None,\n        has_multiple_entities: bool = False,\n    ) -&gt; tuple[list[BaseEntity], int]:\n        \"\"\"Execute a search query with pagination and sorting.\n\n        Args:\n            entity: The entity class to query.\n            query: The SQLAlchemy SELECT query.\n            pagination: Optional pagination settings.\n            sort_info: Optional sorting information.\n            has_multiple_entities: Optional bool\n\n        Returns:\n            Tuple of the list of entities and the total count.\n\n        Raises:\n            DatabaseQueryError: If the database query fails.\n            DatabaseTimeoutError: If the query times out.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        try:\n            sort_info = sort_info or SortDTO.default()\n            session = self.get_session()\n            sorted_query = self._apply_sorting(entity, query, sort_info)\n            paginated_query = self._apply_pagination(sorted_query, pagination)\n            result_set = await session.execute(paginated_query)\n            if has_multiple_entities:\n                results = list(result_set.fetchall())\n            else:\n                results = list(result_set.scalars().all())\n            count_query = select(func.count()).select_from(query.subquery())\n            total_count_result = await session.execute(count_query)\n            total_count = total_count_result.scalar_one()\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n            raise  # This will never be reached, but satisfies MyPy\n        else:\n            return results, total_count  # type: ignore[return-value]\n\n    @override\n    def get_session(self) -&gt; AsyncSession:\n        \"\"\"Get a database session.\n\n        Returns:\n            AsyncSession: A SQLAlchemy async session.\n\n        Raises:\n            DatabaseConnectionError: If there's an error getting the session.\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        return self.session_manager.get_session()\n\n    @override\n    async def create(self, entity: T) -&gt; T | None:\n        \"\"\"Create a new entity in the database.\n\n        Args:\n            entity: The entity to create.\n\n        Returns:\n            The created entity with updated attributes, preserving the original type.\n\n        Raises:\n            InvalidEntityTypeError: If the entity type is not a valid SQLAlchemy model.\n            DatabaseQueryError: If the database operation fails.\n            DatabaseIntegrityError: If there's an integrity constraint violation.\n            DatabaseConstraintError: If there's a constraint violation.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        if not isinstance(entity, BaseEntity):\n            raise InvalidEntityTypeError(\n                message=f\"Expected BaseEntity subclass, got {type(entity).__name__}\",\n                expected_type=\"BaseEntity\",\n                actual_type=type(entity).__name__,\n            )\n\n        try:\n            session = self.get_session()\n            session.add(entity)\n            await session.flush()\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n            raise  # This will never be reached, but satisfies MyPy\n        else:\n            return entity\n\n    @override\n    async def bulk_create(self, entities: list[T]) -&gt; list[T] | None:\n        \"\"\"Creates multiple entities in a single database operation.\n\n        Args:\n            entities: List of entities to create.\n\n        Returns:\n            List of created entities with updated attributes, preserving original types.\n\n        Raises:\n            InvalidEntityTypeError: If any entity is not a valid SQLAlchemy model.\n            DatabaseQueryError: If the database operation fails.\n            DatabaseIntegrityError: If there's an integrity constraint violation.\n            DatabaseConstraintError: If there's a constraint violation.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        if not all(isinstance(entity, BaseEntity) for entity in entities):\n            raise InvalidEntityTypeError(\n                message=\"All entities must be BaseEntity subclasses\",\n                expected_type=\"BaseEntity\",\n                actual_type=\"mixed\",\n            )\n\n        try:\n            session = self.get_session()\n            session.add_all(entities)\n            await session.flush()\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n            raise  # This will never be reached, but satisfies MyPy\n        else:\n            return entities\n\n    @override\n    async def get_by_uuid(self, entity_type: type[T], entity_uuid: UUID) -&gt; T | None:\n        \"\"\"Retrieve an entity by its UUID.\n\n        Args:\n            entity_type: The type of entity to retrieve.\n            entity_uuid: The UUID of the entity.\n\n        Returns:\n            The entity if found, None otherwise.\n\n        Raises:\n            InvalidEntityTypeError: If the entity type is not a valid SQLAlchemy model.\n            DatabaseQueryError: If the database operation fails.\n            DatabaseTimeoutError: If the query times out.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        if not issubclass(entity_type, BaseEntity):\n            raise InvalidEntityTypeError(\n                message=f\"Expected BaseEntity subclass, got {entity_type.__name__}\",\n                expected_type=\"BaseEntity\",\n                actual_type=entity_type.__name__,\n            )\n\n        try:\n            session = self.get_session()\n            result = await session.get(entity_type, entity_uuid)\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n            raise  # This will never be reached, but satisfies MyPy\n        else:\n            return result\n\n    @override\n    async def delete(self, entity: BaseEntity) -&gt; None:\n        \"\"\"Delete an entity from the database.\n\n        Args:\n            entity: The entity to delete.\n\n        Raises:\n            InvalidEntityTypeError: If the entity is not a valid SQLAlchemy model.\n            DatabaseQueryError: If the database operation fails.\n            DatabaseIntegrityError: If there's an integrity constraint violation.\n            DatabaseConstraintError: If there's a constraint violation.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        if not isinstance(entity, BaseEntity):\n            raise InvalidEntityTypeError(\n                message=f\"Expected BaseEntity subclass, got {type(entity).__name__}\",\n                expected_type=\"BaseEntity\",\n                actual_type=type(entity).__name__,\n            )\n\n        try:\n            session = self.get_session()\n            await session.delete(entity)\n            await session.flush()\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n\n    @override\n    async def bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n        \"\"\"Delete multiple entities from the database.\n\n        Args:\n            entities: List of entities to delete.\n\n        Raises:\n            InvalidEntityTypeError: If any entity is not a valid SQLAlchemy model.\n            DatabaseQueryError: If the database operation fails.\n            DatabaseIntegrityError: If there's an integrity constraint violation.\n            DatabaseConstraintError: If there's a constraint violation.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        if not all(isinstance(entity, BaseEntity) for entity in entities):\n            raise InvalidEntityTypeError(\n                message=\"All entities must be BaseEntity subclasses\",\n                expected_type=\"BaseEntity\",\n                actual_type=\"mixed\",\n            )\n\n        try:\n            session = self.get_session()\n            for entity in entities:\n                await session.delete(entity)\n            await session.flush()\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n\n    @override\n    async def execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Result[Any]:\n        \"\"\"Execute a SQLAlchemy statement.\n\n        Args:\n            statement: The SQLAlchemy statement to execute.\n            params: Optional parameters for the statement.\n\n        Returns:\n            The result of the execution.\n\n        Raises:\n            DatabaseQueryError: If the database operation fails.\n            DatabaseTimeoutError: If the query times out.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        try:\n            session = self.get_session()\n            result = await session.execute(statement, params or {})\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n            raise  # This will never be reached, but satisfies MyPy\n        else:\n            return result\n\n    @override\n    async def scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; ScalarResult[Any]:\n        \"\"\"Execute a SQLAlchemy statement and return scalar results.\n\n        Args:\n            statement: The SQLAlchemy statement to execute.\n            params: Optional parameters for the statement.\n\n        Returns:\n            The scalar results of the execution.\n\n        Raises:\n            DatabaseQueryError: If the database operation fails.\n            DatabaseTimeoutError: If the query times out.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        try:\n            session = self.get_session()\n            result = await session.scalars(statement, params or {})\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n            raise  # This will never be reached, but satisfies MyPy\n        else:\n            return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.__init__","title":"<code>archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.__init__(orm_config=None)</code>","text":"<p>Initialize the base async adapter with a session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>ConfigT | None</code> <p>Configuration for SQLAlchemy. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>def __init__(self, orm_config: ConfigT | None = None) -&gt; None:\n    \"\"\"Initialize the base async adapter with a session manager.\n\n    Args:\n        orm_config: Configuration for SQLAlchemy. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().SQLALCHEMY if orm_config is None else orm_config\n    # Cast to ConfigT since subclasses will ensure the proper type\n    self.session_manager: AsyncBaseSQLAlchemySessionManager[ConfigT] = self._create_async_session_manager(configs)  # type: ignore[arg-type]\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.execute_search_query","title":"<code>archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.execute_search_query(entity, query, pagination, sort_info=None, has_multiple_entities=False)</code>  <code>async</code>","text":"<p>Execute a search query with pagination and sorting.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>type[BaseEntity]</code> <p>The entity class to query.</p> required <code>query</code> <code>Select</code> <p>The SQLAlchemy SELECT query.</p> required <code>pagination</code> <code>PaginationDTO | None</code> <p>Optional pagination settings.</p> required <code>sort_info</code> <code>SortDTO | None</code> <p>Optional sorting information.</p> <code>None</code> <code>has_multiple_entities</code> <code>bool</code> <p>Optional bool</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[list[BaseEntity], int]</code> <p>Tuple of the list of entities and the total count.</p> <p>Raises:</p> Type Description <code>DatabaseQueryError</code> <p>If the database query fails.</p> <code>DatabaseTimeoutError</code> <p>If the query times out.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\nasync def execute_search_query(\n    self,\n    entity: type[BaseEntity],\n    query: Select,\n    pagination: PaginationDTO | None,\n    sort_info: SortDTO | None = None,\n    has_multiple_entities: bool = False,\n) -&gt; tuple[list[BaseEntity], int]:\n    \"\"\"Execute a search query with pagination and sorting.\n\n    Args:\n        entity: The entity class to query.\n        query: The SQLAlchemy SELECT query.\n        pagination: Optional pagination settings.\n        sort_info: Optional sorting information.\n        has_multiple_entities: Optional bool\n\n    Returns:\n        Tuple of the list of entities and the total count.\n\n    Raises:\n        DatabaseQueryError: If the database query fails.\n        DatabaseTimeoutError: If the query times out.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    try:\n        sort_info = sort_info or SortDTO.default()\n        session = self.get_session()\n        sorted_query = self._apply_sorting(entity, query, sort_info)\n        paginated_query = self._apply_pagination(sorted_query, pagination)\n        result_set = await session.execute(paginated_query)\n        if has_multiple_entities:\n            results = list(result_set.fetchall())\n        else:\n            results = list(result_set.scalars().all())\n        count_query = select(func.count()).select_from(query.subquery())\n        total_count_result = await session.execute(count_query)\n        total_count = total_count_result.scalar_one()\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n        raise  # This will never be reached, but satisfies MyPy\n    else:\n        return results, total_count  # type: ignore[return-value]\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.get_session","title":"<code>archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.get_session()</code>","text":"<p>Get a database session.</p> <p>Returns:</p> Name Type Description <code>AsyncSession</code> <code>AsyncSession</code> <p>A SQLAlchemy async session.</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error getting the session.</p> <code>DatabaseConfigurationError</code> <p>If there's an error in the database configuration.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\ndef get_session(self) -&gt; AsyncSession:\n    \"\"\"Get a database session.\n\n    Returns:\n        AsyncSession: A SQLAlchemy async session.\n\n    Raises:\n        DatabaseConnectionError: If there's an error getting the session.\n        DatabaseConfigurationError: If there's an error in the database configuration.\n    \"\"\"\n    return self.session_manager.get_session()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.create","title":"<code>archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.create(entity)</code>  <code>async</code>","text":"<p>Create a new entity in the database.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>T</code> <p>The entity to create.</p> required <p>Returns:</p> Type Description <code>T | None</code> <p>The created entity with updated attributes, preserving the original type.</p> <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If the entity type is not a valid SQLAlchemy model.</p> <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseIntegrityError</code> <p>If there's an integrity constraint violation.</p> <code>DatabaseConstraintError</code> <p>If there's a constraint violation.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\nasync def create(self, entity: T) -&gt; T | None:\n    \"\"\"Create a new entity in the database.\n\n    Args:\n        entity: The entity to create.\n\n    Returns:\n        The created entity with updated attributes, preserving the original type.\n\n    Raises:\n        InvalidEntityTypeError: If the entity type is not a valid SQLAlchemy model.\n        DatabaseQueryError: If the database operation fails.\n        DatabaseIntegrityError: If there's an integrity constraint violation.\n        DatabaseConstraintError: If there's a constraint violation.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    if not isinstance(entity, BaseEntity):\n        raise InvalidEntityTypeError(\n            message=f\"Expected BaseEntity subclass, got {type(entity).__name__}\",\n            expected_type=\"BaseEntity\",\n            actual_type=type(entity).__name__,\n        )\n\n    try:\n        session = self.get_session()\n        session.add(entity)\n        await session.flush()\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n        raise  # This will never be reached, but satisfies MyPy\n    else:\n        return entity\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.bulk_create","title":"<code>archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.bulk_create(entities)</code>  <code>async</code>","text":"<p>Creates multiple entities in a single database operation.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[T]</code> <p>List of entities to create.</p> required <p>Returns:</p> Type Description <code>list[T] | None</code> <p>List of created entities with updated attributes, preserving original types.</p> <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If any entity is not a valid SQLAlchemy model.</p> <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseIntegrityError</code> <p>If there's an integrity constraint violation.</p> <code>DatabaseConstraintError</code> <p>If there's a constraint violation.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\nasync def bulk_create(self, entities: list[T]) -&gt; list[T] | None:\n    \"\"\"Creates multiple entities in a single database operation.\n\n    Args:\n        entities: List of entities to create.\n\n    Returns:\n        List of created entities with updated attributes, preserving original types.\n\n    Raises:\n        InvalidEntityTypeError: If any entity is not a valid SQLAlchemy model.\n        DatabaseQueryError: If the database operation fails.\n        DatabaseIntegrityError: If there's an integrity constraint violation.\n        DatabaseConstraintError: If there's a constraint violation.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    if not all(isinstance(entity, BaseEntity) for entity in entities):\n        raise InvalidEntityTypeError(\n            message=\"All entities must be BaseEntity subclasses\",\n            expected_type=\"BaseEntity\",\n            actual_type=\"mixed\",\n        )\n\n    try:\n        session = self.get_session()\n        session.add_all(entities)\n        await session.flush()\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n        raise  # This will never be reached, but satisfies MyPy\n    else:\n        return entities\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.get_by_uuid","title":"<code>archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.get_by_uuid(entity_type, entity_uuid)</code>  <code>async</code>","text":"<p>Retrieve an entity by its UUID.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type[T]</code> <p>The type of entity to retrieve.</p> required <code>entity_uuid</code> <code>UUID</code> <p>The UUID of the entity.</p> required <p>Returns:</p> Type Description <code>T | None</code> <p>The entity if found, None otherwise.</p> <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If the entity type is not a valid SQLAlchemy model.</p> <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseTimeoutError</code> <p>If the query times out.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\nasync def get_by_uuid(self, entity_type: type[T], entity_uuid: UUID) -&gt; T | None:\n    \"\"\"Retrieve an entity by its UUID.\n\n    Args:\n        entity_type: The type of entity to retrieve.\n        entity_uuid: The UUID of the entity.\n\n    Returns:\n        The entity if found, None otherwise.\n\n    Raises:\n        InvalidEntityTypeError: If the entity type is not a valid SQLAlchemy model.\n        DatabaseQueryError: If the database operation fails.\n        DatabaseTimeoutError: If the query times out.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    if not issubclass(entity_type, BaseEntity):\n        raise InvalidEntityTypeError(\n            message=f\"Expected BaseEntity subclass, got {entity_type.__name__}\",\n            expected_type=\"BaseEntity\",\n            actual_type=entity_type.__name__,\n        )\n\n    try:\n        session = self.get_session()\n        result = await session.get(entity_type, entity_uuid)\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n        raise  # This will never be reached, but satisfies MyPy\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.delete","title":"<code>archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.delete(entity)</code>  <code>async</code>","text":"<p>Delete an entity from the database.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>BaseEntity</code> <p>The entity to delete.</p> required <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If the entity is not a valid SQLAlchemy model.</p> <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseIntegrityError</code> <p>If there's an integrity constraint violation.</p> <code>DatabaseConstraintError</code> <p>If there's a constraint violation.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\nasync def delete(self, entity: BaseEntity) -&gt; None:\n    \"\"\"Delete an entity from the database.\n\n    Args:\n        entity: The entity to delete.\n\n    Raises:\n        InvalidEntityTypeError: If the entity is not a valid SQLAlchemy model.\n        DatabaseQueryError: If the database operation fails.\n        DatabaseIntegrityError: If there's an integrity constraint violation.\n        DatabaseConstraintError: If there's a constraint violation.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    if not isinstance(entity, BaseEntity):\n        raise InvalidEntityTypeError(\n            message=f\"Expected BaseEntity subclass, got {type(entity).__name__}\",\n            expected_type=\"BaseEntity\",\n            actual_type=type(entity).__name__,\n        )\n\n    try:\n        session = self.get_session()\n        await session.delete(entity)\n        await session.flush()\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.bulk_delete","title":"<code>archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.bulk_delete(entities)</code>  <code>async</code>","text":"<p>Delete multiple entities from the database.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[BaseEntity]</code> <p>List of entities to delete.</p> required <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If any entity is not a valid SQLAlchemy model.</p> <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseIntegrityError</code> <p>If there's an integrity constraint violation.</p> <code>DatabaseConstraintError</code> <p>If there's a constraint violation.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\nasync def bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n    \"\"\"Delete multiple entities from the database.\n\n    Args:\n        entities: List of entities to delete.\n\n    Raises:\n        InvalidEntityTypeError: If any entity is not a valid SQLAlchemy model.\n        DatabaseQueryError: If the database operation fails.\n        DatabaseIntegrityError: If there's an integrity constraint violation.\n        DatabaseConstraintError: If there's a constraint violation.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    if not all(isinstance(entity, BaseEntity) for entity in entities):\n        raise InvalidEntityTypeError(\n            message=\"All entities must be BaseEntity subclasses\",\n            expected_type=\"BaseEntity\",\n            actual_type=\"mixed\",\n        )\n\n    try:\n        session = self.get_session()\n        for entity in entities:\n            await session.delete(entity)\n        await session.flush()\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.execute","title":"<code>archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.execute(statement, params=None)</code>  <code>async</code>","text":"<p>Execute a SQLAlchemy statement.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQLAlchemy statement to execute.</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the statement.</p> <code>None</code> <p>Returns:</p> Type Description <code>Result[Any]</code> <p>The result of the execution.</p> <p>Raises:</p> Type Description <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseTimeoutError</code> <p>If the query times out.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\nasync def execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Result[Any]:\n    \"\"\"Execute a SQLAlchemy statement.\n\n    Args:\n        statement: The SQLAlchemy statement to execute.\n        params: Optional parameters for the statement.\n\n    Returns:\n        The result of the execution.\n\n    Raises:\n        DatabaseQueryError: If the database operation fails.\n        DatabaseTimeoutError: If the query times out.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    try:\n        session = self.get_session()\n        result = await session.execute(statement, params or {})\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n        raise  # This will never be reached, but satisfies MyPy\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.scalars","title":"<code>archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.scalars(statement, params=None)</code>  <code>async</code>","text":"<p>Execute a SQLAlchemy statement and return scalar results.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQLAlchemy statement to execute.</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the statement.</p> <code>None</code> <p>Returns:</p> Type Description <code>ScalarResult[Any]</code> <p>The scalar results of the execution.</p> <p>Raises:</p> Type Description <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseTimeoutError</code> <p>If the query times out.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\nasync def scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; ScalarResult[Any]:\n    \"\"\"Execute a SQLAlchemy statement and return scalar results.\n\n    Args:\n        statement: The SQLAlchemy statement to execute.\n        params: Optional parameters for the statement.\n\n    Returns:\n        The scalar results of the execution.\n\n    Raises:\n        DatabaseQueryError: If the database operation fails.\n        DatabaseTimeoutError: If the query times out.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    try:\n        session = self.get_session()\n        result = await session.scalars(statement, params or {})\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n        raise  # This will never be reached, but satisfies MyPy\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort","title":"<code>archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort</code>","text":"<p>Abstract interface defining synchronous SQLAlchemy database operations.</p> <p>This interface defines the contract that all synchronous SQLAlchemy adapters must implement, providing standard methods for database operations like create, read, update, delete (CRUD), as well as search and transaction management.</p> <p>Implementations of this interface are responsible for handling the specific details of database interactions and connection management.</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>class SQLAlchemyPort:\n    \"\"\"Abstract interface defining synchronous SQLAlchemy database operations.\n\n    This interface defines the contract that all synchronous SQLAlchemy adapters must\n    implement, providing standard methods for database operations like create,\n    read, update, delete (CRUD), as well as search and transaction management.\n\n    Implementations of this interface are responsible for handling the specific\n    details of database interactions and connection management.\n    \"\"\"\n\n    @abstractmethod\n    def get_session(self) -&gt; Session:\n        \"\"\"Retrieves a SQLAlchemy session for database operations.\n\n        Returns:\n            Session: A SQLAlchemy session object\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def execute_search_query(\n        self,\n        entity: type[BaseEntity],\n        query: Select,\n        pagination: PaginationDTO | None = None,\n        sort_info: SortDTO | None = None,\n        has_multiple_entities: bool = False,\n    ) -&gt; tuple[list[BaseEntity], int]:\n        \"\"\"Executes a search query with pagination and sorting.\n\n        Args:\n            entity: The entity class to query\n            query: The SQLAlchemy SELECT query\n            pagination: Optional pagination settings\n            sort_info: Optional sorting information\n            has_multiple_entities: Optional bool.\n\n        Returns:\n            A tuple containing the list of entities and the total count\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def create(self, entity: BaseEntity) -&gt; BaseEntity | None:\n        \"\"\"Creates a new entity in the database.\n\n        Args:\n            entity: The entity to create\n\n        Returns:\n            The created entity (with updated attributes) or None if creation failed\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def bulk_create(self, entities: list[BaseEntity]) -&gt; list[BaseEntity] | None:\n        \"\"\"Creates multiple entities in the database.\n\n        Args:\n            entities: List of entities to create\n\n        Returns:\n            The list of created entities or None if creation failed\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_by_uuid(self, entity_type: type, entity_uuid: UUID) -&gt; BaseEntity | None:\n        \"\"\"Retrieves an entity by its UUID.\n\n        Args:\n            entity_type: The type of entity to retrieve\n            entity_uuid: The UUID of the entity\n\n        Returns:\n            The entity if found, None otherwise\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def delete(self, entity: BaseEntity) -&gt; None:\n        \"\"\"Deletes an entity from the database.\n\n        Args:\n            entity: The entity to delete\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n        \"\"\"Deletes multiple entities from the database.\n\n        Args:\n            entities: List of entities to delete\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Result[Any]:\n        \"\"\"Executes a raw SQL statement.\n\n        Args:\n            statement: The SQL statement to execute\n            params: Optional parameters for the SQL statement\n\n        Returns:\n            The result of the execution\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; ScalarResult[Any]:\n        \"\"\"Executes a statement and returns the scalar result.\n\n        Args:\n            statement: The SQL statement to execute\n            params: Optional parameters for the SQL statement\n\n        Returns:\n            The scalar result of the execution\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.get_session","title":"<code>archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.get_session()</code>  <code>abstractmethod</code>","text":"<p>Retrieves a SQLAlchemy session for database operations.</p> <p>Returns:</p> Name Type Description <code>Session</code> <code>Session</code> <p>A SQLAlchemy session object</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef get_session(self) -&gt; Session:\n    \"\"\"Retrieves a SQLAlchemy session for database operations.\n\n    Returns:\n        Session: A SQLAlchemy session object\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.execute_search_query","title":"<code>archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.execute_search_query(entity, query, pagination=None, sort_info=None, has_multiple_entities=False)</code>  <code>abstractmethod</code>","text":"<p>Executes a search query with pagination and sorting.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>type[BaseEntity]</code> <p>The entity class to query</p> required <code>query</code> <code>Select</code> <p>The SQLAlchemy SELECT query</p> required <code>pagination</code> <code>PaginationDTO | None</code> <p>Optional pagination settings</p> <code>None</code> <code>sort_info</code> <code>SortDTO | None</code> <p>Optional sorting information</p> <code>None</code> <code>has_multiple_entities</code> <code>bool</code> <p>Optional bool.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[list[BaseEntity], int]</code> <p>A tuple containing the list of entities and the total count</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef execute_search_query(\n    self,\n    entity: type[BaseEntity],\n    query: Select,\n    pagination: PaginationDTO | None = None,\n    sort_info: SortDTO | None = None,\n    has_multiple_entities: bool = False,\n) -&gt; tuple[list[BaseEntity], int]:\n    \"\"\"Executes a search query with pagination and sorting.\n\n    Args:\n        entity: The entity class to query\n        query: The SQLAlchemy SELECT query\n        pagination: Optional pagination settings\n        sort_info: Optional sorting information\n        has_multiple_entities: Optional bool.\n\n    Returns:\n        A tuple containing the list of entities and the total count\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.create","title":"<code>archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.create(entity)</code>  <code>abstractmethod</code>","text":"<p>Creates a new entity in the database.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>BaseEntity</code> <p>The entity to create</p> required <p>Returns:</p> Type Description <code>BaseEntity | None</code> <p>The created entity (with updated attributes) or None if creation failed</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef create(self, entity: BaseEntity) -&gt; BaseEntity | None:\n    \"\"\"Creates a new entity in the database.\n\n    Args:\n        entity: The entity to create\n\n    Returns:\n        The created entity (with updated attributes) or None if creation failed\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.bulk_create","title":"<code>archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.bulk_create(entities)</code>  <code>abstractmethod</code>","text":"<p>Creates multiple entities in the database.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[BaseEntity]</code> <p>List of entities to create</p> required <p>Returns:</p> Type Description <code>list[BaseEntity] | None</code> <p>The list of created entities or None if creation failed</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef bulk_create(self, entities: list[BaseEntity]) -&gt; list[BaseEntity] | None:\n    \"\"\"Creates multiple entities in the database.\n\n    Args:\n        entities: List of entities to create\n\n    Returns:\n        The list of created entities or None if creation failed\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.get_by_uuid","title":"<code>archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.get_by_uuid(entity_type, entity_uuid)</code>  <code>abstractmethod</code>","text":"<p>Retrieves an entity by its UUID.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type</code> <p>The type of entity to retrieve</p> required <code>entity_uuid</code> <code>UUID</code> <p>The UUID of the entity</p> required <p>Returns:</p> Type Description <code>BaseEntity | None</code> <p>The entity if found, None otherwise</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef get_by_uuid(self, entity_type: type, entity_uuid: UUID) -&gt; BaseEntity | None:\n    \"\"\"Retrieves an entity by its UUID.\n\n    Args:\n        entity_type: The type of entity to retrieve\n        entity_uuid: The UUID of the entity\n\n    Returns:\n        The entity if found, None otherwise\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.delete","title":"<code>archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.delete(entity)</code>  <code>abstractmethod</code>","text":"<p>Deletes an entity from the database.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>BaseEntity</code> <p>The entity to delete</p> required Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef delete(self, entity: BaseEntity) -&gt; None:\n    \"\"\"Deletes an entity from the database.\n\n    Args:\n        entity: The entity to delete\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.bulk_delete","title":"<code>archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.bulk_delete(entities)</code>  <code>abstractmethod</code>","text":"<p>Deletes multiple entities from the database.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[BaseEntity]</code> <p>List of entities to delete</p> required Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n    \"\"\"Deletes multiple entities from the database.\n\n    Args:\n        entities: List of entities to delete\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.execute","title":"<code>archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.execute(statement, params=None)</code>  <code>abstractmethod</code>","text":"<p>Executes a raw SQL statement.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQL statement to execute</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the SQL statement</p> <code>None</code> <p>Returns:</p> Type Description <code>Result[Any]</code> <p>The result of the execution</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Result[Any]:\n    \"\"\"Executes a raw SQL statement.\n\n    Args:\n        statement: The SQL statement to execute\n        params: Optional parameters for the SQL statement\n\n    Returns:\n        The result of the execution\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.scalars","title":"<code>archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.scalars(statement, params=None)</code>  <code>abstractmethod</code>","text":"<p>Executes a statement and returns the scalar result.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQL statement to execute</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the SQL statement</p> <code>None</code> <p>Returns:</p> Type Description <code>ScalarResult[Any]</code> <p>The scalar result of the execution</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; ScalarResult[Any]:\n    \"\"\"Executes a statement and returns the scalar result.\n\n    Args:\n        statement: The SQL statement to execute\n        params: Optional parameters for the SQL statement\n\n    Returns:\n        The scalar result of the execution\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort","title":"<code>archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort</code>","text":"<p>Abstract interface defining asynchronous SQLAlchemy database operations.</p> <p>This interface defines the contract that all asynchronous SQLAlchemy adapters must implement, providing standard methods for database operations like create, read, update, delete (CRUD), as well as search and transaction management.</p> <p>Implementations of this interface are responsible for handling the specific details of asynchronous database interactions and connection management.</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>class AsyncSQLAlchemyPort:\n    \"\"\"Abstract interface defining asynchronous SQLAlchemy database operations.\n\n    This interface defines the contract that all asynchronous SQLAlchemy adapters must\n    implement, providing standard methods for database operations like create,\n    read, update, delete (CRUD), as well as search and transaction management.\n\n    Implementations of this interface are responsible for handling the specific\n    details of asynchronous database interactions and connection management.\n    \"\"\"\n\n    @abstractmethod\n    def get_session(self) -&gt; AsyncSession:\n        \"\"\"Retrieves an asynchronous SQLAlchemy session for database operations.\n\n        Returns:\n            AsyncSession: An asynchronous SQLAlchemy session object\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def execute_search_query(\n        self,\n        entity: type[BaseEntity],\n        query: Select,\n        pagination: PaginationDTO | None,\n        sort_info: SortDTO | None = None,\n        has_multiple_entities: bool = False,\n    ) -&gt; tuple[list[BaseEntity], int]:\n        \"\"\"Executes a search query with pagination and sorting asynchronously.\n\n        Args:\n            entity: The entity class to query\n            query: The SQLAlchemy SELECT query\n            pagination: Optional pagination settings\n            sort_info: Optional sorting information\n            has_multiple_entities: Optional bool\n\n        Returns:\n            A tuple containing the list of entities and the total count\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def create(self, entity: BaseEntity) -&gt; BaseEntity | None:\n        \"\"\"Creates a new entity in the database asynchronously.\n\n        Args:\n            entity: The entity to create\n\n        Returns:\n            The created entity (with updated attributes) or None if creation failed\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def bulk_create(self, entities: list[BaseEntity]) -&gt; list[BaseEntity] | None:\n        \"\"\"Creates multiple entities in the database asynchronously.\n\n        Args:\n            entities: List of entities to create\n\n        Returns:\n            The list of created entities or None if creation failed\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_by_uuid(self, entity_type: type, entity_uuid: UUID) -&gt; BaseEntity | None:\n        \"\"\"Retrieves an entity by its UUID asynchronously.\n\n        Args:\n            entity_type: The type of entity to retrieve\n            entity_uuid: The UUID of the entity\n\n        Returns:\n            The entity if found, None otherwise\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def delete(self, entity: BaseEntity) -&gt; None:\n        \"\"\"Deletes an entity from the database asynchronously.\n\n        Args:\n            entity: The entity to delete\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n        \"\"\"Deletes multiple entities from the database asynchronously.\n\n        Args:\n            entities: List of entities to delete\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Result[Any]:\n        \"\"\"Executes a raw SQL statement asynchronously.\n\n        Args:\n            statement: The SQL statement to execute\n            params: Optional parameters for the SQL statement\n\n        Returns:\n            The result of the execution\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; ScalarResult[Any]:\n        \"\"\"Executes a statement and returns the scalar result asynchronously.\n\n        Args:\n            statement: The SQL statement to execute\n            params: Optional parameters for the SQL statement\n\n        Returns:\n            The scalar result of the execution\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.get_session","title":"<code>archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.get_session()</code>  <code>abstractmethod</code>","text":"<p>Retrieves an asynchronous SQLAlchemy session for database operations.</p> <p>Returns:</p> Name Type Description <code>AsyncSession</code> <code>AsyncSession</code> <p>An asynchronous SQLAlchemy session object</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef get_session(self) -&gt; AsyncSession:\n    \"\"\"Retrieves an asynchronous SQLAlchemy session for database operations.\n\n    Returns:\n        AsyncSession: An asynchronous SQLAlchemy session object\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.execute_search_query","title":"<code>archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.execute_search_query(entity, query, pagination, sort_info=None, has_multiple_entities=False)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Executes a search query with pagination and sorting asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>type[BaseEntity]</code> <p>The entity class to query</p> required <code>query</code> <code>Select</code> <p>The SQLAlchemy SELECT query</p> required <code>pagination</code> <code>PaginationDTO | None</code> <p>Optional pagination settings</p> required <code>sort_info</code> <code>SortDTO | None</code> <p>Optional sorting information</p> <code>None</code> <code>has_multiple_entities</code> <code>bool</code> <p>Optional bool</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[list[BaseEntity], int]</code> <p>A tuple containing the list of entities and the total count</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def execute_search_query(\n    self,\n    entity: type[BaseEntity],\n    query: Select,\n    pagination: PaginationDTO | None,\n    sort_info: SortDTO | None = None,\n    has_multiple_entities: bool = False,\n) -&gt; tuple[list[BaseEntity], int]:\n    \"\"\"Executes a search query with pagination and sorting asynchronously.\n\n    Args:\n        entity: The entity class to query\n        query: The SQLAlchemy SELECT query\n        pagination: Optional pagination settings\n        sort_info: Optional sorting information\n        has_multiple_entities: Optional bool\n\n    Returns:\n        A tuple containing the list of entities and the total count\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.create","title":"<code>archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.create(entity)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Creates a new entity in the database asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>BaseEntity</code> <p>The entity to create</p> required <p>Returns:</p> Type Description <code>BaseEntity | None</code> <p>The created entity (with updated attributes) or None if creation failed</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def create(self, entity: BaseEntity) -&gt; BaseEntity | None:\n    \"\"\"Creates a new entity in the database asynchronously.\n\n    Args:\n        entity: The entity to create\n\n    Returns:\n        The created entity (with updated attributes) or None if creation failed\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.bulk_create","title":"<code>archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.bulk_create(entities)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Creates multiple entities in the database asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[BaseEntity]</code> <p>List of entities to create</p> required <p>Returns:</p> Type Description <code>list[BaseEntity] | None</code> <p>The list of created entities or None if creation failed</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def bulk_create(self, entities: list[BaseEntity]) -&gt; list[BaseEntity] | None:\n    \"\"\"Creates multiple entities in the database asynchronously.\n\n    Args:\n        entities: List of entities to create\n\n    Returns:\n        The list of created entities or None if creation failed\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.get_by_uuid","title":"<code>archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.get_by_uuid(entity_type, entity_uuid)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Retrieves an entity by its UUID asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type</code> <p>The type of entity to retrieve</p> required <code>entity_uuid</code> <code>UUID</code> <p>The UUID of the entity</p> required <p>Returns:</p> Type Description <code>BaseEntity | None</code> <p>The entity if found, None otherwise</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def get_by_uuid(self, entity_type: type, entity_uuid: UUID) -&gt; BaseEntity | None:\n    \"\"\"Retrieves an entity by its UUID asynchronously.\n\n    Args:\n        entity_type: The type of entity to retrieve\n        entity_uuid: The UUID of the entity\n\n    Returns:\n        The entity if found, None otherwise\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.delete","title":"<code>archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.delete(entity)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Deletes an entity from the database asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>BaseEntity</code> <p>The entity to delete</p> required Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def delete(self, entity: BaseEntity) -&gt; None:\n    \"\"\"Deletes an entity from the database asynchronously.\n\n    Args:\n        entity: The entity to delete\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.bulk_delete","title":"<code>archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.bulk_delete(entities)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Deletes multiple entities from the database asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[BaseEntity]</code> <p>List of entities to delete</p> required Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n    \"\"\"Deletes multiple entities from the database asynchronously.\n\n    Args:\n        entities: List of entities to delete\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.execute","title":"<code>archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.execute(statement, params=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Executes a raw SQL statement asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQL statement to execute</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the SQL statement</p> <code>None</code> <p>Returns:</p> Type Description <code>Result[Any]</code> <p>The result of the execution</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Result[Any]:\n    \"\"\"Executes a raw SQL statement asynchronously.\n\n    Args:\n        statement: The SQL statement to execute\n        params: Optional parameters for the SQL statement\n\n    Returns:\n        The result of the execution\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.scalars","title":"<code>archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.scalars(statement, params=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Executes a statement and returns the scalar result asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQL statement to execute</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the SQL statement</p> <code>None</code> <p>Returns:</p> Type Description <code>ScalarResult[Any]</code> <p>The scalar result of the execution</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; ScalarResult[Any]:\n    \"\"\"Executes a statement and returns the scalar result asynchronously.\n\n    Args:\n        statement: The SQL statement to execute\n        params: Optional parameters for the SQL statement\n\n    Returns:\n        The scalar result of the execution\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_managers.BaseSQLAlchemySessionManager","title":"<code>archipy.adapters.base.sqlalchemy.session_managers.BaseSQLAlchemySessionManager</code>","text":"<p>               Bases: <code>SessionManagerPort</code></p> <p>Base synchronous SQLAlchemy session manager.</p> <p>Implements the SessionManagerPort interface to provide session management for synchronous database operations. Database-specific session managers should inherit from this class and implement database-specific engine creation.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>ConfigT</code> <p>SQLAlchemy configuration. Must match the expected config type for the database.</p> required Source code in <code>archipy/adapters/base/sqlalchemy/session_managers.py</code> <pre><code>class BaseSQLAlchemySessionManager[ConfigT: SQLAlchemyConfig](SessionManagerPort):\n    \"\"\"Base synchronous SQLAlchemy session manager.\n\n    Implements the SessionManagerPort interface to provide session management for\n    synchronous database operations. Database-specific session managers should inherit\n    from this class and implement database-specific engine creation.\n\n    Args:\n        orm_config: SQLAlchemy configuration. Must match the expected config type for the database.\n    \"\"\"\n\n    def __init__(self, orm_config: ConfigT) -&gt; None:\n        \"\"\"Initialize the base session manager.\n\n        Args:\n            orm_config: SQLAlchemy configuration.\n\n        Raises:\n            InvalidArgumentError: If the configuration type is invalid.\n            DatabaseConnectionError: If there's an error creating the database connection.\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        if not isinstance(orm_config, self._expected_config_type()):\n            raise InvalidArgumentError(\n                f\"Expected {self._expected_config_type().__name__}, got {type(orm_config).__name__}\",\n            )\n        try:\n            self.engine = self._create_engine(orm_config)\n            self._session_generator = self._get_session_generator()\n        except SQLAlchemyError as e:\n            if \"configuration\" in str(e).lower():\n                raise DatabaseConfigurationError(\n                    database=self._get_database_name(),\n                ) from e\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n\n    @abstractmethod\n    def _expected_config_type(self) -&gt; type[SQLAlchemyConfig]:\n        \"\"\"Return the expected configuration type for the database.\n\n        Returns:\n            The SQLAlchemy configuration class expected by this session manager.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _get_database_name(self) -&gt; str:\n        \"\"\"Return the name of the database being used.\n\n        Returns:\n            str: The name of the database (e.g., 'postgresql', 'sqlite', 'starrocks').\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _create_url(self, configs: ConfigT) -&gt; URL:\n        \"\"\"Create a database connection URL.\n\n        Args:\n            configs: Database-specific configuration.\n\n        Returns:\n            A SQLAlchemy URL object for the database.\n\n        Raises:\n            DatabaseConnectionError: If there's an error creating the URL.\n        \"\"\"\n        pass\n\n    def _create_engine(self, configs: ConfigT) -&gt; Engine:\n        \"\"\"Create a SQLAlchemy engine with common configuration.\n\n        Args:\n            configs: SQLAlchemy configuration.\n\n        Returns:\n            A configured SQLAlchemy engine.\n\n        Raises:\n            DatabaseConnectionError: If there's an error creating the engine.\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        try:\n            url = self._create_url(configs)\n            return create_engine(\n                url,\n                isolation_level=configs.ISOLATION_LEVEL,\n                echo=configs.ECHO,\n                echo_pool=configs.ECHO_POOL,\n                enable_from_linting=configs.ENABLE_FROM_LINTING,\n                hide_parameters=configs.HIDE_PARAMETERS,\n                pool_pre_ping=configs.POOL_PRE_PING,\n                pool_size=configs.POOL_SIZE,\n                pool_recycle=configs.POOL_RECYCLE_SECONDS,\n                pool_reset_on_return=configs.POOL_RESET_ON_RETURN,\n                pool_timeout=configs.POOL_TIMEOUT,\n                pool_use_lifo=configs.POOL_USE_LIFO,\n                query_cache_size=configs.QUERY_CACHE_SIZE,\n                max_overflow=configs.POOL_MAX_OVERFLOW,\n                connect_args=self._get_connect_args(),\n            )\n        except SQLAlchemyError as e:\n            if \"configuration\" in str(e).lower():\n                raise DatabaseConfigurationError(\n                    database=self._get_database_name(),\n                ) from e\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n\n    def _get_connect_args(self) -&gt; dict:\n        \"\"\"Return additional connection arguments for the engine.\n\n        Returns:\n            A dictionary of connection arguments (default is empty).\n        \"\"\"\n        return {}\n\n    def _get_session_generator(self) -&gt; scoped_session:\n        \"\"\"Create a scoped session factory for synchronous sessions.\n\n        Returns:\n            A scoped_session instance used by `get_session` to provide thread-safe sessions.\n\n        Raises:\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        try:\n            session_maker = sessionmaker(self.engine)\n            return scoped_session(session_maker)\n        except SQLAlchemyError as e:\n            if \"configuration\" in str(e).lower():\n                raise DatabaseConfigurationError(\n                    database=self._get_database_name(),\n                ) from e\n            raise DatabaseError(\n                database=self._get_database_name(),\n            ) from e\n\n    @override\n    def get_session(self) -&gt; Session:\n        \"\"\"Retrieve a thread-safe SQLAlchemy session.\n\n        Returns:\n            Session: A SQLAlchemy session instance for database operations.\n\n        Raises:\n            DatabaseConnectionError: If there's an error creating the session.\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        try:\n            return self._session_generator()  # type: ignore[no-any-return]\n        except SQLAlchemyError as e:\n            if \"configuration\" in str(e).lower():\n                raise DatabaseConfigurationError(\n                    database=self._get_database_name(),\n                ) from e\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n\n    @override\n    def remove_session(self) -&gt; None:\n        \"\"\"Remove the current session from the registry.\n\n        Cleans up the session to prevent resource leaks, typically called at the end\n        of a request.\n\n        Raises:\n            DatabaseConnectionError: If there's an error removing the session.\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        try:\n            self._session_generator.remove()\n        except SQLAlchemyError as e:\n            if \"configuration\" in str(e).lower():\n                raise DatabaseConfigurationError(\n                    database=self._get_database_name(),\n                ) from e\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_managers.BaseSQLAlchemySessionManager.__init__","title":"<code>archipy.adapters.base.sqlalchemy.session_managers.BaseSQLAlchemySessionManager.__init__(orm_config)</code>","text":"<p>Initialize the base session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>ConfigT</code> <p>SQLAlchemy configuration.</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the configuration type is invalid.</p> <code>DatabaseConnectionError</code> <p>If there's an error creating the database connection.</p> <code>DatabaseConfigurationError</code> <p>If there's an error in the database configuration.</p> Source code in <code>archipy/adapters/base/sqlalchemy/session_managers.py</code> <pre><code>def __init__(self, orm_config: ConfigT) -&gt; None:\n    \"\"\"Initialize the base session manager.\n\n    Args:\n        orm_config: SQLAlchemy configuration.\n\n    Raises:\n        InvalidArgumentError: If the configuration type is invalid.\n        DatabaseConnectionError: If there's an error creating the database connection.\n        DatabaseConfigurationError: If there's an error in the database configuration.\n    \"\"\"\n    if not isinstance(orm_config, self._expected_config_type()):\n        raise InvalidArgumentError(\n            f\"Expected {self._expected_config_type().__name__}, got {type(orm_config).__name__}\",\n        )\n    try:\n        self.engine = self._create_engine(orm_config)\n        self._session_generator = self._get_session_generator()\n    except SQLAlchemyError as e:\n        if \"configuration\" in str(e).lower():\n            raise DatabaseConfigurationError(\n                database=self._get_database_name(),\n            ) from e\n        raise DatabaseConnectionError(\n            database=self._get_database_name(),\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_managers.BaseSQLAlchemySessionManager.get_session","title":"<code>archipy.adapters.base.sqlalchemy.session_managers.BaseSQLAlchemySessionManager.get_session()</code>","text":"<p>Retrieve a thread-safe SQLAlchemy session.</p> <p>Returns:</p> Name Type Description <code>Session</code> <code>Session</code> <p>A SQLAlchemy session instance for database operations.</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error creating the session.</p> <code>DatabaseConfigurationError</code> <p>If there's an error in the database configuration.</p> Source code in <code>archipy/adapters/base/sqlalchemy/session_managers.py</code> <pre><code>@override\ndef get_session(self) -&gt; Session:\n    \"\"\"Retrieve a thread-safe SQLAlchemy session.\n\n    Returns:\n        Session: A SQLAlchemy session instance for database operations.\n\n    Raises:\n        DatabaseConnectionError: If there's an error creating the session.\n        DatabaseConfigurationError: If there's an error in the database configuration.\n    \"\"\"\n    try:\n        return self._session_generator()  # type: ignore[no-any-return]\n    except SQLAlchemyError as e:\n        if \"configuration\" in str(e).lower():\n            raise DatabaseConfigurationError(\n                database=self._get_database_name(),\n            ) from e\n        raise DatabaseConnectionError(\n            database=self._get_database_name(),\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_managers.BaseSQLAlchemySessionManager.remove_session","title":"<code>archipy.adapters.base.sqlalchemy.session_managers.BaseSQLAlchemySessionManager.remove_session()</code>","text":"<p>Remove the current session from the registry.</p> <p>Cleans up the session to prevent resource leaks, typically called at the end of a request.</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error removing the session.</p> <code>DatabaseConfigurationError</code> <p>If there's an error in the database configuration.</p> Source code in <code>archipy/adapters/base/sqlalchemy/session_managers.py</code> <pre><code>@override\ndef remove_session(self) -&gt; None:\n    \"\"\"Remove the current session from the registry.\n\n    Cleans up the session to prevent resource leaks, typically called at the end\n    of a request.\n\n    Raises:\n        DatabaseConnectionError: If there's an error removing the session.\n        DatabaseConfigurationError: If there's an error in the database configuration.\n    \"\"\"\n    try:\n        self._session_generator.remove()\n    except SQLAlchemyError as e:\n        if \"configuration\" in str(e).lower():\n            raise DatabaseConfigurationError(\n                database=self._get_database_name(),\n            ) from e\n        raise DatabaseConnectionError(\n            database=self._get_database_name(),\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_managers.AsyncBaseSQLAlchemySessionManager","title":"<code>archipy.adapters.base.sqlalchemy.session_managers.AsyncBaseSQLAlchemySessionManager</code>","text":"<p>               Bases: <code>AsyncSessionManagerPort</code></p> <p>Base asynchronous SQLAlchemy session manager.</p> <p>Implements the AsyncSessionManagerPort interface to provide session management for asynchronous database operations. Database-specific session managers should inherit from this class and implement database-specific async engine creation.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>ConfigT</code> <p>SQLAlchemy configuration. Must match the expected config type for the database.</p> required Source code in <code>archipy/adapters/base/sqlalchemy/session_managers.py</code> <pre><code>class AsyncBaseSQLAlchemySessionManager[ConfigT: SQLAlchemyConfig](AsyncSessionManagerPort):\n    \"\"\"Base asynchronous SQLAlchemy session manager.\n\n    Implements the AsyncSessionManagerPort interface to provide session management for\n    asynchronous database operations. Database-specific session managers should inherit\n    from this class and implement database-specific async engine creation.\n\n    Args:\n        orm_config: SQLAlchemy configuration. Must match the expected config type for the database.\n    \"\"\"\n\n    def __init__(self, orm_config: ConfigT) -&gt; None:\n        \"\"\"Initialize the base async session manager.\n\n        Args:\n            orm_config: SQLAlchemy configuration.\n\n        Raises:\n            InvalidArgumentError: If the configuration type is invalid.\n            DatabaseConnectionError: If there's an error creating the database connection.\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        if not isinstance(orm_config, self._expected_config_type()):\n            raise InvalidArgumentError(\n                f\"Expected {self._expected_config_type().__name__}, got {type(orm_config).__name__}\",\n            )\n        try:\n            self.engine = self._create_async_engine(orm_config)\n            self._session_generator = self._get_session_generator()\n        except SQLAlchemyError as e:\n            if \"configuration\" in str(e).lower():\n                raise DatabaseConfigurationError(\n                    database=self._get_database_name(),\n                ) from e\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n\n    @abstractmethod\n    def _expected_config_type(self) -&gt; type[SQLAlchemyConfig]:\n        \"\"\"Return the expected configuration type for the database.\n\n        Returns:\n            The SQLAlchemy configuration class expected by this session manager.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _get_database_name(self) -&gt; str:\n        \"\"\"Return the name of the database being used.\n\n        Returns:\n            str: The name of the database (e.g., 'postgresql', 'sqlite', 'starrocks').\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _create_url(self, configs: ConfigT) -&gt; URL:\n        \"\"\"Create a database connection URL.\n\n        Args:\n            configs: Database-specific configuration.\n\n        Returns:\n            A SQLAlchemy URL object for the database.\n\n        Raises:\n            DatabaseConnectionError: If there's an error creating the URL.\n        \"\"\"\n        pass\n\n    def _create_async_engine(self, configs: ConfigT) -&gt; AsyncEngine:\n        \"\"\"Create an async SQLAlchemy engine with common configuration.\n\n        Args:\n            configs: SQLAlchemy configuration.\n\n        Returns:\n            A configured async SQLAlchemy engine.\n\n        Raises:\n            DatabaseConnectionError: If there's an error creating the engine.\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        try:\n            url = self._create_url(configs)\n            return create_async_engine(\n                url,\n                isolation_level=configs.ISOLATION_LEVEL,\n                echo=configs.ECHO,\n                echo_pool=configs.ECHO_POOL,\n                enable_from_linting=configs.ENABLE_FROM_LINTING,\n                hide_parameters=configs.HIDE_PARAMETERS,\n                pool_pre_ping=configs.POOL_PRE_PING,\n                pool_size=configs.POOL_SIZE,\n                pool_recycle=configs.POOL_RECYCLE_SECONDS,\n                pool_reset_on_return=configs.POOL_RESET_ON_RETURN,\n                pool_timeout=configs.POOL_TIMEOUT,\n                pool_use_lifo=configs.POOL_USE_LIFO,\n                query_cache_size=configs.QUERY_CACHE_SIZE,\n                max_overflow=configs.POOL_MAX_OVERFLOW,\n                connect_args=self._get_connect_args(),\n            )\n        except SQLAlchemyError as e:\n            if \"configuration\" in str(e).lower():\n                raise DatabaseConfigurationError(\n                    database=self._get_database_name(),\n                ) from e\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n\n    def _get_connect_args(self) -&gt; dict:\n        \"\"\"Return additional connection arguments for the engine.\n\n        Returns:\n            A dictionary of connection arguments (default is empty).\n        \"\"\"\n        return {}\n\n    def _get_session_generator(self) -&gt; async_scoped_session:\n        \"\"\"Create an async scoped session factory.\n\n        Returns:\n            An async_scoped_session instance used by `get_session` to provide task-safe sessions.\n\n        Raises:\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        try:\n            session_maker = async_sessionmaker(self.engine)\n            return async_scoped_session(session_maker, scopefunc=current_task)\n        except SQLAlchemyError as e:\n            if \"configuration\" in str(e).lower():\n                raise DatabaseConfigurationError(\n                    database=self._get_database_name(),\n                ) from e\n            raise DatabaseError(\n                database=self._get_database_name(),\n            ) from e\n\n    @override\n    def get_session(self) -&gt; AsyncSession:\n        \"\"\"Retrieve a task-safe async SQLAlchemy session.\n\n        Returns:\n            AsyncSession: An async SQLAlchemy session instance for database operations.\n\n        Raises:\n            DatabaseConnectionError: If there's an error creating the session.\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        try:\n            return self._session_generator()  # type: ignore[no-any-return]\n        except SQLAlchemyError as e:\n            if \"configuration\" in str(e).lower():\n                raise DatabaseConfigurationError(\n                    database=self._get_database_name(),\n                ) from e\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n\n    @override\n    async def remove_session(self) -&gt; None:\n        \"\"\"Remove the current session from the registry.\n\n        Cleans up the session to prevent resource leaks, typically called at the end\n        of a request.\n\n        Raises:\n            DatabaseConnectionError: If there's an error removing the session.\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        try:\n            await self._session_generator.remove()\n        except SQLAlchemyError as e:\n            if \"configuration\" in str(e).lower():\n                raise DatabaseConfigurationError(\n                    database=self._get_database_name(),\n                ) from e\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_managers.AsyncBaseSQLAlchemySessionManager.__init__","title":"<code>archipy.adapters.base.sqlalchemy.session_managers.AsyncBaseSQLAlchemySessionManager.__init__(orm_config)</code>","text":"<p>Initialize the base async session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>ConfigT</code> <p>SQLAlchemy configuration.</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the configuration type is invalid.</p> <code>DatabaseConnectionError</code> <p>If there's an error creating the database connection.</p> <code>DatabaseConfigurationError</code> <p>If there's an error in the database configuration.</p> Source code in <code>archipy/adapters/base/sqlalchemy/session_managers.py</code> <pre><code>def __init__(self, orm_config: ConfigT) -&gt; None:\n    \"\"\"Initialize the base async session manager.\n\n    Args:\n        orm_config: SQLAlchemy configuration.\n\n    Raises:\n        InvalidArgumentError: If the configuration type is invalid.\n        DatabaseConnectionError: If there's an error creating the database connection.\n        DatabaseConfigurationError: If there's an error in the database configuration.\n    \"\"\"\n    if not isinstance(orm_config, self._expected_config_type()):\n        raise InvalidArgumentError(\n            f\"Expected {self._expected_config_type().__name__}, got {type(orm_config).__name__}\",\n        )\n    try:\n        self.engine = self._create_async_engine(orm_config)\n        self._session_generator = self._get_session_generator()\n    except SQLAlchemyError as e:\n        if \"configuration\" in str(e).lower():\n            raise DatabaseConfigurationError(\n                database=self._get_database_name(),\n            ) from e\n        raise DatabaseConnectionError(\n            database=self._get_database_name(),\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_managers.AsyncBaseSQLAlchemySessionManager.get_session","title":"<code>archipy.adapters.base.sqlalchemy.session_managers.AsyncBaseSQLAlchemySessionManager.get_session()</code>","text":"<p>Retrieve a task-safe async SQLAlchemy session.</p> <p>Returns:</p> Name Type Description <code>AsyncSession</code> <code>AsyncSession</code> <p>An async SQLAlchemy session instance for database operations.</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error creating the session.</p> <code>DatabaseConfigurationError</code> <p>If there's an error in the database configuration.</p> Source code in <code>archipy/adapters/base/sqlalchemy/session_managers.py</code> <pre><code>@override\ndef get_session(self) -&gt; AsyncSession:\n    \"\"\"Retrieve a task-safe async SQLAlchemy session.\n\n    Returns:\n        AsyncSession: An async SQLAlchemy session instance for database operations.\n\n    Raises:\n        DatabaseConnectionError: If there's an error creating the session.\n        DatabaseConfigurationError: If there's an error in the database configuration.\n    \"\"\"\n    try:\n        return self._session_generator()  # type: ignore[no-any-return]\n    except SQLAlchemyError as e:\n        if \"configuration\" in str(e).lower():\n            raise DatabaseConfigurationError(\n                database=self._get_database_name(),\n            ) from e\n        raise DatabaseConnectionError(\n            database=self._get_database_name(),\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_managers.AsyncBaseSQLAlchemySessionManager.remove_session","title":"<code>archipy.adapters.base.sqlalchemy.session_managers.AsyncBaseSQLAlchemySessionManager.remove_session()</code>  <code>async</code>","text":"<p>Remove the current session from the registry.</p> <p>Cleans up the session to prevent resource leaks, typically called at the end of a request.</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error removing the session.</p> <code>DatabaseConfigurationError</code> <p>If there's an error in the database configuration.</p> Source code in <code>archipy/adapters/base/sqlalchemy/session_managers.py</code> <pre><code>@override\nasync def remove_session(self) -&gt; None:\n    \"\"\"Remove the current session from the registry.\n\n    Cleans up the session to prevent resource leaks, typically called at the end\n    of a request.\n\n    Raises:\n        DatabaseConnectionError: If there's an error removing the session.\n        DatabaseConfigurationError: If there's an error in the database configuration.\n    \"\"\"\n    try:\n        await self._session_generator.remove()\n    except SQLAlchemyError as e:\n        if \"configuration\" in str(e).lower():\n            raise DatabaseConfigurationError(\n                database=self._get_database_name(),\n            ) from e\n        raise DatabaseConnectionError(\n            database=self._get_database_name(),\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry","title":"<code>archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry</code>","text":"<p>Registry for SQLAlchemy session managers.</p> <p>This registry provides a centralized access point for both synchronous and asynchronous session managers, implementing the Service Locator pattern.</p> <p>Subclasses should override get_sync_manager and get_async_manager to provide concrete session managers, or use set_sync_manager and set_async_manager to register managers manually.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from archipy.adapters.postgres.sqlalchemy.session_manager_registry import PostgresSessionManagerRegistry\n&gt;&gt;&gt; sync_manager = PostgresSessionManagerRegistry.get_sync_manager()\n&gt;&gt;&gt; session = sync_manager.get_session()\n</code></pre> Source code in <code>archipy/adapters/base/sqlalchemy/session_manager_registry.py</code> <pre><code>class SessionManagerRegistry:\n    \"\"\"Registry for SQLAlchemy session managers.\n\n    This registry provides a centralized access point for both synchronous and\n    asynchronous session managers, implementing the Service Locator pattern.\n\n    Subclasses should override get_sync_manager and get_async_manager to provide\n    concrete session managers, or use set_sync_manager and set_async_manager to\n    register managers manually.\n\n    Examples:\n        &gt;&gt;&gt; from archipy.adapters.postgres.sqlalchemy.session_manager_registry import PostgresSessionManagerRegistry\n        &gt;&gt;&gt; sync_manager = PostgresSessionManagerRegistry.get_sync_manager()\n        &gt;&gt;&gt; session = sync_manager.get_session()\n    \"\"\"\n\n    _sync_instance: ClassVar[\"SessionManagerPort | None\"] = None\n    _async_instance: ClassVar[\"AsyncSessionManagerPort | None\"] = None\n\n    @classmethod\n    def get_sync_manager(cls) -&gt; \"SessionManagerPort\":\n        \"\"\"Get the synchronous session manager instance.\n\n        Returns:\n            SessionManagerPort: The registered synchronous session manager\n\n        Raises:\n            InternalError: If no synchronous session manager is set\n            DatabaseConnectionError: If there's an error initializing the session manager\n        \"\"\"\n        if cls._sync_instance is None:\n            raise InternalError(\"Synchronous session manager not initialized\")\n        return cls._sync_instance\n\n    @classmethod\n    def set_sync_manager(cls, manager: \"SessionManagerPort\") -&gt; None:\n        \"\"\"Set a custom synchronous session manager.\n\n        Args:\n            manager: An instance implementing SessionManagerPort\n\n        Raises:\n            InvalidArgumentError: If the manager is None or doesn't implement SessionManagerPort\n        \"\"\"\n        if manager is None:\n            raise InvalidArgumentError(\"Session manager cannot be None\")\n        from archipy.adapters.base.sqlalchemy.session_manager_ports import SessionManagerPort\n\n        if not isinstance(manager, SessionManagerPort):\n            raise InvalidArgumentError(f\"Manager must implement SessionManagerPort, got {type(manager).__name__}\")\n        cls._sync_instance = manager\n\n    @classmethod\n    def get_async_manager(cls) -&gt; \"AsyncSessionManagerPort\":\n        \"\"\"Get the asynchronous session manager instance.\n\n        Returns:\n            AsyncSessionManagerPort: The registered asynchronous session manager\n\n        Raises:\n            InternalError: If no asynchronous session manager is set\n            DatabaseConnectionError: If there's an error initializing the session manager\n        \"\"\"\n        if cls._async_instance is None:\n            raise InternalError(\"Asynchronous session manager not initialized\")\n        return cls._async_instance\n\n    @classmethod\n    def set_async_manager(cls, manager: \"AsyncSessionManagerPort\") -&gt; None:\n        \"\"\"Set a custom asynchronous session manager.\n\n        Args:\n            manager: An instance implementing AsyncSessionManagerPort\n\n        Raises:\n            InvalidArgumentError: If the manager is None or doesn't implement AsyncSessionManagerPort\n        \"\"\"\n        if manager is None:\n            raise InvalidArgumentError(\"Session manager cannot be None\")\n        from archipy.adapters.base.sqlalchemy.session_manager_ports import AsyncSessionManagerPort\n\n        if not isinstance(manager, AsyncSessionManagerPort):\n            raise InvalidArgumentError(f\"Manager must implement AsyncSessionManagerPort, got {type(manager).__name__}\")\n        cls._async_instance = manager\n\n    @classmethod\n    def reset(cls) -&gt; None:\n        \"\"\"Reset the registry to its initial state.\n\n        This method clears both registered managers, useful for testing.\n        \"\"\"\n        cls._sync_instance = None\n        cls._async_instance = None\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry.get_sync_manager","title":"<code>archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry.get_sync_manager()</code>  <code>classmethod</code>","text":"<p>Get the synchronous session manager instance.</p> <p>Returns:</p> Name Type Description <code>SessionManagerPort</code> <code>SessionManagerPort</code> <p>The registered synchronous session manager</p> <p>Raises:</p> Type Description <code>InternalError</code> <p>If no synchronous session manager is set</p> <code>DatabaseConnectionError</code> <p>If there's an error initializing the session manager</p> Source code in <code>archipy/adapters/base/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef get_sync_manager(cls) -&gt; \"SessionManagerPort\":\n    \"\"\"Get the synchronous session manager instance.\n\n    Returns:\n        SessionManagerPort: The registered synchronous session manager\n\n    Raises:\n        InternalError: If no synchronous session manager is set\n        DatabaseConnectionError: If there's an error initializing the session manager\n    \"\"\"\n    if cls._sync_instance is None:\n        raise InternalError(\"Synchronous session manager not initialized\")\n    return cls._sync_instance\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry.set_sync_manager","title":"<code>archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry.set_sync_manager(manager)</code>  <code>classmethod</code>","text":"<p>Set a custom synchronous session manager.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>SessionManagerPort</code> <p>An instance implementing SessionManagerPort</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the manager is None or doesn't implement SessionManagerPort</p> Source code in <code>archipy/adapters/base/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef set_sync_manager(cls, manager: \"SessionManagerPort\") -&gt; None:\n    \"\"\"Set a custom synchronous session manager.\n\n    Args:\n        manager: An instance implementing SessionManagerPort\n\n    Raises:\n        InvalidArgumentError: If the manager is None or doesn't implement SessionManagerPort\n    \"\"\"\n    if manager is None:\n        raise InvalidArgumentError(\"Session manager cannot be None\")\n    from archipy.adapters.base.sqlalchemy.session_manager_ports import SessionManagerPort\n\n    if not isinstance(manager, SessionManagerPort):\n        raise InvalidArgumentError(f\"Manager must implement SessionManagerPort, got {type(manager).__name__}\")\n    cls._sync_instance = manager\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry.get_async_manager","title":"<code>archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry.get_async_manager()</code>  <code>classmethod</code>","text":"<p>Get the asynchronous session manager instance.</p> <p>Returns:</p> Name Type Description <code>AsyncSessionManagerPort</code> <code>AsyncSessionManagerPort</code> <p>The registered asynchronous session manager</p> <p>Raises:</p> Type Description <code>InternalError</code> <p>If no asynchronous session manager is set</p> <code>DatabaseConnectionError</code> <p>If there's an error initializing the session manager</p> Source code in <code>archipy/adapters/base/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef get_async_manager(cls) -&gt; \"AsyncSessionManagerPort\":\n    \"\"\"Get the asynchronous session manager instance.\n\n    Returns:\n        AsyncSessionManagerPort: The registered asynchronous session manager\n\n    Raises:\n        InternalError: If no asynchronous session manager is set\n        DatabaseConnectionError: If there's an error initializing the session manager\n    \"\"\"\n    if cls._async_instance is None:\n        raise InternalError(\"Asynchronous session manager not initialized\")\n    return cls._async_instance\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry.set_async_manager","title":"<code>archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry.set_async_manager(manager)</code>  <code>classmethod</code>","text":"<p>Set a custom asynchronous session manager.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>AsyncSessionManagerPort</code> <p>An instance implementing AsyncSessionManagerPort</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the manager is None or doesn't implement AsyncSessionManagerPort</p> Source code in <code>archipy/adapters/base/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef set_async_manager(cls, manager: \"AsyncSessionManagerPort\") -&gt; None:\n    \"\"\"Set a custom asynchronous session manager.\n\n    Args:\n        manager: An instance implementing AsyncSessionManagerPort\n\n    Raises:\n        InvalidArgumentError: If the manager is None or doesn't implement AsyncSessionManagerPort\n    \"\"\"\n    if manager is None:\n        raise InvalidArgumentError(\"Session manager cannot be None\")\n    from archipy.adapters.base.sqlalchemy.session_manager_ports import AsyncSessionManagerPort\n\n    if not isinstance(manager, AsyncSessionManagerPort):\n        raise InvalidArgumentError(f\"Manager must implement AsyncSessionManagerPort, got {type(manager).__name__}\")\n    cls._async_instance = manager\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry.reset","title":"<code>archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry.reset()</code>  <code>classmethod</code>","text":"<p>Reset the registry to its initial state.</p> <p>This method clears both registered managers, useful for testing.</p> Source code in <code>archipy/adapters/base/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef reset(cls) -&gt; None:\n    \"\"\"Reset the registry to its initial state.\n\n    This method clears both registered managers, useful for testing.\n    \"\"\"\n    cls._sync_instance = None\n    cls._async_instance = None\n</code></pre>"},{"location":"api_reference/adapters/#postgresql","title":"PostgreSQL","text":"<p>PostgreSQL database adapter with SQLAlchemy integration.</p> <pre><code>from archipy.adapters.postgres.sqlalchemy.adapters import PostgresSQLAlchemyAdapter, AsyncPostgresSQLAlchemyAdapter\n\n# Create an ORM adapter (uses global config)\norm_adapter = PostgresSQLAlchemyAdapter()\n\n# Use the adapter\nusers = orm_adapter.query(User).filter(User.active == True).all()\n</code></pre> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.adapters.PostgresSQLAlchemyAdapter","title":"<code>archipy.adapters.postgres.sqlalchemy.adapters.PostgresSQLAlchemyAdapter</code>","text":"<p>               Bases: <code>BaseSQLAlchemyAdapter[PostgresSQLAlchemyConfig]</code></p> <p>Synchronous SQLAlchemy adapter for PostgreSQL.</p> <p>Inherits from BaseSQLAlchemyAdapter to provide PostgreSQL-specific session management and database operations.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>PostgresSQLAlchemyConfig | None</code> <p>PostgreSQL-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/postgres/sqlalchemy/adapters.py</code> <pre><code>class PostgresSQLAlchemyAdapter(BaseSQLAlchemyAdapter[PostgresSQLAlchemyConfig]):\n    \"\"\"Synchronous SQLAlchemy adapter for PostgreSQL.\n\n    Inherits from BaseSQLAlchemyAdapter to provide PostgreSQL-specific session management\n    and database operations.\n\n    Args:\n        orm_config: PostgreSQL-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: PostgresSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the PostgreSQL adapter with a session manager.\n\n        Args:\n            orm_config: PostgreSQL-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().POSTGRES_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _create_session_manager(self, configs: PostgresSQLAlchemyConfig) -&gt; PostgresSQlAlchemySessionManager:\n        \"\"\"Create a PostgreSQL-specific session manager.\n\n        Args:\n            configs: PostgreSQL configuration.\n\n        Returns:\n            A PostgreSQL session manager instance.\n        \"\"\"\n        return PostgresSQlAlchemySessionManager(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.adapters.PostgresSQLAlchemyAdapter.__init__","title":"<code>archipy.adapters.postgres.sqlalchemy.adapters.PostgresSQLAlchemyAdapter.__init__(orm_config=None)</code>","text":"<p>Initialize the PostgreSQL adapter with a session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>PostgresSQLAlchemyConfig | None</code> <p>PostgreSQL-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/postgres/sqlalchemy/adapters.py</code> <pre><code>def __init__(self, orm_config: PostgresSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the PostgreSQL adapter with a session manager.\n\n    Args:\n        orm_config: PostgreSQL-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().POSTGRES_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.adapters.AsyncPostgresSQLAlchemyAdapter","title":"<code>archipy.adapters.postgres.sqlalchemy.adapters.AsyncPostgresSQLAlchemyAdapter</code>","text":"<p>               Bases: <code>AsyncBaseSQLAlchemyAdapter[PostgresSQLAlchemyConfig]</code></p> <p>Asynchronous SQLAlchemy adapter for PostgreSQL.</p> <p>Inherits from AsyncBaseSQLAlchemyAdapter to provide async PostgreSQL-specific session management and database operations.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>PostgresSQLAlchemyConfig | None</code> <p>PostgreSQL-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/postgres/sqlalchemy/adapters.py</code> <pre><code>class AsyncPostgresSQLAlchemyAdapter(AsyncBaseSQLAlchemyAdapter[PostgresSQLAlchemyConfig]):\n    \"\"\"Asynchronous SQLAlchemy adapter for PostgreSQL.\n\n    Inherits from AsyncBaseSQLAlchemyAdapter to provide async PostgreSQL-specific session\n    management and database operations.\n\n    Args:\n        orm_config: PostgreSQL-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: PostgresSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the async PostgreSQL adapter with a session manager.\n\n        Args:\n            orm_config: PostgreSQL-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().POSTGRES_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _create_async_session_manager(self, configs: PostgresSQLAlchemyConfig) -&gt; AsyncPostgresSQlAlchemySessionManager:\n        \"\"\"Create an async PostgreSQL-specific session manager.\n\n        Args:\n            configs: PostgreSQL configuration.\n\n        Returns:\n            An async PostgreSQL session manager instance.\n        \"\"\"\n        return AsyncPostgresSQlAlchemySessionManager(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.adapters.AsyncPostgresSQLAlchemyAdapter.__init__","title":"<code>archipy.adapters.postgres.sqlalchemy.adapters.AsyncPostgresSQLAlchemyAdapter.__init__(orm_config=None)</code>","text":"<p>Initialize the async PostgreSQL adapter with a session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>PostgresSQLAlchemyConfig | None</code> <p>PostgreSQL-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/postgres/sqlalchemy/adapters.py</code> <pre><code>def __init__(self, orm_config: PostgresSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the async PostgreSQL adapter with a session manager.\n\n    Args:\n        orm_config: PostgreSQL-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().POSTGRES_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.session_managers.PostgresSQlAlchemySessionManager","title":"<code>archipy.adapters.postgres.sqlalchemy.session_managers.PostgresSQlAlchemySessionManager</code>","text":"<p>               Bases: <code>BaseSQLAlchemySessionManager[PostgresSQLAlchemyConfig]</code></p> <p>Synchronous SQLAlchemy session manager for PostgreSQL.</p> <p>Inherits from BaseSQLAlchemySessionManager to provide PostgreSQL-specific session management, including connection URL creation and engine configuration.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>PostgresSQLAlchemyConfig | None</code> <p>PostgreSQL-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/postgres/sqlalchemy/session_managers.py</code> <pre><code>class PostgresSQlAlchemySessionManager(BaseSQLAlchemySessionManager[PostgresSQLAlchemyConfig], metaclass=Singleton):\n    \"\"\"Synchronous SQLAlchemy session manager for PostgreSQL.\n\n    Inherits from BaseSQLAlchemySessionManager to provide PostgreSQL-specific session\n    management, including connection URL creation and engine configuration.\n\n    Args:\n        orm_config: PostgreSQL-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: PostgresSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the PostgreSQL session manager.\n\n        Args:\n            orm_config: PostgreSQL-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().POSTGRES_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _expected_config_type(self) -&gt; type[PostgresSQLAlchemyConfig]:\n        \"\"\"Return the expected configuration type for PostgreSQL.\n\n        Returns:\n            The PostgresSQLAlchemyConfig class.\n        \"\"\"\n        return PostgresSQLAlchemyConfig\n\n    @override\n    def _get_database_name(self) -&gt; str:\n        \"\"\"Return the name of the database being used.\n\n        Returns:\n            str: The name of the database ('postgresql').\n        \"\"\"\n        return \"postgresql\"\n\n    @override\n    def _create_url(self, configs: PostgresSQLAlchemyConfig) -&gt; URL:\n        \"\"\"Create a PostgreSQL connection URL.\n\n        Args:\n            configs: PostgreSQL configuration.\n\n        Returns:\n            A SQLAlchemy URL object for PostgreSQL.\n\n        Raises:\n            DatabaseConnectionError: If there's an error creating the URL.\n        \"\"\"\n        try:\n            return URL.create(\n                drivername=configs.DRIVER_NAME,\n                username=configs.USERNAME,\n                password=configs.PASSWORD,\n                host=configs.HOST,\n                port=configs.PORT,\n                database=configs.DATABASE,\n            )\n        except SQLAlchemyError as e:\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.session_managers.PostgresSQlAlchemySessionManager.__init__","title":"<code>archipy.adapters.postgres.sqlalchemy.session_managers.PostgresSQlAlchemySessionManager.__init__(orm_config=None)</code>","text":"<p>Initialize the PostgreSQL session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>PostgresSQLAlchemyConfig | None</code> <p>PostgreSQL-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/postgres/sqlalchemy/session_managers.py</code> <pre><code>def __init__(self, orm_config: PostgresSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the PostgreSQL session manager.\n\n    Args:\n        orm_config: PostgreSQL-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().POSTGRES_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.session_managers.AsyncPostgresSQlAlchemySessionManager","title":"<code>archipy.adapters.postgres.sqlalchemy.session_managers.AsyncPostgresSQlAlchemySessionManager</code>","text":"<p>               Bases: <code>AsyncBaseSQLAlchemySessionManager[PostgresSQLAlchemyConfig]</code></p> <p>Asynchronous SQLAlchemy session manager for PostgreSQL.</p> <p>Inherits from AsyncBaseSQLAlchemySessionManager to provide async PostgreSQL-specific session management, including connection URL creation and async engine configuration.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>PostgresSQLAlchemyConfig | None</code> <p>PostgreSQL-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/postgres/sqlalchemy/session_managers.py</code> <pre><code>class AsyncPostgresSQlAlchemySessionManager(\n    AsyncBaseSQLAlchemySessionManager[PostgresSQLAlchemyConfig],\n    metaclass=Singleton,\n):\n    \"\"\"Asynchronous SQLAlchemy session manager for PostgreSQL.\n\n    Inherits from AsyncBaseSQLAlchemySessionManager to provide async PostgreSQL-specific\n    session management, including connection URL creation and async engine configuration.\n\n    Args:\n        orm_config: PostgreSQL-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: PostgresSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the async PostgreSQL session manager.\n\n        Args:\n            orm_config: PostgreSQL-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().POSTGRES_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _expected_config_type(self) -&gt; type[PostgresSQLAlchemyConfig]:\n        \"\"\"Return the expected configuration type for PostgreSQL.\n\n        Returns:\n            The PostgresSQLAlchemyConfig class.\n        \"\"\"\n        return PostgresSQLAlchemyConfig\n\n    @override\n    def _get_database_name(self) -&gt; str:\n        \"\"\"Return the name of the database being used.\n\n        Returns:\n            str: The name of the database ('postgresql').\n        \"\"\"\n        return \"postgresql\"\n\n    @override\n    def _create_url(self, configs: PostgresSQLAlchemyConfig) -&gt; URL:\n        \"\"\"Create an async PostgreSQL connection URL.\n\n        Args:\n            configs: PostgreSQL configuration.\n\n        Returns:\n            A SQLAlchemy URL object for PostgreSQL.\n\n        Raises:\n            DatabaseConnectionError: If there's an error creating the URL.\n        \"\"\"\n        try:\n            return URL.create(\n                drivername=configs.DRIVER_NAME,\n                username=configs.USERNAME,\n                password=configs.PASSWORD,\n                host=configs.HOST,\n                port=configs.PORT,\n                database=configs.DATABASE,\n            )\n        except SQLAlchemyError as e:\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.session_managers.AsyncPostgresSQlAlchemySessionManager.__init__","title":"<code>archipy.adapters.postgres.sqlalchemy.session_managers.AsyncPostgresSQlAlchemySessionManager.__init__(orm_config=None)</code>","text":"<p>Initialize the async PostgreSQL session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>PostgresSQLAlchemyConfig | None</code> <p>PostgreSQL-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/postgres/sqlalchemy/session_managers.py</code> <pre><code>def __init__(self, orm_config: PostgresSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the async PostgreSQL session manager.\n\n    Args:\n        orm_config: PostgreSQL-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().POSTGRES_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry","title":"<code>archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry</code>","text":"<p>               Bases: <code>SessionManagerRegistry</code></p> <p>Registry for PostgreSQL SQLAlchemy session managers.</p> <p>This registry provides a centralized access point for both synchronous and asynchronous PostgreSQL session managers, implementing the Service Locator pattern. It lazily initializes the appropriate session manager when first requested.</p> <p>The registry maintains singleton instances of: - A synchronous session manager (PostgresSQlAlchemySessionManager) - An asynchronous session manager (AsyncPostgresSQlAlchemySessionManager)</p> Source code in <code>archipy/adapters/postgres/sqlalchemy/session_manager_registry.py</code> <pre><code>class PostgresSessionManagerRegistry(SessionManagerRegistry, metaclass=Singleton):\n    \"\"\"Registry for PostgreSQL SQLAlchemy session managers.\n\n    This registry provides a centralized access point for both synchronous and\n    asynchronous PostgreSQL session managers, implementing the Service Locator pattern.\n    It lazily initializes the appropriate session manager when first requested.\n\n    The registry maintains singleton instances of:\n    - A synchronous session manager (PostgresSQlAlchemySessionManager)\n    - An asynchronous session manager (AsyncPostgresSQlAlchemySessionManager)\n    \"\"\"\n\n    @classmethod\n    def get_sync_manager(cls) -&gt; \"SessionManagerPort\":\n        \"\"\"Get the synchronous PostgreSQL session manager instance.\n\n        Lazily initializes a default PostgresSQlAlchemySessionManager if none has been set.\n\n        Returns:\n            SessionManagerPort: The registered synchronous session manager\n\n        Raises:\n            DatabaseConnectionError: If there's an error initializing the session manager\n        \"\"\"\n        if cls._sync_instance is None:\n            try:\n                from archipy.adapters.postgres.sqlalchemy.session_managers import PostgresSQlAlchemySessionManager\n\n                cls._sync_instance = PostgresSQlAlchemySessionManager()\n            except Exception as e:\n                raise DatabaseConnectionError(\n                    database=\"postgresql\",\n                ) from e\n        return cls._sync_instance\n\n    @classmethod\n    def set_sync_manager(cls, manager: \"SessionManagerPort\") -&gt; None:\n        \"\"\"Set a custom synchronous session manager.\n\n        Args:\n            manager: An instance implementing SessionManagerPort\n\n        Raises:\n            InvalidArgumentError: If the manager is None or doesn't implement SessionManagerPort\n        \"\"\"\n        if manager is None:\n            raise InvalidArgumentError(\"PostgreSQL session manager cannot be None\")\n        from archipy.adapters.base.sqlalchemy.session_manager_ports import SessionManagerPort\n\n        if not isinstance(manager, SessionManagerPort):\n            raise InvalidArgumentError(f\"Manager must implement SessionManagerPort, got {type(manager).__name__}\")\n        cls._sync_instance = manager\n\n    @classmethod\n    def get_async_manager(cls) -&gt; \"AsyncSessionManagerPort\":\n        \"\"\"Get the asynchronous PostgreSQL session manager instance.\n\n        Lazily initializes a default AsyncPostgresSQlAlchemySessionManager if none has been set.\n\n        Returns:\n            AsyncSessionManagerPort: The registered asynchronous session manager\n\n        Raises:\n            DatabaseConnectionError: If there's an error initializing the session manager\n        \"\"\"\n        if cls._async_instance is None:\n            try:\n                from archipy.adapters.postgres.sqlalchemy.session_managers import AsyncPostgresSQlAlchemySessionManager\n\n                cls._async_instance = AsyncPostgresSQlAlchemySessionManager()\n            except Exception as e:\n                raise DatabaseConnectionError(\n                    database=\"postgresql\",\n                ) from e\n        return cls._async_instance\n\n    @classmethod\n    def set_async_manager(cls, manager: \"AsyncSessionManagerPort\") -&gt; None:\n        \"\"\"Set a custom asynchronous session manager.\n\n        Args:\n            manager: An instance implementing AsyncSessionManagerPort\n\n        Raises:\n            InvalidArgumentError: If the manager is None or doesn't implement AsyncSessionManagerPort\n        \"\"\"\n        if manager is None:\n            raise InvalidArgumentError(\"PostgreSQL async session manager cannot be None\")\n        from archipy.adapters.base.sqlalchemy.session_manager_ports import AsyncSessionManagerPort\n\n        if not isinstance(manager, AsyncSessionManagerPort):\n            raise InvalidArgumentError(f\"Manager must implement AsyncSessionManagerPort, got {type(manager).__name__}\")\n        cls._async_instance = manager\n\n    @classmethod\n    def reset(cls) -&gt; None:\n        \"\"\"Reset the registry to its initial state.\n\n        This method clears both registered managers, useful for testing.\n        \"\"\"\n        cls._sync_instance = None\n        cls._async_instance = None\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry.get_sync_manager","title":"<code>archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry.get_sync_manager()</code>  <code>classmethod</code>","text":"<p>Get the synchronous PostgreSQL session manager instance.</p> <p>Lazily initializes a default PostgresSQlAlchemySessionManager if none has been set.</p> <p>Returns:</p> Name Type Description <code>SessionManagerPort</code> <code>SessionManagerPort</code> <p>The registered synchronous session manager</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error initializing the session manager</p> Source code in <code>archipy/adapters/postgres/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef get_sync_manager(cls) -&gt; \"SessionManagerPort\":\n    \"\"\"Get the synchronous PostgreSQL session manager instance.\n\n    Lazily initializes a default PostgresSQlAlchemySessionManager if none has been set.\n\n    Returns:\n        SessionManagerPort: The registered synchronous session manager\n\n    Raises:\n        DatabaseConnectionError: If there's an error initializing the session manager\n    \"\"\"\n    if cls._sync_instance is None:\n        try:\n            from archipy.adapters.postgres.sqlalchemy.session_managers import PostgresSQlAlchemySessionManager\n\n            cls._sync_instance = PostgresSQlAlchemySessionManager()\n        except Exception as e:\n            raise DatabaseConnectionError(\n                database=\"postgresql\",\n            ) from e\n    return cls._sync_instance\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry.set_sync_manager","title":"<code>archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry.set_sync_manager(manager)</code>  <code>classmethod</code>","text":"<p>Set a custom synchronous session manager.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>SessionManagerPort</code> <p>An instance implementing SessionManagerPort</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the manager is None or doesn't implement SessionManagerPort</p> Source code in <code>archipy/adapters/postgres/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef set_sync_manager(cls, manager: \"SessionManagerPort\") -&gt; None:\n    \"\"\"Set a custom synchronous session manager.\n\n    Args:\n        manager: An instance implementing SessionManagerPort\n\n    Raises:\n        InvalidArgumentError: If the manager is None or doesn't implement SessionManagerPort\n    \"\"\"\n    if manager is None:\n        raise InvalidArgumentError(\"PostgreSQL session manager cannot be None\")\n    from archipy.adapters.base.sqlalchemy.session_manager_ports import SessionManagerPort\n\n    if not isinstance(manager, SessionManagerPort):\n        raise InvalidArgumentError(f\"Manager must implement SessionManagerPort, got {type(manager).__name__}\")\n    cls._sync_instance = manager\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry.get_async_manager","title":"<code>archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry.get_async_manager()</code>  <code>classmethod</code>","text":"<p>Get the asynchronous PostgreSQL session manager instance.</p> <p>Lazily initializes a default AsyncPostgresSQlAlchemySessionManager if none has been set.</p> <p>Returns:</p> Name Type Description <code>AsyncSessionManagerPort</code> <code>AsyncSessionManagerPort</code> <p>The registered asynchronous session manager</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error initializing the session manager</p> Source code in <code>archipy/adapters/postgres/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef get_async_manager(cls) -&gt; \"AsyncSessionManagerPort\":\n    \"\"\"Get the asynchronous PostgreSQL session manager instance.\n\n    Lazily initializes a default AsyncPostgresSQlAlchemySessionManager if none has been set.\n\n    Returns:\n        AsyncSessionManagerPort: The registered asynchronous session manager\n\n    Raises:\n        DatabaseConnectionError: If there's an error initializing the session manager\n    \"\"\"\n    if cls._async_instance is None:\n        try:\n            from archipy.adapters.postgres.sqlalchemy.session_managers import AsyncPostgresSQlAlchemySessionManager\n\n            cls._async_instance = AsyncPostgresSQlAlchemySessionManager()\n        except Exception as e:\n            raise DatabaseConnectionError(\n                database=\"postgresql\",\n            ) from e\n    return cls._async_instance\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry.set_async_manager","title":"<code>archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry.set_async_manager(manager)</code>  <code>classmethod</code>","text":"<p>Set a custom asynchronous session manager.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>AsyncSessionManagerPort</code> <p>An instance implementing AsyncSessionManagerPort</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the manager is None or doesn't implement AsyncSessionManagerPort</p> Source code in <code>archipy/adapters/postgres/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef set_async_manager(cls, manager: \"AsyncSessionManagerPort\") -&gt; None:\n    \"\"\"Set a custom asynchronous session manager.\n\n    Args:\n        manager: An instance implementing AsyncSessionManagerPort\n\n    Raises:\n        InvalidArgumentError: If the manager is None or doesn't implement AsyncSessionManagerPort\n    \"\"\"\n    if manager is None:\n        raise InvalidArgumentError(\"PostgreSQL async session manager cannot be None\")\n    from archipy.adapters.base.sqlalchemy.session_manager_ports import AsyncSessionManagerPort\n\n    if not isinstance(manager, AsyncSessionManagerPort):\n        raise InvalidArgumentError(f\"Manager must implement AsyncSessionManagerPort, got {type(manager).__name__}\")\n    cls._async_instance = manager\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry.reset","title":"<code>archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry.reset()</code>  <code>classmethod</code>","text":"<p>Reset the registry to its initial state.</p> <p>This method clears both registered managers, useful for testing.</p> Source code in <code>archipy/adapters/postgres/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef reset(cls) -&gt; None:\n    \"\"\"Reset the registry to its initial state.\n\n    This method clears both registered managers, useful for testing.\n    \"\"\"\n    cls._sync_instance = None\n    cls._async_instance = None\n</code></pre>"},{"location":"api_reference/adapters/#sqlite","title":"SQLite","text":"<p>SQLite database adapter with SQLAlchemy integration.</p> <pre><code>from archipy.adapters.sqlite.sqlalchemy.adapters import SQLiteSQLAlchemyAdapter, AsyncSQLiteSQLAlchemyAdapter\n\n# Create an ORM adapter (uses global config)\norm_adapter = SQLiteSQLAlchemyAdapter()\n</code></pre> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.adapters.SQLiteSQLAlchemyAdapter","title":"<code>archipy.adapters.sqlite.sqlalchemy.adapters.SQLiteSQLAlchemyAdapter</code>","text":"<p>               Bases: <code>BaseSQLAlchemyAdapter[SQLiteSQLAlchemyConfig]</code></p> <p>Synchronous SQLAlchemy adapter for SQLite.</p> <p>Inherits from BaseSQLAlchemyAdapter to provide SQLite-specific session management and database operations, typically used for in-memory testing.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLiteSQLAlchemyConfig | None</code> <p>SQLite-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/sqlite/sqlalchemy/adapters.py</code> <pre><code>class SQLiteSQLAlchemyAdapter(BaseSQLAlchemyAdapter[SQLiteSQLAlchemyConfig]):\n    \"\"\"Synchronous SQLAlchemy adapter for SQLite.\n\n    Inherits from BaseSQLAlchemyAdapter to provide SQLite-specific session management\n    and database operations, typically used for in-memory testing.\n\n    Args:\n        orm_config: SQLite-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: SQLiteSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the SQLite adapter with a session manager.\n\n        Args:\n            orm_config: SQLite-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().SQLITE_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _create_session_manager(self, configs: SQLiteSQLAlchemyConfig) -&gt; SQLiteSQLAlchemySessionManager:\n        \"\"\"Create a SQLite-specific session manager.\n\n        Args:\n            configs: SQLite configuration.\n\n        Returns:\n            A SQLite session manager instance.\n        \"\"\"\n        return SQLiteSQLAlchemySessionManager(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.adapters.SQLiteSQLAlchemyAdapter.__init__","title":"<code>archipy.adapters.sqlite.sqlalchemy.adapters.SQLiteSQLAlchemyAdapter.__init__(orm_config=None)</code>","text":"<p>Initialize the SQLite adapter with a session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLiteSQLAlchemyConfig | None</code> <p>SQLite-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/sqlite/sqlalchemy/adapters.py</code> <pre><code>def __init__(self, orm_config: SQLiteSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the SQLite adapter with a session manager.\n\n    Args:\n        orm_config: SQLite-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().SQLITE_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.adapters.AsyncSQLiteSQLAlchemyAdapter","title":"<code>archipy.adapters.sqlite.sqlalchemy.adapters.AsyncSQLiteSQLAlchemyAdapter</code>","text":"<p>               Bases: <code>AsyncBaseSQLAlchemyAdapter[SQLiteSQLAlchemyConfig]</code></p> <p>Asynchronous SQLAlchemy adapter for SQLite.</p> <p>Inherits from AsyncBaseSQLAlchemyAdapter to provide async SQLite-specific session management and database operations, typically used for in-memory testing.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLiteSQLAlchemyConfig | None</code> <p>SQLite-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/sqlite/sqlalchemy/adapters.py</code> <pre><code>class AsyncSQLiteSQLAlchemyAdapter(AsyncBaseSQLAlchemyAdapter[SQLiteSQLAlchemyConfig]):\n    \"\"\"Asynchronous SQLAlchemy adapter for SQLite.\n\n    Inherits from AsyncBaseSQLAlchemyAdapter to provide async SQLite-specific session\n    management and database operations, typically used for in-memory testing.\n\n    Args:\n        orm_config: SQLite-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: SQLiteSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the async SQLite adapter with a session manager.\n\n        Args:\n            orm_config: SQLite-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().SQLITE_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _create_async_session_manager(self, configs: SQLiteSQLAlchemyConfig) -&gt; AsyncSQLiteSQLAlchemySessionManager:\n        \"\"\"Create an async SQLite-specific session manager.\n\n        Args:\n            configs: SQLite configuration.\n\n        Returns:\n            An async SQLite session manager instance.\n        \"\"\"\n        return AsyncSQLiteSQLAlchemySessionManager(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.adapters.AsyncSQLiteSQLAlchemyAdapter.__init__","title":"<code>archipy.adapters.sqlite.sqlalchemy.adapters.AsyncSQLiteSQLAlchemyAdapter.__init__(orm_config=None)</code>","text":"<p>Initialize the async SQLite adapter with a session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLiteSQLAlchemyConfig | None</code> <p>SQLite-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/sqlite/sqlalchemy/adapters.py</code> <pre><code>def __init__(self, orm_config: SQLiteSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the async SQLite adapter with a session manager.\n\n    Args:\n        orm_config: SQLite-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().SQLITE_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.session_managers.SQLiteSQLAlchemySessionManager","title":"<code>archipy.adapters.sqlite.sqlalchemy.session_managers.SQLiteSQLAlchemySessionManager</code>","text":"<p>               Bases: <code>BaseSQLAlchemySessionManager[SQLiteSQLAlchemyConfig]</code></p> <p>Synchronous SQLAlchemy session manager for SQLite.</p> <p>Inherits from BaseSQLAlchemySessionManager to provide SQLite-specific session management, including connection URL creation and engine configuration.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLiteSQLAlchemyConfig | None</code> <p>SQLite-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/sqlite/sqlalchemy/session_managers.py</code> <pre><code>class SQLiteSQLAlchemySessionManager(BaseSQLAlchemySessionManager[SQLiteSQLAlchemyConfig], metaclass=Singleton):\n    \"\"\"Synchronous SQLAlchemy session manager for SQLite.\n\n    Inherits from BaseSQLAlchemySessionManager to provide SQLite-specific session\n    management, including connection URL creation and engine configuration.\n\n    Args:\n        orm_config: SQLite-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: SQLiteSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the SQLite session manager.\n\n        Args:\n            orm_config: SQLite-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().SQLITE_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _expected_config_type(self) -&gt; type[SQLiteSQLAlchemyConfig]:\n        \"\"\"Return the expected configuration type for SQLite.\n\n        Returns:\n            The SQLiteSQLAlchemyConfig class.\n        \"\"\"\n        return SQLiteSQLAlchemyConfig\n\n    @override\n    def _get_database_name(self) -&gt; str:\n        \"\"\"Return the name of the database being used.\n\n        Returns:\n            str: The name of the database ('sqlite').\n        \"\"\"\n        return \"sqlite\"\n\n    @override\n    def _create_url(self, configs: SQLiteSQLAlchemyConfig) -&gt; URL:\n        \"\"\"Create a SQLite connection URL.\n\n        Args:\n            configs: SQLite configuration.\n\n        Returns:\n            A SQLAlchemy URL object for SQLite.\n\n        Raises:\n            DatabaseConnectionError: If there's an error creating the URL.\n        \"\"\"\n        try:\n            return URL.create(\n                drivername=configs.DRIVER_NAME,\n                database=configs.DATABASE,\n            )\n        except SQLAlchemyError as e:\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.session_managers.SQLiteSQLAlchemySessionManager.__init__","title":"<code>archipy.adapters.sqlite.sqlalchemy.session_managers.SQLiteSQLAlchemySessionManager.__init__(orm_config=None)</code>","text":"<p>Initialize the SQLite session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLiteSQLAlchemyConfig | None</code> <p>SQLite-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/sqlite/sqlalchemy/session_managers.py</code> <pre><code>def __init__(self, orm_config: SQLiteSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the SQLite session manager.\n\n    Args:\n        orm_config: SQLite-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().SQLITE_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.session_managers.AsyncSQLiteSQLAlchemySessionManager","title":"<code>archipy.adapters.sqlite.sqlalchemy.session_managers.AsyncSQLiteSQLAlchemySessionManager</code>","text":"<p>               Bases: <code>AsyncBaseSQLAlchemySessionManager[SQLiteSQLAlchemyConfig]</code></p> <p>Asynchronous SQLAlchemy session manager for SQLite.</p> <p>Inherits from AsyncBaseSQLAlchemySessionManager to provide async SQLite-specific session management, including connection URL creation and async engine configuration.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLiteSQLAlchemyConfig | None</code> <p>SQLite-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/sqlite/sqlalchemy/session_managers.py</code> <pre><code>class AsyncSQLiteSQLAlchemySessionManager(\n    AsyncBaseSQLAlchemySessionManager[SQLiteSQLAlchemyConfig],\n    metaclass=Singleton,\n):\n    \"\"\"Asynchronous SQLAlchemy session manager for SQLite.\n\n    Inherits from AsyncBaseSQLAlchemySessionManager to provide async SQLite-specific\n    session management, including connection URL creation and async engine configuration.\n\n    Args:\n        orm_config: SQLite-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: SQLiteSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the async SQLite session manager.\n\n        Args:\n            orm_config: SQLite-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().SQLITE_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _expected_config_type(self) -&gt; type[SQLiteSQLAlchemyConfig]:\n        \"\"\"Return the expected configuration type for SQLite.\n\n        Returns:\n            The SQLiteSQLAlchemyConfig class.\n        \"\"\"\n        return SQLiteSQLAlchemyConfig\n\n    @override\n    def _get_database_name(self) -&gt; str:\n        \"\"\"Return the name of the database being used.\n\n        Returns:\n            str: The name of the database ('sqlite').\n        \"\"\"\n        return \"sqlite\"\n\n    @override\n    def _create_url(self, configs: SQLiteSQLAlchemyConfig) -&gt; URL:\n        \"\"\"Create an async SQLite connection URL.\n\n        Args:\n            configs: SQLite configuration.\n\n        Returns:\n            A SQLAlchemy URL object for SQLite.\n\n        Raises:\n            DatabaseConnectionError: If there's an error creating the URL.\n        \"\"\"\n        try:\n            return URL.create(\n                drivername=configs.DRIVER_NAME,\n                database=configs.DATABASE,\n            )\n        except SQLAlchemyError as e:\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.session_managers.AsyncSQLiteSQLAlchemySessionManager.__init__","title":"<code>archipy.adapters.sqlite.sqlalchemy.session_managers.AsyncSQLiteSQLAlchemySessionManager.__init__(orm_config=None)</code>","text":"<p>Initialize the async SQLite session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLiteSQLAlchemyConfig | None</code> <p>SQLite-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/sqlite/sqlalchemy/session_managers.py</code> <pre><code>def __init__(self, orm_config: SQLiteSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the async SQLite session manager.\n\n    Args:\n        orm_config: SQLite-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().SQLITE_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry","title":"<code>archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry</code>","text":"<p>               Bases: <code>SessionManagerRegistry</code></p> <p>Registry for SQLite SQLAlchemy session managers.</p> <p>This registry provides a centralized access point for both synchronous and asynchronous SQLite session managers, implementing the Service Locator pattern. It lazily initializes the appropriate session manager when first requested.</p> <p>The registry maintains singleton instances of: - A synchronous session manager (SQLiteSQLAlchemySessionManager) - An asynchronous session manager (AsyncSQLiteSQLAlchemySessionManager)</p> Source code in <code>archipy/adapters/sqlite/sqlalchemy/session_manager_registry.py</code> <pre><code>class SQLiteSessionManagerRegistry(SessionManagerRegistry, metaclass=Singleton):\n    \"\"\"Registry for SQLite SQLAlchemy session managers.\n\n    This registry provides a centralized access point for both synchronous and\n    asynchronous SQLite session managers, implementing the Service Locator pattern.\n    It lazily initializes the appropriate session manager when first requested.\n\n    The registry maintains singleton instances of:\n    - A synchronous session manager (SQLiteSQLAlchemySessionManager)\n    - An asynchronous session manager (AsyncSQLiteSQLAlchemySessionManager)\n    \"\"\"\n\n    @classmethod\n    def get_sync_manager(cls) -&gt; \"SessionManagerPort\":\n        \"\"\"Get the synchronous SQLite session manager instance.\n\n        Lazily initializes a default SQLiteSQLAlchemySessionManager if none has been set.\n\n        Returns:\n            SessionManagerPort: The registered synchronous session manager\n\n        Raises:\n            DatabaseConnectionError: If there's an error initializing the session manager\n        \"\"\"\n        if cls._sync_instance is None:\n            try:\n                from archipy.adapters.sqlite.sqlalchemy.session_managers import SQLiteSQLAlchemySessionManager\n\n                cls._sync_instance = SQLiteSQLAlchemySessionManager()\n            except Exception as e:\n                raise DatabaseConnectionError(\n                    database=\"sqlite\",\n                ) from e\n        return cls._sync_instance\n\n    @classmethod\n    def set_sync_manager(cls, manager: \"SessionManagerPort\") -&gt; None:\n        \"\"\"Register a synchronous session manager.\n\n        Args:\n            manager: The session manager to register\n        \"\"\"\n        cls._sync_instance = manager\n\n    @classmethod\n    def get_async_manager(cls) -&gt; \"AsyncSessionManagerPort\":\n        \"\"\"Get the asynchronous SQLite session manager instance.\n\n        Lazily initializes a default AsyncSQLiteSQLAlchemySessionManager if none has been set.\n\n        Returns:\n            AsyncSessionManagerPort: The registered asynchronous session manager\n\n        Raises:\n            DatabaseConnectionError: If there's an error initializing the session manager\n        \"\"\"\n        if cls._async_instance is None:\n            try:\n                from archipy.adapters.sqlite.sqlalchemy.session_managers import AsyncSQLiteSQLAlchemySessionManager\n\n                cls._async_instance = AsyncSQLiteSQLAlchemySessionManager()\n            except Exception as e:\n                raise DatabaseConnectionError(\n                    database=\"sqlite\",\n                ) from e\n        return cls._async_instance\n\n    @classmethod\n    def set_async_manager(cls, manager: \"AsyncSessionManagerPort\") -&gt; None:\n        \"\"\"Register an asynchronous session manager.\n\n        Args:\n            manager: The async session manager to register\n        \"\"\"\n        cls._async_instance = manager\n\n    @classmethod\n    def reset(cls) -&gt; None:\n        \"\"\"Reset the registry to its initial state.\n\n        This method clears both registered managers, useful for testing.\n        \"\"\"\n        cls._sync_instance = None\n        cls._async_instance = None\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry.get_sync_manager","title":"<code>archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry.get_sync_manager()</code>  <code>classmethod</code>","text":"<p>Get the synchronous SQLite session manager instance.</p> <p>Lazily initializes a default SQLiteSQLAlchemySessionManager if none has been set.</p> <p>Returns:</p> Name Type Description <code>SessionManagerPort</code> <code>SessionManagerPort</code> <p>The registered synchronous session manager</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error initializing the session manager</p> Source code in <code>archipy/adapters/sqlite/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef get_sync_manager(cls) -&gt; \"SessionManagerPort\":\n    \"\"\"Get the synchronous SQLite session manager instance.\n\n    Lazily initializes a default SQLiteSQLAlchemySessionManager if none has been set.\n\n    Returns:\n        SessionManagerPort: The registered synchronous session manager\n\n    Raises:\n        DatabaseConnectionError: If there's an error initializing the session manager\n    \"\"\"\n    if cls._sync_instance is None:\n        try:\n            from archipy.adapters.sqlite.sqlalchemy.session_managers import SQLiteSQLAlchemySessionManager\n\n            cls._sync_instance = SQLiteSQLAlchemySessionManager()\n        except Exception as e:\n            raise DatabaseConnectionError(\n                database=\"sqlite\",\n            ) from e\n    return cls._sync_instance\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry.set_sync_manager","title":"<code>archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry.set_sync_manager(manager)</code>  <code>classmethod</code>","text":"<p>Register a synchronous session manager.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>SessionManagerPort</code> <p>The session manager to register</p> required Source code in <code>archipy/adapters/sqlite/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef set_sync_manager(cls, manager: \"SessionManagerPort\") -&gt; None:\n    \"\"\"Register a synchronous session manager.\n\n    Args:\n        manager: The session manager to register\n    \"\"\"\n    cls._sync_instance = manager\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry.get_async_manager","title":"<code>archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry.get_async_manager()</code>  <code>classmethod</code>","text":"<p>Get the asynchronous SQLite session manager instance.</p> <p>Lazily initializes a default AsyncSQLiteSQLAlchemySessionManager if none has been set.</p> <p>Returns:</p> Name Type Description <code>AsyncSessionManagerPort</code> <code>AsyncSessionManagerPort</code> <p>The registered asynchronous session manager</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error initializing the session manager</p> Source code in <code>archipy/adapters/sqlite/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef get_async_manager(cls) -&gt; \"AsyncSessionManagerPort\":\n    \"\"\"Get the asynchronous SQLite session manager instance.\n\n    Lazily initializes a default AsyncSQLiteSQLAlchemySessionManager if none has been set.\n\n    Returns:\n        AsyncSessionManagerPort: The registered asynchronous session manager\n\n    Raises:\n        DatabaseConnectionError: If there's an error initializing the session manager\n    \"\"\"\n    if cls._async_instance is None:\n        try:\n            from archipy.adapters.sqlite.sqlalchemy.session_managers import AsyncSQLiteSQLAlchemySessionManager\n\n            cls._async_instance = AsyncSQLiteSQLAlchemySessionManager()\n        except Exception as e:\n            raise DatabaseConnectionError(\n                database=\"sqlite\",\n            ) from e\n    return cls._async_instance\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry.set_async_manager","title":"<code>archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry.set_async_manager(manager)</code>  <code>classmethod</code>","text":"<p>Register an asynchronous session manager.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>AsyncSessionManagerPort</code> <p>The async session manager to register</p> required Source code in <code>archipy/adapters/sqlite/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef set_async_manager(cls, manager: \"AsyncSessionManagerPort\") -&gt; None:\n    \"\"\"Register an asynchronous session manager.\n\n    Args:\n        manager: The async session manager to register\n    \"\"\"\n    cls._async_instance = manager\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry.reset","title":"<code>archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry.reset()</code>  <code>classmethod</code>","text":"<p>Reset the registry to its initial state.</p> <p>This method clears both registered managers, useful for testing.</p> Source code in <code>archipy/adapters/sqlite/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef reset(cls) -&gt; None:\n    \"\"\"Reset the registry to its initial state.\n\n    This method clears both registered managers, useful for testing.\n    \"\"\"\n    cls._sync_instance = None\n    cls._async_instance = None\n</code></pre>"},{"location":"api_reference/adapters/#starrocks","title":"StarRocks","text":"<p>StarRocks database adapter with SQLAlchemy integration.</p> <pre><code>from archipy.adapters.starrocks.sqlalchemy.adapters import StarrocksSQLAlchemyAdapter, AsyncStarrocksSQLAlchemyAdapter\n\n# Create an ORM adapter (uses global config)\norm_adapter = StarrocksSQLAlchemyAdapter()\n</code></pre> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.adapters.StarrocksSQLAlchemyAdapter","title":"<code>archipy.adapters.starrocks.sqlalchemy.adapters.StarrocksSQLAlchemyAdapter</code>","text":"<p>               Bases: <code>BaseSQLAlchemyAdapter[StarRocksSQLAlchemyConfig]</code></p> <p>Synchronous SQLAlchemy adapter for Starrocks.</p> <p>Inherits from BaseSQLAlchemyAdapter to provide Starrocks-specific session management and database operations.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>StarRocksSQLAlchemyConfig | None</code> <p>Starrocks-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/starrocks/sqlalchemy/adapters.py</code> <pre><code>class StarrocksSQLAlchemyAdapter(BaseSQLAlchemyAdapter[StarRocksSQLAlchemyConfig]):\n    \"\"\"Synchronous SQLAlchemy adapter for Starrocks.\n\n    Inherits from BaseSQLAlchemyAdapter to provide Starrocks-specific session management\n    and database operations.\n\n    Args:\n        orm_config: Starrocks-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: StarRocksSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the Starrocks adapter with a session manager.\n\n        Args:\n            orm_config: Starrocks-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().STARROCKS_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _create_session_manager(self, configs: StarRocksSQLAlchemyConfig) -&gt; StarRocksSQlAlchemySessionManager:\n        \"\"\"Create a Starrocks-specific session manager.\n\n        Args:\n            configs: Starrocks configuration.\n\n        Returns:\n            A Starrocks session manager instance.\n        \"\"\"\n        return StarRocksSQlAlchemySessionManager(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.adapters.StarrocksSQLAlchemyAdapter.__init__","title":"<code>archipy.adapters.starrocks.sqlalchemy.adapters.StarrocksSQLAlchemyAdapter.__init__(orm_config=None)</code>","text":"<p>Initialize the Starrocks adapter with a session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>StarRocksSQLAlchemyConfig | None</code> <p>Starrocks-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/starrocks/sqlalchemy/adapters.py</code> <pre><code>def __init__(self, orm_config: StarRocksSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the Starrocks adapter with a session manager.\n\n    Args:\n        orm_config: Starrocks-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().STARROCKS_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.adapters.AsyncStarrocksSQLAlchemyAdapter","title":"<code>archipy.adapters.starrocks.sqlalchemy.adapters.AsyncStarrocksSQLAlchemyAdapter</code>","text":"<p>               Bases: <code>AsyncBaseSQLAlchemyAdapter[StarRocksSQLAlchemyConfig]</code></p> <p>Asynchronous SQLAlchemy adapter for Starrocks.</p> <p>Inherits from AsyncBaseSQLAlchemyAdapter to provide async Starrocks-specific session management and database operations.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>StarRocksSQLAlchemyConfig | None</code> <p>Starrocks-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/starrocks/sqlalchemy/adapters.py</code> <pre><code>class AsyncStarrocksSQLAlchemyAdapter(AsyncBaseSQLAlchemyAdapter[StarRocksSQLAlchemyConfig]):\n    \"\"\"Asynchronous SQLAlchemy adapter for Starrocks.\n\n    Inherits from AsyncBaseSQLAlchemyAdapter to provide async Starrocks-specific session\n    management and database operations.\n\n    Args:\n        orm_config: Starrocks-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: StarRocksSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the async Starrocks adapter with a session manager.\n\n        Args:\n            orm_config: Starrocks-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().STARROCKS_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _create_async_session_manager(\n        self,\n        configs: StarRocksSQLAlchemyConfig,\n    ) -&gt; AsyncStarRocksSQlAlchemySessionManager:\n        \"\"\"Create an async Starrocks-specific session manager.\n\n        Args:\n            configs: Starrocks configuration.\n\n        Returns:\n            An async Starrocks session manager instance.\n        \"\"\"\n        return AsyncStarRocksSQlAlchemySessionManager(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.adapters.AsyncStarrocksSQLAlchemyAdapter.__init__","title":"<code>archipy.adapters.starrocks.sqlalchemy.adapters.AsyncStarrocksSQLAlchemyAdapter.__init__(orm_config=None)</code>","text":"<p>Initialize the async Starrocks adapter with a session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>StarRocksSQLAlchemyConfig | None</code> <p>Starrocks-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/starrocks/sqlalchemy/adapters.py</code> <pre><code>def __init__(self, orm_config: StarRocksSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the async Starrocks adapter with a session manager.\n\n    Args:\n        orm_config: Starrocks-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().STARROCKS_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.session_managers.StarRocksSQlAlchemySessionManager","title":"<code>archipy.adapters.starrocks.sqlalchemy.session_managers.StarRocksSQlAlchemySessionManager</code>","text":"<p>               Bases: <code>BaseSQLAlchemySessionManager[StarRocksSQLAlchemyConfig]</code></p> <p>Synchronous SQLAlchemy session manager for StarRocks.</p> <p>Inherits from BaseSQLAlchemySessionManager to provide StarRocks-specific session management, including connection URL creation and engine configuration.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>StarRocksSQLAlchemyConfig | None</code> <p>StarRocks-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/starrocks/sqlalchemy/session_managers.py</code> <pre><code>class StarRocksSQlAlchemySessionManager(BaseSQLAlchemySessionManager[StarRocksSQLAlchemyConfig], metaclass=Singleton):\n    \"\"\"Synchronous SQLAlchemy session manager for StarRocks.\n\n    Inherits from BaseSQLAlchemySessionManager to provide StarRocks-specific session\n    management, including connection URL creation and engine configuration.\n\n    Args:\n        orm_config: StarRocks-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: StarRocksSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the StarRocks session manager.\n\n        Args:\n            orm_config: StarRocks-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().STARROCKS_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _expected_config_type(self) -&gt; type[StarRocksSQLAlchemyConfig]:\n        \"\"\"Return the expected configuration type for StarRocks.\n\n        Returns:\n            The StarRocksSQLAlchemyConfig class.\n        \"\"\"\n        return StarRocksSQLAlchemyConfig\n\n    @override\n    def _get_database_name(self) -&gt; str:\n        \"\"\"Return the name of the database being used.\n\n        Returns:\n            str: The name of the database ('starrocks').\n        \"\"\"\n        return \"starrocks\"\n\n    @override\n    def _create_url(self, configs: StarRocksSQLAlchemyConfig) -&gt; URL:\n        \"\"\"Create a StarRocks connection URL.\n\n        Args:\n            configs: StarRocks configuration.\n\n        Returns:\n            A SQLAlchemy URL object for StarRocks.\n\n        Raises:\n            DatabaseConnectionError: If there's an error creating the URL.\n        \"\"\"\n        try:\n            return URL.create(\n                drivername=configs.DRIVER_NAME,\n                username=configs.USERNAME,\n                password=configs.PASSWORD,\n                host=configs.HOST,\n                port=configs.PORT,\n                database=configs.DATABASE,\n            )\n        except SQLAlchemyError as e:\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.session_managers.StarRocksSQlAlchemySessionManager.__init__","title":"<code>archipy.adapters.starrocks.sqlalchemy.session_managers.StarRocksSQlAlchemySessionManager.__init__(orm_config=None)</code>","text":"<p>Initialize the StarRocks session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>StarRocksSQLAlchemyConfig | None</code> <p>StarRocks-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/starrocks/sqlalchemy/session_managers.py</code> <pre><code>def __init__(self, orm_config: StarRocksSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the StarRocks session manager.\n\n    Args:\n        orm_config: StarRocks-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().STARROCKS_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.session_managers.AsyncStarRocksSQlAlchemySessionManager","title":"<code>archipy.adapters.starrocks.sqlalchemy.session_managers.AsyncStarRocksSQlAlchemySessionManager</code>","text":"<p>               Bases: <code>AsyncBaseSQLAlchemySessionManager[StarRocksSQLAlchemyConfig]</code></p> <p>Asynchronous SQLAlchemy session manager for StarRocks.</p> <p>Inherits from AsyncBaseSQLAlchemySessionManager to provide async StarRocks-specific session management, including connection URL creation and async engine configuration.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>StarRocksSQLAlchemyConfig | None</code> <p>StarRocks-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/starrocks/sqlalchemy/session_managers.py</code> <pre><code>class AsyncStarRocksSQlAlchemySessionManager(\n    AsyncBaseSQLAlchemySessionManager[StarRocksSQLAlchemyConfig],\n    metaclass=Singleton,\n):\n    \"\"\"Asynchronous SQLAlchemy session manager for StarRocks.\n\n    Inherits from AsyncBaseSQLAlchemySessionManager to provide async StarRocks-specific\n    session management, including connection URL creation and async engine configuration.\n\n    Args:\n        orm_config: StarRocks-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: StarRocksSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the async StarRocks session manager.\n\n        Args:\n            orm_config: StarRocks-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().STARROCKS_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _expected_config_type(self) -&gt; type[StarRocksSQLAlchemyConfig]:\n        \"\"\"Return the expected configuration type for StarRocks.\n\n        Returns:\n            The StarRocksSQLAlchemyConfig class.\n        \"\"\"\n        return StarRocksSQLAlchemyConfig\n\n    @override\n    def _get_database_name(self) -&gt; str:\n        \"\"\"Return the name of the database being used.\n\n        Returns:\n            str: The name of the database ('starrocks').\n        \"\"\"\n        return \"starrocks\"\n\n    @override\n    def _create_url(self, configs: StarRocksSQLAlchemyConfig) -&gt; URL:\n        \"\"\"Create an async StarRocks connection URL.\n\n        Args:\n            configs: StarRocks configuration.\n\n        Returns:\n            A SQLAlchemy URL object for StarRocks.\n\n        Raises:\n            DatabaseConnectionError: If there's an error creating the URL.\n        \"\"\"\n        try:\n            return URL.create(\n                drivername=configs.DRIVER_NAME,\n                username=configs.USERNAME,\n                password=configs.PASSWORD,\n                host=configs.HOST,\n                port=configs.PORT,\n                database=configs.DATABASE,\n            )\n        except SQLAlchemyError as e:\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.session_managers.AsyncStarRocksSQlAlchemySessionManager.__init__","title":"<code>archipy.adapters.starrocks.sqlalchemy.session_managers.AsyncStarRocksSQlAlchemySessionManager.__init__(orm_config=None)</code>","text":"<p>Initialize the async StarRocks session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>StarRocksSQLAlchemyConfig | None</code> <p>StarRocks-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/starrocks/sqlalchemy/session_managers.py</code> <pre><code>def __init__(self, orm_config: StarRocksSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the async StarRocks session manager.\n\n    Args:\n        orm_config: StarRocks-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().STARROCKS_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry","title":"<code>archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry</code>","text":"<p>               Bases: <code>SessionManagerRegistry</code></p> <p>Registry for StarRocks SQLAlchemy session managers.</p> <p>This registry provides a centralized access point for both synchronous and asynchronous StarRocks session managers, implementing the Service Locator pattern. It lazily initializes the appropriate session manager when first requested.</p> <p>The registry maintains singleton instances of: - A synchronous session manager (StarRocksSQlAlchemySessionManager) - An asynchronous session manager (AsyncStarRocksSQlAlchemySessionManager)</p> Source code in <code>archipy/adapters/starrocks/sqlalchemy/session_manager_registry.py</code> <pre><code>class StarRocksSessionManagerRegistry(SessionManagerRegistry, metaclass=Singleton):\n    \"\"\"Registry for StarRocks SQLAlchemy session managers.\n\n    This registry provides a centralized access point for both synchronous and\n    asynchronous StarRocks session managers, implementing the Service Locator pattern.\n    It lazily initializes the appropriate session manager when first requested.\n\n    The registry maintains singleton instances of:\n    - A synchronous session manager (StarRocksSQlAlchemySessionManager)\n    - An asynchronous session manager (AsyncStarRocksSQlAlchemySessionManager)\n    \"\"\"\n\n    @classmethod\n    def get_sync_manager(cls) -&gt; \"SessionManagerPort\":\n        \"\"\"Get the synchronous StarRocks session manager instance.\n\n        Lazily initializes a default StarRocksSQlAlchemySessionManager if none has been set.\n\n        Returns:\n            SessionManagerPort: The registered synchronous session manager\n\n        Raises:\n            DatabaseConnectionError: If there's an error initializing the session manager\n        \"\"\"\n        if cls._sync_instance is None:\n            try:\n                from archipy.adapters.starrocks.sqlalchemy.session_managers import StarRocksSQlAlchemySessionManager\n\n                cls._sync_instance = StarRocksSQlAlchemySessionManager()\n            except Exception as e:\n                raise DatabaseConnectionError(\n                    database=\"starrocks\",\n                ) from e\n        return cls._sync_instance\n\n    @classmethod\n    def set_sync_manager(cls, manager: \"SessionManagerPort\") -&gt; None:\n        \"\"\"Set a custom synchronous session manager.\n\n        Args:\n            manager: An instance implementing SessionManagerPort\n\n        Raises:\n            InvalidArgumentError: If the manager is None or doesn't implement SessionManagerPort\n        \"\"\"\n        if manager is None:\n            raise InvalidArgumentError(\"StarRocks session manager cannot be None\")\n        from archipy.adapters.base.sqlalchemy.session_manager_ports import SessionManagerPort\n\n        if not isinstance(manager, SessionManagerPort):\n            raise InvalidArgumentError(f\"Manager must implement SessionManagerPort, got {type(manager).__name__}\")\n        cls._sync_instance = manager\n\n    @classmethod\n    def get_async_manager(cls) -&gt; \"AsyncSessionManagerPort\":\n        \"\"\"Get the asynchronous StarRocks session manager instance.\n\n        Lazily initializes a default AsyncStarRocksSQlAlchemySessionManager if none has been set.\n\n        Returns:\n            AsyncSessionManagerPort: The registered asynchronous session manager\n\n        Raises:\n            DatabaseConnectionError: If there's an error initializing the session manager\n        \"\"\"\n        if cls._async_instance is None:\n            try:\n                from archipy.adapters.starrocks.sqlalchemy.session_managers import (\n                    AsyncStarRocksSQlAlchemySessionManager,\n                )\n\n                cls._async_instance = AsyncStarRocksSQlAlchemySessionManager()\n            except Exception as e:\n                raise DatabaseConnectionError(\n                    database=\"starrocks\",\n                ) from e\n        return cls._async_instance\n\n    @classmethod\n    def set_async_manager(cls, manager: \"AsyncSessionManagerPort\") -&gt; None:\n        \"\"\"Set a custom asynchronous session manager.\n\n        Args:\n            manager: An instance implementing AsyncSessionManagerPort\n\n        Raises:\n            InvalidArgumentError: If the manager is None or doesn't implement AsyncSessionManagerPort\n        \"\"\"\n        if manager is None:\n            raise InvalidArgumentError(\"StarRocks async session manager cannot be None\")\n        from archipy.adapters.base.sqlalchemy.session_manager_ports import AsyncSessionManagerPort\n\n        if not isinstance(manager, AsyncSessionManagerPort):\n            raise InvalidArgumentError(f\"Manager must implement AsyncSessionManagerPort, got {type(manager).__name__}\")\n        cls._async_instance = manager\n\n    @classmethod\n    def reset(cls) -&gt; None:\n        \"\"\"Reset the registry to its initial state.\n\n        This method clears both registered managers, useful for testing.\n        \"\"\"\n        cls._sync_instance = None\n        cls._async_instance = None\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry.get_sync_manager","title":"<code>archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry.get_sync_manager()</code>  <code>classmethod</code>","text":"<p>Get the synchronous StarRocks session manager instance.</p> <p>Lazily initializes a default StarRocksSQlAlchemySessionManager if none has been set.</p> <p>Returns:</p> Name Type Description <code>SessionManagerPort</code> <code>SessionManagerPort</code> <p>The registered synchronous session manager</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error initializing the session manager</p> Source code in <code>archipy/adapters/starrocks/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef get_sync_manager(cls) -&gt; \"SessionManagerPort\":\n    \"\"\"Get the synchronous StarRocks session manager instance.\n\n    Lazily initializes a default StarRocksSQlAlchemySessionManager if none has been set.\n\n    Returns:\n        SessionManagerPort: The registered synchronous session manager\n\n    Raises:\n        DatabaseConnectionError: If there's an error initializing the session manager\n    \"\"\"\n    if cls._sync_instance is None:\n        try:\n            from archipy.adapters.starrocks.sqlalchemy.session_managers import StarRocksSQlAlchemySessionManager\n\n            cls._sync_instance = StarRocksSQlAlchemySessionManager()\n        except Exception as e:\n            raise DatabaseConnectionError(\n                database=\"starrocks\",\n            ) from e\n    return cls._sync_instance\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry.set_sync_manager","title":"<code>archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry.set_sync_manager(manager)</code>  <code>classmethod</code>","text":"<p>Set a custom synchronous session manager.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>SessionManagerPort</code> <p>An instance implementing SessionManagerPort</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the manager is None or doesn't implement SessionManagerPort</p> Source code in <code>archipy/adapters/starrocks/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef set_sync_manager(cls, manager: \"SessionManagerPort\") -&gt; None:\n    \"\"\"Set a custom synchronous session manager.\n\n    Args:\n        manager: An instance implementing SessionManagerPort\n\n    Raises:\n        InvalidArgumentError: If the manager is None or doesn't implement SessionManagerPort\n    \"\"\"\n    if manager is None:\n        raise InvalidArgumentError(\"StarRocks session manager cannot be None\")\n    from archipy.adapters.base.sqlalchemy.session_manager_ports import SessionManagerPort\n\n    if not isinstance(manager, SessionManagerPort):\n        raise InvalidArgumentError(f\"Manager must implement SessionManagerPort, got {type(manager).__name__}\")\n    cls._sync_instance = manager\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry.get_async_manager","title":"<code>archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry.get_async_manager()</code>  <code>classmethod</code>","text":"<p>Get the asynchronous StarRocks session manager instance.</p> <p>Lazily initializes a default AsyncStarRocksSQlAlchemySessionManager if none has been set.</p> <p>Returns:</p> Name Type Description <code>AsyncSessionManagerPort</code> <code>AsyncSessionManagerPort</code> <p>The registered asynchronous session manager</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error initializing the session manager</p> Source code in <code>archipy/adapters/starrocks/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef get_async_manager(cls) -&gt; \"AsyncSessionManagerPort\":\n    \"\"\"Get the asynchronous StarRocks session manager instance.\n\n    Lazily initializes a default AsyncStarRocksSQlAlchemySessionManager if none has been set.\n\n    Returns:\n        AsyncSessionManagerPort: The registered asynchronous session manager\n\n    Raises:\n        DatabaseConnectionError: If there's an error initializing the session manager\n    \"\"\"\n    if cls._async_instance is None:\n        try:\n            from archipy.adapters.starrocks.sqlalchemy.session_managers import (\n                AsyncStarRocksSQlAlchemySessionManager,\n            )\n\n            cls._async_instance = AsyncStarRocksSQlAlchemySessionManager()\n        except Exception as e:\n            raise DatabaseConnectionError(\n                database=\"starrocks\",\n            ) from e\n    return cls._async_instance\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry.set_async_manager","title":"<code>archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry.set_async_manager(manager)</code>  <code>classmethod</code>","text":"<p>Set a custom asynchronous session manager.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>AsyncSessionManagerPort</code> <p>An instance implementing AsyncSessionManagerPort</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the manager is None or doesn't implement AsyncSessionManagerPort</p> Source code in <code>archipy/adapters/starrocks/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef set_async_manager(cls, manager: \"AsyncSessionManagerPort\") -&gt; None:\n    \"\"\"Set a custom asynchronous session manager.\n\n    Args:\n        manager: An instance implementing AsyncSessionManagerPort\n\n    Raises:\n        InvalidArgumentError: If the manager is None or doesn't implement AsyncSessionManagerPort\n    \"\"\"\n    if manager is None:\n        raise InvalidArgumentError(\"StarRocks async session manager cannot be None\")\n    from archipy.adapters.base.sqlalchemy.session_manager_ports import AsyncSessionManagerPort\n\n    if not isinstance(manager, AsyncSessionManagerPort):\n        raise InvalidArgumentError(f\"Manager must implement AsyncSessionManagerPort, got {type(manager).__name__}\")\n    cls._async_instance = manager\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry.reset","title":"<code>archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry.reset()</code>  <code>classmethod</code>","text":"<p>Reset the registry to its initial state.</p> <p>This method clears both registered managers, useful for testing.</p> Source code in <code>archipy/adapters/starrocks/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef reset(cls) -&gt; None:\n    \"\"\"Reset the registry to its initial state.\n\n    This method clears both registered managers, useful for testing.\n    \"\"\"\n    cls._sync_instance = None\n    cls._async_instance = None\n</code></pre>"},{"location":"api_reference/adapters/#email","title":"Email","text":"<p>Email sending functionality with standardized interface.</p> <pre><code>from archipy.adapters.email import EmailAdapter, EmailPort\n\n# Configure email adapter\nemail_adapter = EmailAdapter(host=\"smtp.example.com\", port=587, username=\"user\", password=\"pass\")\n\n# Send an email\nemail_adapter.send_email(\n    subject=\"Test Email\",\n    body=\"This is a test email\",\n    recipients=[\"recipient@example.com\"],\n)\n</code></pre> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.EmailConnectionManager","title":"<code>archipy.adapters.email.adapters.EmailConnectionManager</code>","text":"<p>Manages SMTP connections with connection pooling and timeout handling.</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>class EmailConnectionManager:\n    \"\"\"Manages SMTP connections with connection pooling and timeout handling.\"\"\"\n\n    def __init__(self, config: EmailConfig) -&gt; None:\n        self.config = config\n        self.smtp_connection: smtplib.SMTP | None = None\n        self.last_used: datetime | None = None\n\n    def connect(self) -&gt; None:\n        \"\"\"Establish SMTP connection with authentication.\"\"\"\n        if not self.config.SMTP_SERVER:\n            raise InvalidArgumentError(\"SMTP_SERVER is required for email connection\")\n\n        try:\n            self.smtp_connection = smtplib.SMTP(\n                self.config.SMTP_SERVER,\n                self.config.SMTP_PORT,\n                timeout=self.config.CONNECTION_TIMEOUT,\n            )\n            self.smtp_connection.starttls()\n            if self.config.USERNAME and self.config.PASSWORD:\n                self.smtp_connection.login(self.config.USERNAME, self.config.PASSWORD)\n            self.last_used = datetime.now()\n        except Exception as e:\n            BaseUtils.capture_exception(e)\n            self.smtp_connection = None\n\n    def disconnect(self) -&gt; None:\n        \"\"\"Close SMTP connection safely.\"\"\"\n        try:\n            if self.smtp_connection:\n                self.smtp_connection.quit()\n                self.smtp_connection = None\n        except Exception as e:\n            BaseUtils.capture_exception(e)\n        finally:\n            self.smtp_connection = None\n\n    def refresh_if_needed(self) -&gt; None:\n        \"\"\"Refresh connection if needed based on timeout.\"\"\"\n        if not self.smtp_connection or not self.last_used:\n            self.connect()\n            return\n\n        time_diff = (datetime.now() - self.last_used).total_seconds()\n        if time_diff &gt; 300:  # Refresh after 5 minutes\n            self.disconnect()\n            self.connect()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.EmailConnectionManager.connect","title":"<code>archipy.adapters.email.adapters.EmailConnectionManager.connect()</code>","text":"<p>Establish SMTP connection with authentication.</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>def connect(self) -&gt; None:\n    \"\"\"Establish SMTP connection with authentication.\"\"\"\n    if not self.config.SMTP_SERVER:\n        raise InvalidArgumentError(\"SMTP_SERVER is required for email connection\")\n\n    try:\n        self.smtp_connection = smtplib.SMTP(\n            self.config.SMTP_SERVER,\n            self.config.SMTP_PORT,\n            timeout=self.config.CONNECTION_TIMEOUT,\n        )\n        self.smtp_connection.starttls()\n        if self.config.USERNAME and self.config.PASSWORD:\n            self.smtp_connection.login(self.config.USERNAME, self.config.PASSWORD)\n        self.last_used = datetime.now()\n    except Exception as e:\n        BaseUtils.capture_exception(e)\n        self.smtp_connection = None\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.EmailConnectionManager.disconnect","title":"<code>archipy.adapters.email.adapters.EmailConnectionManager.disconnect()</code>","text":"<p>Close SMTP connection safely.</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Close SMTP connection safely.\"\"\"\n    try:\n        if self.smtp_connection:\n            self.smtp_connection.quit()\n            self.smtp_connection = None\n    except Exception as e:\n        BaseUtils.capture_exception(e)\n    finally:\n        self.smtp_connection = None\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.EmailConnectionManager.refresh_if_needed","title":"<code>archipy.adapters.email.adapters.EmailConnectionManager.refresh_if_needed()</code>","text":"<p>Refresh connection if needed based on timeout.</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>def refresh_if_needed(self) -&gt; None:\n    \"\"\"Refresh connection if needed based on timeout.\"\"\"\n    if not self.smtp_connection or not self.last_used:\n        self.connect()\n        return\n\n    time_diff = (datetime.now() - self.last_used).total_seconds()\n    if time_diff &gt; 300:  # Refresh after 5 minutes\n        self.disconnect()\n        self.connect()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.EmailConnectionPool","title":"<code>archipy.adapters.email.adapters.EmailConnectionPool</code>","text":"<p>Connection pool for managing multiple SMTP connections.</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>class EmailConnectionPool:\n    \"\"\"Connection pool for managing multiple SMTP connections.\"\"\"\n\n    def __init__(self, config: EmailConfig) -&gt; None:\n        self.config = config\n        self.pool: Queue[EmailConnectionManager] = Queue(maxsize=config.POOL_SIZE)\n        self._initialize_pool()\n\n    def _initialize_pool(self) -&gt; None:\n        for _ in range(self.config.POOL_SIZE):\n            connection = EmailConnectionManager(self.config)\n            self.pool.put(connection)\n\n    def get_connection(self) -&gt; EmailConnectionManager:\n        \"\"\"Get a connection from the pool.\"\"\"\n        connection = self.pool.get()\n        connection.refresh_if_needed()\n        return connection\n\n    def return_connection(self, connection: EmailConnectionManager) -&gt; None:\n        \"\"\"Return a connection to the pool.\"\"\"\n        connection.last_used = datetime.now()\n        self.pool.put(connection)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.EmailConnectionPool.get_connection","title":"<code>archipy.adapters.email.adapters.EmailConnectionPool.get_connection()</code>","text":"<p>Get a connection from the pool.</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>def get_connection(self) -&gt; EmailConnectionManager:\n    \"\"\"Get a connection from the pool.\"\"\"\n    connection = self.pool.get()\n    connection.refresh_if_needed()\n    return connection\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.EmailConnectionPool.return_connection","title":"<code>archipy.adapters.email.adapters.EmailConnectionPool.return_connection(connection)</code>","text":"<p>Return a connection to the pool.</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>def return_connection(self, connection: EmailConnectionManager) -&gt; None:\n    \"\"\"Return a connection to the pool.\"\"\"\n    connection.last_used = datetime.now()\n    self.pool.put(connection)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.AttachmentHandler","title":"<code>archipy.adapters.email.adapters.AttachmentHandler</code>","text":"<p>Enhanced attachment handler with better type safety and validation.</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>class AttachmentHandler:\n    \"\"\"Enhanced attachment handler with better type safety and validation.\"\"\"\n\n    @staticmethod\n    def create_attachment(\n        source: str | bytes | BinaryIO | HttpUrl,\n        filename: str,\n        attachment_type: EmailAttachmentType,\n        content_type: str | None = None,\n        content_disposition: EmailAttachmentDispositionType = EmailAttachmentDispositionType.ATTACHMENT,\n        content_id: str | None = None,\n        max_size: int | None = None,\n    ) -&gt; EmailAttachmentDTO:\n        \"\"\"Create an attachment with validation.\"\"\"\n        if max_size is None:\n            max_size = BaseConfig.global_config().EMAIL.ATTACHMENT_MAX_SIZE\n        try:\n            processed_content = AttachmentHandler._process_source(source, attachment_type)\n\n            return EmailAttachmentDTO(\n                content=processed_content,\n                filename=filename,\n                content_type=content_type,\n                content_disposition=content_disposition,\n                content_id=content_id,\n                attachment_type=attachment_type,\n                max_size=max_size,\n            )\n        except Exception as exception:\n            raise InvalidArgumentError(f\"Failed to create attachment: {exception!s}\") from exception\n\n    @staticmethod\n    def _process_source(source: str | bytes | BinaryIO | HttpUrl, attachment_type: EmailAttachmentType) -&gt; bytes:\n        \"\"\"Process different types of attachment sources.\"\"\"\n        if attachment_type == EmailAttachmentType.FILE:\n            if isinstance(source, str | os.PathLike):\n                with open(source, \"rb\") as f:\n                    return f.read()\n            raise ValueError(f\"File attachment type requires string path, got {type(source)}\")\n        elif attachment_type == EmailAttachmentType.BASE64:\n            if isinstance(source, str | bytes):\n                return base64.b64decode(source)\n            raise ValueError(f\"Base64 attachment type requires str or bytes, got {type(source)}\")\n        elif attachment_type == EmailAttachmentType.URL:\n            if isinstance(source, str | HttpUrl):\n                response = requests.get(str(source), timeout=30)\n                response.raise_for_status()\n                return bytes(response.content)\n            raise ValueError(f\"URL attachment type requires str or HttpUrl, got {type(source)}\")\n        elif attachment_type == EmailAttachmentType.BINARY:\n            if isinstance(source, bytes):\n                return source\n            if hasattr(source, \"read\"):\n                return source.read()\n            raise ValueError(f\"Invalid binary source type: {type(source)}\")\n        raise ValueError(f\"Unsupported attachment type: {attachment_type}\")\n\n    @staticmethod\n    def process_attachment(msg: MIMEMultipart, attachment: EmailAttachmentDTO) -&gt; None:\n        \"\"\"Process and attach the attachment to the email message.\"\"\"\n        content = AttachmentHandler._get_content(attachment)\n        part = AttachmentHandler._create_mime_part(content, attachment)\n\n        # Add headers\n        part.add_header(\"Content-Disposition\", attachment.content_disposition.value, filename=attachment.filename)\n\n        if attachment.content_id:\n            part.add_header(\"Content-ID\", attachment.content_id)\n\n        msg.attach(part)\n\n    @staticmethod\n    def _get_content(attachment: EmailAttachmentDTO) -&gt; bytes:\n        \"\"\"Get content as bytes from attachment.\"\"\"\n        if isinstance(attachment.content, str | bytes):\n            return attachment.content if isinstance(attachment.content, bytes) else attachment.content.encode()\n        return attachment.content.read()\n\n    @staticmethod\n    def _create_mime_part(\n        content: bytes,\n        attachment: EmailAttachmentDTO,\n    ) -&gt; MIMEText | MIMEImage | MIMEAudio | MIMEBase:\n        \"\"\"Create appropriate MIME part based on content type.\"\"\"\n        if not attachment.content_type:\n            raise ValueError(\"Content type is required for attachment\")\n        main_type, sub_type = attachment.content_type.split(\"/\", 1)\n\n        if main_type == \"text\":\n            return MIMEText(content.decode(), sub_type)\n        if main_type == \"image\":\n            return MIMEImage(content, _subtype=sub_type)\n        if main_type == \"audio\":\n            return MIMEAudio(content, _subtype=sub_type)\n        part = MIMEBase(main_type, sub_type)\n        part.set_payload(content)\n        encoders.encode_base64(part)\n        return part\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.AttachmentHandler.create_attachment","title":"<code>archipy.adapters.email.adapters.AttachmentHandler.create_attachment(source, filename, attachment_type, content_type=None, content_disposition=EmailAttachmentDispositionType.ATTACHMENT, content_id=None, max_size=None)</code>  <code>staticmethod</code>","text":"<p>Create an attachment with validation.</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>@staticmethod\ndef create_attachment(\n    source: str | bytes | BinaryIO | HttpUrl,\n    filename: str,\n    attachment_type: EmailAttachmentType,\n    content_type: str | None = None,\n    content_disposition: EmailAttachmentDispositionType = EmailAttachmentDispositionType.ATTACHMENT,\n    content_id: str | None = None,\n    max_size: int | None = None,\n) -&gt; EmailAttachmentDTO:\n    \"\"\"Create an attachment with validation.\"\"\"\n    if max_size is None:\n        max_size = BaseConfig.global_config().EMAIL.ATTACHMENT_MAX_SIZE\n    try:\n        processed_content = AttachmentHandler._process_source(source, attachment_type)\n\n        return EmailAttachmentDTO(\n            content=processed_content,\n            filename=filename,\n            content_type=content_type,\n            content_disposition=content_disposition,\n            content_id=content_id,\n            attachment_type=attachment_type,\n            max_size=max_size,\n        )\n    except Exception as exception:\n        raise InvalidArgumentError(f\"Failed to create attachment: {exception!s}\") from exception\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.AttachmentHandler.process_attachment","title":"<code>archipy.adapters.email.adapters.AttachmentHandler.process_attachment(msg, attachment)</code>  <code>staticmethod</code>","text":"<p>Process and attach the attachment to the email message.</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>@staticmethod\ndef process_attachment(msg: MIMEMultipart, attachment: EmailAttachmentDTO) -&gt; None:\n    \"\"\"Process and attach the attachment to the email message.\"\"\"\n    content = AttachmentHandler._get_content(attachment)\n    part = AttachmentHandler._create_mime_part(content, attachment)\n\n    # Add headers\n    part.add_header(\"Content-Disposition\", attachment.content_disposition.value, filename=attachment.filename)\n\n    if attachment.content_id:\n        part.add_header(\"Content-ID\", attachment.content_id)\n\n    msg.attach(part)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.EmailAdapter","title":"<code>archipy.adapters.email.adapters.EmailAdapter</code>","text":"<p>               Bases: <code>EmailPort</code></p> <p>Email adapter implementing EmailPort for sending emails with SMTP.</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>class EmailAdapter(EmailPort):\n    \"\"\"Email adapter implementing EmailPort for sending emails with SMTP.\"\"\"\n\n    def __init__(self, config: EmailConfig | None = None) -&gt; None:\n        self.config = config or BaseConfig.global_config().EMAIL\n        self.connection_pool = EmailConnectionPool(self.config)\n\n    @override\n    def send_email(\n        self,\n        to_email: EmailStr | list[EmailStr],\n        subject: str,\n        body: str,\n        cc: EmailStr | list[EmailStr] | None = None,\n        bcc: EmailStr | list[EmailStr] | None = None,\n        attachments: list[str | EmailAttachmentDTO] | None = None,\n        html: bool = False,\n        template: str | None = None,\n        template_vars: dict | None = None,\n    ) -&gt; None:\n        \"\"\"Send email with advanced features and connection pooling.\"\"\"\n        connection: EmailConnectionManager | None = None\n        try:\n            connection = self.connection_pool.get_connection()\n            msg = self._create_message(\n                to_email=to_email,\n                subject=subject,\n                body=body,\n                cc=cc,\n                bcc=bcc,\n                attachments=attachments,\n                html=html,\n                template=template,\n                template_vars=template_vars,\n            )\n\n            recipients = self._get_all_recipients(to_email, cc, bcc)\n\n            for attempt in range(self.config.MAX_RETRIES):\n                try:\n                    if connection.smtp_connection:\n                        connection.smtp_connection.send_message(msg, to_addrs=recipients)\n                        logging.debug(f\"Email sent successfully to {to_email}\")\n                        return\n                    else:\n                        connection.connect()\n                except Exception as e:\n                    if attempt == self.config.MAX_RETRIES - 1:\n                        BaseUtils.capture_exception(e)\n                    connection.connect()  # Retry with fresh connection\n\n        except Exception as e:\n            BaseUtils.capture_exception(e)\n        finally:\n            if connection:\n                self.connection_pool.return_connection(connection)\n\n    def _create_message(\n        self,\n        to_email: EmailStr | list[EmailStr],\n        subject: str,\n        body: str,\n        cc: EmailStr | list[EmailStr] | None = None,\n        bcc: EmailStr | list[EmailStr] | None = None,\n        attachments: list[str | EmailAttachmentDTO] | None = None,\n        html: bool = False,\n        template: str | None = None,\n        template_vars: dict | None = None,\n    ) -&gt; MIMEMultipart:\n        msg = MIMEMultipart()\n        msg[\"From\"] = self.config.USERNAME or \"no-reply@example.com\"\n        msg[\"To\"] = to_email if isinstance(to_email, str) else \", \".join(to_email)\n        msg[\"Subject\"] = subject\n\n        if cc:\n            msg[\"Cc\"] = cc if isinstance(cc, str) else \", \".join(cc)\n        if bcc:\n            msg[\"Bcc\"] = bcc if isinstance(bcc, str) else \", \".join(bcc)\n\n        if template:\n            body = Template(template).render(**(template_vars or {}))\n\n        msg.attach(MIMEText(body, \"html\" if html else \"plain\"))\n\n        if attachments:\n            for attachment in attachments:\n                if isinstance(attachment, str):\n                    # Treat as file path\n                    attachment_obj = AttachmentHandler.create_attachment(\n                        source=attachment,\n                        filename=os.path.basename(attachment),\n                        attachment_type=EmailAttachmentType.FILE,\n                    )\n                else:\n                    attachment_obj = attachment\n                AttachmentHandler.process_attachment(msg, attachment_obj)\n\n        return msg\n\n    @staticmethod\n    def _get_all_recipients(\n        to_email: EmailStr | list[EmailStr],\n        cc: EmailStr | list[EmailStr] | None,\n        bcc: EmailStr | list[EmailStr] | None,\n    ) -&gt; list[str]:\n        \"\"\"Get list of all recipients.\"\"\"\n        recipients = []\n\n        # Add primary recipients\n        if isinstance(to_email, str):\n            recipients.append(to_email)\n        else:\n            recipients.extend(to_email)\n\n        # Add CC recipients\n        if cc:\n            if isinstance(cc, str):\n                recipients.append(cc)\n            else:\n                recipients.extend(cc)\n\n        # Add BCC recipients\n        if bcc:\n            if isinstance(bcc, str):\n                recipients.append(bcc)\n            else:\n                recipients.extend(bcc)\n\n        return recipients\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.EmailAdapter.send_email","title":"<code>archipy.adapters.email.adapters.EmailAdapter.send_email(to_email, subject, body, cc=None, bcc=None, attachments=None, html=False, template=None, template_vars=None)</code>","text":"<p>Send email with advanced features and connection pooling.</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>@override\ndef send_email(\n    self,\n    to_email: EmailStr | list[EmailStr],\n    subject: str,\n    body: str,\n    cc: EmailStr | list[EmailStr] | None = None,\n    bcc: EmailStr | list[EmailStr] | None = None,\n    attachments: list[str | EmailAttachmentDTO] | None = None,\n    html: bool = False,\n    template: str | None = None,\n    template_vars: dict | None = None,\n) -&gt; None:\n    \"\"\"Send email with advanced features and connection pooling.\"\"\"\n    connection: EmailConnectionManager | None = None\n    try:\n        connection = self.connection_pool.get_connection()\n        msg = self._create_message(\n            to_email=to_email,\n            subject=subject,\n            body=body,\n            cc=cc,\n            bcc=bcc,\n            attachments=attachments,\n            html=html,\n            template=template,\n            template_vars=template_vars,\n        )\n\n        recipients = self._get_all_recipients(to_email, cc, bcc)\n\n        for attempt in range(self.config.MAX_RETRIES):\n            try:\n                if connection.smtp_connection:\n                    connection.smtp_connection.send_message(msg, to_addrs=recipients)\n                    logging.debug(f\"Email sent successfully to {to_email}\")\n                    return\n                else:\n                    connection.connect()\n            except Exception as e:\n                if attempt == self.config.MAX_RETRIES - 1:\n                    BaseUtils.capture_exception(e)\n                connection.connect()  # Retry with fresh connection\n\n    except Exception as e:\n        BaseUtils.capture_exception(e)\n    finally:\n        if connection:\n            self.connection_pool.return_connection(connection)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.ports.EmailPort","title":"<code>archipy.adapters.email.ports.EmailPort</code>","text":"<p>Interface for email sending operations.</p> <p>This interface defines the contract for email adapters, ensuring a consistent approach to sending emails across different implementations. It provides a comprehensive set of features including support for:</p> <ul> <li>Multiple recipients (To, CC, BCC)</li> <li>HTML and plain text content</li> <li>File and in-memory attachments</li> <li>Template-based email rendering</li> </ul> <p>Implementing classes should handle the details of connecting to an email service, managing connections, and ensuring reliable delivery.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from archipy.adapters.email.email_port import EmailPort\n&gt;&gt;&gt;\n&gt;&gt;&gt; class CustomEmailAdapter(EmailPort):\n...     def __init__(self, config):\n...         self.config = config\n...\n...     def send_email(\n...         self,\n...         to_email,\n...         subject,\n...         body,\n...         cc=None,\n...         bcc=None,\n...         attachments=None,\n...         html=False,\n...         template=None,\n...         template_vars=None\n...     ):\n...         # Implementation details...\n...         pass\n</code></pre> Source code in <code>archipy/adapters/email/ports.py</code> <pre><code>class EmailPort:\n    \"\"\"Interface for email sending operations.\n\n    This interface defines the contract for email adapters, ensuring\n    a consistent approach to sending emails across different implementations.\n    It provides a comprehensive set of features including support for:\n\n    - Multiple recipients (To, CC, BCC)\n    - HTML and plain text content\n    - File and in-memory attachments\n    - Template-based email rendering\n\n    Implementing classes should handle the details of connecting to an\n    email service, managing connections, and ensuring reliable delivery.\n\n    Examples:\n        &gt;&gt;&gt; from archipy.adapters.email.email_port import EmailPort\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class CustomEmailAdapter(EmailPort):\n        ...     def __init__(self, config):\n        ...         self.config = config\n        ...\n        ...     def send_email(\n        ...         self,\n        ...         to_email,\n        ...         subject,\n        ...         body,\n        ...         cc=None,\n        ...         bcc=None,\n        ...         attachments=None,\n        ...         html=False,\n        ...         template=None,\n        ...         template_vars=None\n        ...     ):\n        ...         # Implementation details...\n        ...         pass\n    \"\"\"\n\n    @abstractmethod\n    def send_email(\n        self,\n        to_email: EmailStr | list[EmailStr],\n        subject: str,\n        body: str,\n        cc: EmailStr | list[EmailStr] | None = None,\n        bcc: EmailStr | list[EmailStr] | None = None,\n        attachments: list[str | EmailAttachmentDTO] | None = None,\n        html: bool = False,\n        template: str | None = None,\n        template_vars: dict | None = None,\n    ) -&gt; None:\n        \"\"\"Send an email with various options and features.\n\n        This method handles the composition and delivery of an email with\n        support for multiple recipients, HTML content, templates, and attachments.\n\n        Args:\n            to_email: Primary recipient(s) of the email\n            subject: Email subject line\n            body: Email body content (either plain text or HTML)\n            cc: Carbon copy recipient(s)\n            bcc: Blind carbon copy recipient(s)\n            attachments: List of file paths or EmailAttachmentDTO objects\n            html: If True, treats body as HTML content, otherwise plain text\n            template: A template string to render using template_vars\n            template_vars: Variables to use when rendering the template\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; # Simple text email\n            &gt;&gt;&gt; adapter.send_email(\n            ...     to_email=\"user@example.com\",\n            ...     subject=\"Hello\",\n            ...     body=\"This is a test email\"\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # HTML email with attachment\n            &gt;&gt;&gt; adapter.send_email(\n            ...     to_email=[\"user1@example.com\", \"user2@example.com\"],\n            ...     subject=\"Report\",\n            ...     body=\"&lt;h1&gt;Monthly Report&lt;/h1&gt;&lt;p&gt;Please see attached&lt;/p&gt;\",\n            ...     html=True,\n            ...     attachments=[\"path/to/report.pdf\"]\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Template-based email\n            &gt;&gt;&gt; template = \"Hello {{ name }}, your account expires on {{ date }}\"\n            &gt;&gt;&gt; adapter.send_email(\n            ...     to_email=\"user@example.com\",\n            ...     subject=\"Account Expiration\",\n            ...     body=\"\",  # Body will be rendered from template\n            ...     template=template,\n            ...     template_vars={\"name\": \"John\", \"date\": \"2023-12-31\"}\n            ... )\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.ports.EmailPort.send_email","title":"<code>archipy.adapters.email.ports.EmailPort.send_email(to_email, subject, body, cc=None, bcc=None, attachments=None, html=False, template=None, template_vars=None)</code>  <code>abstractmethod</code>","text":"<p>Send an email with various options and features.</p> <p>This method handles the composition and delivery of an email with support for multiple recipients, HTML content, templates, and attachments.</p> <p>Parameters:</p> Name Type Description Default <code>to_email</code> <code>EmailStr | list[EmailStr]</code> <p>Primary recipient(s) of the email</p> required <code>subject</code> <code>str</code> <p>Email subject line</p> required <code>body</code> <code>str</code> <p>Email body content (either plain text or HTML)</p> required <code>cc</code> <code>EmailStr | list[EmailStr] | None</code> <p>Carbon copy recipient(s)</p> <code>None</code> <code>bcc</code> <code>EmailStr | list[EmailStr] | None</code> <p>Blind carbon copy recipient(s)</p> <code>None</code> <code>attachments</code> <code>list[str | EmailAttachmentDTO] | None</code> <p>List of file paths or EmailAttachmentDTO objects</p> <code>None</code> <code>html</code> <code>bool</code> <p>If True, treats body as HTML content, otherwise plain text</p> <code>False</code> <code>template</code> <code>str | None</code> <p>A template string to render using template_vars</p> <code>None</code> <code>template_vars</code> <code>dict | None</code> <p>Variables to use when rendering the template</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Simple text email\n&gt;&gt;&gt; adapter.send_email(\n...     to_email=\"user@example.com\",\n...     subject=\"Hello\",\n...     body=\"This is a test email\"\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # HTML email with attachment\n&gt;&gt;&gt; adapter.send_email(\n...     to_email=[\"user1@example.com\", \"user2@example.com\"],\n...     subject=\"Report\",\n...     body=\"&lt;h1&gt;Monthly Report&lt;/h1&gt;&lt;p&gt;Please see attached&lt;/p&gt;\",\n...     html=True,\n...     attachments=[\"path/to/report.pdf\"]\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Template-based email\n&gt;&gt;&gt; template = \"Hello {{ name }}, your account expires on {{ date }}\"\n&gt;&gt;&gt; adapter.send_email(\n...     to_email=\"user@example.com\",\n...     subject=\"Account Expiration\",\n...     body=\"\",  # Body will be rendered from template\n...     template=template,\n...     template_vars={\"name\": \"John\", \"date\": \"2023-12-31\"}\n... )\n</code></pre> Source code in <code>archipy/adapters/email/ports.py</code> <pre><code>@abstractmethod\ndef send_email(\n    self,\n    to_email: EmailStr | list[EmailStr],\n    subject: str,\n    body: str,\n    cc: EmailStr | list[EmailStr] | None = None,\n    bcc: EmailStr | list[EmailStr] | None = None,\n    attachments: list[str | EmailAttachmentDTO] | None = None,\n    html: bool = False,\n    template: str | None = None,\n    template_vars: dict | None = None,\n) -&gt; None:\n    \"\"\"Send an email with various options and features.\n\n    This method handles the composition and delivery of an email with\n    support for multiple recipients, HTML content, templates, and attachments.\n\n    Args:\n        to_email: Primary recipient(s) of the email\n        subject: Email subject line\n        body: Email body content (either plain text or HTML)\n        cc: Carbon copy recipient(s)\n        bcc: Blind carbon copy recipient(s)\n        attachments: List of file paths or EmailAttachmentDTO objects\n        html: If True, treats body as HTML content, otherwise plain text\n        template: A template string to render using template_vars\n        template_vars: Variables to use when rendering the template\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; # Simple text email\n        &gt;&gt;&gt; adapter.send_email(\n        ...     to_email=\"user@example.com\",\n        ...     subject=\"Hello\",\n        ...     body=\"This is a test email\"\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # HTML email with attachment\n        &gt;&gt;&gt; adapter.send_email(\n        ...     to_email=[\"user1@example.com\", \"user2@example.com\"],\n        ...     subject=\"Report\",\n        ...     body=\"&lt;h1&gt;Monthly Report&lt;/h1&gt;&lt;p&gt;Please see attached&lt;/p&gt;\",\n        ...     html=True,\n        ...     attachments=[\"path/to/report.pdf\"]\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Template-based email\n        &gt;&gt;&gt; template = \"Hello {{ name }}, your account expires on {{ date }}\"\n        &gt;&gt;&gt; adapter.send_email(\n        ...     to_email=\"user@example.com\",\n        ...     subject=\"Account Expiration\",\n        ...     body=\"\",  # Body will be rendered from template\n        ...     template=template,\n        ...     template_vars={\"name\": \"John\", \"date\": \"2023-12-31\"}\n        ... )\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#keycloak","title":"Keycloak","text":"<p>Keycloak integration for authentication and authorization services.</p> <pre><code>from archipy.adapters.keycloak import KeycloakAdapter, AsyncKeycloakAdapter\n\n# Create a Keycloak adapter (synchronous)\nkeycloak = KeycloakAdapter()  # Uses global config by default\n\n# Authenticate a user\ntoken = keycloak.get_token(\"username\", \"password\")\n\n# Validate token\nis_valid = keycloak.validate_token(token[\"access_token\"])\n\n# Check user roles\nhas_admin = keycloak.has_role(token[\"access_token\"], \"admin\")\n\n# Async usage example\nimport asyncio\n\nasync def auth_example():\n    # Create async Keycloak adapter\n    async_keycloak = AsyncKeycloakAdapter()\n\n    # Get token asynchronously\n    token = await async_keycloak.get_token(\"username\", \"password\")\n\n    # Get user info\n    user_info = await async_keycloak.get_userinfo(token[\"access_token\"])\n    return user_info\n\n# Run the async example\nuser_info = asyncio.run(auth_example())\n</code></pre> <p>For detailed examples and usage guidelines, see the Keycloak Adapter Examples.</p> <p>options: show_root_heading: true show_source: true</p> <p>Keycloak port definitions for ArchiPy.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakExceptionHandlerMixin","title":"<code>archipy.adapters.keycloak.adapters.KeycloakExceptionHandlerMixin</code>","text":"<p>Mixin class to handle Keycloak exceptions in a consistent way.</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>class KeycloakExceptionHandlerMixin:\n    \"\"\"Mixin class to handle Keycloak exceptions in a consistent way.\"\"\"\n\n    @classmethod\n    def _extract_error_message(cls, exception: KeycloakError) -&gt; str:\n        \"\"\"Extract the actual error message from Keycloak error response.\n\n        Args:\n            exception: The Keycloak exception\n\n        Returns:\n            str: The extracted error message\n        \"\"\"\n        error_message = str(exception)\n\n        # Try to parse JSON response body\n        if hasattr(exception, \"response_body\") and exception.response_body:\n            try:\n                body = exception.response_body\n                if isinstance(body, bytes):\n                    body_str = body.decode(\"utf-8\")\n                elif isinstance(body, str):\n                    body_str = body\n                else:\n                    body_str = str(body)\n\n                parsed = json.loads(body_str)\n                if isinstance(parsed, dict):\n                    error_message = (\n                        parsed.get(\"errorMessage\")\n                        or parsed.get(\"error_description\")\n                        or parsed.get(\"error\")\n                        or error_message\n                    )\n            except (json.JSONDecodeError, UnicodeDecodeError):\n                pass\n\n        return error_message\n\n    @classmethod\n    def _handle_keycloak_exception(cls, exception: KeycloakError, operation: str) -&gt; None:\n        \"\"\"Handle Keycloak exceptions and map them to appropriate application errors.\n\n        Args:\n            exception: The original Keycloak exception\n            operation: The name of the operation that failed\n\n        Raises:\n            Various application-specific errors based on the exception type/content\n        \"\"\"\n        error_message = cls._extract_error_message(exception)\n        response_code = getattr(exception, \"response_code\", None)\n        error_lower = error_message.lower()\n\n        # Common context data\n        additional_data = {\n            \"operation\": operation,\n            \"original_error\": error_message,\n            \"response_code\": response_code,\n            \"keycloak_error_type\": type(exception).__name__,\n        }\n\n        # Connection and network errors\n        if isinstance(exception, KeycloakConnectionError):\n            if \"timeout\" in error_lower:\n                raise KeycloakConnectionTimeoutError(\n                    error=KeycloakErrorMessageType.CONNECTION_TIMEOUT.value,\n                    additional_data=additional_data,\n                ) from exception\n            raise KeycloakServiceUnavailableError(\n                error=KeycloakErrorMessageType.SERVICE_UNAVAILABLE.value,\n                additional_data=additional_data,\n            ) from exception\n\n        # Authentication errors\n        if isinstance(exception, KeycloakAuthenticationError) or any(\n            phrase in error_lower\n            for phrase in [\"invalid user credentials\", \"invalid credentials\", \"authentication failed\", \"unauthorized\"]\n        ):\n            raise InvalidCredentialsError(\n                error=KeycloakErrorMessageType.INVALID_CREDENTIALS.value,\n                additional_data=additional_data,\n            ) from exception\n\n        # Resource already exists errors\n        if \"already exists\" in error_lower:\n            if \"realm\" in error_lower:\n                raise RealmAlreadyExistsError(\n                    error=KeycloakErrorMessageType.REALM_ALREADY_EXISTS.value,\n                    additional_data=additional_data,\n                ) from exception\n            elif \"user exists with same\" in error_lower:\n                raise UserAlreadyExistsError(\n                    error=KeycloakErrorMessageType.USER_ALREADY_EXISTS.value,\n                    additional_data=additional_data,\n                ) from exception\n            elif \"client\" in error_lower:\n                raise ClientAlreadyExistsError(\n                    error=KeycloakErrorMessageType.CLIENT_ALREADY_EXISTS.value,\n                    additional_data=additional_data,\n                ) from exception\n            elif \"role\" in error_lower:\n                raise RoleAlreadyExistsError(\n                    error=KeycloakErrorMessageType.ROLE_ALREADY_EXISTS.value,\n                    additional_data=additional_data,\n                ) from exception\n\n        # Not found errors\n        if \"not found\" in error_lower:\n            raise ResourceNotFoundError(\n                error=KeycloakErrorMessageType.RESOURCE_NOT_FOUND.value,\n                additional_data=additional_data,\n            ) from exception\n\n        # Permission errors\n        if any(\n            phrase in error_lower\n            for phrase in [\"forbidden\", \"access denied\", \"insufficient permissions\", \"insufficient scope\"]\n        ):\n            raise InsufficientPermissionsError(\n                error=KeycloakErrorMessageType.INSUFFICIENT_PERMISSIONS.value,\n                additional_data=additional_data,\n            ) from exception\n\n        # Password policy errors\n        if any(\n            phrase in error_lower\n            for phrase in [\"invalid password\", \"password policy\", \"minimum length\", \"password must\"]\n        ):\n            raise PasswordPolicyError(\n                error=KeycloakErrorMessageType.PASSWORD_POLICY_VIOLATION.value,\n                additional_data=additional_data,\n            ) from exception\n\n        # Validation errors (400 status codes that don't match above)\n        if response_code == 400 or any(\n            phrase in error_lower for phrase in [\"validation\", \"invalid\", \"required field\", \"bad request\"]\n        ):\n            raise ValidationError(\n                error=KeycloakErrorMessageType.VALIDATION_ERROR.value,\n                additional_data=additional_data,\n            ) from exception\n\n        # Service unavailable\n        if response_code in [503, 504] or \"unavailable\" in error_lower:\n            raise KeycloakServiceUnavailableError(\n                error=KeycloakErrorMessageType.SERVICE_UNAVAILABLE.value,\n                additional_data=additional_data,\n            ) from exception\n\n        # Default to InternalError for unrecognized errors\n        raise InternalError(additional_data=additional_data) from exception\n\n    @classmethod\n    def _handle_realm_exception(cls, exception: KeycloakError, operation: str, realm_name: str | None = None) -&gt; None:\n        \"\"\"Handle realm-specific exceptions.\n\n        Args:\n            exception: The original Keycloak exception\n            operation: The name of the operation that failed\n            realm_name: The realm name involved in the operation\n\n        Raises:\n            RealmAlreadyExistsError: If realm already exists\n            Various other errors from _handle_keycloak_exception\n        \"\"\"\n        # Add realm-specific context\n        error_message = cls._extract_error_message(exception)\n\n        # Realm-specific error handling\n        if realm_name and \"already exists\" in error_message.lower():\n            additional_data = {\n                \"operation\": operation,\n                \"realm_name\": realm_name,\n                \"original_error\": error_message,\n                \"response_code\": getattr(exception, \"response_code\", None),\n            }\n            raise RealmAlreadyExistsError(\n                error=KeycloakErrorMessageType.REALM_ALREADY_EXISTS.value,\n                additional_data=additional_data,\n            ) from exception\n\n        # Fall back to general Keycloak error handling\n        cls._handle_keycloak_exception(exception, operation)\n\n    @classmethod\n    def _handle_user_exception(cls, exception: KeycloakError, operation: str, user_data: dict | None = None) -&gt; None:\n        \"\"\"Handle user-specific exceptions.\n\n        Args:\n            exception: The original Keycloak exception\n            operation: The name of the operation that failed\n            user_data: The user data involved in the operation\n\n        Raises:\n            UserAlreadyExistsError: If user already exists\n            Various other errors from _handle_keycloak_exception\n        \"\"\"\n        error_message = cls._extract_error_message(exception)\n\n        # User-specific error handling\n        if \"user exists with same\" in error_message.lower():\n            additional_data = {\n                \"operation\": operation,\n                \"original_error\": error_message,\n                \"response_code\": getattr(exception, \"response_code\", None),\n            }\n            if user_data:\n                additional_data.update(\n                    {\n                        \"username\": user_data.get(\"username\"),\n                        \"email\": user_data.get(\"email\"),\n                    },\n                )\n            raise UserAlreadyExistsError(\n                error=KeycloakErrorMessageType.USER_ALREADY_EXISTS.value,\n                additional_data=additional_data,\n            ) from exception\n\n        # Fall back to general Keycloak error handling\n        cls._handle_keycloak_exception(exception, operation)\n\n    @classmethod\n    def _handle_client_exception(\n        cls,\n        exception: KeycloakError,\n        operation: str,\n        client_data: dict | None = None,\n    ) -&gt; None:\n        \"\"\"Handle client-specific exceptions.\n\n        Args:\n            exception: The original Keycloak exception\n            operation: The name of the operation that failed\n            client_data: The client data involved in the operation\n\n        Raises:\n            ClientAlreadyExistsError: If client already exists\n            Various other errors from _handle_keycloak_exception\n        \"\"\"\n        error_message = cls._extract_error_message(exception)\n\n        # Client-specific error handling\n        if \"client\" in error_message.lower() and \"already exists\" in error_message.lower():\n            additional_data = {\n                \"operation\": operation,\n                \"original_error\": error_message,\n                \"response_code\": getattr(exception, \"response_code\", None),\n            }\n            if client_data:\n                additional_data.update(\n                    {\n                        \"client_id\": client_data.get(\"clientId\"),\n                        \"client_name\": client_data.get(\"name\"),\n                    },\n                )\n            raise ClientAlreadyExistsError(\n                error=KeycloakErrorMessageType.CLIENT_ALREADY_EXISTS.value,\n                additional_data=additional_data,\n            ) from exception\n\n        # Fall back to general Keycloak error handling\n        cls._handle_keycloak_exception(exception, operation)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter</code>","text":"<p>               Bases: <code>KeycloakPort</code>, <code>KeycloakExceptionHandlerMixin</code></p> <p>Concrete implementation of the KeycloakPort interface using python-keycloak library.</p> <p>This implementation includes TTL caching for appropriate operations to improve performance while ensuring cache entries expire after a configured time to prevent stale data.</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>class KeycloakAdapter(KeycloakPort, KeycloakExceptionHandlerMixin):\n    \"\"\"Concrete implementation of the KeycloakPort interface using python-keycloak library.\n\n    This implementation includes TTL caching for appropriate operations to improve performance\n    while ensuring cache entries expire after a configured time to prevent stale data.\n    \"\"\"\n\n    def __init__(self, keycloak_configs: KeycloakConfig | None = None) -&gt; None:\n        \"\"\"Initialize KeycloakAdapter with configuration.\n\n        Args:\n            keycloak_configs: Optional Keycloak configuration. If None, global config is used.\n        \"\"\"\n        self.configs: KeycloakConfig = (\n            BaseConfig.global_config().KEYCLOAK if keycloak_configs is None else keycloak_configs\n        )\n\n        # Initialize the OpenID client for authentication\n        self._openid_adapter = self._get_openid_client(self.configs)\n\n        # Cache for admin client to avoid unnecessary re-authentication\n        self._admin_adapter: KeycloakAdmin | None = None\n        self._admin_token_expiry: float = 0.0\n\n        # Initialize admin client if admin mode is enabled and credentials are provided\n        if self.configs.IS_ADMIN_MODE_ENABLED and (\n            self.configs.CLIENT_SECRET_KEY or (self.configs.ADMIN_USERNAME and self.configs.ADMIN_PASSWORD)\n        ):\n            self._initialize_admin_client()\n\n    def clear_all_caches(self) -&gt; None:\n        \"\"\"Clear all cached values.\"\"\"\n        for attr_name in dir(self):\n            attr = getattr(self, attr_name)\n            if hasattr(attr, \"clear_cache\"):\n                attr.clear_cache()\n\n    @staticmethod\n    def _get_openid_client(configs: KeycloakConfig) -&gt; KeycloakOpenID:\n        \"\"\"Create and configure a KeycloakOpenID instance.\n\n        Args:\n            configs: Keycloak configuration\n\n        Returns:\n            Configured KeycloakOpenID client\n        \"\"\"\n        return KeycloakOpenID(\n            server_url=configs.SERVER_URL,\n            client_id=configs.CLIENT_ID,\n            realm_name=configs.REALM_NAME,\n            client_secret_key=configs.CLIENT_SECRET_KEY,\n            verify=configs.VERIFY_SSL,\n            timeout=configs.TIMEOUT,\n        )\n\n    def _initialize_admin_client(self) -&gt; None:\n        \"\"\"Initialize or refresh the admin client.\"\"\"\n        try:\n            # Check if admin credentials are available\n            if self.configs.ADMIN_USERNAME and self.configs.ADMIN_PASSWORD:\n                # Create admin client using admin credentials\n                self._admin_adapter = KeycloakAdmin(\n                    server_url=self.configs.SERVER_URL,\n                    username=self.configs.ADMIN_USERNAME,\n                    password=self.configs.ADMIN_PASSWORD,\n                    realm_name=self.configs.REALM_NAME,\n                    user_realm_name=self.configs.ADMIN_REALM_NAME,\n                    verify=self.configs.VERIFY_SSL,\n                    timeout=self.configs.TIMEOUT,\n                )\n                # Since we're using direct credentials, set a long expiry time\n                self._admin_token_expiry = time.time() + 3600  # 1 hour\n                logger.debug(\"Admin client initialized with admin credentials\")\n\n            elif self.configs.CLIENT_SECRET_KEY:\n                # Get token using client credentials\n                token = self._openid_adapter.token(grant_type=\"client_credentials\")\n\n                # Set token expiry time (current time + expires_in - buffer)\n                # Using a 30-second buffer to ensure we refresh before expiration\n                self._admin_token_expiry = time.time() + token.get(\"expires_in\", 60) - 30\n\n                self._admin_adapter = KeycloakAdmin(\n                    server_url=self.configs.SERVER_URL,\n                    realm_name=self.configs.REALM_NAME,\n                    token=token,\n                    verify=self.configs.VERIFY_SSL,\n                    timeout=self.configs.TIMEOUT,\n                )\n                logger.debug(\"Admin client initialized with client credentials\")\n\n            else:\n                raise UnauthenticatedError(\n                    additional_data={\"detail\": \"Neither admin credentials nor client secret provided\"},\n                )\n\n        except KeycloakAuthenticationError as e:\n            self._admin_adapter = None\n            self._admin_token_expiry = 0\n            raise UnauthenticatedError(\n                additional_data={\"detail\": \"Failed to authenticate with Keycloak service account\"},\n            ) from e\n        except KeycloakConnectionError as e:\n            self._admin_adapter = None\n            self._admin_token_expiry = 0\n            raise ConnectionTimeoutError(\"Failed to connect to Keycloak server\") from e\n        except KeycloakError as e:\n            self._admin_adapter = None\n            self._admin_token_expiry = 0\n            self._handle_keycloak_exception(e, \"_initialize_admin_client\")\n\n    @property\n    def admin_adapter(self) -&gt; KeycloakAdmin:\n        \"\"\"Get the admin adapter, refreshing it if necessary.\n\n        Returns:\n            KeycloakAdmin instance\n\n        Raises:\n            UnauthenticatedError: If admin client is not available due to authentication issues\n            UnavailableError: If Keycloak service is unavailable\n        \"\"\"\n        if not self.configs.IS_ADMIN_MODE_ENABLED or not (\n            self.configs.CLIENT_SECRET_KEY or (self.configs.ADMIN_USERNAME and self.configs.ADMIN_PASSWORD)\n        ):\n            raise UnauthenticatedError(\n                additional_data={\n                    \"data\": \"Admin mode is disabled or neither admin credentials nor client secret provided\",\n                },\n            )\n\n        # Check if token is about to expire and refresh if needed\n        if self._admin_adapter is None or time.time() &gt;= self._admin_token_expiry:\n            self._initialize_admin_client()\n\n        if self._admin_adapter is None:\n            raise UnavailableError(\"Keycloak admin client is not available\")\n\n        return self._admin_adapter\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour, public key rarely changes\n    def get_public_key(self) -&gt; PublicKeyType:\n        \"\"\"Get the public key used to verify tokens.\n\n        Returns:\n            JWK key object used to verify signatures\n\n        Raises:\n            ServiceUnavailableError: If Keycloak service is unavailable\n            InternalError: If there's an internal error processing the public key\n        \"\"\"\n        try:\n            from jwcrypto import jwk\n\n            keys_info = self._openid_adapter.public_key()\n            key = f\"-----BEGIN PUBLIC KEY-----\\n{keys_info}\\n-----END PUBLIC KEY-----\"\n            return jwk.JWK.from_pem(key.encode(\"utf-8\"))\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_public_key\")\n        except Exception as e:\n            raise InternalError(additional_data={\"operation\": \"get_public_key\", \"error\": str(e)}) from e\n\n    @override\n    def get_token(self, username: str, password: str) -&gt; KeycloakTokenType | None:\n        \"\"\"Get a user token by username and password using the Resource Owner Password Credentials Grant.\n\n        Warning:\n            This method uses the direct password grant flow, which is less secure and not recommended\n            for user login in production environments. Instead, prefer the web-based OAuth 2.0\n            Authorization Code Flow (use `get_token_from_code`) for secure authentication.\n            Use this method only for testing, administrative tasks, or specific service accounts\n            where direct credential use is acceptable and properly secured.\n\n        Args:\n            username: User's username\n            password: User's password\n\n        Returns:\n            Token response containing access_token, refresh_token, etc.\n\n        Raises:\n            InvalidCredentialsError: If username or password is invalid\n            ServiceUnavailableError: If Keycloak service is unavailable\n        \"\"\"\n        try:\n            return self._openid_adapter.token(grant_type=\"password\", username=username, password=password)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_token\")\n\n    @override\n    def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType | None:\n        \"\"\"Refresh an existing token using a refresh token.\n\n        Args:\n            refresh_token: Refresh token string\n\n        Returns:\n            New token response containing access_token, refresh_token, etc.\n\n        Raises:\n            InvalidTokenError: If refresh token is invalid or expired\n            ServiceUnavailableError: If Keycloak service is unavailable\n        \"\"\"\n        try:\n            return self._openid_adapter.refresh_token(refresh_token)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"refresh_token\")\n\n    @override\n    def validate_token(self, token: str) -&gt; bool:\n        \"\"\"Validate if a token is still valid.\n\n        Args:\n            token: Access token to validate\n\n        Returns:\n            True if token is valid, False otherwise\n        \"\"\"\n        # Not caching validation results as tokens are time-sensitive\n        try:\n            self._openid_adapter.decode_token(\n                token,\n                key=self.get_public_key(),\n            )\n        except Exception as e:\n            logger.debug(f\"Token validation failed: {e!s}\")\n            return False\n        else:\n            return True\n\n    @override\n    def get_userinfo(self, token: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user information from a token.\n\n        Args:\n            token: Access token\n\n        Returns:\n            User information\n\n        Raises:\n            ValueError: If getting user info fails\n        \"\"\"\n        if not self.validate_token(token):\n            raise InvalidTokenError()\n        try:\n            return self._get_userinfo_cached(token)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_userinfo\")\n\n    @ttl_cache_decorator(ttl_seconds=30, maxsize=100)  # Cache for 30 seconds\n    def _get_userinfo_cached(self, token: str) -&gt; KeycloakUserType:\n        return self._openid_adapter.userinfo(token)\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by user ID.\n\n        Args:\n            user_id: User's ID\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If getting user fails\n        \"\"\"\n        try:\n            return self.admin_adapter.get_user(user_id)\n        except KeycloakGetError as e:\n            if e.response_code == 404:\n                return None\n            self._handle_keycloak_exception(e, \"get_user_by_id\")\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_user_by_id\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by username.\n\n        Args:\n            username: User's username\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If query fails\n        \"\"\"\n        try:\n            users = self.admin_adapter.get_users({\"username\": username})\n            return users[0] if users else None\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by email.\n\n        Args:\n            email: User's email\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If query fails\n        \"\"\"\n        try:\n            users = self.admin_adapter.get_users({\"email\": email})\n            return users[0] if users else None\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_user_by_email\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType] | None:\n        \"\"\"Get roles assigned to a user.\n\n        Args:\n            user_id: User's ID\n\n        Returns:\n            List of roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return self.admin_adapter.get_realm_roles_of_user(user_id)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_user_roles\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get client-specific roles assigned to a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n\n        Returns:\n            List of client-specific roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return self.admin_adapter.get_client_roles_of_user(user_id, client_id)\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    def create_user(self, user_data: dict[str, Any]) -&gt; str | None:\n        \"\"\"Create a new user in Keycloak.\n\n        Args:\n            user_data: User data including username, email, etc.\n\n        Returns:\n            ID of the created user\n\n        Raises:\n            ValueError: If creating user fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            user_id = self.admin_adapter.create_user(user_data)\n\n            # Clear related caches\n            self.clear_all_caches()\n\n        except KeycloakError as e:\n            self._handle_user_exception(e, \"create_user\", user_data)\n        else:\n            return user_id\n\n    @override\n    def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n        \"\"\"Update user details.\n\n        Args:\n            user_id: User's ID\n            user_data: User data to update\n\n        Raises:\n            ValueError: If updating user fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            self.admin_adapter.update_user(user_id, user_data)\n\n            # Clear user-related caches\n            self.clear_all_caches()\n\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"update_user\")\n\n    @override\n    def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n        \"\"\"Reset a user's password.\n\n        Args:\n            user_id: User's ID\n            password: New password\n            temporary: Whether the password is temporary and should be changed on next login\n\n        Raises:\n            ValueError: If password reset fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            self.admin_adapter.set_user_password(user_id, password, temporary)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"reset_password\")\n\n    @override\n    def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a realm role to a user.\n\n        Args:\n            user_id: User's ID\n            role_name: Role name to assign\n\n        Raises:\n            ValueError: If role assignment fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get role representation\n            role = self.admin_adapter.get_realm_role(role_name)\n            # Assign role to user\n            self.admin_adapter.assign_realm_roles(user_id, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_user_roles, \"clear_cache\"):\n                self.get_user_roles.clear_cache()\n\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"assign_realm_role\")\n\n    @override\n    def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a realm role from a user.\n\n        Args:\n            user_id: User's ID\n            role_name: Role name to remove\n\n        Raises:\n            ValueError: If role removal fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get role representation\n            role = self.admin_adapter.get_realm_role(role_name)\n            # Remove role from user\n            self.admin_adapter.delete_realm_roles_of_user(user_id, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_user_roles, \"clear_cache\"):\n                self.get_user_roles.clear_cache()\n\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"remove_realm_role\")\n\n    @override\n    def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a client-specific role to a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n            role_name: Role name to assign\n\n        Raises:\n            ValueError: If role assignment fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get client\n            client = self.admin_adapter.get_client_id(client_id)\n            # Get role representation\n            role = self.admin_adapter.get_client_role(client, role_name)\n            # Assign role to user\n            self.admin_adapter.assign_client_role(user_id, client, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n                self.get_client_roles_for_user.clear_cache()\n\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"assign_client_role\")\n\n    @override\n    def create_realm_role(\n        self,\n        role_name: str,\n        description: str | None = None,\n        skip_exists: bool = True,\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"Create a new realm role.\n\n        Args:\n            role_name: Role name\n            description: Optional role description\n            skip_exists: Skip creation if realm role already exists\n\n        Returns:\n            Created role details\n\n        Raises:\n            ValueError: If role creation fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            role_data = {\"name\": role_name}\n            if description:\n                role_data[\"description\"] = description\n\n            self.admin_adapter.create_realm_role(role_data, skip_exists=skip_exists)\n\n            # Clear realm roles cache\n            if hasattr(self.get_realm_roles, \"clear_cache\"):\n                self.get_realm_roles.clear_cache()\n\n            return self.admin_adapter.get_realm_role(role_name)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"create_realm_role\")\n\n    @override\n    def create_client_role(\n        self,\n        client_id: str,\n        role_name: str,\n        description: str | None = None,\n        skip_exists: bool = True,\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"Create a new client role.\n\n        Args:\n            client_id: Client ID or client name\n            role_name: Role name\n            description: Optional role description\n            skip_exists: Skip creation if client role already exists\n\n        Returns:\n            Created role details\n\n        Raises:\n            ValueError: If role creation fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            client_id = self.admin_adapter.get_client_id(client_id)\n\n            # Prepare role data\n            role_data = {\"name\": role_name}\n            if description:\n                role_data[\"description\"] = description\n\n            # Create client role\n            self.admin_adapter.create_client_role(client_id, role_data, skip_exists=skip_exists)\n\n            # Clear related caches if they exist\n            if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n                self.get_client_roles_for_user.clear_cache()\n\n            # Return created role\n            return self.admin_adapter.get_client_role(client_id, role_name)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"create_client_role\")\n\n    @override\n    def delete_realm_role(self, role_name: str) -&gt; None:\n        \"\"\"Delete a realm role.\n\n        Args:\n            role_name: Role name to delete\n\n        Raises:\n            ValueError: If role deletion fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            self.admin_adapter.delete_realm_role(role_name)\n\n            # Clear realm roles cache\n            if hasattr(self.get_realm_roles, \"clear_cache\"):\n                self.get_realm_roles.clear_cache()\n\n            # We also need to clear user role caches since they might contain this role\n            if hasattr(self.get_user_roles, \"clear_cache\"):\n                self.get_user_roles.clear_cache()\n\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"delete_realm_role\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\n    def get_service_account_id(self) -&gt; str | None:\n        \"\"\"Get service account user ID for the current client.\n\n        Returns:\n            Service account user ID\n\n        Raises:\n            ValueError: If getting service account fails\n        \"\"\"\n        try:\n            client_id = self.get_client_id(self.configs.CLIENT_ID)\n            return self.admin_adapter.get_client_service_account_user(str(client_id)).get(\"id\")\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_service_account_id\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\n    def get_well_known_config(self) -&gt; dict[str, Any] | None:\n        \"\"\"Get the well-known OpenID configuration.\n\n        Returns:\n            OIDC configuration\n\n        Raises:\n            ValueError: If getting configuration fails\n        \"\"\"\n        try:\n            return self._openid_adapter.well_known()\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_well_known_config\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\n    def get_certs(self) -&gt; dict[str, Any] | None:\n        \"\"\"Get the JWT verification certificates.\n\n        Returns:\n            Certificate information\n\n        Raises:\n            ValueError: If getting certificates fails\n        \"\"\"\n        try:\n            return self._openid_adapter.certs()\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_certs\")\n\n    @override\n    def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType | None:\n        \"\"\"Exchange authorization code for token.\n\n        Args:\n            code: Authorization code\n            redirect_uri: Redirect URI used in authorization request\n\n        Returns:\n            Token response\n\n        Raises:\n            ValueError: If token exchange fails\n        \"\"\"\n        # Authorization codes can only be used once, don't cache\n        try:\n            return self._openid_adapter.token(grant_type=\"authorization_code\", code=code, redirect_uri=redirect_uri)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_token_from_code\")\n\n    @override\n    def get_client_credentials_token(self) -&gt; KeycloakTokenType | None:\n        \"\"\"Get token using client credentials.\n\n        Returns:\n            Token response\n\n        Raises:\n            ValueError: If token acquisition fails\n        \"\"\"\n        # Tokens are time-sensitive, don't cache\n        try:\n            return self._openid_adapter.token(grant_type=\"client_credentials\")\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_client_credentials_token\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=30, maxsize=50)  # Cache for 30 seconds with limited entries\n    def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType] | None:\n        \"\"\"Search for users by username, email, or name.\n\n        Args:\n            query: Search query\n            max_results: Maximum number of results to return\n\n        Returns:\n            List of matching users\n\n        Raises:\n            ValueError: If search fails\n        \"\"\"\n        try:\n            # Try searching by different fields\n            users = []\n\n            # Search by username\n            users.extend(self.admin_adapter.get_users({\"username\": query, \"max\": max_results}))\n\n            # Search by email if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                email_users = self.admin_adapter.get_users({\"email\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in email_users if user[\"id\"] not in user_ids])\n\n            # Search by firstName if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                first_name_users = self.admin_adapter.get_users({\"firstName\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in first_name_users if user[\"id\"] not in user_ids])\n\n            # Search by lastName if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                last_name_users = self.admin_adapter.get_users({\"lastName\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in last_name_users if user[\"id\"] not in user_ids])\n\n            return users[:max_results]\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"search_users\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=50)  # Cache for 1 hour\n    def get_client_secret(self, client_id: str) -&gt; str | None:\n        \"\"\"Get client secret.\n\n        Args:\n            client_id: Client ID\n\n        Returns:\n            Client secret\n\n        Raises:\n            ValueError: If getting secret fails\n        \"\"\"\n        try:\n            client = self.admin_adapter.get_client(client_id)\n            return client.get(\"secret\", \"\")\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_client_secret\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=50)  # Cache for 1 hour\n    def get_client_id(self, client_name: str) -&gt; str | None:\n        \"\"\"Get client ID by client name.\n\n        Args:\n            client_name: Name of the client\n\n        Returns:\n            Client ID\n\n        Raises:\n            ValueError: If client not found\n        \"\"\"\n        try:\n            return self.admin_adapter.get_client_id(client_name)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_client_id\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=1)  # Cache for 5 minutes\n    def get_realm_roles(self) -&gt; list[dict[str, Any]] | None:\n        \"\"\"Get all realm roles.\n\n        Returns:\n            List of realm roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return self.admin_adapter.get_realm_roles()\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_realm_roles\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=1)  # Cache for 5 minutes\n    def get_realm_role(self, role_name: str) -&gt; dict | None:\n        \"\"\"Get realm role.\n\n        Args:\n            role_name: Role name\n        Returns:\n            A realm role\n\n        Raises:\n            ValueError: If getting role fails\n        \"\"\"\n        try:\n            return self.admin_adapter.get_realm_role(role_name)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_realm_role\")\n\n    @override\n    def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a client-specific role from a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n            role_name: Role name to remove\n\n        Raises:\n            ValueError: If role removal fails\n        \"\"\"\n        try:\n            client = self.admin_adapter.get_client_id(client_id)\n            role = self.admin_adapter.get_client_role(client, role_name)\n            self.admin_adapter.delete_client_roles_of_user(user_id, client, [role])\n\n            if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n                self.get_client_roles_for_user.clear_cache()\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"remove_client_role\")\n\n    @override\n    def clear_user_sessions(self, user_id: str) -&gt; None:\n        \"\"\"Clear all sessions for a user.\n\n        Args:\n            user_id: User's ID\n\n        Raises:\n            ValueError: If clearing sessions fails\n        \"\"\"\n        try:\n            self.admin_adapter.user_logout(user_id)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"clear_user_sessions\")\n\n    @override\n    def logout(self, refresh_token: str) -&gt; None:\n        \"\"\"Logout user by invalidating their refresh token.\n\n        Args:\n            refresh_token: Refresh token to invalidate\n\n        Raises:\n            ValueError: If logout fails\n        \"\"\"\n        try:\n            self._openid_adapter.logout(refresh_token)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"logout\")\n\n    @override\n    def introspect_token(self, token: str) -&gt; dict[str, Any] | None:\n        \"\"\"Introspect token to get detailed information about it.\n\n        Args:\n            token: Access token\n\n        Returns:\n            Token introspection details\n\n        Raises:\n            ValueError: If token introspection fails\n        \"\"\"\n        try:\n            return self._openid_adapter.introspect(token)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"introspect_token\")\n\n    @override\n    def get_token_info(self, token: str) -&gt; dict[str, Any] | None:\n        \"\"\"Decode token to get its claims.\n\n        Args:\n            token: Access token\n\n        Returns:\n            Dictionary of token claims\n\n        Raises:\n            ValueError: If token decoding fails\n        \"\"\"\n        try:\n            return self._openid_adapter.decode_token(\n                token,\n                key=self.get_public_key(),\n            )\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_token_info\")\n\n    @override\n    def delete_user(self, user_id: str) -&gt; None:\n        \"\"\"Delete a user from Keycloak by their ID.\n\n        Args:\n            user_id: The ID of the user to delete\n\n        Raises:\n            ValueError: If the deletion fails\n        \"\"\"\n        try:\n            self.admin_adapter.delete_user(user_id=user_id)\n\n            if hasattr(self.get_user_by_username, \"clear_cache\"):\n                self.get_user_by_username.clear_cache()\n\n            logger.info(f\"Successfully deleted user with ID {user_id}\")\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"delete_user\")\n\n    @override\n    def has_role(self, token: str, role_name: str) -&gt; bool:\n        \"\"\"Check if a user has a specific role.\n\n        Args:\n            token: Access token\n            role_name: Role name to check\n\n        Returns:\n            True if user has the role, False otherwise\n        \"\"\"\n        # Not caching this result as token validation is time-sensitive\n        try:\n            user_info = self.get_userinfo(token)\n\n            # Check realm roles\n            realm_access = user_info.get(\"realm_access\", {})\n            roles = realm_access.get(\"roles\", [])\n            if role_name in roles:\n                return True\n\n            # Check client roles\n            resource_access = user_info.get(\"resource_access\", {})\n            client_roles = resource_access.get(self.configs.CLIENT_ID, {}).get(\"roles\", [])\n            if role_name in client_roles:\n                return True\n\n        except Exception as e:\n            logger.debug(f\"Role check failed: {e!s}\")\n            return False\n        else:\n            return False\n\n    @override\n    def has_any_of_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n        \"\"\"Check if a user has any of the specified roles.\n\n        Args:\n            token: Access token\n            role_names: Set of role names to check\n\n        Returns:\n            True if user has any of the roles, False otherwise\n        \"\"\"\n        try:\n            user_info = self.get_userinfo(token)\n\n            # Check realm roles first\n            realm_access = user_info.get(\"realm_access\", {})\n            realm_roles = set(realm_access.get(\"roles\", []))\n            if role_names.intersection(realm_roles):\n                return True\n\n            # Check roles for the configured client\n            resource_access = user_info.get(\"resource_access\", {})\n            client_roles = set(resource_access.get(self.configs.CLIENT_ID, {}).get(\"roles\", []))\n            if role_names.intersection(client_roles):\n                return True\n\n        except Exception as e:\n            logger.debug(f\"Role check failed: {e!s}\")\n            return False\n        else:\n            return False\n\n    @override\n    def has_all_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n        \"\"\"Check if a user has all the specified roles.\n\n        Args:\n            token: Access token\n            role_names: Set of role names to check\n\n        Returns:\n            True if user has all the roles, False otherwise\n        \"\"\"\n        try:\n            user_info = self.get_userinfo(token)\n\n            # Get all user roles\n            all_roles = set()\n\n            # Add realm roles\n            realm_access = user_info.get(\"realm_access\", {})\n            all_roles.update(realm_access.get(\"roles\", []))\n\n            # Add client roles\n            resource_access = user_info.get(\"resource_access\", {})\n            client_roles = resource_access.get(self.configs.CLIENT_ID, {}).get(\"roles\", [])\n            all_roles.update(client_roles)\n\n            # Check if all required roles are present\n            return role_names.issubset(all_roles)\n\n        except Exception as e:\n            logger.debug(f\"All roles check failed: {e!s}\")\n            return False\n\n    @override\n    def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n        \"\"\"Check if a user has permission to access a resource with the specified scope.\n\n        Args:\n            token: Access token\n            resource: Resource name\n            scope: Permission scope\n\n        Returns:\n            True if permission granted, False otherwise\n        \"\"\"\n        try:\n            # Use UMA permissions endpoint to check specific resource and scope\n            permissions = self._openid_adapter.uma_permissions(token, permissions=f\"{resource}#{scope}\")\n\n            # Check if the response indicates permission is granted\n            if not permissions or not isinstance(permissions, list):\n                logger.debug(\"No permissions returned or invalid response format\")\n                return False\n\n            # Look for the specific permission in the response\n            for perm in permissions:\n                if perm.get(\"rsname\") == resource and scope in perm.get(\"scopes\", []):\n                    return True\n\n        except KeycloakError as e:\n            logger.debug(f\"Permission check failed with Keycloak error: {e!s}\")\n            return False\n        except Exception as e:\n            logger.debug(f\"Permission check failed with unexpected error: {e!s}\")\n            return False\n        else:\n            return False\n\n    @override\n    def create_realm(self, realm_name: str, skip_exists: bool = True, **kwargs: Any) -&gt; dict[str, Any] | None:\n        \"\"\"Create a Keycloak realm with minimum required fields and optional additional config.\n\n        Args:\n            realm_name: The realm identifier (required)\n            skip_exists: Skip creation if realm already exists\n            kwargs: Additional optional configurations for the realm\n\n        Returns:\n            Realm details\n        \"\"\"\n        payload = {\n            \"realm\": realm_name,\n            \"enabled\": kwargs.get(\"enabled\", True),\n            \"displayName\": kwargs.get(\"display_name\", realm_name),\n        }\n\n        # Add any additional parameters from kwargs\n        for key, value in kwargs.items():\n            # Skip display_name as it's already handled\n            if key == \"display_name\":\n                continue\n\n            # Convert Python snake_case to Keycloak camelCase\n            camel_key = StringUtils.snake_to_camel_case(key)\n            payload[camel_key] = value\n\n        try:\n            self.admin_adapter.create_realm(payload=payload, skip_exists=skip_exists)\n        except KeycloakError as e:\n            logger.debug(f\"Failed to create realm: {e!s}\")\n\n            # Handle realm already exists with skip_exists option\n            if skip_exists:\n                error_message = self._extract_error_message(e).lower()\n                if \"already exists\" in error_message and \"realm\" in error_message:\n                    return {\"realm\": realm_name, \"status\": \"already_exists\", \"config\": payload}\n\n            # Use the mixin to handle realm-specific errors\n            self._handle_realm_exception(e, \"create_realm\", realm_name)\n        else:\n            return {\"realm\": realm_name, \"status\": \"created\", \"config\": payload}\n\n    @override\n    def get_realm(self, realm_name: str) -&gt; dict[str, Any] | None:\n        \"\"\"Get realm details by realm name.\n\n        Args:\n            realm_name: Name of the realm\n\n        Returns:\n            Realm details\n        \"\"\"\n        try:\n            return self.admin_adapter.get_realm(realm_name)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_realm\")\n\n    @override\n    def create_client(\n        self,\n        client_id: str,\n        realm: str | None = None,\n        skip_exists: bool = True,\n        **kwargs: Any,\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"Create a Keycloak client with minimum required fields and optional additional config.\n\n        Args:\n            client_id: The client identifier (required)\n            realm: Target realm name (uses the current realm in KeycloakAdmin if not specified)\n            skip_exists: Skip creation if client already exists\n            kwargs: Additional optional configurations for the client\n\n        Returns:\n            Client details\n        \"\"\"\n        original_realm = self.admin_adapter.connection.realm_name\n\n        try:\n            # Set the target realm if provided\n            if realm and realm != original_realm:\n                self.admin_adapter.connection.realm_name = realm\n\n            public_client = kwargs.get(\"public_client\", False)\n\n            # Prepare the minimal client payload\n            payload = {\n                \"clientId\": client_id,\n                \"enabled\": kwargs.get(\"enabled\", True),\n                \"protocol\": kwargs.get(\"protocol\", \"openid-connect\"),\n                \"name\": kwargs.get(\"name\", client_id),\n                \"publicClient\": public_client,\n            }\n\n            # Enable service accounts for confidential clients by default\n            if not public_client:\n                payload[\"serviceAccountsEnabled\"] = kwargs.get(\"service_account_enabled\", True)\n                payload[\"clientAuthenticatorType\"] = \"client-secret\"\n\n            for key, value in kwargs.items():\n                if key in [\"enabled\", \"protocol\", \"name\", \"public_client\", \"service_account_enabled\"]:\n                    continue\n\n                # Convert snake_case to camelCase\n                camel_key = StringUtils.snake_to_camel_case(key)\n                payload[camel_key] = value\n\n            internal_client_id = None\n            try:\n                internal_client_id = self.admin_adapter.create_client(payload, skip_exists=skip_exists)\n            except KeycloakError as e:\n                logger.debug(f\"Failed to create client: {e!s}\")\n\n                # Handle client already exists with skip_exists option\n                if skip_exists:\n                    error_message = self._extract_error_message(e).lower()\n                    if \"already exists\" in error_message and \"client\" in error_message:\n                        return {\n                            \"client_id\": client_id,\n                            \"status\": \"already_exists\",\n                            \"realm\": self.admin_adapter.connection.realm_name,\n                        }\n\n                # Use the mixin to handle client-specific errors\n                client_data = {\"clientId\": client_id, \"name\": kwargs.get(\"name\", client_id)}\n                self._handle_client_exception(e, \"create_client\", client_data)\n\n            return {\n                \"client_id\": client_id,\n                \"internal_client_id\": internal_client_id,\n                \"realm\": self.admin_adapter.connection.realm_name,\n                \"status\": \"created\",\n            }\n\n        finally:\n            # Always restore the original realm\n            if realm and realm != original_realm:\n                self.admin_adapter.connection.realm_name = original_realm\n\n    @override\n    def add_realm_roles_to_composite(self, composite_role_name: str, child_role_names: list[str]) -&gt; None:\n        \"\"\"Add realm roles to a composite role.\n\n        Args:\n            composite_role_name: Name of the composite realm role\n            child_role_names: List of child role names to add\n        \"\"\"\n        try:\n            child_roles = []\n            for role_name in child_role_names:\n                try:\n                    role = self.admin_adapter.get_realm_role(role_name)\n                    child_roles.append(role)\n                except KeycloakGetError as e:\n                    if e.response_code == 404:\n                        logger.warning(f\"Child role not found: {role_name}\")\n                        continue\n                    raise\n\n            if child_roles:\n                self.admin_adapter.add_composite_realm_roles_to_role(role_name=composite_role_name, roles=child_roles)\n                logger.info(f\"Added {len(child_roles)} realm roles to composite role: {composite_role_name}\")\n\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"add_realm_roles_to_composite\")\n\n    @override\n    def add_client_roles_to_composite(\n        self,\n        composite_role_name: str,\n        client_id: str,\n        child_role_names: list[str],\n    ) -&gt; None:\n        \"\"\"Add client roles to a composite role.\n\n        Args:\n            composite_role_name: Name of the composite client role\n            client_id: Client ID or client name\n            child_role_names: List of child role names to add\n        \"\"\"\n        try:\n            internal_client_id = self.admin_adapter.get_client_id(client_id)\n\n            child_roles = []\n            for role_name in child_role_names:\n                try:\n                    role = self.admin_adapter.get_client_role(internal_client_id, role_name)\n                    child_roles.append(role)\n                except KeycloakGetError as e:\n                    if e.response_code == 404:\n                        logger.warning(f\"Client role not found: {role_name}\")\n                        continue\n                    raise\n\n            if child_roles:\n                self.admin_adapter.add_composite_client_roles_to_role(\n                    role_name=composite_role_name,\n                    client_role_id=internal_client_id,\n                    roles=child_roles,\n                )\n                logger.info(f\"Added {len(child_roles)} client roles to composite role: {composite_role_name}\")\n\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"add_client_roles_to_composite\")\n\n    @override\n    def get_composite_realm_roles(self, role_name: str) -&gt; list[dict[str, Any]] | None:\n        \"\"\"Get composite roles for a realm role.\n\n        Args:\n            role_name: Name of the role\n\n        Returns:\n            List of composite roles\n        \"\"\"\n        try:\n            return self.admin_adapter.get_composite_realm_roles_of_role(role_name)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_composite_realm_roles\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.admin_adapter","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.admin_adapter</code>  <code>property</code>","text":"<p>Get the admin adapter, refreshing it if necessary.</p> <p>Returns:</p> Type Description <code>KeycloakAdmin</code> <p>KeycloakAdmin instance</p> <p>Raises:</p> Type Description <code>UnauthenticatedError</code> <p>If admin client is not available due to authentication issues</p> <code>UnavailableError</code> <p>If Keycloak service is unavailable</p>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.__init__","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.__init__(keycloak_configs=None)</code>","text":"<p>Initialize KeycloakAdapter with configuration.</p> <p>Parameters:</p> Name Type Description Default <code>keycloak_configs</code> <code>KeycloakConfig | None</code> <p>Optional Keycloak configuration. If None, global config is used.</p> <code>None</code> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>def __init__(self, keycloak_configs: KeycloakConfig | None = None) -&gt; None:\n    \"\"\"Initialize KeycloakAdapter with configuration.\n\n    Args:\n        keycloak_configs: Optional Keycloak configuration. If None, global config is used.\n    \"\"\"\n    self.configs: KeycloakConfig = (\n        BaseConfig.global_config().KEYCLOAK if keycloak_configs is None else keycloak_configs\n    )\n\n    # Initialize the OpenID client for authentication\n    self._openid_adapter = self._get_openid_client(self.configs)\n\n    # Cache for admin client to avoid unnecessary re-authentication\n    self._admin_adapter: KeycloakAdmin | None = None\n    self._admin_token_expiry: float = 0.0\n\n    # Initialize admin client if admin mode is enabled and credentials are provided\n    if self.configs.IS_ADMIN_MODE_ENABLED and (\n        self.configs.CLIENT_SECRET_KEY or (self.configs.ADMIN_USERNAME and self.configs.ADMIN_PASSWORD)\n    ):\n        self._initialize_admin_client()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.clear_all_caches","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.clear_all_caches()</code>","text":"<p>Clear all cached values.</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>def clear_all_caches(self) -&gt; None:\n    \"\"\"Clear all cached values.\"\"\"\n    for attr_name in dir(self):\n        attr = getattr(self, attr_name)\n        if hasattr(attr, \"clear_cache\"):\n            attr.clear_cache()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_public_key","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_public_key()</code>","text":"<p>Get the public key used to verify tokens.</p> <p>Returns:</p> Type Description <code>PublicKeyType</code> <p>JWK key object used to verify signatures</p> <p>Raises:</p> Type Description <code>ServiceUnavailableError</code> <p>If Keycloak service is unavailable</p> <code>InternalError</code> <p>If there's an internal error processing the public key</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour, public key rarely changes\ndef get_public_key(self) -&gt; PublicKeyType:\n    \"\"\"Get the public key used to verify tokens.\n\n    Returns:\n        JWK key object used to verify signatures\n\n    Raises:\n        ServiceUnavailableError: If Keycloak service is unavailable\n        InternalError: If there's an internal error processing the public key\n    \"\"\"\n    try:\n        from jwcrypto import jwk\n\n        keys_info = self._openid_adapter.public_key()\n        key = f\"-----BEGIN PUBLIC KEY-----\\n{keys_info}\\n-----END PUBLIC KEY-----\"\n        return jwk.JWK.from_pem(key.encode(\"utf-8\"))\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_public_key\")\n    except Exception as e:\n        raise InternalError(additional_data={\"operation\": \"get_public_key\", \"error\": str(e)}) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token(username, password)</code>","text":"<p>Get a user token by username and password using the Resource Owner Password Credentials Grant.</p> Warning <p>This method uses the direct password grant flow, which is less secure and not recommended for user login in production environments. Instead, prefer the web-based OAuth 2.0 Authorization Code Flow (use <code>get_token_from_code</code>) for secure authentication. Use this method only for testing, administrative tasks, or specific service accounts where direct credential use is acceptable and properly secured.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>User's username</p> required <code>password</code> <code>str</code> <p>User's password</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType | None</code> <p>Token response containing access_token, refresh_token, etc.</p> <p>Raises:</p> Type Description <code>InvalidCredentialsError</code> <p>If username or password is invalid</p> <code>ServiceUnavailableError</code> <p>If Keycloak service is unavailable</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef get_token(self, username: str, password: str) -&gt; KeycloakTokenType | None:\n    \"\"\"Get a user token by username and password using the Resource Owner Password Credentials Grant.\n\n    Warning:\n        This method uses the direct password grant flow, which is less secure and not recommended\n        for user login in production environments. Instead, prefer the web-based OAuth 2.0\n        Authorization Code Flow (use `get_token_from_code`) for secure authentication.\n        Use this method only for testing, administrative tasks, or specific service accounts\n        where direct credential use is acceptable and properly secured.\n\n    Args:\n        username: User's username\n        password: User's password\n\n    Returns:\n        Token response containing access_token, refresh_token, etc.\n\n    Raises:\n        InvalidCredentialsError: If username or password is invalid\n        ServiceUnavailableError: If Keycloak service is unavailable\n    \"\"\"\n    try:\n        return self._openid_adapter.token(grant_type=\"password\", username=username, password=password)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_token\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.refresh_token","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.refresh_token(refresh_token)</code>","text":"<p>Refresh an existing token using a refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str</code> <p>Refresh token string</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType | None</code> <p>New token response containing access_token, refresh_token, etc.</p> <p>Raises:</p> Type Description <code>InvalidTokenError</code> <p>If refresh token is invalid or expired</p> <code>ServiceUnavailableError</code> <p>If Keycloak service is unavailable</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType | None:\n    \"\"\"Refresh an existing token using a refresh token.\n\n    Args:\n        refresh_token: Refresh token string\n\n    Returns:\n        New token response containing access_token, refresh_token, etc.\n\n    Raises:\n        InvalidTokenError: If refresh token is invalid or expired\n        ServiceUnavailableError: If Keycloak service is unavailable\n    \"\"\"\n    try:\n        return self._openid_adapter.refresh_token(refresh_token)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"refresh_token\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.validate_token","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.validate_token(token)</code>","text":"<p>Validate if a token is still valid.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token to validate</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if token is valid, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef validate_token(self, token: str) -&gt; bool:\n    \"\"\"Validate if a token is still valid.\n\n    Args:\n        token: Access token to validate\n\n    Returns:\n        True if token is valid, False otherwise\n    \"\"\"\n    # Not caching validation results as tokens are time-sensitive\n    try:\n        self._openid_adapter.decode_token(\n            token,\n            key=self.get_public_key(),\n        )\n    except Exception as e:\n        logger.debug(f\"Token validation failed: {e!s}\")\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_userinfo","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_userinfo(token)</code>","text":"<p>Get user information from a token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User information</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting user info fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef get_userinfo(self, token: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user information from a token.\n\n    Args:\n        token: Access token\n\n    Returns:\n        User information\n\n    Raises:\n        ValueError: If getting user info fails\n    \"\"\"\n    if not self.validate_token(token):\n        raise InvalidTokenError()\n    try:\n        return self._get_userinfo_cached(token)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_userinfo\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_id","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_id(user_id)</code>","text":"<p>Get user details by user ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by user ID.\n\n    Args:\n        user_id: User's ID\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If getting user fails\n    \"\"\"\n    try:\n        return self.admin_adapter.get_user(user_id)\n    except KeycloakGetError as e:\n        if e.response_code == 404:\n            return None\n        self._handle_keycloak_exception(e, \"get_user_by_id\")\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_user_by_id\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_username","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_username(username)</code>","text":"<p>Get user details by username.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>User's username</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If query fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by username.\n\n    Args:\n        username: User's username\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If query fails\n    \"\"\"\n    try:\n        users = self.admin_adapter.get_users({\"username\": username})\n        return users[0] if users else None\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_email","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_email(email)</code>","text":"<p>Get user details by email.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>User's email</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If query fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by email.\n\n    Args:\n        email: User's email\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If query fails\n    \"\"\"\n    try:\n        users = self.admin_adapter.get_users({\"email\": email})\n        return users[0] if users else None\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_user_by_email\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_roles","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_roles(user_id)</code>","text":"<p>Get roles assigned to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Returns:</p> Type Description <code>list[KeycloakRoleType] | None</code> <p>List of roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType] | None:\n    \"\"\"Get roles assigned to a user.\n\n    Args:\n        user_id: User's ID\n\n    Returns:\n        List of roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return self.admin_adapter.get_realm_roles_of_user(user_id)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_user_roles\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_roles_for_user","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_roles_for_user(user_id, client_id)</code>","text":"<p>Get client-specific roles assigned to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <p>Returns:</p> Type Description <code>list[KeycloakRoleType]</code> <p>List of client-specific roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get client-specific roles assigned to a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n\n    Returns:\n        List of client-specific roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return self.admin_adapter.get_client_roles_of_user(user_id, client_id)\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.create_user","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.create_user(user_data)</code>","text":"<p>Create a new user in Keycloak.</p> <p>Parameters:</p> Name Type Description Default <code>user_data</code> <code>dict[str, Any]</code> <p>User data including username, email, etc.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>ID of the created user</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If creating user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef create_user(self, user_data: dict[str, Any]) -&gt; str | None:\n    \"\"\"Create a new user in Keycloak.\n\n    Args:\n        user_data: User data including username, email, etc.\n\n    Returns:\n        ID of the created user\n\n    Raises:\n        ValueError: If creating user fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        user_id = self.admin_adapter.create_user(user_data)\n\n        # Clear related caches\n        self.clear_all_caches()\n\n    except KeycloakError as e:\n        self._handle_user_exception(e, \"create_user\", user_data)\n    else:\n        return user_id\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.update_user","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.update_user(user_id, user_data)</code>","text":"<p>Update user details.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>user_data</code> <code>dict[str, Any]</code> <p>User data to update</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If updating user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n    \"\"\"Update user details.\n\n    Args:\n        user_id: User's ID\n        user_data: User data to update\n\n    Raises:\n        ValueError: If updating user fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        self.admin_adapter.update_user(user_id, user_data)\n\n        # Clear user-related caches\n        self.clear_all_caches()\n\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"update_user\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.reset_password","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.reset_password(user_id, password, temporary=False)</code>","text":"<p>Reset a user's password.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>password</code> <code>str</code> <p>New password</p> required <code>temporary</code> <code>bool</code> <p>Whether the password is temporary and should be changed on next login</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If password reset fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n    \"\"\"Reset a user's password.\n\n    Args:\n        user_id: User's ID\n        password: New password\n        temporary: Whether the password is temporary and should be changed on next login\n\n    Raises:\n        ValueError: If password reset fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        self.admin_adapter.set_user_password(user_id, password, temporary)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"reset_password\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.assign_realm_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.assign_realm_role(user_id, role_name)</code>","text":"<p>Assign a realm role to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>role_name</code> <code>str</code> <p>Role name to assign</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role assignment fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a realm role to a user.\n\n    Args:\n        user_id: User's ID\n        role_name: Role name to assign\n\n    Raises:\n        ValueError: If role assignment fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get role representation\n        role = self.admin_adapter.get_realm_role(role_name)\n        # Assign role to user\n        self.admin_adapter.assign_realm_roles(user_id, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_user_roles, \"clear_cache\"):\n            self.get_user_roles.clear_cache()\n\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"assign_realm_role\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.remove_realm_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.remove_realm_role(user_id, role_name)</code>","text":"<p>Remove a realm role from a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>role_name</code> <code>str</code> <p>Role name to remove</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role removal fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a realm role from a user.\n\n    Args:\n        user_id: User's ID\n        role_name: Role name to remove\n\n    Raises:\n        ValueError: If role removal fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get role representation\n        role = self.admin_adapter.get_realm_role(role_name)\n        # Remove role from user\n        self.admin_adapter.delete_realm_roles_of_user(user_id, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_user_roles, \"clear_cache\"):\n            self.get_user_roles.clear_cache()\n\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"remove_realm_role\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.assign_client_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.assign_client_role(user_id, client_id, role_name)</code>","text":"<p>Assign a client-specific role to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>role_name</code> <code>str</code> <p>Role name to assign</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role assignment fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a client-specific role to a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n        role_name: Role name to assign\n\n    Raises:\n        ValueError: If role assignment fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get client\n        client = self.admin_adapter.get_client_id(client_id)\n        # Get role representation\n        role = self.admin_adapter.get_client_role(client, role_name)\n        # Assign role to user\n        self.admin_adapter.assign_client_role(user_id, client, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n            self.get_client_roles_for_user.clear_cache()\n\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"assign_client_role\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.create_realm_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.create_realm_role(role_name, description=None, skip_exists=True)</code>","text":"<p>Create a new realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name</p> required <code>description</code> <code>str | None</code> <p>Optional role description</p> <code>None</code> <code>skip_exists</code> <code>bool</code> <p>Skip creation if realm role already exists</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Created role details</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If role creation fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef create_realm_role(\n    self,\n    role_name: str,\n    description: str | None = None,\n    skip_exists: bool = True,\n) -&gt; dict[str, Any] | None:\n    \"\"\"Create a new realm role.\n\n    Args:\n        role_name: Role name\n        description: Optional role description\n        skip_exists: Skip creation if realm role already exists\n\n    Returns:\n        Created role details\n\n    Raises:\n        ValueError: If role creation fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        role_data = {\"name\": role_name}\n        if description:\n            role_data[\"description\"] = description\n\n        self.admin_adapter.create_realm_role(role_data, skip_exists=skip_exists)\n\n        # Clear realm roles cache\n        if hasattr(self.get_realm_roles, \"clear_cache\"):\n            self.get_realm_roles.clear_cache()\n\n        return self.admin_adapter.get_realm_role(role_name)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"create_realm_role\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.create_client_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.create_client_role(client_id, role_name, description=None, skip_exists=True)</code>","text":"<p>Create a new client role.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Client ID or client name</p> required <code>role_name</code> <code>str</code> <p>Role name</p> required <code>description</code> <code>str | None</code> <p>Optional role description</p> <code>None</code> <code>skip_exists</code> <code>bool</code> <p>Skip creation if client role already exists</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Created role details</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If role creation fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef create_client_role(\n    self,\n    client_id: str,\n    role_name: str,\n    description: str | None = None,\n    skip_exists: bool = True,\n) -&gt; dict[str, Any] | None:\n    \"\"\"Create a new client role.\n\n    Args:\n        client_id: Client ID or client name\n        role_name: Role name\n        description: Optional role description\n        skip_exists: Skip creation if client role already exists\n\n    Returns:\n        Created role details\n\n    Raises:\n        ValueError: If role creation fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        client_id = self.admin_adapter.get_client_id(client_id)\n\n        # Prepare role data\n        role_data = {\"name\": role_name}\n        if description:\n            role_data[\"description\"] = description\n\n        # Create client role\n        self.admin_adapter.create_client_role(client_id, role_data, skip_exists=skip_exists)\n\n        # Clear related caches if they exist\n        if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n            self.get_client_roles_for_user.clear_cache()\n\n        # Return created role\n        return self.admin_adapter.get_client_role(client_id, role_name)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"create_client_role\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.delete_realm_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.delete_realm_role(role_name)</code>","text":"<p>Delete a realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name to delete</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role deletion fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef delete_realm_role(self, role_name: str) -&gt; None:\n    \"\"\"Delete a realm role.\n\n    Args:\n        role_name: Role name to delete\n\n    Raises:\n        ValueError: If role deletion fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        self.admin_adapter.delete_realm_role(role_name)\n\n        # Clear realm roles cache\n        if hasattr(self.get_realm_roles, \"clear_cache\"):\n            self.get_realm_roles.clear_cache()\n\n        # We also need to clear user role caches since they might contain this role\n        if hasattr(self.get_user_roles, \"clear_cache\"):\n            self.get_user_roles.clear_cache()\n\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"delete_realm_role\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_service_account_id","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_service_account_id()</code>","text":"<p>Get service account user ID for the current client.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>Service account user ID</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting service account fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\ndef get_service_account_id(self) -&gt; str | None:\n    \"\"\"Get service account user ID for the current client.\n\n    Returns:\n        Service account user ID\n\n    Raises:\n        ValueError: If getting service account fails\n    \"\"\"\n    try:\n        client_id = self.get_client_id(self.configs.CLIENT_ID)\n        return self.admin_adapter.get_client_service_account_user(str(client_id)).get(\"id\")\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_service_account_id\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_well_known_config","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_well_known_config()</code>","text":"<p>Get the well-known OpenID configuration.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>OIDC configuration</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting configuration fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\ndef get_well_known_config(self) -&gt; dict[str, Any] | None:\n    \"\"\"Get the well-known OpenID configuration.\n\n    Returns:\n        OIDC configuration\n\n    Raises:\n        ValueError: If getting configuration fails\n    \"\"\"\n    try:\n        return self._openid_adapter.well_known()\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_well_known_config\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_certs","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_certs()</code>","text":"<p>Get the JWT verification certificates.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Certificate information</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting certificates fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\ndef get_certs(self) -&gt; dict[str, Any] | None:\n    \"\"\"Get the JWT verification certificates.\n\n    Returns:\n        Certificate information\n\n    Raises:\n        ValueError: If getting certificates fails\n    \"\"\"\n    try:\n        return self._openid_adapter.certs()\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_certs\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token_from_code","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token_from_code(code, redirect_uri)</code>","text":"<p>Exchange authorization code for token.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Authorization code</p> required <code>redirect_uri</code> <code>str</code> <p>Redirect URI used in authorization request</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType | None</code> <p>Token response</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token exchange fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType | None:\n    \"\"\"Exchange authorization code for token.\n\n    Args:\n        code: Authorization code\n        redirect_uri: Redirect URI used in authorization request\n\n    Returns:\n        Token response\n\n    Raises:\n        ValueError: If token exchange fails\n    \"\"\"\n    # Authorization codes can only be used once, don't cache\n    try:\n        return self._openid_adapter.token(grant_type=\"authorization_code\", code=code, redirect_uri=redirect_uri)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_token_from_code\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_credentials_token","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_credentials_token()</code>","text":"<p>Get token using client credentials.</p> <p>Returns:</p> Type Description <code>KeycloakTokenType | None</code> <p>Token response</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token acquisition fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef get_client_credentials_token(self) -&gt; KeycloakTokenType | None:\n    \"\"\"Get token using client credentials.\n\n    Returns:\n        Token response\n\n    Raises:\n        ValueError: If token acquisition fails\n    \"\"\"\n    # Tokens are time-sensitive, don't cache\n    try:\n        return self._openid_adapter.token(grant_type=\"client_credentials\")\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_client_credentials_token\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.search_users","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.search_users(query, max_results=100)</code>","text":"<p>Search for users by username, email, or name.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Search query</p> required <code>max_results</code> <code>int</code> <p>Maximum number of results to return</p> <code>100</code> <p>Returns:</p> Type Description <code>list[KeycloakUserType] | None</code> <p>List of matching users</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If search fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=30, maxsize=50)  # Cache for 30 seconds with limited entries\ndef search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType] | None:\n    \"\"\"Search for users by username, email, or name.\n\n    Args:\n        query: Search query\n        max_results: Maximum number of results to return\n\n    Returns:\n        List of matching users\n\n    Raises:\n        ValueError: If search fails\n    \"\"\"\n    try:\n        # Try searching by different fields\n        users = []\n\n        # Search by username\n        users.extend(self.admin_adapter.get_users({\"username\": query, \"max\": max_results}))\n\n        # Search by email if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            email_users = self.admin_adapter.get_users({\"email\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in email_users if user[\"id\"] not in user_ids])\n\n        # Search by firstName if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            first_name_users = self.admin_adapter.get_users({\"firstName\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in first_name_users if user[\"id\"] not in user_ids])\n\n        # Search by lastName if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            last_name_users = self.admin_adapter.get_users({\"lastName\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in last_name_users if user[\"id\"] not in user_ids])\n\n        return users[:max_results]\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"search_users\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_secret","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_secret(client_id)</code>","text":"<p>Get client secret.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Client ID</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Client secret</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting secret fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=50)  # Cache for 1 hour\ndef get_client_secret(self, client_id: str) -&gt; str | None:\n    \"\"\"Get client secret.\n\n    Args:\n        client_id: Client ID\n\n    Returns:\n        Client secret\n\n    Raises:\n        ValueError: If getting secret fails\n    \"\"\"\n    try:\n        client = self.admin_adapter.get_client(client_id)\n        return client.get(\"secret\", \"\")\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_client_secret\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_id","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_id(client_name)</code>","text":"<p>Get client ID by client name.</p> <p>Parameters:</p> Name Type Description Default <code>client_name</code> <code>str</code> <p>Name of the client</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Client ID</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If client not found</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=50)  # Cache for 1 hour\ndef get_client_id(self, client_name: str) -&gt; str | None:\n    \"\"\"Get client ID by client name.\n\n    Args:\n        client_name: Name of the client\n\n    Returns:\n        Client ID\n\n    Raises:\n        ValueError: If client not found\n    \"\"\"\n    try:\n        return self.admin_adapter.get_client_id(client_name)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_client_id\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_realm_roles","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_realm_roles()</code>","text":"<p>Get all realm roles.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]] | None</code> <p>List of realm roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=1)  # Cache for 5 minutes\ndef get_realm_roles(self) -&gt; list[dict[str, Any]] | None:\n    \"\"\"Get all realm roles.\n\n    Returns:\n        List of realm roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return self.admin_adapter.get_realm_roles()\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_realm_roles\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_realm_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_realm_role(role_name)</code>","text":"<p>Get realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name</p> required <p>Returns:     A realm role</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting role fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=1)  # Cache for 5 minutes\ndef get_realm_role(self, role_name: str) -&gt; dict | None:\n    \"\"\"Get realm role.\n\n    Args:\n        role_name: Role name\n    Returns:\n        A realm role\n\n    Raises:\n        ValueError: If getting role fails\n    \"\"\"\n    try:\n        return self.admin_adapter.get_realm_role(role_name)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_realm_role\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.remove_client_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.remove_client_role(user_id, client_id, role_name)</code>","text":"<p>Remove a client-specific role from a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>role_name</code> <code>str</code> <p>Role name to remove</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role removal fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a client-specific role from a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n        role_name: Role name to remove\n\n    Raises:\n        ValueError: If role removal fails\n    \"\"\"\n    try:\n        client = self.admin_adapter.get_client_id(client_id)\n        role = self.admin_adapter.get_client_role(client, role_name)\n        self.admin_adapter.delete_client_roles_of_user(user_id, client, [role])\n\n        if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n            self.get_client_roles_for_user.clear_cache()\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"remove_client_role\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.clear_user_sessions","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.clear_user_sessions(user_id)</code>","text":"<p>Clear all sessions for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If clearing sessions fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef clear_user_sessions(self, user_id: str) -&gt; None:\n    \"\"\"Clear all sessions for a user.\n\n    Args:\n        user_id: User's ID\n\n    Raises:\n        ValueError: If clearing sessions fails\n    \"\"\"\n    try:\n        self.admin_adapter.user_logout(user_id)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"clear_user_sessions\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.logout","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.logout(refresh_token)</code>","text":"<p>Logout user by invalidating their refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str</code> <p>Refresh token to invalidate</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If logout fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef logout(self, refresh_token: str) -&gt; None:\n    \"\"\"Logout user by invalidating their refresh token.\n\n    Args:\n        refresh_token: Refresh token to invalidate\n\n    Raises:\n        ValueError: If logout fails\n    \"\"\"\n    try:\n        self._openid_adapter.logout(refresh_token)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"logout\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.introspect_token","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.introspect_token(token)</code>","text":"<p>Introspect token to get detailed information about it.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Token introspection details</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token introspection fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef introspect_token(self, token: str) -&gt; dict[str, Any] | None:\n    \"\"\"Introspect token to get detailed information about it.\n\n    Args:\n        token: Access token\n\n    Returns:\n        Token introspection details\n\n    Raises:\n        ValueError: If token introspection fails\n    \"\"\"\n    try:\n        return self._openid_adapter.introspect(token)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"introspect_token\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token_info","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token_info(token)</code>","text":"<p>Decode token to get its claims.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Dictionary of token claims</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token decoding fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef get_token_info(self, token: str) -&gt; dict[str, Any] | None:\n    \"\"\"Decode token to get its claims.\n\n    Args:\n        token: Access token\n\n    Returns:\n        Dictionary of token claims\n\n    Raises:\n        ValueError: If token decoding fails\n    \"\"\"\n    try:\n        return self._openid_adapter.decode_token(\n            token,\n            key=self.get_public_key(),\n        )\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_token_info\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.delete_user","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.delete_user(user_id)</code>","text":"<p>Delete a user from Keycloak by their ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>The ID of the user to delete</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the deletion fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef delete_user(self, user_id: str) -&gt; None:\n    \"\"\"Delete a user from Keycloak by their ID.\n\n    Args:\n        user_id: The ID of the user to delete\n\n    Raises:\n        ValueError: If the deletion fails\n    \"\"\"\n    try:\n        self.admin_adapter.delete_user(user_id=user_id)\n\n        if hasattr(self.get_user_by_username, \"clear_cache\"):\n            self.get_user_by_username.clear_cache()\n\n        logger.info(f\"Successfully deleted user with ID {user_id}\")\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"delete_user\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.has_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.has_role(token, role_name)</code>","text":"<p>Check if a user has a specific role.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_name</code> <code>str</code> <p>Role name to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has the role, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef has_role(self, token: str, role_name: str) -&gt; bool:\n    \"\"\"Check if a user has a specific role.\n\n    Args:\n        token: Access token\n        role_name: Role name to check\n\n    Returns:\n        True if user has the role, False otherwise\n    \"\"\"\n    # Not caching this result as token validation is time-sensitive\n    try:\n        user_info = self.get_userinfo(token)\n\n        # Check realm roles\n        realm_access = user_info.get(\"realm_access\", {})\n        roles = realm_access.get(\"roles\", [])\n        if role_name in roles:\n            return True\n\n        # Check client roles\n        resource_access = user_info.get(\"resource_access\", {})\n        client_roles = resource_access.get(self.configs.CLIENT_ID, {}).get(\"roles\", [])\n        if role_name in client_roles:\n            return True\n\n    except Exception as e:\n        logger.debug(f\"Role check failed: {e!s}\")\n        return False\n    else:\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.has_any_of_roles","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.has_any_of_roles(token, role_names)</code>","text":"<p>Check if a user has any of the specified roles.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_names</code> <code>frozenset[str]</code> <p>Set of role names to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has any of the roles, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef has_any_of_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n    \"\"\"Check if a user has any of the specified roles.\n\n    Args:\n        token: Access token\n        role_names: Set of role names to check\n\n    Returns:\n        True if user has any of the roles, False otherwise\n    \"\"\"\n    try:\n        user_info = self.get_userinfo(token)\n\n        # Check realm roles first\n        realm_access = user_info.get(\"realm_access\", {})\n        realm_roles = set(realm_access.get(\"roles\", []))\n        if role_names.intersection(realm_roles):\n            return True\n\n        # Check roles for the configured client\n        resource_access = user_info.get(\"resource_access\", {})\n        client_roles = set(resource_access.get(self.configs.CLIENT_ID, {}).get(\"roles\", []))\n        if role_names.intersection(client_roles):\n            return True\n\n    except Exception as e:\n        logger.debug(f\"Role check failed: {e!s}\")\n        return False\n    else:\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.has_all_roles","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.has_all_roles(token, role_names)</code>","text":"<p>Check if a user has all the specified roles.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_names</code> <code>frozenset[str]</code> <p>Set of role names to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has all the roles, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef has_all_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n    \"\"\"Check if a user has all the specified roles.\n\n    Args:\n        token: Access token\n        role_names: Set of role names to check\n\n    Returns:\n        True if user has all the roles, False otherwise\n    \"\"\"\n    try:\n        user_info = self.get_userinfo(token)\n\n        # Get all user roles\n        all_roles = set()\n\n        # Add realm roles\n        realm_access = user_info.get(\"realm_access\", {})\n        all_roles.update(realm_access.get(\"roles\", []))\n\n        # Add client roles\n        resource_access = user_info.get(\"resource_access\", {})\n        client_roles = resource_access.get(self.configs.CLIENT_ID, {}).get(\"roles\", [])\n        all_roles.update(client_roles)\n\n        # Check if all required roles are present\n        return role_names.issubset(all_roles)\n\n    except Exception as e:\n        logger.debug(f\"All roles check failed: {e!s}\")\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.check_permissions","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.check_permissions(token, resource, scope)</code>","text":"<p>Check if a user has permission to access a resource with the specified scope.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>resource</code> <code>str</code> <p>Resource name</p> required <code>scope</code> <code>str</code> <p>Permission scope</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if permission granted, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n    \"\"\"Check if a user has permission to access a resource with the specified scope.\n\n    Args:\n        token: Access token\n        resource: Resource name\n        scope: Permission scope\n\n    Returns:\n        True if permission granted, False otherwise\n    \"\"\"\n    try:\n        # Use UMA permissions endpoint to check specific resource and scope\n        permissions = self._openid_adapter.uma_permissions(token, permissions=f\"{resource}#{scope}\")\n\n        # Check if the response indicates permission is granted\n        if not permissions or not isinstance(permissions, list):\n            logger.debug(\"No permissions returned or invalid response format\")\n            return False\n\n        # Look for the specific permission in the response\n        for perm in permissions:\n            if perm.get(\"rsname\") == resource and scope in perm.get(\"scopes\", []):\n                return True\n\n    except KeycloakError as e:\n        logger.debug(f\"Permission check failed with Keycloak error: {e!s}\")\n        return False\n    except Exception as e:\n        logger.debug(f\"Permission check failed with unexpected error: {e!s}\")\n        return False\n    else:\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.create_realm","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.create_realm(realm_name, skip_exists=True, **kwargs)</code>","text":"<p>Create a Keycloak realm with minimum required fields and optional additional config.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>The realm identifier (required)</p> required <code>skip_exists</code> <code>bool</code> <p>Skip creation if realm already exists</p> <code>True</code> <code>kwargs</code> <code>Any</code> <p>Additional optional configurations for the realm</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Realm details</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef create_realm(self, realm_name: str, skip_exists: bool = True, **kwargs: Any) -&gt; dict[str, Any] | None:\n    \"\"\"Create a Keycloak realm with minimum required fields and optional additional config.\n\n    Args:\n        realm_name: The realm identifier (required)\n        skip_exists: Skip creation if realm already exists\n        kwargs: Additional optional configurations for the realm\n\n    Returns:\n        Realm details\n    \"\"\"\n    payload = {\n        \"realm\": realm_name,\n        \"enabled\": kwargs.get(\"enabled\", True),\n        \"displayName\": kwargs.get(\"display_name\", realm_name),\n    }\n\n    # Add any additional parameters from kwargs\n    for key, value in kwargs.items():\n        # Skip display_name as it's already handled\n        if key == \"display_name\":\n            continue\n\n        # Convert Python snake_case to Keycloak camelCase\n        camel_key = StringUtils.snake_to_camel_case(key)\n        payload[camel_key] = value\n\n    try:\n        self.admin_adapter.create_realm(payload=payload, skip_exists=skip_exists)\n    except KeycloakError as e:\n        logger.debug(f\"Failed to create realm: {e!s}\")\n\n        # Handle realm already exists with skip_exists option\n        if skip_exists:\n            error_message = self._extract_error_message(e).lower()\n            if \"already exists\" in error_message and \"realm\" in error_message:\n                return {\"realm\": realm_name, \"status\": \"already_exists\", \"config\": payload}\n\n        # Use the mixin to handle realm-specific errors\n        self._handle_realm_exception(e, \"create_realm\", realm_name)\n    else:\n        return {\"realm\": realm_name, \"status\": \"created\", \"config\": payload}\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_realm","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_realm(realm_name)</code>","text":"<p>Get realm details by realm name.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Realm details</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef get_realm(self, realm_name: str) -&gt; dict[str, Any] | None:\n    \"\"\"Get realm details by realm name.\n\n    Args:\n        realm_name: Name of the realm\n\n    Returns:\n        Realm details\n    \"\"\"\n    try:\n        return self.admin_adapter.get_realm(realm_name)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_realm\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.create_client","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.create_client(client_id, realm=None, skip_exists=True, **kwargs)</code>","text":"<p>Create a Keycloak client with minimum required fields and optional additional config.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>The client identifier (required)</p> required <code>realm</code> <code>str | None</code> <p>Target realm name (uses the current realm in KeycloakAdmin if not specified)</p> <code>None</code> <code>skip_exists</code> <code>bool</code> <p>Skip creation if client already exists</p> <code>True</code> <code>kwargs</code> <code>Any</code> <p>Additional optional configurations for the client</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Client details</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef create_client(\n    self,\n    client_id: str,\n    realm: str | None = None,\n    skip_exists: bool = True,\n    **kwargs: Any,\n) -&gt; dict[str, Any] | None:\n    \"\"\"Create a Keycloak client with minimum required fields and optional additional config.\n\n    Args:\n        client_id: The client identifier (required)\n        realm: Target realm name (uses the current realm in KeycloakAdmin if not specified)\n        skip_exists: Skip creation if client already exists\n        kwargs: Additional optional configurations for the client\n\n    Returns:\n        Client details\n    \"\"\"\n    original_realm = self.admin_adapter.connection.realm_name\n\n    try:\n        # Set the target realm if provided\n        if realm and realm != original_realm:\n            self.admin_adapter.connection.realm_name = realm\n\n        public_client = kwargs.get(\"public_client\", False)\n\n        # Prepare the minimal client payload\n        payload = {\n            \"clientId\": client_id,\n            \"enabled\": kwargs.get(\"enabled\", True),\n            \"protocol\": kwargs.get(\"protocol\", \"openid-connect\"),\n            \"name\": kwargs.get(\"name\", client_id),\n            \"publicClient\": public_client,\n        }\n\n        # Enable service accounts for confidential clients by default\n        if not public_client:\n            payload[\"serviceAccountsEnabled\"] = kwargs.get(\"service_account_enabled\", True)\n            payload[\"clientAuthenticatorType\"] = \"client-secret\"\n\n        for key, value in kwargs.items():\n            if key in [\"enabled\", \"protocol\", \"name\", \"public_client\", \"service_account_enabled\"]:\n                continue\n\n            # Convert snake_case to camelCase\n            camel_key = StringUtils.snake_to_camel_case(key)\n            payload[camel_key] = value\n\n        internal_client_id = None\n        try:\n            internal_client_id = self.admin_adapter.create_client(payload, skip_exists=skip_exists)\n        except KeycloakError as e:\n            logger.debug(f\"Failed to create client: {e!s}\")\n\n            # Handle client already exists with skip_exists option\n            if skip_exists:\n                error_message = self._extract_error_message(e).lower()\n                if \"already exists\" in error_message and \"client\" in error_message:\n                    return {\n                        \"client_id\": client_id,\n                        \"status\": \"already_exists\",\n                        \"realm\": self.admin_adapter.connection.realm_name,\n                    }\n\n            # Use the mixin to handle client-specific errors\n            client_data = {\"clientId\": client_id, \"name\": kwargs.get(\"name\", client_id)}\n            self._handle_client_exception(e, \"create_client\", client_data)\n\n        return {\n            \"client_id\": client_id,\n            \"internal_client_id\": internal_client_id,\n            \"realm\": self.admin_adapter.connection.realm_name,\n            \"status\": \"created\",\n        }\n\n    finally:\n        # Always restore the original realm\n        if realm and realm != original_realm:\n            self.admin_adapter.connection.realm_name = original_realm\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.add_realm_roles_to_composite","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.add_realm_roles_to_composite(composite_role_name, child_role_names)</code>","text":"<p>Add realm roles to a composite role.</p> <p>Parameters:</p> Name Type Description Default <code>composite_role_name</code> <code>str</code> <p>Name of the composite realm role</p> required <code>child_role_names</code> <code>list[str]</code> <p>List of child role names to add</p> required Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef add_realm_roles_to_composite(self, composite_role_name: str, child_role_names: list[str]) -&gt; None:\n    \"\"\"Add realm roles to a composite role.\n\n    Args:\n        composite_role_name: Name of the composite realm role\n        child_role_names: List of child role names to add\n    \"\"\"\n    try:\n        child_roles = []\n        for role_name in child_role_names:\n            try:\n                role = self.admin_adapter.get_realm_role(role_name)\n                child_roles.append(role)\n            except KeycloakGetError as e:\n                if e.response_code == 404:\n                    logger.warning(f\"Child role not found: {role_name}\")\n                    continue\n                raise\n\n        if child_roles:\n            self.admin_adapter.add_composite_realm_roles_to_role(role_name=composite_role_name, roles=child_roles)\n            logger.info(f\"Added {len(child_roles)} realm roles to composite role: {composite_role_name}\")\n\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"add_realm_roles_to_composite\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.add_client_roles_to_composite","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.add_client_roles_to_composite(composite_role_name, client_id, child_role_names)</code>","text":"<p>Add client roles to a composite role.</p> <p>Parameters:</p> Name Type Description Default <code>composite_role_name</code> <code>str</code> <p>Name of the composite client role</p> required <code>client_id</code> <code>str</code> <p>Client ID or client name</p> required <code>child_role_names</code> <code>list[str]</code> <p>List of child role names to add</p> required Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef add_client_roles_to_composite(\n    self,\n    composite_role_name: str,\n    client_id: str,\n    child_role_names: list[str],\n) -&gt; None:\n    \"\"\"Add client roles to a composite role.\n\n    Args:\n        composite_role_name: Name of the composite client role\n        client_id: Client ID or client name\n        child_role_names: List of child role names to add\n    \"\"\"\n    try:\n        internal_client_id = self.admin_adapter.get_client_id(client_id)\n\n        child_roles = []\n        for role_name in child_role_names:\n            try:\n                role = self.admin_adapter.get_client_role(internal_client_id, role_name)\n                child_roles.append(role)\n            except KeycloakGetError as e:\n                if e.response_code == 404:\n                    logger.warning(f\"Client role not found: {role_name}\")\n                    continue\n                raise\n\n        if child_roles:\n            self.admin_adapter.add_composite_client_roles_to_role(\n                role_name=composite_role_name,\n                client_role_id=internal_client_id,\n                roles=child_roles,\n            )\n            logger.info(f\"Added {len(child_roles)} client roles to composite role: {composite_role_name}\")\n\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"add_client_roles_to_composite\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_composite_realm_roles","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_composite_realm_roles(role_name)</code>","text":"<p>Get composite roles for a realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Name of the role</p> required <p>Returns:</p> Type Description <code>list[dict[str, Any]] | None</code> <p>List of composite roles</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef get_composite_realm_roles(self, role_name: str) -&gt; list[dict[str, Any]] | None:\n    \"\"\"Get composite roles for a realm role.\n\n    Args:\n        role_name: Name of the role\n\n    Returns:\n        List of composite roles\n    \"\"\"\n    try:\n        return self.admin_adapter.get_composite_realm_roles_of_role(role_name)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_composite_realm_roles\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter</code>","text":"<p>               Bases: <code>AsyncKeycloakPort</code>, <code>KeycloakExceptionHandlerMixin</code></p> <p>Concrete implementation of the KeycloakPort interface using python-keycloak library.</p> <p>This implementation includes TTL caching for appropriate operations to improve performance while ensuring cache entries expire after a configured time to prevent stale data.</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>class AsyncKeycloakAdapter(AsyncKeycloakPort, KeycloakExceptionHandlerMixin):\n    \"\"\"Concrete implementation of the KeycloakPort interface using python-keycloak library.\n\n    This implementation includes TTL caching for appropriate operations to improve performance\n    while ensuring cache entries expire after a configured time to prevent stale data.\n    \"\"\"\n\n    def __init__(self, keycloak_configs: KeycloakConfig | None = None) -&gt; None:\n        \"\"\"Initialize KeycloakAdapter with configuration.\n\n        Args:\n            keycloak_configs: Optional Keycloak configuration. If None, global config is used.\n        \"\"\"\n        self.configs: KeycloakConfig = (\n            BaseConfig.global_config().KEYCLOAK if keycloak_configs is None else keycloak_configs\n        )\n\n        # Initialize the OpenID client for authentication\n        self.openid_adapter = self._get_openid_client(self.configs)\n\n        # Cache for admin client to avoid unnecessary re-authentication\n        self._admin_adapter: KeycloakAdmin | None = None\n        self._admin_token_expiry: float = 0.0\n\n        # Initialize admin client if admin mode is enabled and credentials are provided\n        if self.configs.IS_ADMIN_MODE_ENABLED and (\n            self.configs.CLIENT_SECRET_KEY or (self.configs.ADMIN_USERNAME and self.configs.ADMIN_PASSWORD)\n        ):\n            self._initialize_admin_client()\n\n    def clear_all_caches(self) -&gt; None:\n        \"\"\"Clear all cached values.\"\"\"\n        for attr_name in dir(self):\n            attr = getattr(self, attr_name)\n            if hasattr(attr, \"cache_clear\"):\n                attr.cache_clear()\n\n    @staticmethod\n    def _get_openid_client(configs: KeycloakConfig) -&gt; KeycloakOpenID:\n        \"\"\"Create and configure a KeycloakOpenID instance.\n\n        Args:\n            configs: Keycloak configuration\n\n        Returns:\n            Configured KeycloakOpenID client\n        \"\"\"\n        return KeycloakOpenID(\n            server_url=configs.SERVER_URL,\n            client_id=configs.CLIENT_ID,\n            realm_name=configs.REALM_NAME,\n            client_secret_key=configs.CLIENT_SECRET_KEY,\n            verify=configs.VERIFY_SSL,\n            timeout=configs.TIMEOUT,\n        )\n\n    def _initialize_admin_client(self) -&gt; None:\n        \"\"\"Initialize or refresh the admin client.\"\"\"\n        try:\n            # Check if admin credentials are available\n            if self.configs.ADMIN_USERNAME and self.configs.ADMIN_PASSWORD:\n                # Create admin client using admin credentials\n                self._admin_adapter = KeycloakAdmin(\n                    server_url=self.configs.SERVER_URL,\n                    username=self.configs.ADMIN_USERNAME,\n                    password=self.configs.ADMIN_PASSWORD,\n                    realm_name=self.configs.REALM_NAME,\n                    user_realm_name=self.configs.ADMIN_REALM_NAME,\n                    verify=self.configs.VERIFY_SSL,\n                    timeout=self.configs.TIMEOUT,\n                )\n                # Since we're using direct credentials, set a long expiry time\n                self._admin_token_expiry = time.time() + 3600  # 1 hour\n                logger.debug(\"Admin client initialized with admin credentials\")\n            elif self.configs.CLIENT_SECRET_KEY:\n                # Get token using client credentials\n                token = self.openid_adapter.token(grant_type=\"client_credentials\")\n\n                # Set token expiry time (current time + expires_in - buffer)\n                # Using a 30-second buffer to ensure we refresh before expiration\n                self._admin_token_expiry = time.time() + token.get(\"expires_in\", 60) - 30\n\n                # Create admin client with the token\n                self._admin_adapter = KeycloakAdmin(\n                    server_url=self.configs.SERVER_URL,\n                    realm_name=self.configs.REALM_NAME,\n                    token=token,\n                    verify=self.configs.VERIFY_SSL,\n                    timeout=self.configs.TIMEOUT,\n                )\n                logger.debug(\"Admin client initialized with client credentials\")\n            else:\n                raise UnauthenticatedError(\n                    additional_data={\"detail\": \"Neither admin credentials nor client secret provided\"},\n                )\n\n        except KeycloakAuthenticationError as e:\n            self._admin_adapter = None\n            self._admin_token_expiry = 0\n            raise UnauthenticatedError(\n                additional_data={\"detail\": \"Failed to authenticate with Keycloak service account\"},\n            ) from e\n        except KeycloakConnectionError as e:\n            self._admin_adapter = None\n            self._admin_token_expiry = 0\n            raise ConnectionTimeoutError(\"Failed to connect to Keycloak server\") from e\n        except KeycloakError as e:\n            self._admin_adapter = None\n            self._admin_token_expiry = 0\n            self._handle_keycloak_exception(e, \"_initialize_admin_client\")\n\n    @property\n    def admin_adapter(self) -&gt; KeycloakAdmin:\n        \"\"\"Get the admin adapter, refreshing it if necessary.\n\n        Returns:\n            KeycloakAdmin instance\n\n        Raises:\n            UnauthenticatedError: If admin client is not available due to authentication issues\n            UnavailableError: If Keycloak service is unavailable\n        \"\"\"\n        if not self.configs.IS_ADMIN_MODE_ENABLED or not (\n            self.configs.CLIENT_SECRET_KEY or (self.configs.ADMIN_USERNAME and self.configs.ADMIN_PASSWORD)\n        ):\n            raise UnauthenticatedError(\n                additional_data={\n                    \"detail\": \"Admin mode is disabled or neither admin credentials nor client secret provided\",\n                },\n            )\n\n        # Check if token is about to expire and refresh if needed\n        if self._admin_adapter is None or time.time() &gt;= self._admin_token_expiry:\n            self._initialize_admin_client()\n\n        if self._admin_adapter is None:\n            raise UnavailableError(\"Keycloak admin client is not available\")\n\n        return self._admin_adapter\n\n    @override\n    @alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour, public key rarely changes\n    async def get_public_key(self) -&gt; PublicKeyType:\n        \"\"\"Get the public key used to verify tokens.\n\n        Returns:\n            JWK key object used to verify signatures\n\n        Raises:\n            ServiceUnavailableError: If Keycloak service is unavailable\n            InternalError: If there's an internal error processing the public key\n        \"\"\"\n        try:\n            from jwcrypto import jwk\n\n            keys_info = await self.openid_adapter.a_public_key()\n            key = f\"-----BEGIN PUBLIC KEY-----\\n{keys_info}\\n-----END PUBLIC KEY-----\"\n            return jwk.JWK.from_pem(key.encode(\"utf-8\"))\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_public_key\")\n        except Exception as e:\n            raise InternalError(additional_data={\"operation\": \"get_public_key\", \"error\": str(e)}) from e\n\n    @override\n    async def get_token(self, username: str, password: str) -&gt; KeycloakTokenType | None:\n        \"\"\"Get a user token by username and password using the Resource Owner Password Credentials Grant.\n\n        Warning:\n            This method uses the direct password grant flow, which is less secure and not recommended\n            for user login in production environments. Instead, prefer the web-based OAuth 2.0\n            Authorization Code Flow (use `get_token_from_code`) for secure authentication.\n            Use this method only for testing, administrative tasks, or specific service accounts\n            where direct credential use is acceptable and properly secured.\n\n        Args:\n            username: User's username\n            password: User's password\n\n        Returns:\n            Token response containing access_token, refresh_token, etc.\n\n        Raises:\n            InvalidCredentialsError: If username or password is invalid\n            ServiceUnavailableError: If Keycloak service is unavailable\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_token(grant_type=\"password\", username=username, password=password)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_token\")\n\n    @override\n    async def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType | None:\n        \"\"\"Refresh an existing token using a refresh token.\n\n        Args:\n            refresh_token: Refresh token string\n\n        Returns:\n            New token response containing access_token, refresh_token, etc.\n\n        Raises:\n            InvalidTokenError: If refresh token is invalid or expired\n            ServiceUnavailableError: If Keycloak service is unavailable\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_refresh_token(refresh_token)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"refresh_token\")\n\n    @override\n    async def validate_token(self, token: str) -&gt; bool:\n        \"\"\"Validate if a token is still valid.\n\n        Args:\n            token: Access token to validate\n\n        Returns:\n            True if token is valid, False otherwise\n        \"\"\"\n        # Not caching validation results as tokens are time-sensitive\n        try:\n            await self.openid_adapter.a_decode_token(\n                token,\n                key=await self.get_public_key(),\n            )\n        except Exception as e:\n            logger.debug(f\"Token validation failed: {e!s}\")\n            return False\n        else:\n            return True\n\n    @override\n    async def get_userinfo(self, token: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user information from a token.\n\n        Args:\n            token: Access token\n\n        Returns:\n            User information\n\n        Raises:\n            ValueError: If getting user info fails\n        \"\"\"\n        if not await self.validate_token(token):\n            raise InvalidTokenError()\n        try:\n            return await self._get_userinfo_cached(token)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_userinfo\")\n\n    @alru_cache(ttl=30, maxsize=100)  # Cache for 30 seconds\n    async def _get_userinfo_cached(self, token: str) -&gt; KeycloakUserType:\n        return await self.openid_adapter.a_userinfo(token)\n\n    @override\n    @alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\n    async def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by user ID.\n\n        Args:\n            user_id: User's ID\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If getting user fails\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_user(user_id)\n        except KeycloakGetError as e:\n            if e.response_code == 404:\n                return None\n            raise InternalError() from e\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_user_by_id\")\n\n    @override\n    @alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\n    async def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by username.\n\n        Args:\n            username: User's username\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If query fails\n        \"\"\"\n        try:\n            users = await self.admin_adapter.a_get_users({\"username\": username})\n            return users[0] if users else None\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_user_by_username\")\n\n    @override\n    @alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\n    async def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by email.\n\n        Args:\n            email: User's email\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If query fails\n        \"\"\"\n        try:\n            users = await self.admin_adapter.a_get_users({\"email\": email})\n            return users[0] if users else None\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_user_by_email\")\n\n    @override\n    @alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\n    async def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType] | None:\n        \"\"\"Get roles assigned to a user.\n\n        Args:\n            user_id: User's ID\n\n        Returns:\n            List of roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_realm_roles_of_user(user_id)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_user_roles\")\n\n    @override\n    @alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\n    async def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get client-specific roles assigned to a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n\n        Returns:\n            List of client-specific roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_client_roles_of_user(user_id, client_id)\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    async def create_user(self, user_data: dict[str, Any]) -&gt; str | None:\n        \"\"\"Create a new user in Keycloak.\n\n        Args:\n            user_data: User data including username, email, etc.\n\n        Returns:\n            ID of the created user\n\n        Raises:\n            ValueError: If creating user fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            user_id = await self.admin_adapter.a_create_user(user_data)\n\n            # Clear related caches\n            self.clear_all_caches()\n        except KeycloakError as e:\n            self._handle_user_exception(e, \"create_user\", user_data)\n        else:\n            return user_id\n\n    @override\n    async def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n        \"\"\"Update user details.\n\n        Args:\n            user_id: User's ID\n            user_data: User data to update\n\n        Raises:\n            ValueError: If updating user fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            await self.admin_adapter.a_update_user(user_id, user_data)\n\n            # Clear user-related caches\n            self.clear_all_caches()\n\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"update_user\")\n\n    @override\n    async def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n        \"\"\"Reset a user's password.\n\n        Args:\n            user_id: User's ID\n            password: New password\n            temporary: Whether the password is temporary and should be changed on next login\n\n        Raises:\n            ValueError: If password reset fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            await self.admin_adapter.a_set_user_password(user_id, password, temporary)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"reset_password\")\n\n    @override\n    async def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a realm role to a user.\n\n        Args:\n            user_id: User's ID\n            role_name: Role name to assign\n\n        Raises:\n            ValueError: If role assignment fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get role representation\n            role = await self.admin_adapter.a_get_realm_role(role_name)\n            # Assign role to user\n            await self.admin_adapter.a_assign_realm_roles(user_id, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_user_roles, \"cache_clear\"):\n                self.get_user_roles.cache_clear()\n\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"assign_realm_role\")\n\n    @override\n    async def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a realm role from a user.\n\n        Args:\n            user_id: User's ID\n            role_name: Role name to remove\n\n        Raises:\n            ValueError: If role removal fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get role representation\n            role = await self.admin_adapter.a_get_realm_role(role_name)\n            # Remove role from user\n            await self.admin_adapter.a_delete_realm_roles_of_user(user_id, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_user_roles, \"cache_clear\"):\n                self.get_user_roles.cache_clear()\n\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"remove_realm_role\")\n\n    @override\n    async def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a client-specific role to a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n            role_name: Role name to assign\n\n        Raises:\n            ValueError: If role assignment fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get client\n            client = await self.admin_adapter.a_get_client_id(client_id)\n            # Get role representation\n            role = await self.admin_adapter.a_get_client_role(client, role_name)\n            # Assign role to user\n            await self.admin_adapter.a_assign_client_role(user_id, client, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_client_roles_for_user, \"cache_clear\"):\n                self.get_client_roles_for_user.cache_clear()\n\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"assign_client_role\")\n\n    @override\n    async def create_realm_role(\n        self,\n        role_name: str,\n        description: str | None = None,\n        skip_exists: bool = True,\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"Create a new realm role.\n\n        Args:\n            role_name: Role name\n            description: Optional role description\n            skip_exists: Skip creation if role already exists\n\n        Returns:\n            Created role details\n\n        Raises:\n            ValueError: If role creation fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            role_data = {\"name\": role_name}\n            if description:\n                role_data[\"description\"] = description\n\n            await self.admin_adapter.a_create_realm_role(role_data, skip_exists=skip_exists)\n\n            # Clear realm roles cache\n            if hasattr(self.get_realm_roles, \"cache_clear\"):\n                self.get_realm_roles.cache_clear()\n\n            return await self.admin_adapter.a_get_realm_role(role_name)\n\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"create_realm_role\")\n\n    @override\n    async def create_client_role(\n        self,\n        client_id: str,\n        role_name: str,\n        description: str | None = None,\n        skip_exists: bool = True,\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"Create a new client role.\n\n        Args:\n            client_id: Client ID or client name\n            role_name: Role name\n            skip_exists: Skip creation if role already exists\n            description: Optional role description\n\n        Returns:\n            Created role details\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            client_id = await self.admin_adapter.a_get_client_id(client_id)\n\n            # Prepare role data\n            role_data = {\"name\": role_name}\n            if description:\n                role_data[\"description\"] = description\n\n            # Create client role\n            await self.admin_adapter.a_create_client_role(client_id, role_data, skip_exists=skip_exists)\n\n            # Clear related caches if they exist\n            if hasattr(self.get_client_roles_for_user, \"cache_clear\"):\n                self.get_client_roles_for_user.cache_clear()\n\n            # Return created role\n            return await self.admin_adapter.a_get_client_role(client_id, role_name)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"create_client_role\")\n\n    @override\n    async def delete_realm_role(self, role_name: str) -&gt; None:\n        \"\"\"Delete a realm role.\n\n        Args:\n            role_name: Role name to delete\n\n        Raises:\n            ValueError: If role deletion fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            await self.admin_adapter.a_delete_realm_role(role_name)\n\n            # Clear realm roles cache\n            if hasattr(self.get_realm_roles, \"cache_clear\"):\n                self.get_realm_roles.cache_clear()\n\n            # We also need to clear user role caches since they might contain this role\n            if hasattr(self.get_user_roles, \"cache_clear\"):\n                self.get_user_roles.cache_clear()\n\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"delete_realm_role\")\n\n    @override\n    @alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\n    async def get_service_account_id(self) -&gt; str | None:\n        \"\"\"Get service account user ID for the current client.\n\n        Returns:\n            Service account user ID\n\n        Raises:\n            ValueError: If getting service account fails\n        \"\"\"\n        try:\n            client_id = await self.get_client_id(self.configs.CLIENT_ID)\n            service_account = await self.admin_adapter.a_get_client_service_account_user(client_id)\n            return service_account.get(\"id\")\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_service_account_id\")\n\n    @override\n    @alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\n    async def get_well_known_config(self) -&gt; dict[str, Any] | None:\n        \"\"\"Get the well-known OpenID configuration.\n\n        Returns:\n            OIDC configuration\n\n        Raises:\n            ValueError: If getting configuration fails\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_well_known()\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_well_known_config\")\n\n    @override\n    @alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\n    async def get_certs(self) -&gt; dict[str, Any] | None:\n        \"\"\"Get the JWT verification certificates.\n\n        Returns:\n            Certificate information\n\n        Raises:\n            ValueError: If getting certificates fails\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_certs()\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_certs\")\n\n    @override\n    async def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType | None:\n        \"\"\"Exchange authorization code for token.\n\n        Args:\n            code: Authorization code\n            redirect_uri: Redirect URI used in authorization request\n\n        Returns:\n            Token response\n\n        Raises:\n            ValueError: If token exchange fails\n        \"\"\"\n        # Authorization codes can only be used once, don't cache\n        try:\n            return await self.openid_adapter.a_token(\n                grant_type=\"authorization_code\",\n                code=code,\n                redirect_uri=redirect_uri,\n            )\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_token_from_code\")\n\n    @override\n    async def get_client_credentials_token(self) -&gt; KeycloakTokenType | None:\n        \"\"\"Get token using client credentials.\n\n        Returns:\n            Token response\n\n        Raises:\n            ValueError: If token acquisition fails\n        \"\"\"\n        # Tokens are time-sensitive, don't cache\n        try:\n            return await self.openid_adapter.a_token(grant_type=\"client_credentials\")\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_client_credentials_token\")\n\n    @override\n    @alru_cache(ttl=30, maxsize=50)  # Cache for 30 seconds with limited entries\n    async def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType] | None:\n        \"\"\"Search for users by username, email, or name.\n\n        Args:\n            query: Search query\n            max_results: Maximum number of results to return\n\n        Returns:\n            List of matching users\n\n        Raises:\n            ValueError: If search fails\n        \"\"\"\n        try:\n            # Try searching by different fields\n            users = []\n\n            # Search by username\n            users.extend(await self.admin_adapter.a_get_users({\"username\": query, \"max\": max_results}))\n\n            # Search by email if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                email_users = await self.admin_adapter.a_get_users({\"email\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in email_users if user[\"id\"] not in user_ids])\n\n            # Search by firstName if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                first_name_users = await self.admin_adapter.a_get_users({\"firstName\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in first_name_users if user[\"id\"] not in user_ids])\n\n            # Search by lastName if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                last_name_users = await self.admin_adapter.a_get_users({\"lastName\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in last_name_users if user[\"id\"] not in user_ids])\n\n            return users[:max_results]\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"search_users\")\n\n    @override\n    @alru_cache(ttl=3600, maxsize=50)  # Cache for 1 hour\n    async def get_client_secret(self, client_id: str) -&gt; str | None:\n        \"\"\"Get client secret.\n\n        Args:\n            client_id: Client ID\n\n        Returns:\n            Client secret\n\n        Raises:\n            ValueError: If getting secret fails\n        \"\"\"\n        try:\n            client = await self.admin_adapter.a_get_client(client_id)\n            return client.get(\"secret\", \"\")\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_client_secret\")\n\n    @override\n    @alru_cache(ttl=3600, maxsize=50)  # Cache for 1 hour\n    async def get_client_id(self, client_name: str) -&gt; str | None:\n        \"\"\"Get client ID by client name.\n\n        Args:\n            client_name: Name of the client\n\n        Returns:\n            Client ID\n\n        Raises:\n            ValueError: If client not found\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_client_id(client_name)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_client_id\")\n\n    @override\n    @alru_cache(ttl=300, maxsize=1)  # Cache for 5 minutes\n    async def get_realm_roles(self) -&gt; list[dict[str, Any]] | None:\n        \"\"\"Get all realm roles.\n\n        Returns:\n            List of realm roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_realm_roles()\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_realm_roles\")\n\n    @override\n    @alru_cache(ttl=300, maxsize=1)  # Cache for 5 minutes\n    async def get_realm_role(self, role_name: str) -&gt; dict | None:\n        \"\"\"Get realm role.\n\n        Args:\n            role_name: Role name\n        Returns:\n            A realm role\n\n        Raises:\n            ValueError: If getting role fails\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_realm_role(role_name)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_realm_role\")\n\n    @override\n    async def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a client-specific role from a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n            role_name: Role name to remove\n\n        Raises:\n            ValueError: If role removal fails\n        \"\"\"\n        try:\n            client = await self.admin_adapter.a_get_client_id(client_id)\n            role = await self.admin_adapter.a_get_client_role(client, role_name)\n            await self.admin_adapter.a_delete_client_roles_of_user(user_id, client, [role])\n\n            if hasattr(self.get_client_roles_for_user, \"cache_clear\"):\n                self.get_client_roles_for_user.cache_clear()\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"remove_client_role\")\n\n    @override\n    async def clear_user_sessions(self, user_id: str) -&gt; None:\n        \"\"\"Clear all sessions for a user.\n\n        Args:\n            user_id: User's ID\n\n        Raises:\n            ValueError: If clearing sessions fails\n        \"\"\"\n        try:\n            await self.admin_adapter.a_user_logout(user_id)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"clear_user_sessions\")\n\n    @override\n    async def logout(self, refresh_token: str) -&gt; None:\n        \"\"\"Logout user by invalidating their refresh token.\n\n        Args:\n            refresh_token: Refresh token to invalidate\n\n        Raises:\n            ValueError: If logout fails\n        \"\"\"\n        try:\n            await self.openid_adapter.a_logout(refresh_token)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"logout\")\n\n    @override\n    async def introspect_token(self, token: str) -&gt; dict[str, Any] | None:\n        \"\"\"Introspect token to get detailed information about it.\n\n        Args:\n            token: Access token\n\n        Returns:\n            Token introspection details\n\n        Raises:\n            ValueError: If token introspection fails\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_introspect(token)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"introspect_token\")\n\n    @override\n    async def get_token_info(self, token: str) -&gt; dict[str, Any] | None:\n        \"\"\"Decode token to get its claims.\n\n        Args:\n            token: Access token\n\n        Returns:\n            Dictionary of token claims\n\n        Raises:\n            ValueError: If token decoding fails\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_decode_token(\n                token,\n                key=await self.get_public_key(),\n            )\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_token_info\")\n\n    @override\n    async def delete_user(self, user_id: str) -&gt; None:\n        \"\"\"Delete a user from Keycloak by their ID.\n\n        Args:\n            user_id: The ID of the user to delete\n\n        Raises:\n            ValueError: If the deletion fails\n        \"\"\"\n        try:\n            await self.admin_adapter.a_delete_user(user_id=user_id)\n\n            if hasattr(self.get_user_by_username, \"cache_clear\"):\n                self.get_user_by_username.cache_clear()\n\n            logger.info(f\"Successfully deleted user with ID {user_id}\")\n\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"delete_user\")\n\n    @override\n    async def has_role(self, token: str, role_name: str) -&gt; bool:\n        \"\"\"Check if a user has a specific role.\n\n        Args:\n            token: Access token\n            role_name: Role name to check\n\n        Returns:\n            True if user has the role, False otherwise\n        \"\"\"\n        # Not caching this result as token validation is time-sensitive\n        try:\n            user_info = await self.get_userinfo(token)\n\n            # Check realm roles\n            realm_access = user_info.get(\"realm_access\", {})\n            roles = realm_access.get(\"roles\", [])\n            if role_name in roles:\n                return True\n\n            # Check roles for the configured client\n            resource_access = user_info.get(\"resource_access\", {})\n            client_roles = resource_access.get(self.configs.CLIENT_ID, {}).get(\"roles\", [])\n            if role_name in client_roles:\n                return True\n\n        except Exception as e:\n            logger.debug(f\"Role check failed: {e!s}\")\n            return False\n        else:\n            return False\n\n    @override\n    async def has_any_of_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n        \"\"\"Check if a user has any of the specified roles.\n\n        Args:\n            token: Access token\n            role_names: Set of role names to check\n\n        Returns:\n            True if user has any of the roles, False otherwise\n        \"\"\"\n        try:\n            user_info = await self.get_userinfo(token)\n\n            # Check realm roles first\n            realm_access = user_info.get(\"realm_access\", {})\n            realm_roles = set(realm_access.get(\"roles\", []))\n            if role_names.intersection(realm_roles):\n                return True\n\n            # Check roles for the configured client\n            resource_access = user_info.get(\"resource_access\", {})\n            client_roles = set(resource_access.get(self.configs.CLIENT_ID, {}).get(\"roles\", []))\n            if role_names.intersection(client_roles):\n                return True\n\n        except Exception as e:\n            logger.debug(f\"Role check failed: {e!s}\")\n            return False\n        else:\n            return False\n\n    @override\n    async def has_all_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n        \"\"\"Check if a user has all the specified roles.\n\n        Args:\n            token: Access token\n            role_names: Set of role names to check\n\n        Returns:\n            True if user has all the roles, False otherwise\n        \"\"\"\n        try:\n            user_info = await self.get_userinfo(token)\n\n            # Get all user roles\n            all_roles = set()\n\n            # Add realm roles\n            realm_access = user_info.get(\"realm_access\", {})\n            all_roles.update(realm_access.get(\"roles\", []))\n\n            # Add roles from the configured client\n            resource_access = user_info.get(\"resource_access\", {})\n            client_roles = resource_access.get(self.configs.CLIENT_ID, {}).get(\"roles\", [])\n            all_roles.update(client_roles)\n\n            # Check if all required roles are present\n            return role_names.issubset(all_roles)\n\n        except Exception as e:\n            logger.debug(f\"All roles check failed: {e!s}\")\n            return False\n\n    @override\n    async def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n        \"\"\"Check if a user has permission to access a resource with the specified scope.\n\n        Args:\n            token: Access token\n            resource: Resource name\n            scope: Permission scope\n\n        Returns:\n            True if permission granted, False otherwise\n        \"\"\"\n        try:\n            # Use UMA permissions endpoint to check specific resource and scope\n            permissions = await self.openid_adapter.a_uma_permissions(token, permissions=f\"{resource}#{scope}\")\n\n            # Check if the response indicates permission is granted\n            if not permissions or not isinstance(permissions, list):\n                logger.debug(\"No permissions returned or invalid response format\")\n                return False\n\n            # Look for the specific permission in the response\n            for perm in permissions:\n                if perm.get(\"rsname\") == resource and scope in perm.get(\"scopes\", []):\n                    return True\n\n        except KeycloakError as e:\n            logger.debug(f\"Permission check failed with Keycloak error: {e!s}\")\n            return False\n        except Exception as e:\n            logger.debug(f\"Permission check failed with unexpected error: {e!s}\")\n            return False\n        else:\n            return False\n\n    @override\n    async def create_realm(self, realm_name: str, skip_exists: bool = True, **kwargs: Any) -&gt; dict[str, Any] | None:\n        \"\"\"Create a Keycloak realm with minimum required fields and optional additional config.\n\n        Args:\n            realm_name: The realm identifier (required)\n            skip_exists: Skip creation if realm already exists\n            kwargs: Additional optional configurations for the realm\n\n        Returns:\n            Dictionary with realm information and status\n\n        Raises:\n            InternalError: If realm creation fails\n        \"\"\"\n        payload = {\n            \"realm\": realm_name,\n            \"enabled\": kwargs.get(\"enabled\", True),\n            \"displayName\": kwargs.get(\"display_name\", realm_name),\n        }\n\n        # Add any additional parameters from kwargs\n        for key, value in kwargs.items():\n            # Skip display_name as it's already handled\n            if key == \"display_name\":\n                continue\n\n            # Convert Python snake_case to Keycloak camelCase\n            camel_key = StringUtils.snake_to_camel_case(key)\n            payload[camel_key] = value\n\n        try:\n            await self.admin_adapter.a_create_realm(payload=payload, skip_exists=skip_exists)\n        except KeycloakError as e:\n            logger.debug(f\"Failed to create realm: {e!s}\")\n\n            # Handle realm already exists with skip_exists option\n            if skip_exists:\n                error_message = self._extract_error_message(e).lower()\n                if \"already exists\" in error_message and \"realm\" in error_message:\n                    return {\"realm\": realm_name, \"status\": \"already_exists\", \"config\": payload}\n\n            # Use the mixin to handle realm-specific errors\n            self._handle_realm_exception(e, \"create_realm\", realm_name)\n        else:\n            return {\"realm\": realm_name, \"status\": \"created\", \"config\": payload}\n\n    @override\n    async def get_realm(self, realm_name: str) -&gt; dict[str, Any] | None:\n        \"\"\"Get realm details by realm name.\n\n        Args:\n            realm_name: Name of the realm\n\n        Returns:\n            Realm details\n\n        Raises:\n            InternalError: If getting realm fails\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_realm(realm_name)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_realm\")\n\n    @override\n    async def create_client(\n        self,\n        client_id: str,\n        realm: str | None = None,\n        skip_exists: bool = True,\n        **kwargs: Any,\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"Create a Keycloak client with minimum required fields and optional additional config.\n\n        Args:\n            client_id: The client identifier (required)\n            realm: Target realm name (uses the current realm in KeycloakAdmin if not specified)\n            skip_exists: Skip creation if client already exists\n            kwargs: Additional optional configurations for the client\n\n        Returns:\n            Dictionary with client information\n\n        Raises:\n            InternalError: If client creation fails\n        \"\"\"\n        original_realm = self.admin_adapter.connection.realm_name\n\n        try:\n            # Set the target realm if provided\n            if realm and realm != original_realm:\n                self.admin_adapter.connection.realm_name = realm\n\n            public_client = kwargs.get(\"public_client\", False)\n\n            # Prepare the minimal client payload\n            payload = {\n                \"clientId\": client_id,\n                \"enabled\": kwargs.get(\"enabled\", True),\n                \"protocol\": kwargs.get(\"protocol\", \"openid-connect\"),\n                \"name\": kwargs.get(\"name\", client_id),\n                \"publicClient\": public_client,\n            }\n\n            # Enable service accounts for confidential clients by default\n            if not public_client:\n                payload[\"serviceAccountsEnabled\"] = kwargs.get(\"service_account_enabled\", True)\n                payload[\"clientAuthenticatorType\"] = \"client-secret\"\n\n            for key, value in kwargs.items():\n                if key in [\"enabled\", \"protocol\", \"name\", \"public_client\", \"service_account_enabled\"]:\n                    continue\n\n                # Convert snake_case to camelCase\n                camel_key = StringUtils.snake_to_camel_case(key)\n                payload[camel_key] = value\n\n            internal_client_id = None\n            try:\n                internal_client_id = await self.admin_adapter.a_create_client(payload, skip_exists=skip_exists)\n            except KeycloakError as e:\n                logger.debug(f\"Failed to create client: {e!s}\")\n\n                # Handle client already exists with skip_exists option\n                if skip_exists:\n                    error_message = self._extract_error_message(e).lower()\n                    if \"already exists\" in error_message and \"client\" in error_message:\n                        return {\n                            \"client_id\": client_id,\n                            \"status\": \"already_exists\",\n                            \"realm\": self.admin_adapter.connection.realm_name,\n                        }\n\n                # Use the mixin to handle client-specific errors\n                client_data = {\"clientId\": client_id, \"name\": kwargs.get(\"name\", client_id)}\n                self._handle_client_exception(e, \"create_client\", client_data)\n\n            return {\n                \"client_id\": client_id,\n                \"internal_client_id\": internal_client_id,\n                \"realm\": self.admin_adapter.connection.realm_name,\n                \"status\": \"created\",\n            }\n\n        finally:\n            # Always restore the original realm\n            if realm and realm != original_realm:\n                self.admin_adapter.connection.realm_name = original_realm\n\n    @override\n    async def add_realm_roles_to_composite(self, composite_role_name: str, child_role_names: list[str]) -&gt; None:\n        \"\"\"Add realm roles to a composite role.\n\n        Args:\n            composite_role_name: Name of the composite role\n            child_role_names: List of child role names to add\n        \"\"\"\n        try:\n            child_roles = []\n            for role_name in child_role_names:\n                try:\n                    role = await self.admin_adapter.a_get_realm_role(role_name)\n                    child_roles.append(role)\n                except KeycloakGetError as e:\n                    if e.response_code == 404:\n                        logger.warning(f\"Child role not found: {role_name}\")\n                        continue\n                    raise\n\n            if child_roles:\n                await self.admin_adapter.a_add_composite_realm_roles_to_role(\n                    role_name=composite_role_name,\n                    roles=child_roles,\n                )\n                logger.info(f\"Added {len(child_roles)} realm roles to composite role: {composite_role_name}\")\n\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"add_realm_roles_to_composite\")\n\n    @override\n    async def add_client_roles_to_composite(\n        self,\n        composite_role_name: str,\n        client_id: str,\n        child_role_names: list[str],\n    ) -&gt; None:\n        \"\"\"Add client roles to a composite role.\n\n        Args:\n            composite_role_name: Name of the composite role\n            client_id: Client ID or client name\n            child_role_names: List of child role names to add\n        \"\"\"\n        try:\n            internal_client_id = await self.admin_adapter.a_get_client_id(client_id)\n\n            child_roles = []\n            for role_name in child_role_names:\n                try:\n                    role = await self.admin_adapter.a_get_client_role(internal_client_id, role_name)\n                    child_roles.append(role)\n                except KeycloakGetError as e:\n                    if e.response_code == 404:\n                        logger.warning(f\"Client role not found: {role_name}\")\n                        continue\n                    raise\n\n            if child_roles:\n                await self.admin_adapter.a_add_composite_client_roles_to_role(\n                    role_name=composite_role_name,\n                    client_role_id=internal_client_id,\n                    roles=child_roles,\n                )\n                logger.info(f\"Added {len(child_roles)} client roles to composite role: {composite_role_name}\")\n\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"add_client_roles_to_composite\")\n\n    @override\n    async def get_composite_realm_roles(self, role_name: str) -&gt; list[dict[str, Any]] | None:\n        \"\"\"Get composite roles for a realm role.\n\n        Args:\n            role_name: Name of the role\n\n        Returns:\n            List of composite roles\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_composite_realm_roles_of_role(role_name)\n        except KeycloakError as e:\n            self._handle_keycloak_exception(e, \"get_composite_realm_roles\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.admin_adapter","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.admin_adapter</code>  <code>property</code>","text":"<p>Get the admin adapter, refreshing it if necessary.</p> <p>Returns:</p> Type Description <code>KeycloakAdmin</code> <p>KeycloakAdmin instance</p> <p>Raises:</p> Type Description <code>UnauthenticatedError</code> <p>If admin client is not available due to authentication issues</p> <code>UnavailableError</code> <p>If Keycloak service is unavailable</p>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.__init__","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.__init__(keycloak_configs=None)</code>","text":"<p>Initialize KeycloakAdapter with configuration.</p> <p>Parameters:</p> Name Type Description Default <code>keycloak_configs</code> <code>KeycloakConfig | None</code> <p>Optional Keycloak configuration. If None, global config is used.</p> <code>None</code> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>def __init__(self, keycloak_configs: KeycloakConfig | None = None) -&gt; None:\n    \"\"\"Initialize KeycloakAdapter with configuration.\n\n    Args:\n        keycloak_configs: Optional Keycloak configuration. If None, global config is used.\n    \"\"\"\n    self.configs: KeycloakConfig = (\n        BaseConfig.global_config().KEYCLOAK if keycloak_configs is None else keycloak_configs\n    )\n\n    # Initialize the OpenID client for authentication\n    self.openid_adapter = self._get_openid_client(self.configs)\n\n    # Cache for admin client to avoid unnecessary re-authentication\n    self._admin_adapter: KeycloakAdmin | None = None\n    self._admin_token_expiry: float = 0.0\n\n    # Initialize admin client if admin mode is enabled and credentials are provided\n    if self.configs.IS_ADMIN_MODE_ENABLED and (\n        self.configs.CLIENT_SECRET_KEY or (self.configs.ADMIN_USERNAME and self.configs.ADMIN_PASSWORD)\n    ):\n        self._initialize_admin_client()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.clear_all_caches","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.clear_all_caches()</code>","text":"<p>Clear all cached values.</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>def clear_all_caches(self) -&gt; None:\n    \"\"\"Clear all cached values.\"\"\"\n    for attr_name in dir(self):\n        attr = getattr(self, attr_name)\n        if hasattr(attr, \"cache_clear\"):\n            attr.cache_clear()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_public_key","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_public_key()</code>  <code>async</code>","text":"<p>Get the public key used to verify tokens.</p> <p>Returns:</p> Type Description <code>PublicKeyType</code> <p>JWK key object used to verify signatures</p> <p>Raises:</p> Type Description <code>ServiceUnavailableError</code> <p>If Keycloak service is unavailable</p> <code>InternalError</code> <p>If there's an internal error processing the public key</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour, public key rarely changes\nasync def get_public_key(self) -&gt; PublicKeyType:\n    \"\"\"Get the public key used to verify tokens.\n\n    Returns:\n        JWK key object used to verify signatures\n\n    Raises:\n        ServiceUnavailableError: If Keycloak service is unavailable\n        InternalError: If there's an internal error processing the public key\n    \"\"\"\n    try:\n        from jwcrypto import jwk\n\n        keys_info = await self.openid_adapter.a_public_key()\n        key = f\"-----BEGIN PUBLIC KEY-----\\n{keys_info}\\n-----END PUBLIC KEY-----\"\n        return jwk.JWK.from_pem(key.encode(\"utf-8\"))\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_public_key\")\n    except Exception as e:\n        raise InternalError(additional_data={\"operation\": \"get_public_key\", \"error\": str(e)}) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token(username, password)</code>  <code>async</code>","text":"<p>Get a user token by username and password using the Resource Owner Password Credentials Grant.</p> Warning <p>This method uses the direct password grant flow, which is less secure and not recommended for user login in production environments. Instead, prefer the web-based OAuth 2.0 Authorization Code Flow (use <code>get_token_from_code</code>) for secure authentication. Use this method only for testing, administrative tasks, or specific service accounts where direct credential use is acceptable and properly secured.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>User's username</p> required <code>password</code> <code>str</code> <p>User's password</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType | None</code> <p>Token response containing access_token, refresh_token, etc.</p> <p>Raises:</p> Type Description <code>InvalidCredentialsError</code> <p>If username or password is invalid</p> <code>ServiceUnavailableError</code> <p>If Keycloak service is unavailable</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def get_token(self, username: str, password: str) -&gt; KeycloakTokenType | None:\n    \"\"\"Get a user token by username and password using the Resource Owner Password Credentials Grant.\n\n    Warning:\n        This method uses the direct password grant flow, which is less secure and not recommended\n        for user login in production environments. Instead, prefer the web-based OAuth 2.0\n        Authorization Code Flow (use `get_token_from_code`) for secure authentication.\n        Use this method only for testing, administrative tasks, or specific service accounts\n        where direct credential use is acceptable and properly secured.\n\n    Args:\n        username: User's username\n        password: User's password\n\n    Returns:\n        Token response containing access_token, refresh_token, etc.\n\n    Raises:\n        InvalidCredentialsError: If username or password is invalid\n        ServiceUnavailableError: If Keycloak service is unavailable\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_token(grant_type=\"password\", username=username, password=password)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_token\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.refresh_token","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.refresh_token(refresh_token)</code>  <code>async</code>","text":"<p>Refresh an existing token using a refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str</code> <p>Refresh token string</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType | None</code> <p>New token response containing access_token, refresh_token, etc.</p> <p>Raises:</p> Type Description <code>InvalidTokenError</code> <p>If refresh token is invalid or expired</p> <code>ServiceUnavailableError</code> <p>If Keycloak service is unavailable</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType | None:\n    \"\"\"Refresh an existing token using a refresh token.\n\n    Args:\n        refresh_token: Refresh token string\n\n    Returns:\n        New token response containing access_token, refresh_token, etc.\n\n    Raises:\n        InvalidTokenError: If refresh token is invalid or expired\n        ServiceUnavailableError: If Keycloak service is unavailable\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_refresh_token(refresh_token)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"refresh_token\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.validate_token","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.validate_token(token)</code>  <code>async</code>","text":"<p>Validate if a token is still valid.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token to validate</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if token is valid, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def validate_token(self, token: str) -&gt; bool:\n    \"\"\"Validate if a token is still valid.\n\n    Args:\n        token: Access token to validate\n\n    Returns:\n        True if token is valid, False otherwise\n    \"\"\"\n    # Not caching validation results as tokens are time-sensitive\n    try:\n        await self.openid_adapter.a_decode_token(\n            token,\n            key=await self.get_public_key(),\n        )\n    except Exception as e:\n        logger.debug(f\"Token validation failed: {e!s}\")\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_userinfo","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_userinfo(token)</code>  <code>async</code>","text":"<p>Get user information from a token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User information</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting user info fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def get_userinfo(self, token: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user information from a token.\n\n    Args:\n        token: Access token\n\n    Returns:\n        User information\n\n    Raises:\n        ValueError: If getting user info fails\n    \"\"\"\n    if not await self.validate_token(token):\n        raise InvalidTokenError()\n    try:\n        return await self._get_userinfo_cached(token)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_userinfo\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_id","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_id(user_id)</code>  <code>async</code>","text":"<p>Get user details by user ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\nasync def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by user ID.\n\n    Args:\n        user_id: User's ID\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If getting user fails\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_user(user_id)\n    except KeycloakGetError as e:\n        if e.response_code == 404:\n            return None\n        raise InternalError() from e\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_user_by_id\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_username","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_username(username)</code>  <code>async</code>","text":"<p>Get user details by username.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>User's username</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If query fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\nasync def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by username.\n\n    Args:\n        username: User's username\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If query fails\n    \"\"\"\n    try:\n        users = await self.admin_adapter.a_get_users({\"username\": username})\n        return users[0] if users else None\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_user_by_username\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_email","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_email(email)</code>  <code>async</code>","text":"<p>Get user details by email.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>User's email</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If query fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\nasync def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by email.\n\n    Args:\n        email: User's email\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If query fails\n    \"\"\"\n    try:\n        users = await self.admin_adapter.a_get_users({\"email\": email})\n        return users[0] if users else None\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_user_by_email\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_roles","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_roles(user_id)</code>  <code>async</code>","text":"<p>Get roles assigned to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Returns:</p> Type Description <code>list[KeycloakRoleType] | None</code> <p>List of roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\nasync def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType] | None:\n    \"\"\"Get roles assigned to a user.\n\n    Args:\n        user_id: User's ID\n\n    Returns:\n        List of roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_realm_roles_of_user(user_id)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_user_roles\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_roles_for_user","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_roles_for_user(user_id, client_id)</code>  <code>async</code>","text":"<p>Get client-specific roles assigned to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <p>Returns:</p> Type Description <code>list[KeycloakRoleType]</code> <p>List of client-specific roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\nasync def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get client-specific roles assigned to a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n\n    Returns:\n        List of client-specific roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_client_roles_of_user(user_id, client_id)\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_user","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_user(user_data)</code>  <code>async</code>","text":"<p>Create a new user in Keycloak.</p> <p>Parameters:</p> Name Type Description Default <code>user_data</code> <code>dict[str, Any]</code> <p>User data including username, email, etc.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>ID of the created user</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If creating user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def create_user(self, user_data: dict[str, Any]) -&gt; str | None:\n    \"\"\"Create a new user in Keycloak.\n\n    Args:\n        user_data: User data including username, email, etc.\n\n    Returns:\n        ID of the created user\n\n    Raises:\n        ValueError: If creating user fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        user_id = await self.admin_adapter.a_create_user(user_data)\n\n        # Clear related caches\n        self.clear_all_caches()\n    except KeycloakError as e:\n        self._handle_user_exception(e, \"create_user\", user_data)\n    else:\n        return user_id\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.update_user","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.update_user(user_id, user_data)</code>  <code>async</code>","text":"<p>Update user details.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>user_data</code> <code>dict[str, Any]</code> <p>User data to update</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If updating user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n    \"\"\"Update user details.\n\n    Args:\n        user_id: User's ID\n        user_data: User data to update\n\n    Raises:\n        ValueError: If updating user fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        await self.admin_adapter.a_update_user(user_id, user_data)\n\n        # Clear user-related caches\n        self.clear_all_caches()\n\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"update_user\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.reset_password","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.reset_password(user_id, password, temporary=False)</code>  <code>async</code>","text":"<p>Reset a user's password.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>password</code> <code>str</code> <p>New password</p> required <code>temporary</code> <code>bool</code> <p>Whether the password is temporary and should be changed on next login</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If password reset fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n    \"\"\"Reset a user's password.\n\n    Args:\n        user_id: User's ID\n        password: New password\n        temporary: Whether the password is temporary and should be changed on next login\n\n    Raises:\n        ValueError: If password reset fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        await self.admin_adapter.a_set_user_password(user_id, password, temporary)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"reset_password\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.assign_realm_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.assign_realm_role(user_id, role_name)</code>  <code>async</code>","text":"<p>Assign a realm role to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>role_name</code> <code>str</code> <p>Role name to assign</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role assignment fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a realm role to a user.\n\n    Args:\n        user_id: User's ID\n        role_name: Role name to assign\n\n    Raises:\n        ValueError: If role assignment fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get role representation\n        role = await self.admin_adapter.a_get_realm_role(role_name)\n        # Assign role to user\n        await self.admin_adapter.a_assign_realm_roles(user_id, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_user_roles, \"cache_clear\"):\n            self.get_user_roles.cache_clear()\n\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"assign_realm_role\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.remove_realm_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.remove_realm_role(user_id, role_name)</code>  <code>async</code>","text":"<p>Remove a realm role from a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>role_name</code> <code>str</code> <p>Role name to remove</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role removal fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a realm role from a user.\n\n    Args:\n        user_id: User's ID\n        role_name: Role name to remove\n\n    Raises:\n        ValueError: If role removal fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get role representation\n        role = await self.admin_adapter.a_get_realm_role(role_name)\n        # Remove role from user\n        await self.admin_adapter.a_delete_realm_roles_of_user(user_id, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_user_roles, \"cache_clear\"):\n            self.get_user_roles.cache_clear()\n\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"remove_realm_role\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.assign_client_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.assign_client_role(user_id, client_id, role_name)</code>  <code>async</code>","text":"<p>Assign a client-specific role to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>role_name</code> <code>str</code> <p>Role name to assign</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role assignment fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a client-specific role to a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n        role_name: Role name to assign\n\n    Raises:\n        ValueError: If role assignment fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get client\n        client = await self.admin_adapter.a_get_client_id(client_id)\n        # Get role representation\n        role = await self.admin_adapter.a_get_client_role(client, role_name)\n        # Assign role to user\n        await self.admin_adapter.a_assign_client_role(user_id, client, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_client_roles_for_user, \"cache_clear\"):\n            self.get_client_roles_for_user.cache_clear()\n\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"assign_client_role\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_realm_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_realm_role(role_name, description=None, skip_exists=True)</code>  <code>async</code>","text":"<p>Create a new realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name</p> required <code>description</code> <code>str | None</code> <p>Optional role description</p> <code>None</code> <code>skip_exists</code> <code>bool</code> <p>Skip creation if role already exists</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Created role details</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If role creation fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def create_realm_role(\n    self,\n    role_name: str,\n    description: str | None = None,\n    skip_exists: bool = True,\n) -&gt; dict[str, Any] | None:\n    \"\"\"Create a new realm role.\n\n    Args:\n        role_name: Role name\n        description: Optional role description\n        skip_exists: Skip creation if role already exists\n\n    Returns:\n        Created role details\n\n    Raises:\n        ValueError: If role creation fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        role_data = {\"name\": role_name}\n        if description:\n            role_data[\"description\"] = description\n\n        await self.admin_adapter.a_create_realm_role(role_data, skip_exists=skip_exists)\n\n        # Clear realm roles cache\n        if hasattr(self.get_realm_roles, \"cache_clear\"):\n            self.get_realm_roles.cache_clear()\n\n        return await self.admin_adapter.a_get_realm_role(role_name)\n\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"create_realm_role\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_client_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_client_role(client_id, role_name, description=None, skip_exists=True)</code>  <code>async</code>","text":"<p>Create a new client role.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Client ID or client name</p> required <code>role_name</code> <code>str</code> <p>Role name</p> required <code>skip_exists</code> <code>bool</code> <p>Skip creation if role already exists</p> <code>True</code> <code>description</code> <code>str | None</code> <p>Optional role description</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Created role details</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def create_client_role(\n    self,\n    client_id: str,\n    role_name: str,\n    description: str | None = None,\n    skip_exists: bool = True,\n) -&gt; dict[str, Any] | None:\n    \"\"\"Create a new client role.\n\n    Args:\n        client_id: Client ID or client name\n        role_name: Role name\n        skip_exists: Skip creation if role already exists\n        description: Optional role description\n\n    Returns:\n        Created role details\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        client_id = await self.admin_adapter.a_get_client_id(client_id)\n\n        # Prepare role data\n        role_data = {\"name\": role_name}\n        if description:\n            role_data[\"description\"] = description\n\n        # Create client role\n        await self.admin_adapter.a_create_client_role(client_id, role_data, skip_exists=skip_exists)\n\n        # Clear related caches if they exist\n        if hasattr(self.get_client_roles_for_user, \"cache_clear\"):\n            self.get_client_roles_for_user.cache_clear()\n\n        # Return created role\n        return await self.admin_adapter.a_get_client_role(client_id, role_name)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"create_client_role\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.delete_realm_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.delete_realm_role(role_name)</code>  <code>async</code>","text":"<p>Delete a realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name to delete</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role deletion fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def delete_realm_role(self, role_name: str) -&gt; None:\n    \"\"\"Delete a realm role.\n\n    Args:\n        role_name: Role name to delete\n\n    Raises:\n        ValueError: If role deletion fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        await self.admin_adapter.a_delete_realm_role(role_name)\n\n        # Clear realm roles cache\n        if hasattr(self.get_realm_roles, \"cache_clear\"):\n            self.get_realm_roles.cache_clear()\n\n        # We also need to clear user role caches since they might contain this role\n        if hasattr(self.get_user_roles, \"cache_clear\"):\n            self.get_user_roles.cache_clear()\n\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"delete_realm_role\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_service_account_id","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_service_account_id()</code>  <code>async</code>","text":"<p>Get service account user ID for the current client.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>Service account user ID</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting service account fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\nasync def get_service_account_id(self) -&gt; str | None:\n    \"\"\"Get service account user ID for the current client.\n\n    Returns:\n        Service account user ID\n\n    Raises:\n        ValueError: If getting service account fails\n    \"\"\"\n    try:\n        client_id = await self.get_client_id(self.configs.CLIENT_ID)\n        service_account = await self.admin_adapter.a_get_client_service_account_user(client_id)\n        return service_account.get(\"id\")\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_service_account_id\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_well_known_config","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_well_known_config()</code>  <code>async</code>","text":"<p>Get the well-known OpenID configuration.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>OIDC configuration</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting configuration fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\nasync def get_well_known_config(self) -&gt; dict[str, Any] | None:\n    \"\"\"Get the well-known OpenID configuration.\n\n    Returns:\n        OIDC configuration\n\n    Raises:\n        ValueError: If getting configuration fails\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_well_known()\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_well_known_config\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_certs","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_certs()</code>  <code>async</code>","text":"<p>Get the JWT verification certificates.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Certificate information</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting certificates fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\nasync def get_certs(self) -&gt; dict[str, Any] | None:\n    \"\"\"Get the JWT verification certificates.\n\n    Returns:\n        Certificate information\n\n    Raises:\n        ValueError: If getting certificates fails\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_certs()\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_certs\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token_from_code","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token_from_code(code, redirect_uri)</code>  <code>async</code>","text":"<p>Exchange authorization code for token.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Authorization code</p> required <code>redirect_uri</code> <code>str</code> <p>Redirect URI used in authorization request</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType | None</code> <p>Token response</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token exchange fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType | None:\n    \"\"\"Exchange authorization code for token.\n\n    Args:\n        code: Authorization code\n        redirect_uri: Redirect URI used in authorization request\n\n    Returns:\n        Token response\n\n    Raises:\n        ValueError: If token exchange fails\n    \"\"\"\n    # Authorization codes can only be used once, don't cache\n    try:\n        return await self.openid_adapter.a_token(\n            grant_type=\"authorization_code\",\n            code=code,\n            redirect_uri=redirect_uri,\n        )\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_token_from_code\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_credentials_token","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_credentials_token()</code>  <code>async</code>","text":"<p>Get token using client credentials.</p> <p>Returns:</p> Type Description <code>KeycloakTokenType | None</code> <p>Token response</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token acquisition fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def get_client_credentials_token(self) -&gt; KeycloakTokenType | None:\n    \"\"\"Get token using client credentials.\n\n    Returns:\n        Token response\n\n    Raises:\n        ValueError: If token acquisition fails\n    \"\"\"\n    # Tokens are time-sensitive, don't cache\n    try:\n        return await self.openid_adapter.a_token(grant_type=\"client_credentials\")\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_client_credentials_token\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.search_users","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.search_users(query, max_results=100)</code>  <code>async</code>","text":"<p>Search for users by username, email, or name.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Search query</p> required <code>max_results</code> <code>int</code> <p>Maximum number of results to return</p> <code>100</code> <p>Returns:</p> Type Description <code>list[KeycloakUserType] | None</code> <p>List of matching users</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If search fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=30, maxsize=50)  # Cache for 30 seconds with limited entries\nasync def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType] | None:\n    \"\"\"Search for users by username, email, or name.\n\n    Args:\n        query: Search query\n        max_results: Maximum number of results to return\n\n    Returns:\n        List of matching users\n\n    Raises:\n        ValueError: If search fails\n    \"\"\"\n    try:\n        # Try searching by different fields\n        users = []\n\n        # Search by username\n        users.extend(await self.admin_adapter.a_get_users({\"username\": query, \"max\": max_results}))\n\n        # Search by email if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            email_users = await self.admin_adapter.a_get_users({\"email\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in email_users if user[\"id\"] not in user_ids])\n\n        # Search by firstName if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            first_name_users = await self.admin_adapter.a_get_users({\"firstName\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in first_name_users if user[\"id\"] not in user_ids])\n\n        # Search by lastName if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            last_name_users = await self.admin_adapter.a_get_users({\"lastName\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in last_name_users if user[\"id\"] not in user_ids])\n\n        return users[:max_results]\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"search_users\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_secret","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_secret(client_id)</code>  <code>async</code>","text":"<p>Get client secret.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Client ID</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Client secret</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting secret fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=50)  # Cache for 1 hour\nasync def get_client_secret(self, client_id: str) -&gt; str | None:\n    \"\"\"Get client secret.\n\n    Args:\n        client_id: Client ID\n\n    Returns:\n        Client secret\n\n    Raises:\n        ValueError: If getting secret fails\n    \"\"\"\n    try:\n        client = await self.admin_adapter.a_get_client(client_id)\n        return client.get(\"secret\", \"\")\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_client_secret\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_id","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_id(client_name)</code>  <code>async</code>","text":"<p>Get client ID by client name.</p> <p>Parameters:</p> Name Type Description Default <code>client_name</code> <code>str</code> <p>Name of the client</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Client ID</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If client not found</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=50)  # Cache for 1 hour\nasync def get_client_id(self, client_name: str) -&gt; str | None:\n    \"\"\"Get client ID by client name.\n\n    Args:\n        client_name: Name of the client\n\n    Returns:\n        Client ID\n\n    Raises:\n        ValueError: If client not found\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_client_id(client_name)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_client_id\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_realm_roles","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_realm_roles()</code>  <code>async</code>","text":"<p>Get all realm roles.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]] | None</code> <p>List of realm roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=1)  # Cache for 5 minutes\nasync def get_realm_roles(self) -&gt; list[dict[str, Any]] | None:\n    \"\"\"Get all realm roles.\n\n    Returns:\n        List of realm roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_realm_roles()\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_realm_roles\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_realm_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_realm_role(role_name)</code>  <code>async</code>","text":"<p>Get realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name</p> required <p>Returns:     A realm role</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting role fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=1)  # Cache for 5 minutes\nasync def get_realm_role(self, role_name: str) -&gt; dict | None:\n    \"\"\"Get realm role.\n\n    Args:\n        role_name: Role name\n    Returns:\n        A realm role\n\n    Raises:\n        ValueError: If getting role fails\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_realm_role(role_name)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_realm_role\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.remove_client_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.remove_client_role(user_id, client_id, role_name)</code>  <code>async</code>","text":"<p>Remove a client-specific role from a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>role_name</code> <code>str</code> <p>Role name to remove</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role removal fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a client-specific role from a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n        role_name: Role name to remove\n\n    Raises:\n        ValueError: If role removal fails\n    \"\"\"\n    try:\n        client = await self.admin_adapter.a_get_client_id(client_id)\n        role = await self.admin_adapter.a_get_client_role(client, role_name)\n        await self.admin_adapter.a_delete_client_roles_of_user(user_id, client, [role])\n\n        if hasattr(self.get_client_roles_for_user, \"cache_clear\"):\n            self.get_client_roles_for_user.cache_clear()\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"remove_client_role\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.clear_user_sessions","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.clear_user_sessions(user_id)</code>  <code>async</code>","text":"<p>Clear all sessions for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If clearing sessions fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def clear_user_sessions(self, user_id: str) -&gt; None:\n    \"\"\"Clear all sessions for a user.\n\n    Args:\n        user_id: User's ID\n\n    Raises:\n        ValueError: If clearing sessions fails\n    \"\"\"\n    try:\n        await self.admin_adapter.a_user_logout(user_id)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"clear_user_sessions\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.logout","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.logout(refresh_token)</code>  <code>async</code>","text":"<p>Logout user by invalidating their refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str</code> <p>Refresh token to invalidate</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If logout fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def logout(self, refresh_token: str) -&gt; None:\n    \"\"\"Logout user by invalidating their refresh token.\n\n    Args:\n        refresh_token: Refresh token to invalidate\n\n    Raises:\n        ValueError: If logout fails\n    \"\"\"\n    try:\n        await self.openid_adapter.a_logout(refresh_token)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"logout\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.introspect_token","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.introspect_token(token)</code>  <code>async</code>","text":"<p>Introspect token to get detailed information about it.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Token introspection details</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token introspection fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def introspect_token(self, token: str) -&gt; dict[str, Any] | None:\n    \"\"\"Introspect token to get detailed information about it.\n\n    Args:\n        token: Access token\n\n    Returns:\n        Token introspection details\n\n    Raises:\n        ValueError: If token introspection fails\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_introspect(token)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"introspect_token\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token_info","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token_info(token)</code>  <code>async</code>","text":"<p>Decode token to get its claims.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Dictionary of token claims</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token decoding fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def get_token_info(self, token: str) -&gt; dict[str, Any] | None:\n    \"\"\"Decode token to get its claims.\n\n    Args:\n        token: Access token\n\n    Returns:\n        Dictionary of token claims\n\n    Raises:\n        ValueError: If token decoding fails\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_decode_token(\n            token,\n            key=await self.get_public_key(),\n        )\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_token_info\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.delete_user","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.delete_user(user_id)</code>  <code>async</code>","text":"<p>Delete a user from Keycloak by their ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>The ID of the user to delete</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the deletion fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def delete_user(self, user_id: str) -&gt; None:\n    \"\"\"Delete a user from Keycloak by their ID.\n\n    Args:\n        user_id: The ID of the user to delete\n\n    Raises:\n        ValueError: If the deletion fails\n    \"\"\"\n    try:\n        await self.admin_adapter.a_delete_user(user_id=user_id)\n\n        if hasattr(self.get_user_by_username, \"cache_clear\"):\n            self.get_user_by_username.cache_clear()\n\n        logger.info(f\"Successfully deleted user with ID {user_id}\")\n\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"delete_user\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_role(token, role_name)</code>  <code>async</code>","text":"<p>Check if a user has a specific role.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_name</code> <code>str</code> <p>Role name to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has the role, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def has_role(self, token: str, role_name: str) -&gt; bool:\n    \"\"\"Check if a user has a specific role.\n\n    Args:\n        token: Access token\n        role_name: Role name to check\n\n    Returns:\n        True if user has the role, False otherwise\n    \"\"\"\n    # Not caching this result as token validation is time-sensitive\n    try:\n        user_info = await self.get_userinfo(token)\n\n        # Check realm roles\n        realm_access = user_info.get(\"realm_access\", {})\n        roles = realm_access.get(\"roles\", [])\n        if role_name in roles:\n            return True\n\n        # Check roles for the configured client\n        resource_access = user_info.get(\"resource_access\", {})\n        client_roles = resource_access.get(self.configs.CLIENT_ID, {}).get(\"roles\", [])\n        if role_name in client_roles:\n            return True\n\n    except Exception as e:\n        logger.debug(f\"Role check failed: {e!s}\")\n        return False\n    else:\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_any_of_roles","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_any_of_roles(token, role_names)</code>  <code>async</code>","text":"<p>Check if a user has any of the specified roles.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_names</code> <code>frozenset[str]</code> <p>Set of role names to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has any of the roles, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def has_any_of_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n    \"\"\"Check if a user has any of the specified roles.\n\n    Args:\n        token: Access token\n        role_names: Set of role names to check\n\n    Returns:\n        True if user has any of the roles, False otherwise\n    \"\"\"\n    try:\n        user_info = await self.get_userinfo(token)\n\n        # Check realm roles first\n        realm_access = user_info.get(\"realm_access\", {})\n        realm_roles = set(realm_access.get(\"roles\", []))\n        if role_names.intersection(realm_roles):\n            return True\n\n        # Check roles for the configured client\n        resource_access = user_info.get(\"resource_access\", {})\n        client_roles = set(resource_access.get(self.configs.CLIENT_ID, {}).get(\"roles\", []))\n        if role_names.intersection(client_roles):\n            return True\n\n    except Exception as e:\n        logger.debug(f\"Role check failed: {e!s}\")\n        return False\n    else:\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_all_roles","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_all_roles(token, role_names)</code>  <code>async</code>","text":"<p>Check if a user has all the specified roles.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_names</code> <code>frozenset[str]</code> <p>Set of role names to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has all the roles, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def has_all_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n    \"\"\"Check if a user has all the specified roles.\n\n    Args:\n        token: Access token\n        role_names: Set of role names to check\n\n    Returns:\n        True if user has all the roles, False otherwise\n    \"\"\"\n    try:\n        user_info = await self.get_userinfo(token)\n\n        # Get all user roles\n        all_roles = set()\n\n        # Add realm roles\n        realm_access = user_info.get(\"realm_access\", {})\n        all_roles.update(realm_access.get(\"roles\", []))\n\n        # Add roles from the configured client\n        resource_access = user_info.get(\"resource_access\", {})\n        client_roles = resource_access.get(self.configs.CLIENT_ID, {}).get(\"roles\", [])\n        all_roles.update(client_roles)\n\n        # Check if all required roles are present\n        return role_names.issubset(all_roles)\n\n    except Exception as e:\n        logger.debug(f\"All roles check failed: {e!s}\")\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.check_permissions","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.check_permissions(token, resource, scope)</code>  <code>async</code>","text":"<p>Check if a user has permission to access a resource with the specified scope.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>resource</code> <code>str</code> <p>Resource name</p> required <code>scope</code> <code>str</code> <p>Permission scope</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if permission granted, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n    \"\"\"Check if a user has permission to access a resource with the specified scope.\n\n    Args:\n        token: Access token\n        resource: Resource name\n        scope: Permission scope\n\n    Returns:\n        True if permission granted, False otherwise\n    \"\"\"\n    try:\n        # Use UMA permissions endpoint to check specific resource and scope\n        permissions = await self.openid_adapter.a_uma_permissions(token, permissions=f\"{resource}#{scope}\")\n\n        # Check if the response indicates permission is granted\n        if not permissions or not isinstance(permissions, list):\n            logger.debug(\"No permissions returned or invalid response format\")\n            return False\n\n        # Look for the specific permission in the response\n        for perm in permissions:\n            if perm.get(\"rsname\") == resource and scope in perm.get(\"scopes\", []):\n                return True\n\n    except KeycloakError as e:\n        logger.debug(f\"Permission check failed with Keycloak error: {e!s}\")\n        return False\n    except Exception as e:\n        logger.debug(f\"Permission check failed with unexpected error: {e!s}\")\n        return False\n    else:\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_realm","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_realm(realm_name, skip_exists=True, **kwargs)</code>  <code>async</code>","text":"<p>Create a Keycloak realm with minimum required fields and optional additional config.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>The realm identifier (required)</p> required <code>skip_exists</code> <code>bool</code> <p>Skip creation if realm already exists</p> <code>True</code> <code>kwargs</code> <code>Any</code> <p>Additional optional configurations for the realm</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Dictionary with realm information and status</p> <p>Raises:</p> Type Description <code>InternalError</code> <p>If realm creation fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def create_realm(self, realm_name: str, skip_exists: bool = True, **kwargs: Any) -&gt; dict[str, Any] | None:\n    \"\"\"Create a Keycloak realm with minimum required fields and optional additional config.\n\n    Args:\n        realm_name: The realm identifier (required)\n        skip_exists: Skip creation if realm already exists\n        kwargs: Additional optional configurations for the realm\n\n    Returns:\n        Dictionary with realm information and status\n\n    Raises:\n        InternalError: If realm creation fails\n    \"\"\"\n    payload = {\n        \"realm\": realm_name,\n        \"enabled\": kwargs.get(\"enabled\", True),\n        \"displayName\": kwargs.get(\"display_name\", realm_name),\n    }\n\n    # Add any additional parameters from kwargs\n    for key, value in kwargs.items():\n        # Skip display_name as it's already handled\n        if key == \"display_name\":\n            continue\n\n        # Convert Python snake_case to Keycloak camelCase\n        camel_key = StringUtils.snake_to_camel_case(key)\n        payload[camel_key] = value\n\n    try:\n        await self.admin_adapter.a_create_realm(payload=payload, skip_exists=skip_exists)\n    except KeycloakError as e:\n        logger.debug(f\"Failed to create realm: {e!s}\")\n\n        # Handle realm already exists with skip_exists option\n        if skip_exists:\n            error_message = self._extract_error_message(e).lower()\n            if \"already exists\" in error_message and \"realm\" in error_message:\n                return {\"realm\": realm_name, \"status\": \"already_exists\", \"config\": payload}\n\n        # Use the mixin to handle realm-specific errors\n        self._handle_realm_exception(e, \"create_realm\", realm_name)\n    else:\n        return {\"realm\": realm_name, \"status\": \"created\", \"config\": payload}\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_realm","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_realm(realm_name)</code>  <code>async</code>","text":"<p>Get realm details by realm name.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Realm details</p> <p>Raises:</p> Type Description <code>InternalError</code> <p>If getting realm fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def get_realm(self, realm_name: str) -&gt; dict[str, Any] | None:\n    \"\"\"Get realm details by realm name.\n\n    Args:\n        realm_name: Name of the realm\n\n    Returns:\n        Realm details\n\n    Raises:\n        InternalError: If getting realm fails\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_realm(realm_name)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_realm\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_client","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_client(client_id, realm=None, skip_exists=True, **kwargs)</code>  <code>async</code>","text":"<p>Create a Keycloak client with minimum required fields and optional additional config.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>The client identifier (required)</p> required <code>realm</code> <code>str | None</code> <p>Target realm name (uses the current realm in KeycloakAdmin if not specified)</p> <code>None</code> <code>skip_exists</code> <code>bool</code> <p>Skip creation if client already exists</p> <code>True</code> <code>kwargs</code> <code>Any</code> <p>Additional optional configurations for the client</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Dictionary with client information</p> <p>Raises:</p> Type Description <code>InternalError</code> <p>If client creation fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def create_client(\n    self,\n    client_id: str,\n    realm: str | None = None,\n    skip_exists: bool = True,\n    **kwargs: Any,\n) -&gt; dict[str, Any] | None:\n    \"\"\"Create a Keycloak client with minimum required fields and optional additional config.\n\n    Args:\n        client_id: The client identifier (required)\n        realm: Target realm name (uses the current realm in KeycloakAdmin if not specified)\n        skip_exists: Skip creation if client already exists\n        kwargs: Additional optional configurations for the client\n\n    Returns:\n        Dictionary with client information\n\n    Raises:\n        InternalError: If client creation fails\n    \"\"\"\n    original_realm = self.admin_adapter.connection.realm_name\n\n    try:\n        # Set the target realm if provided\n        if realm and realm != original_realm:\n            self.admin_adapter.connection.realm_name = realm\n\n        public_client = kwargs.get(\"public_client\", False)\n\n        # Prepare the minimal client payload\n        payload = {\n            \"clientId\": client_id,\n            \"enabled\": kwargs.get(\"enabled\", True),\n            \"protocol\": kwargs.get(\"protocol\", \"openid-connect\"),\n            \"name\": kwargs.get(\"name\", client_id),\n            \"publicClient\": public_client,\n        }\n\n        # Enable service accounts for confidential clients by default\n        if not public_client:\n            payload[\"serviceAccountsEnabled\"] = kwargs.get(\"service_account_enabled\", True)\n            payload[\"clientAuthenticatorType\"] = \"client-secret\"\n\n        for key, value in kwargs.items():\n            if key in [\"enabled\", \"protocol\", \"name\", \"public_client\", \"service_account_enabled\"]:\n                continue\n\n            # Convert snake_case to camelCase\n            camel_key = StringUtils.snake_to_camel_case(key)\n            payload[camel_key] = value\n\n        internal_client_id = None\n        try:\n            internal_client_id = await self.admin_adapter.a_create_client(payload, skip_exists=skip_exists)\n        except KeycloakError as e:\n            logger.debug(f\"Failed to create client: {e!s}\")\n\n            # Handle client already exists with skip_exists option\n            if skip_exists:\n                error_message = self._extract_error_message(e).lower()\n                if \"already exists\" in error_message and \"client\" in error_message:\n                    return {\n                        \"client_id\": client_id,\n                        \"status\": \"already_exists\",\n                        \"realm\": self.admin_adapter.connection.realm_name,\n                    }\n\n            # Use the mixin to handle client-specific errors\n            client_data = {\"clientId\": client_id, \"name\": kwargs.get(\"name\", client_id)}\n            self._handle_client_exception(e, \"create_client\", client_data)\n\n        return {\n            \"client_id\": client_id,\n            \"internal_client_id\": internal_client_id,\n            \"realm\": self.admin_adapter.connection.realm_name,\n            \"status\": \"created\",\n        }\n\n    finally:\n        # Always restore the original realm\n        if realm and realm != original_realm:\n            self.admin_adapter.connection.realm_name = original_realm\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.add_realm_roles_to_composite","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.add_realm_roles_to_composite(composite_role_name, child_role_names)</code>  <code>async</code>","text":"<p>Add realm roles to a composite role.</p> <p>Parameters:</p> Name Type Description Default <code>composite_role_name</code> <code>str</code> <p>Name of the composite role</p> required <code>child_role_names</code> <code>list[str]</code> <p>List of child role names to add</p> required Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def add_realm_roles_to_composite(self, composite_role_name: str, child_role_names: list[str]) -&gt; None:\n    \"\"\"Add realm roles to a composite role.\n\n    Args:\n        composite_role_name: Name of the composite role\n        child_role_names: List of child role names to add\n    \"\"\"\n    try:\n        child_roles = []\n        for role_name in child_role_names:\n            try:\n                role = await self.admin_adapter.a_get_realm_role(role_name)\n                child_roles.append(role)\n            except KeycloakGetError as e:\n                if e.response_code == 404:\n                    logger.warning(f\"Child role not found: {role_name}\")\n                    continue\n                raise\n\n        if child_roles:\n            await self.admin_adapter.a_add_composite_realm_roles_to_role(\n                role_name=composite_role_name,\n                roles=child_roles,\n            )\n            logger.info(f\"Added {len(child_roles)} realm roles to composite role: {composite_role_name}\")\n\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"add_realm_roles_to_composite\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.add_client_roles_to_composite","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.add_client_roles_to_composite(composite_role_name, client_id, child_role_names)</code>  <code>async</code>","text":"<p>Add client roles to a composite role.</p> <p>Parameters:</p> Name Type Description Default <code>composite_role_name</code> <code>str</code> <p>Name of the composite role</p> required <code>client_id</code> <code>str</code> <p>Client ID or client name</p> required <code>child_role_names</code> <code>list[str]</code> <p>List of child role names to add</p> required Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def add_client_roles_to_composite(\n    self,\n    composite_role_name: str,\n    client_id: str,\n    child_role_names: list[str],\n) -&gt; None:\n    \"\"\"Add client roles to a composite role.\n\n    Args:\n        composite_role_name: Name of the composite role\n        client_id: Client ID or client name\n        child_role_names: List of child role names to add\n    \"\"\"\n    try:\n        internal_client_id = await self.admin_adapter.a_get_client_id(client_id)\n\n        child_roles = []\n        for role_name in child_role_names:\n            try:\n                role = await self.admin_adapter.a_get_client_role(internal_client_id, role_name)\n                child_roles.append(role)\n            except KeycloakGetError as e:\n                if e.response_code == 404:\n                    logger.warning(f\"Client role not found: {role_name}\")\n                    continue\n                raise\n\n        if child_roles:\n            await self.admin_adapter.a_add_composite_client_roles_to_role(\n                role_name=composite_role_name,\n                client_role_id=internal_client_id,\n                roles=child_roles,\n            )\n            logger.info(f\"Added {len(child_roles)} client roles to composite role: {composite_role_name}\")\n\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"add_client_roles_to_composite\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_composite_realm_roles","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_composite_realm_roles(role_name)</code>  <code>async</code>","text":"<p>Get composite roles for a realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Name of the role</p> required <p>Returns:</p> Type Description <code>list[dict[str, Any]] | None</code> <p>List of composite roles</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def get_composite_realm_roles(self, role_name: str) -&gt; list[dict[str, Any]] | None:\n    \"\"\"Get composite roles for a realm role.\n\n    Args:\n        role_name: Name of the role\n\n    Returns:\n        List of composite roles\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_composite_realm_roles_of_role(role_name)\n    except KeycloakError as e:\n        self._handle_keycloak_exception(e, \"get_composite_realm_roles\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort</code>","text":"<p>Interface for Keycloak operations providing a standardized access pattern.</p> <p>This interface defines the contract for Keycloak adapters, ensuring consistent implementation of Keycloak operations across different adapters. It covers essential functionality including authentication, user management, and role management.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>class KeycloakPort:\n    \"\"\"Interface for Keycloak operations providing a standardized access pattern.\n\n    This interface defines the contract for Keycloak adapters, ensuring consistent\n    implementation of Keycloak operations across different adapters. It covers essential\n    functionality including authentication, user management, and role management.\n    \"\"\"\n\n    # Token Operations\n    @abstractmethod\n    def get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n        \"\"\"Get a user token by username and password.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n        \"\"\"Refresh an existing token using a refresh token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def validate_token(self, token: str) -&gt; bool:\n        \"\"\"Validate if a token is still valid.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_userinfo(self, token: str) -&gt; KeycloakUserType:\n        \"\"\"Get user information from a token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_token_info(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Decode token to get its claims.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def introspect_token(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Introspect token to get detailed information about it.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_client_credentials_token(self) -&gt; KeycloakTokenType:\n        \"\"\"Get token using client credentials.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def logout(self, refresh_token: str) -&gt; None:\n        \"\"\"Logout user by invalidating their refresh token.\"\"\"\n        raise NotImplementedError\n\n    # User Operations\n    @abstractmethod\n    def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by user ID.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by username.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by email.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def create_user(self, user_data: dict[str, Any]) -&gt; str:\n        \"\"\"Create a new user in Keycloak.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n        \"\"\"Update user details.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n        \"\"\"Reset a user's password.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n        \"\"\"Search for users by username, email, or name.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def clear_user_sessions(self, user_id: str) -&gt; None:\n        \"\"\"Clear all sessions for a user.\"\"\"\n        raise NotImplementedError\n\n    # Role Operations\n    @abstractmethod\n    def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get roles assigned to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get client-specific roles assigned to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def has_role(self, token: str, role_name: str) -&gt; bool:\n        \"\"\"Check if a user has a specific role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def has_any_of_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n        \"\"\"Check if a user has any of the specified roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def has_all_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n        \"\"\"Check if a user has all of the specified roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a realm role to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a realm role from a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a client-specific role to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a client-specific role from a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_realm_role(self, role_name: str) -&gt; dict:\n        \"\"\"Get realm role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_realm_roles(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Get all realm roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n        \"\"\"Create a new realm role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def delete_realm_role(self, role_name: str) -&gt; None:\n        \"\"\"Delete a realm role.\"\"\"\n        raise NotImplementedError\n\n    # Client Operations\n    @abstractmethod\n    def get_client_id(self, client_name: str) -&gt; str:\n        \"\"\"Get client ID by client name.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_client_secret(self, client_id: str) -&gt; str:\n        \"\"\"Get client secret.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_service_account_id(self) -&gt; str:\n        \"\"\"Get service account user ID for the current client.\"\"\"\n        raise NotImplementedError\n\n    # System Operations\n    @abstractmethod\n    def get_public_key(self) -&gt; PublicKeyType:\n        \"\"\"Get the public key used to verify tokens.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_well_known_config(self) -&gt; dict[str, Any]:\n        \"\"\"Get the well-known OpenID configuration.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_certs(self) -&gt; dict[str, Any]:\n        \"\"\"Get the JWT verification certificates.\"\"\"\n        raise NotImplementedError\n\n    # Authorization\n    @abstractmethod\n    def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n        \"\"\"Exchange authorization code for token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n        \"\"\"Check if a user has permission to access a resource with the specified scope.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def delete_user(self, user_id: str) -&gt; None:\n        \"\"\"Delete a user from Keycloak by their ID.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def create_client_role(self, client_id: str, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n        \"\"\"Create a new client role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def create_realm(self, realm_name: str, skip_exists: bool = True, **kwargs: Any) -&gt; dict[str, Any]:\n        \"\"\"Create a new Keycloak realm.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_realm(self, realm_name: str) -&gt; dict[str, Any]:\n        \"\"\"Get realm details by realm name.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def create_client(\n        self,\n        client_id: str,\n        realm: str | None = None,\n        skip_exists: bool = True,\n        **kwargs: Any,\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"Create a new client in the specified realm.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def add_realm_roles_to_composite(self, composite_role_name: str, child_role_names: list[str]) -&gt; None:\n        \"\"\"Add realm roles to a composite role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def add_client_roles_to_composite(\n        self,\n        composite_role_name: str,\n        client_id: str,\n        child_role_names: list[str],\n    ) -&gt; None:\n        \"\"\"Add client roles to a composite role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_composite_realm_roles(self, role_name: str) -&gt; list[dict[str, Any]] | None:\n        \"\"\"Get composite roles for a realm role.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_token","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_token(username, password)</code>  <code>abstractmethod</code>","text":"<p>Get a user token by username and password.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n    \"\"\"Get a user token by username and password.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.refresh_token","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.refresh_token(refresh_token)</code>  <code>abstractmethod</code>","text":"<p>Refresh an existing token using a refresh token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n    \"\"\"Refresh an existing token using a refresh token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.validate_token","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.validate_token(token)</code>  <code>abstractmethod</code>","text":"<p>Validate if a token is still valid.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef validate_token(self, token: str) -&gt; bool:\n    \"\"\"Validate if a token is still valid.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_userinfo","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_userinfo(token)</code>  <code>abstractmethod</code>","text":"<p>Get user information from a token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_userinfo(self, token: str) -&gt; KeycloakUserType:\n    \"\"\"Get user information from a token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_token_info","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_token_info(token)</code>  <code>abstractmethod</code>","text":"<p>Decode token to get its claims.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_token_info(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Decode token to get its claims.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.introspect_token","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.introspect_token(token)</code>  <code>abstractmethod</code>","text":"<p>Introspect token to get detailed information about it.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef introspect_token(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Introspect token to get detailed information about it.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_client_credentials_token","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_client_credentials_token()</code>  <code>abstractmethod</code>","text":"<p>Get token using client credentials.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_client_credentials_token(self) -&gt; KeycloakTokenType:\n    \"\"\"Get token using client credentials.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.logout","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.logout(refresh_token)</code>  <code>abstractmethod</code>","text":"<p>Logout user by invalidating their refresh token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef logout(self, refresh_token: str) -&gt; None:\n    \"\"\"Logout user by invalidating their refresh token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_id","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_id(user_id)</code>  <code>abstractmethod</code>","text":"<p>Get user details by user ID.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by user ID.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_username","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_username(username)</code>  <code>abstractmethod</code>","text":"<p>Get user details by username.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by username.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_email","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_email(email)</code>  <code>abstractmethod</code>","text":"<p>Get user details by email.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by email.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.create_user","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.create_user(user_data)</code>  <code>abstractmethod</code>","text":"<p>Create a new user in Keycloak.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef create_user(self, user_data: dict[str, Any]) -&gt; str:\n    \"\"\"Create a new user in Keycloak.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.update_user","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.update_user(user_id, user_data)</code>  <code>abstractmethod</code>","text":"<p>Update user details.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n    \"\"\"Update user details.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.reset_password","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.reset_password(user_id, password, temporary=False)</code>  <code>abstractmethod</code>","text":"<p>Reset a user's password.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n    \"\"\"Reset a user's password.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.search_users","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.search_users(query, max_results=100)</code>  <code>abstractmethod</code>","text":"<p>Search for users by username, email, or name.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n    \"\"\"Search for users by username, email, or name.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.clear_user_sessions","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.clear_user_sessions(user_id)</code>  <code>abstractmethod</code>","text":"<p>Clear all sessions for a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef clear_user_sessions(self, user_id: str) -&gt; None:\n    \"\"\"Clear all sessions for a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_user_roles","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_user_roles(user_id)</code>  <code>abstractmethod</code>","text":"<p>Get roles assigned to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get roles assigned to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_client_roles_for_user","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_client_roles_for_user(user_id, client_id)</code>  <code>abstractmethod</code>","text":"<p>Get client-specific roles assigned to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get client-specific roles assigned to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.has_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.has_role(token, role_name)</code>  <code>abstractmethod</code>","text":"<p>Check if a user has a specific role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef has_role(self, token: str, role_name: str) -&gt; bool:\n    \"\"\"Check if a user has a specific role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.has_any_of_roles","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.has_any_of_roles(token, role_names)</code>  <code>abstractmethod</code>","text":"<p>Check if a user has any of the specified roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef has_any_of_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n    \"\"\"Check if a user has any of the specified roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.has_all_roles","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.has_all_roles(token, role_names)</code>  <code>abstractmethod</code>","text":"<p>Check if a user has all of the specified roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef has_all_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n    \"\"\"Check if a user has all of the specified roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.assign_realm_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.assign_realm_role(user_id, role_name)</code>  <code>abstractmethod</code>","text":"<p>Assign a realm role to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a realm role to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.remove_realm_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.remove_realm_role(user_id, role_name)</code>  <code>abstractmethod</code>","text":"<p>Remove a realm role from a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a realm role from a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.assign_client_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.assign_client_role(user_id, client_id, role_name)</code>  <code>abstractmethod</code>","text":"<p>Assign a client-specific role to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a client-specific role to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.remove_client_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.remove_client_role(user_id, client_id, role_name)</code>  <code>abstractmethod</code>","text":"<p>Remove a client-specific role from a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a client-specific role from a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_realm_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_realm_role(role_name)</code>  <code>abstractmethod</code>","text":"<p>Get realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_realm_role(self, role_name: str) -&gt; dict:\n    \"\"\"Get realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_realm_roles","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_realm_roles()</code>  <code>abstractmethod</code>","text":"<p>Get all realm roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_realm_roles(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Get all realm roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.create_realm_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.create_realm_role(role_name, description=None)</code>  <code>abstractmethod</code>","text":"<p>Create a new realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Create a new realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.delete_realm_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.delete_realm_role(role_name)</code>  <code>abstractmethod</code>","text":"<p>Delete a realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef delete_realm_role(self, role_name: str) -&gt; None:\n    \"\"\"Delete a realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_client_id","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_client_id(client_name)</code>  <code>abstractmethod</code>","text":"<p>Get client ID by client name.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_client_id(self, client_name: str) -&gt; str:\n    \"\"\"Get client ID by client name.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_client_secret","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_client_secret(client_id)</code>  <code>abstractmethod</code>","text":"<p>Get client secret.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_client_secret(self, client_id: str) -&gt; str:\n    \"\"\"Get client secret.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_service_account_id","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_service_account_id()</code>  <code>abstractmethod</code>","text":"<p>Get service account user ID for the current client.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_service_account_id(self) -&gt; str:\n    \"\"\"Get service account user ID for the current client.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_public_key","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_public_key()</code>  <code>abstractmethod</code>","text":"<p>Get the public key used to verify tokens.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_public_key(self) -&gt; PublicKeyType:\n    \"\"\"Get the public key used to verify tokens.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_well_known_config","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_well_known_config()</code>  <code>abstractmethod</code>","text":"<p>Get the well-known OpenID configuration.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_well_known_config(self) -&gt; dict[str, Any]:\n    \"\"\"Get the well-known OpenID configuration.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_certs","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_certs()</code>  <code>abstractmethod</code>","text":"<p>Get the JWT verification certificates.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_certs(self) -&gt; dict[str, Any]:\n    \"\"\"Get the JWT verification certificates.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_token_from_code","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_token_from_code(code, redirect_uri)</code>  <code>abstractmethod</code>","text":"<p>Exchange authorization code for token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n    \"\"\"Exchange authorization code for token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.check_permissions","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.check_permissions(token, resource, scope)</code>  <code>abstractmethod</code>","text":"<p>Check if a user has permission to access a resource with the specified scope.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n    \"\"\"Check if a user has permission to access a resource with the specified scope.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.delete_user","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.delete_user(user_id)</code>  <code>abstractmethod</code>","text":"<p>Delete a user from Keycloak by their ID.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef delete_user(self, user_id: str) -&gt; None:\n    \"\"\"Delete a user from Keycloak by their ID.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.create_client_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.create_client_role(client_id, role_name, description=None)</code>  <code>abstractmethod</code>","text":"<p>Create a new client role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef create_client_role(self, client_id: str, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Create a new client role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.create_realm","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.create_realm(realm_name, skip_exists=True, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Create a new Keycloak realm.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef create_realm(self, realm_name: str, skip_exists: bool = True, **kwargs: Any) -&gt; dict[str, Any]:\n    \"\"\"Create a new Keycloak realm.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_realm","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_realm(realm_name)</code>  <code>abstractmethod</code>","text":"<p>Get realm details by realm name.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_realm(self, realm_name: str) -&gt; dict[str, Any]:\n    \"\"\"Get realm details by realm name.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.create_client","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.create_client(client_id, realm=None, skip_exists=True, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Create a new client in the specified realm.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef create_client(\n    self,\n    client_id: str,\n    realm: str | None = None,\n    skip_exists: bool = True,\n    **kwargs: Any,\n) -&gt; dict[str, Any] | None:\n    \"\"\"Create a new client in the specified realm.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.add_realm_roles_to_composite","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.add_realm_roles_to_composite(composite_role_name, child_role_names)</code>  <code>abstractmethod</code>","text":"<p>Add realm roles to a composite role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef add_realm_roles_to_composite(self, composite_role_name: str, child_role_names: list[str]) -&gt; None:\n    \"\"\"Add realm roles to a composite role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.add_client_roles_to_composite","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.add_client_roles_to_composite(composite_role_name, client_id, child_role_names)</code>  <code>abstractmethod</code>","text":"<p>Add client roles to a composite role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef add_client_roles_to_composite(\n    self,\n    composite_role_name: str,\n    client_id: str,\n    child_role_names: list[str],\n) -&gt; None:\n    \"\"\"Add client roles to a composite role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_composite_realm_roles","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_composite_realm_roles(role_name)</code>  <code>abstractmethod</code>","text":"<p>Get composite roles for a realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_composite_realm_roles(self, role_name: str) -&gt; list[dict[str, Any]] | None:\n    \"\"\"Get composite roles for a realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort</code>","text":"<p>Asynchronous interface for Keycloak operations providing a standardized access pattern.</p> <p>This interface defines the contract for async Keycloak adapters, ensuring consistent implementation of Keycloak operations across different adapters. It covers essential functionality including authentication, user management, and role management.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>class AsyncKeycloakPort:\n    \"\"\"Asynchronous interface for Keycloak operations providing a standardized access pattern.\n\n    This interface defines the contract for async Keycloak adapters, ensuring consistent\n    implementation of Keycloak operations across different adapters. It covers essential\n    functionality including authentication, user management, and role management.\n    \"\"\"\n\n    # Token Operations\n    @abstractmethod\n    async def get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n        \"\"\"Get a user token by username and password.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n        \"\"\"Refresh an existing token using a refresh token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def validate_token(self, token: str) -&gt; bool:\n        \"\"\"Validate if a token is still valid.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_userinfo(self, token: str) -&gt; KeycloakUserType:\n        \"\"\"Get user information from a token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_token_info(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Decode token to get its claims.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def introspect_token(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Introspect token to get detailed information about it.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_client_credentials_token(self) -&gt; KeycloakTokenType:\n        \"\"\"Get token using client credentials.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def logout(self, refresh_token: str) -&gt; None:\n        \"\"\"Logout user by invalidating their refresh token.\"\"\"\n        raise NotImplementedError\n\n    # User Operations\n    @abstractmethod\n    async def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by user ID.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by username.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by email.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def create_user(self, user_data: dict[str, Any]) -&gt; str:\n        \"\"\"Create a new user in Keycloak.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n        \"\"\"Update user details.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n        \"\"\"Reset a user's password.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n        \"\"\"Search for users by username, email, or name.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def clear_user_sessions(self, user_id: str) -&gt; None:\n        \"\"\"Clear all sessions for a user.\"\"\"\n        raise NotImplementedError\n\n    # Role Operations\n    @abstractmethod\n    async def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get roles assigned to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get client-specific roles assigned to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def has_role(self, token: str, role_name: str) -&gt; bool:\n        \"\"\"Check if a user has a specific role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def has_any_of_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n        \"\"\"Check if a user has any of the specified roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def has_all_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n        \"\"\"Check if a user has all of the specified roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a realm role to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a realm role from a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a client-specific role to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a client-specific role from a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_realm_role(self, role_name: str) -&gt; dict:\n        \"\"\"Get realm role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_realm_roles(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Get all realm roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n        \"\"\"Create a new realm role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def delete_realm_role(self, role_name: str) -&gt; None:\n        \"\"\"Delete a realm role.\"\"\"\n        raise NotImplementedError\n\n    # Client Operations\n    @abstractmethod\n    async def get_client_id(self, client_name: str) -&gt; str:\n        \"\"\"Get client ID by client name.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_client_secret(self, client_id: str) -&gt; str:\n        \"\"\"Get client secret.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_service_account_id(self) -&gt; str:\n        \"\"\"Get service account user ID for the current client.\"\"\"\n        raise NotImplementedError\n\n    # System Operations\n    @abstractmethod\n    async def get_public_key(self) -&gt; PublicKeyType:\n        \"\"\"Get the public key used to verify tokens.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_well_known_config(self) -&gt; dict[str, Any]:\n        \"\"\"Get the well-known OpenID configuration.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_certs(self) -&gt; dict[str, Any]:\n        \"\"\"Get the JWT verification certificates.\"\"\"\n        raise NotImplementedError\n\n    # Authorization\n    @abstractmethod\n    async def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n        \"\"\"Exchange authorization code for token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n        \"\"\"Check if a user has permission to access a resource with the specified scope.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def delete_user(self, user_id: str) -&gt; None:\n        \"\"\"Delete a user from Keycloak by their ID.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def create_client_role(\n        self,\n        client_id: str,\n        role_name: str,\n        description: str | None = None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Create a new client role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def create_realm(self, realm_name: str, skip_exists: bool = True, **kwargs: Any) -&gt; dict[str, Any] | None:\n        \"\"\"Create a new Keycloak realm.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_realm(self, realm_name: str) -&gt; dict[str, Any]:\n        \"\"\"Get realm details by realm name.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def create_client(\n        self,\n        client_id: str,\n        realm: str | None = None,\n        skip_exists: bool = True,\n        **kwargs: Any,\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"Create a new client in the specified realm.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def add_realm_roles_to_composite(self, composite_role_name: str, child_role_names: list[str]) -&gt; None:\n        \"\"\"Add realm roles to a composite role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def add_client_roles_to_composite(\n        self,\n        composite_role_name: str,\n        client_id: str,\n        child_role_names: list[str],\n    ) -&gt; None:\n        \"\"\"Add client roles to a composite role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_composite_realm_roles(self, role_name: str) -&gt; list[dict[str, Any]] | None:\n        \"\"\"Get composite roles for a realm role.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token(username, password)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get a user token by username and password.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n    \"\"\"Get a user token by username and password.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.refresh_token","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.refresh_token(refresh_token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Refresh an existing token using a refresh token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n    \"\"\"Refresh an existing token using a refresh token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.validate_token","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.validate_token(token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Validate if a token is still valid.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def validate_token(self, token: str) -&gt; bool:\n    \"\"\"Validate if a token is still valid.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_userinfo","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_userinfo(token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get user information from a token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_userinfo(self, token: str) -&gt; KeycloakUserType:\n    \"\"\"Get user information from a token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token_info","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token_info(token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Decode token to get its claims.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_token_info(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Decode token to get its claims.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.introspect_token","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.introspect_token(token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Introspect token to get detailed information about it.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def introspect_token(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Introspect token to get detailed information about it.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_credentials_token","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_credentials_token()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get token using client credentials.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_client_credentials_token(self) -&gt; KeycloakTokenType:\n    \"\"\"Get token using client credentials.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.logout","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.logout(refresh_token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Logout user by invalidating their refresh token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def logout(self, refresh_token: str) -&gt; None:\n    \"\"\"Logout user by invalidating their refresh token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_id","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_id(user_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get user details by user ID.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by user ID.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_username","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_username(username)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get user details by username.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by username.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_email","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_email(email)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get user details by email.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by email.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_user","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_user(user_data)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Create a new user in Keycloak.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def create_user(self, user_data: dict[str, Any]) -&gt; str:\n    \"\"\"Create a new user in Keycloak.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.update_user","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.update_user(user_id, user_data)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Update user details.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n    \"\"\"Update user details.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.reset_password","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.reset_password(user_id, password, temporary=False)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Reset a user's password.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n    \"\"\"Reset a user's password.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.search_users","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.search_users(query, max_results=100)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Search for users by username, email, or name.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n    \"\"\"Search for users by username, email, or name.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.clear_user_sessions","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.clear_user_sessions(user_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Clear all sessions for a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def clear_user_sessions(self, user_id: str) -&gt; None:\n    \"\"\"Clear all sessions for a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_roles","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_roles(user_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get roles assigned to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get roles assigned to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_roles_for_user","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_roles_for_user(user_id, client_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get client-specific roles assigned to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get client-specific roles assigned to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_role(token, role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Check if a user has a specific role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def has_role(self, token: str, role_name: str) -&gt; bool:\n    \"\"\"Check if a user has a specific role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_any_of_roles","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_any_of_roles(token, role_names)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Check if a user has any of the specified roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def has_any_of_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n    \"\"\"Check if a user has any of the specified roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_all_roles","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_all_roles(token, role_names)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Check if a user has all of the specified roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def has_all_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n    \"\"\"Check if a user has all of the specified roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.assign_realm_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.assign_realm_role(user_id, role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Assign a realm role to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a realm role to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.remove_realm_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.remove_realm_role(user_id, role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Remove a realm role from a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a realm role from a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.assign_client_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.assign_client_role(user_id, client_id, role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Assign a client-specific role to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a client-specific role to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.remove_client_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.remove_client_role(user_id, client_id, role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Remove a client-specific role from a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a client-specific role from a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_realm_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_realm_role(role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_realm_role(self, role_name: str) -&gt; dict:\n    \"\"\"Get realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_realm_roles","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_realm_roles()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get all realm roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_realm_roles(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Get all realm roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_realm_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_realm_role(role_name, description=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Create a new realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Create a new realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.delete_realm_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.delete_realm_role(role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Delete a realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def delete_realm_role(self, role_name: str) -&gt; None:\n    \"\"\"Delete a realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_id","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_id(client_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get client ID by client name.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_client_id(self, client_name: str) -&gt; str:\n    \"\"\"Get client ID by client name.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_secret","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_secret(client_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get client secret.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_client_secret(self, client_id: str) -&gt; str:\n    \"\"\"Get client secret.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_service_account_id","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_service_account_id()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get service account user ID for the current client.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_service_account_id(self) -&gt; str:\n    \"\"\"Get service account user ID for the current client.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_public_key","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_public_key()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get the public key used to verify tokens.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_public_key(self) -&gt; PublicKeyType:\n    \"\"\"Get the public key used to verify tokens.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_well_known_config","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_well_known_config()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get the well-known OpenID configuration.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_well_known_config(self) -&gt; dict[str, Any]:\n    \"\"\"Get the well-known OpenID configuration.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_certs","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_certs()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get the JWT verification certificates.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_certs(self) -&gt; dict[str, Any]:\n    \"\"\"Get the JWT verification certificates.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token_from_code","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token_from_code(code, redirect_uri)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Exchange authorization code for token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n    \"\"\"Exchange authorization code for token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.check_permissions","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.check_permissions(token, resource, scope)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Check if a user has permission to access a resource with the specified scope.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n    \"\"\"Check if a user has permission to access a resource with the specified scope.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.delete_user","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.delete_user(user_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Delete a user from Keycloak by their ID.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def delete_user(self, user_id: str) -&gt; None:\n    \"\"\"Delete a user from Keycloak by their ID.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_client_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_client_role(client_id, role_name, description=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Create a new client role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def create_client_role(\n    self,\n    client_id: str,\n    role_name: str,\n    description: str | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Create a new client role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_realm","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_realm(realm_name, skip_exists=True, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Create a new Keycloak realm.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def create_realm(self, realm_name: str, skip_exists: bool = True, **kwargs: Any) -&gt; dict[str, Any] | None:\n    \"\"\"Create a new Keycloak realm.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_realm","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_realm(realm_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get realm details by realm name.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_realm(self, realm_name: str) -&gt; dict[str, Any]:\n    \"\"\"Get realm details by realm name.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_client","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_client(client_id, realm=None, skip_exists=True, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Create a new client in the specified realm.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def create_client(\n    self,\n    client_id: str,\n    realm: str | None = None,\n    skip_exists: bool = True,\n    **kwargs: Any,\n) -&gt; dict[str, Any] | None:\n    \"\"\"Create a new client in the specified realm.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.add_realm_roles_to_composite","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.add_realm_roles_to_composite(composite_role_name, child_role_names)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Add realm roles to a composite role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def add_realm_roles_to_composite(self, composite_role_name: str, child_role_names: list[str]) -&gt; None:\n    \"\"\"Add realm roles to a composite role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.add_client_roles_to_composite","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.add_client_roles_to_composite(composite_role_name, client_id, child_role_names)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Add client roles to a composite role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def add_client_roles_to_composite(\n    self,\n    composite_role_name: str,\n    client_id: str,\n    child_role_names: list[str],\n) -&gt; None:\n    \"\"\"Add client roles to a composite role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_composite_realm_roles","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_composite_realm_roles(role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get composite roles for a realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_composite_realm_roles(self, role_name: str) -&gt; list[dict[str, Any]] | None:\n    \"\"\"Get composite roles for a realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#minio","title":"MinIO","text":"<p>MinIO integration for S3-compatible object storage operations.</p> <pre><code>from archipy.adapters.minio import MinioAdapter\n\n# Create a MinIO adapter\nminio = MinioAdapter()  # Uses global config by default\n\n# Create a bucket\nif not minio.bucket_exists(\"my-bucket\"):\n    minio.make_bucket(\"my-bucket\")\n\n# Upload a file\nminio.put_object(\"my-bucket\", \"document.pdf\", \"/path/to/local/file.pdf\")\n\n# Generate a download URL (valid for 1 hour)\ndownload_url = minio.presigned_get_object(\"my-bucket\", \"document.pdf\")\n</code></pre> <p>For detailed examples and usage guidelines, see the MinIO Adapter Examples.</p> <p>options: show_root_heading: true show_source: true</p> <p>MinIO port definitions for ArchiPy.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioExceptionHandlerMixin","title":"<code>archipy.adapters.minio.adapters.MinioExceptionHandlerMixin</code>","text":"<p>Mixin class to handle MinIO/S3 exceptions in a consistent way.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>class MinioExceptionHandlerMixin:\n    \"\"\"Mixin class to handle MinIO/S3 exceptions in a consistent way.\"\"\"\n\n    @classmethod\n    def _handle_s3_exception(cls, exception: S3Error, operation: str) -&gt; None:\n        \"\"\"Handle S3Error exceptions and map them to appropriate application errors.\n\n        Args:\n            exception: The original S3Error exception\n            operation: The name of the operation that failed\n\n        Raises:\n            Various application-specific errors based on the exception type/content\n        \"\"\"\n        error_msg = str(exception).lower()\n\n        # Bucket existence errors\n        if \"NoSuchBucket\" in str(exception):\n            raise NotFoundError(resource_type=\"bucket\") from exception\n\n        # Object existence errors\n        if \"NoSuchKey\" in str(exception):\n            raise NotFoundError(resource_type=\"object\") from exception\n\n        # Bucket ownership/existence errors\n        if \"BucketAlreadyOwnedByYou\" in str(exception) or \"BucketAlreadyExists\" in str(exception):\n            raise AlreadyExistsError(resource_type=\"bucket\") from exception\n\n        # Permission errors\n        if \"AccessDenied\" in str(exception):\n            raise PermissionDeniedError(\n                additional_data={\"details\": f\"Permission denied for operation: {operation}\"},\n            ) from exception\n\n        # Resource limit errors\n        if \"quota\" in error_msg or \"limit\" in error_msg or \"exceeded\" in error_msg:\n            raise ResourceExhaustedError(resource_type=\"storage\") from exception\n\n        # Connection/availability errors\n        if \"timeout\" in error_msg:\n            raise ConnectionTimeoutError(service=\"MinIO\") from exception\n\n        if \"unavailable\" in error_msg or \"connection\" in error_msg:\n            raise ServiceUnavailableError(service=\"MinIO\") from exception\n\n        # Default: general storage error\n        raise StorageError(additional_data={\"operation\": operation}) from exception\n\n    @classmethod\n    def _handle_general_exception(cls, exception: Exception, component: str) -&gt; None:\n        \"\"\"Handle general exceptions by converting them to appropriate application errors.\n\n        Args:\n            exception: The original exception\n            component: The component/operation name for context\n\n        Raises:\n            InternalError: A wrapped version of the original exception\n        \"\"\"\n        raise InternalError(additional_data={\"component\": component}) from exception\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter","title":"<code>archipy.adapters.minio.adapters.MinioAdapter</code>","text":"<p>               Bases: <code>MinioPort</code>, <code>MinioExceptionHandlerMixin</code></p> <p>Concrete implementation of the MinioPort interface using the minio library.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>class MinioAdapter(MinioPort, MinioExceptionHandlerMixin):\n    \"\"\"Concrete implementation of the MinioPort interface using the minio library.\"\"\"\n\n    def __init__(self, minio_configs: MinioConfig | None = None) -&gt; None:\n        \"\"\"Initialize MinioAdapter with configuration.\n\n        Args:\n            minio_configs: Optional MinIO configuration. If None, global config is used.\n\n        Raises:\n            ConfigurationError: If there is an error in the MinIO configuration.\n            InvalidArgumentError: If required parameters are missing.\n            NetworkError: If there are network errors connecting to MinIO server.\n        \"\"\"\n        try:\n            # Determine config source (explicit or from global config)\n            if minio_configs is not None:\n                self.configs = minio_configs\n            else:\n                # First get global config, then extract MINIO config\n                global_config: Any = BaseConfig.global_config()\n                if not hasattr(global_config, \"MINIO\"):\n                    raise InvalidArgumentError(argument_name=\"MINIO\")\n                self.configs = cast(MinioConfig, global_config.MINIO)\n\n            # Ensure we have a valid endpoint value\n            endpoint = str(self.configs.ENDPOINT or \"\")\n            if not endpoint:\n                raise InvalidArgumentError(argument_name=\"endpoint\")\n\n            self._adapter = Minio(\n                endpoint,\n                access_key=self.configs.ACCESS_KEY,\n                secret_key=self.configs.SECRET_KEY,\n                session_token=self.configs.SESSION_TOKEN,\n                secure=self.configs.SECURE,\n                region=self.configs.REGION,\n            )\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            error_msg = str(e).lower()\n            if \"configuration\" in error_msg:\n                raise ConfigurationError(config_key=\"minio\") from e\n            elif \"connection\" in error_msg:\n                raise NetworkError(service=\"MinIO\") from e\n            else:\n                raise InternalError(additional_data={\"component\": \"MinIO\"}) from e\n        except Exception as e:\n            raise InternalError(additional_data={\"component\": \"MinIO\"}) from e\n\n    def clear_all_caches(self) -&gt; None:\n        \"\"\"Clear all cached values.\"\"\"\n        for attr_name in dir(self):\n            attr = getattr(self, attr_name)\n            if hasattr(attr, \"clear_cache\"):\n                attr.clear_cache()\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def bucket_exists(self, bucket_name: str) -&gt; bool:\n        \"\"\"Check if a bucket exists.\n\n        Args:\n            bucket_name: Name of the bucket to check.\n\n        Returns:\n            bool: True if bucket exists, False otherwise.\n\n        Raises:\n            InvalidArgumentError: If bucket_name is empty.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name:\n                raise InvalidArgumentError(argument_name=\"bucket_name\")\n            result = self._adapter.bucket_exists(bucket_name)\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            if \"NoSuchBucket\" in str(e):\n                return False\n            self._handle_s3_exception(e, \"bucket_exists\")\n        except Exception as e:\n            self._handle_general_exception(e, \"bucket_exists\")\n        else:\n            return result\n\n    @override\n    def make_bucket(self, bucket_name: str) -&gt; None:\n        \"\"\"Create a new bucket.\n\n        Args:\n            bucket_name: Name of the bucket to create.\n\n        Raises:\n            InvalidArgumentError: If bucket_name is empty.\n            AlreadyExistsError: If the bucket already exists.\n            PermissionDeniedError: If permission to create bucket is denied.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name:\n                raise InvalidArgumentError(argument_name=\"bucket_name\")\n            self._adapter.make_bucket(bucket_name)\n            self.clear_all_caches()  # Clear cache since bucket list changed\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            self._handle_s3_exception(e, \"make_bucket\")\n        except Exception as e:\n            self._handle_general_exception(e, \"make_bucket\")\n\n    @override\n    def remove_bucket(self, bucket_name: str) -&gt; None:\n        \"\"\"Remove a bucket.\n\n        Args:\n            bucket_name: Name of the bucket to remove.\n\n        Raises:\n            InvalidArgumentError: If bucket_name is empty.\n            NotFoundError: If the bucket does not exist.\n            PermissionDeniedError: If permission to delete bucket is denied.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name:\n                raise InvalidArgumentError(argument_name=\"bucket_name\")\n            self._adapter.remove_bucket(bucket_name)\n            self.clear_all_caches()  # Clear cache since bucket list changed\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            self._handle_s3_exception(e, \"remove_bucket\")\n        except Exception as e:\n            self._handle_general_exception(e, \"remove_bucket\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=1)  # Cache for 5 minutes\n    def list_buckets(self) -&gt; list[MinioBucketType]:\n        \"\"\"List all buckets.\n\n        Returns:\n            list: List of buckets and their creation dates.\n\n        Raises:\n            PermissionDeniedError: If permission to list buckets is denied.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            buckets = self._adapter.list_buckets()\n        except S3Error as e:\n            self._handle_s3_exception(e, \"list_buckets\")\n        except Exception as e:\n            self._handle_general_exception(e, \"list_buckets\")\n        else:\n            return [{\"name\": b.name, \"creation_date\": b.creation_date} for b in buckets]\n\n    @override\n    def put_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n        \"\"\"Upload a file to a bucket.\n\n        Args:\n            bucket_name: Destination bucket name.\n            object_name: Object name in the bucket.\n            file_path: Local file path to upload.\n\n        Raises:\n            InvalidArgumentError: If any required parameter is empty.\n            NotFoundError: If the bucket does not exist.\n            PermissionDeniedError: If permission to upload is denied.\n            ResourceExhaustedError: If storage limits are exceeded.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name or not object_name or not file_path:\n                raise InvalidArgumentError(\n                    argument_name=(\n                        \"bucket_name, object_name or file_path\"\n                        if not all([bucket_name, object_name, file_path])\n                        else \"bucket_name\" if not bucket_name else \"object_name\" if not object_name else \"file_path\"\n                    ),\n                )\n            self._adapter.fput_object(bucket_name, object_name, file_path)\n            if hasattr(self.list_objects, \"clear_cache\"):\n                self.list_objects.clear_cache()  # Clear object list cache\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            self._handle_s3_exception(e, \"put_object\")\n        except Exception as e:\n            self._handle_general_exception(e, \"put_object\")\n\n    @override\n    def get_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n        \"\"\"Download an object to a file.\n\n        Args:\n            bucket_name: Source bucket name.\n            object_name: Object name in the bucket.\n            file_path: Local file path to save the object.\n\n        Raises:\n            InvalidArgumentError: If any required parameter is empty.\n            NotFoundError: If the bucket or object does not exist.\n            PermissionDeniedError: If permission to download is denied.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name or not object_name or not file_path:\n                raise InvalidArgumentError(\n                    argument_name=(\n                        \"bucket_name, object_name or file_path\"\n                        if not all([bucket_name, object_name, file_path])\n                        else \"bucket_name\" if not bucket_name else \"object_name\" if not object_name else \"file_path\"\n                    ),\n                )\n            self._adapter.fget_object(bucket_name, object_name, file_path)\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            self._handle_s3_exception(e, \"get_object\")\n        except Exception as e:\n            self._handle_general_exception(e, \"get_object\")\n\n    @override\n    def remove_object(self, bucket_name: str, object_name: str) -&gt; None:\n        \"\"\"Remove an object from a bucket.\n\n        Args:\n            bucket_name: Bucket name.\n            object_name: Object name to remove.\n\n        Raises:\n            InvalidArgumentError: If any required parameter is empty.\n            NotFoundError: If the bucket or object does not exist.\n            PermissionDeniedError: If permission to remove is denied.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name or not object_name:\n                raise InvalidArgumentError(\n                    argument_name=(\n                        \"bucket_name or object_name\"\n                        if not all([bucket_name, object_name])\n                        else \"bucket_name\" if not bucket_name else \"object_name\"\n                    ),\n                )\n            self._adapter.remove_object(bucket_name, object_name)\n            if hasattr(self.list_objects, \"clear_cache\"):\n                self.list_objects.clear_cache()  # Clear object list cache\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            self._handle_s3_exception(e, \"remove_object\")\n        except Exception as e:\n            self._handle_general_exception(e, \"remove_object\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def list_objects(\n        self,\n        bucket_name: str,\n        prefix: str = \"\",\n        *,\n        recursive: bool = False,\n    ) -&gt; list[MinioObjectType]:\n        \"\"\"List objects in a bucket.\n\n        Args:\n            bucket_name: Bucket name.\n            prefix: Optional prefix to filter objects.\n            recursive: Whether to list objects recursively.\n\n        Returns:\n            list: List of objects with metadata.\n\n        Raises:\n            InvalidArgumentError: If bucket_name is empty.\n            NotFoundError: If the bucket does not exist.\n            PermissionDeniedError: If permission to list objects is denied.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name:\n                raise InvalidArgumentError(argument_name=\"bucket_name\")\n            objects = self._adapter.list_objects(bucket_name, prefix=prefix, recursive=recursive)\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            self._handle_s3_exception(e, \"list_objects\")\n        except Exception as e:\n            self._handle_general_exception(e, \"list_objects\")\n        else:\n            return [\n                {\"object_name\": obj.object_name, \"size\": obj.size, \"last_modified\": obj.last_modified}\n                for obj in objects\n            ]\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def stat_object(self, bucket_name: str, object_name: str) -&gt; MinioObjectType:\n        \"\"\"Get object metadata.\n\n        Args:\n            bucket_name: Bucket name.\n            object_name: Object name to get stats for.\n\n        Returns:\n            dict: Object metadata including name, size, last modified date, etc.\n\n        Raises:\n            InvalidArgumentError: If any required parameter is empty.\n            NotFoundError: If the bucket or object does not exist.\n            PermissionDeniedError: If permission to get stats is denied.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name or not object_name:\n                raise InvalidArgumentError(\n                    argument_name=(\n                        \"bucket_name or object_name\"\n                        if not all([bucket_name, object_name])\n                        else \"bucket_name\" if not bucket_name else \"object_name\"\n                    ),\n                )\n            obj = self._adapter.stat_object(bucket_name, object_name)\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            self._handle_s3_exception(e, \"stat_object\")\n        except Exception as e:\n            self._handle_general_exception(e, \"stat_object\")\n        else:\n            return {\n                \"object_name\": obj.object_name,\n                \"size\": obj.size,\n                \"last_modified\": obj.last_modified,\n                \"content_type\": obj.content_type,\n                \"etag\": obj.etag,\n            }\n\n    @override\n    def presigned_get_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n        \"\"\"Generate a presigned URL for downloading an object.\n\n        Args:\n            bucket_name: Bucket name.\n            object_name: Object name to generate URL for.\n            expires: URL expiry time in seconds.\n\n        Returns:\n            str: Presigned URL for downloading the object.\n\n        Raises:\n            InvalidArgumentError: If any required parameter is empty.\n            NotFoundError: If the bucket or object does not exist.\n            PermissionDeniedError: If permission to generate URL is denied.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name or not object_name:\n                raise InvalidArgumentError(\n                    argument_name=(\n                        \"bucket_name or object_name\"\n                        if not all([bucket_name, object_name])\n                        else \"bucket_name\" if not bucket_name else \"object_name\"\n                    ),\n                )\n            url = self._adapter.presigned_get_object(\n                bucket_name=bucket_name,\n                object_name=object_name,\n                expires=timedelta(seconds=expires),\n            )\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            self._handle_s3_exception(e, \"presigned_get_object\")\n        except Exception as e:\n            self._handle_general_exception(e, \"presigned_get_object\")\n        else:\n            return url\n\n    @override\n    def presigned_put_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n        \"\"\"Generate a presigned URL for uploading an object.\n\n        Args:\n            bucket_name: Bucket name.\n            object_name: Object name to generate URL for.\n            expires: URL expiry time in seconds.\n\n        Returns:\n            str: Presigned URL for uploading the object.\n\n        Raises:\n            InvalidArgumentError: If any required parameter is empty.\n            NotFoundError: If the bucket does not exist.\n            PermissionDeniedError: If permission to generate URL is denied.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name or not object_name:\n                raise InvalidArgumentError(\n                    argument_name=(\n                        \"bucket_name or object_name\"\n                        if not all([bucket_name, object_name])\n                        else \"bucket_name\" if not bucket_name else \"object_name\"\n                    ),\n                )\n            url = self._adapter.presigned_put_object(\n                bucket_name=bucket_name,\n                object_name=object_name,\n                expires=timedelta(seconds=expires),\n            )\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            self._handle_s3_exception(e, \"presigned_put_object\")\n        except Exception as e:\n            self._handle_general_exception(e, \"presigned_put_object\")\n        else:\n            return url\n\n    @override\n    def set_bucket_policy(self, bucket_name: str, policy: str) -&gt; None:\n        \"\"\"Set bucket policy.\n\n        Args:\n            bucket_name: Bucket name.\n            policy: JSON policy string.\n\n        Raises:\n            InvalidArgumentError: If any required parameter is empty.\n            NotFoundError: If the bucket does not exist.\n            PermissionDeniedError: If permission to set policy is denied.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name or not policy:\n                raise InvalidArgumentError(\n                    argument_name=(\n                        \"bucket_name or policy\"\n                        if not all([bucket_name, policy])\n                        else \"bucket_name\" if not bucket_name else \"policy\"\n                    ),\n                )\n            self._adapter.set_bucket_policy(bucket_name, policy)\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            self._handle_s3_exception(e, \"set_bucket_policy\")\n        except Exception as e:\n            self._handle_general_exception(e, \"set_bucket_policy\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_bucket_policy(self, bucket_name: str) -&gt; MinioPolicyType:\n        \"\"\"Get bucket policy.\n\n        Args:\n            bucket_name: Bucket name.\n\n        Returns:\n            dict: Bucket policy information.\n\n        Raises:\n            InvalidArgumentError: If bucket_name is empty.\n            NotFoundError: If the bucket does not exist.\n            PermissionDeniedError: If permission to get policy is denied.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name:\n                raise InvalidArgumentError(argument_name=\"bucket_name\")\n            policy = self._adapter.get_bucket_policy(bucket_name)\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            self._handle_s3_exception(e, \"get_bucket_policy\")\n        except Exception as e:\n            self._handle_general_exception(e, \"get_bucket_policy\")\n        else:\n            return {\"policy\": policy}\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.__init__","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.__init__(minio_configs=None)</code>","text":"<p>Initialize MinioAdapter with configuration.</p> <p>Parameters:</p> Name Type Description Default <code>minio_configs</code> <code>MinioConfig | None</code> <p>Optional MinIO configuration. If None, global config is used.</p> <code>None</code> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If there is an error in the MinIO configuration.</p> <code>InvalidArgumentError</code> <p>If required parameters are missing.</p> <code>NetworkError</code> <p>If there are network errors connecting to MinIO server.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>def __init__(self, minio_configs: MinioConfig | None = None) -&gt; None:\n    \"\"\"Initialize MinioAdapter with configuration.\n\n    Args:\n        minio_configs: Optional MinIO configuration. If None, global config is used.\n\n    Raises:\n        ConfigurationError: If there is an error in the MinIO configuration.\n        InvalidArgumentError: If required parameters are missing.\n        NetworkError: If there are network errors connecting to MinIO server.\n    \"\"\"\n    try:\n        # Determine config source (explicit or from global config)\n        if minio_configs is not None:\n            self.configs = minio_configs\n        else:\n            # First get global config, then extract MINIO config\n            global_config: Any = BaseConfig.global_config()\n            if not hasattr(global_config, \"MINIO\"):\n                raise InvalidArgumentError(argument_name=\"MINIO\")\n            self.configs = cast(MinioConfig, global_config.MINIO)\n\n        # Ensure we have a valid endpoint value\n        endpoint = str(self.configs.ENDPOINT or \"\")\n        if not endpoint:\n            raise InvalidArgumentError(argument_name=\"endpoint\")\n\n        self._adapter = Minio(\n            endpoint,\n            access_key=self.configs.ACCESS_KEY,\n            secret_key=self.configs.SECRET_KEY,\n            session_token=self.configs.SESSION_TOKEN,\n            secure=self.configs.SECURE,\n            region=self.configs.REGION,\n        )\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        error_msg = str(e).lower()\n        if \"configuration\" in error_msg:\n            raise ConfigurationError(config_key=\"minio\") from e\n        elif \"connection\" in error_msg:\n            raise NetworkError(service=\"MinIO\") from e\n        else:\n            raise InternalError(additional_data={\"component\": \"MinIO\"}) from e\n    except Exception as e:\n        raise InternalError(additional_data={\"component\": \"MinIO\"}) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.clear_all_caches","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.clear_all_caches()</code>","text":"<p>Clear all cached values.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>def clear_all_caches(self) -&gt; None:\n    \"\"\"Clear all cached values.\"\"\"\n    for attr_name in dir(self):\n        attr = getattr(self, attr_name)\n        if hasattr(attr, \"clear_cache\"):\n            attr.clear_cache()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.bucket_exists","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.bucket_exists(bucket_name)</code>","text":"<p>Check if a bucket exists.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Name of the bucket to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if bucket exists, False otherwise.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If bucket_name is empty.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef bucket_exists(self, bucket_name: str) -&gt; bool:\n    \"\"\"Check if a bucket exists.\n\n    Args:\n        bucket_name: Name of the bucket to check.\n\n    Returns:\n        bool: True if bucket exists, False otherwise.\n\n    Raises:\n        InvalidArgumentError: If bucket_name is empty.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name:\n            raise InvalidArgumentError(argument_name=\"bucket_name\")\n        result = self._adapter.bucket_exists(bucket_name)\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        if \"NoSuchBucket\" in str(e):\n            return False\n        self._handle_s3_exception(e, \"bucket_exists\")\n    except Exception as e:\n        self._handle_general_exception(e, \"bucket_exists\")\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.make_bucket","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.make_bucket(bucket_name)</code>","text":"<p>Create a new bucket.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Name of the bucket to create.</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If bucket_name is empty.</p> <code>AlreadyExistsError</code> <p>If the bucket already exists.</p> <code>PermissionDeniedError</code> <p>If permission to create bucket is denied.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef make_bucket(self, bucket_name: str) -&gt; None:\n    \"\"\"Create a new bucket.\n\n    Args:\n        bucket_name: Name of the bucket to create.\n\n    Raises:\n        InvalidArgumentError: If bucket_name is empty.\n        AlreadyExistsError: If the bucket already exists.\n        PermissionDeniedError: If permission to create bucket is denied.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name:\n            raise InvalidArgumentError(argument_name=\"bucket_name\")\n        self._adapter.make_bucket(bucket_name)\n        self.clear_all_caches()  # Clear cache since bucket list changed\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        self._handle_s3_exception(e, \"make_bucket\")\n    except Exception as e:\n        self._handle_general_exception(e, \"make_bucket\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.remove_bucket","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.remove_bucket(bucket_name)</code>","text":"<p>Remove a bucket.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Name of the bucket to remove.</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If bucket_name is empty.</p> <code>NotFoundError</code> <p>If the bucket does not exist.</p> <code>PermissionDeniedError</code> <p>If permission to delete bucket is denied.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef remove_bucket(self, bucket_name: str) -&gt; None:\n    \"\"\"Remove a bucket.\n\n    Args:\n        bucket_name: Name of the bucket to remove.\n\n    Raises:\n        InvalidArgumentError: If bucket_name is empty.\n        NotFoundError: If the bucket does not exist.\n        PermissionDeniedError: If permission to delete bucket is denied.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name:\n            raise InvalidArgumentError(argument_name=\"bucket_name\")\n        self._adapter.remove_bucket(bucket_name)\n        self.clear_all_caches()  # Clear cache since bucket list changed\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        self._handle_s3_exception(e, \"remove_bucket\")\n    except Exception as e:\n        self._handle_general_exception(e, \"remove_bucket\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.list_buckets","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.list_buckets()</code>","text":"<p>List all buckets.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list[MinioBucketType]</code> <p>List of buckets and their creation dates.</p> <p>Raises:</p> Type Description <code>PermissionDeniedError</code> <p>If permission to list buckets is denied.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=1)  # Cache for 5 minutes\ndef list_buckets(self) -&gt; list[MinioBucketType]:\n    \"\"\"List all buckets.\n\n    Returns:\n        list: List of buckets and their creation dates.\n\n    Raises:\n        PermissionDeniedError: If permission to list buckets is denied.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        buckets = self._adapter.list_buckets()\n    except S3Error as e:\n        self._handle_s3_exception(e, \"list_buckets\")\n    except Exception as e:\n        self._handle_general_exception(e, \"list_buckets\")\n    else:\n        return [{\"name\": b.name, \"creation_date\": b.creation_date} for b in buckets]\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.put_object","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.put_object(bucket_name, object_name, file_path)</code>","text":"<p>Upload a file to a bucket.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Destination bucket name.</p> required <code>object_name</code> <code>str</code> <p>Object name in the bucket.</p> required <code>file_path</code> <code>str</code> <p>Local file path to upload.</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If any required parameter is empty.</p> <code>NotFoundError</code> <p>If the bucket does not exist.</p> <code>PermissionDeniedError</code> <p>If permission to upload is denied.</p> <code>ResourceExhaustedError</code> <p>If storage limits are exceeded.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef put_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n    \"\"\"Upload a file to a bucket.\n\n    Args:\n        bucket_name: Destination bucket name.\n        object_name: Object name in the bucket.\n        file_path: Local file path to upload.\n\n    Raises:\n        InvalidArgumentError: If any required parameter is empty.\n        NotFoundError: If the bucket does not exist.\n        PermissionDeniedError: If permission to upload is denied.\n        ResourceExhaustedError: If storage limits are exceeded.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name or not object_name or not file_path:\n            raise InvalidArgumentError(\n                argument_name=(\n                    \"bucket_name, object_name or file_path\"\n                    if not all([bucket_name, object_name, file_path])\n                    else \"bucket_name\" if not bucket_name else \"object_name\" if not object_name else \"file_path\"\n                ),\n            )\n        self._adapter.fput_object(bucket_name, object_name, file_path)\n        if hasattr(self.list_objects, \"clear_cache\"):\n            self.list_objects.clear_cache()  # Clear object list cache\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        self._handle_s3_exception(e, \"put_object\")\n    except Exception as e:\n        self._handle_general_exception(e, \"put_object\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.get_object","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.get_object(bucket_name, object_name, file_path)</code>","text":"<p>Download an object to a file.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Source bucket name.</p> required <code>object_name</code> <code>str</code> <p>Object name in the bucket.</p> required <code>file_path</code> <code>str</code> <p>Local file path to save the object.</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If any required parameter is empty.</p> <code>NotFoundError</code> <p>If the bucket or object does not exist.</p> <code>PermissionDeniedError</code> <p>If permission to download is denied.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef get_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n    \"\"\"Download an object to a file.\n\n    Args:\n        bucket_name: Source bucket name.\n        object_name: Object name in the bucket.\n        file_path: Local file path to save the object.\n\n    Raises:\n        InvalidArgumentError: If any required parameter is empty.\n        NotFoundError: If the bucket or object does not exist.\n        PermissionDeniedError: If permission to download is denied.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name or not object_name or not file_path:\n            raise InvalidArgumentError(\n                argument_name=(\n                    \"bucket_name, object_name or file_path\"\n                    if not all([bucket_name, object_name, file_path])\n                    else \"bucket_name\" if not bucket_name else \"object_name\" if not object_name else \"file_path\"\n                ),\n            )\n        self._adapter.fget_object(bucket_name, object_name, file_path)\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        self._handle_s3_exception(e, \"get_object\")\n    except Exception as e:\n        self._handle_general_exception(e, \"get_object\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.remove_object","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.remove_object(bucket_name, object_name)</code>","text":"<p>Remove an object from a bucket.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Bucket name.</p> required <code>object_name</code> <code>str</code> <p>Object name to remove.</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If any required parameter is empty.</p> <code>NotFoundError</code> <p>If the bucket or object does not exist.</p> <code>PermissionDeniedError</code> <p>If permission to remove is denied.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef remove_object(self, bucket_name: str, object_name: str) -&gt; None:\n    \"\"\"Remove an object from a bucket.\n\n    Args:\n        bucket_name: Bucket name.\n        object_name: Object name to remove.\n\n    Raises:\n        InvalidArgumentError: If any required parameter is empty.\n        NotFoundError: If the bucket or object does not exist.\n        PermissionDeniedError: If permission to remove is denied.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name or not object_name:\n            raise InvalidArgumentError(\n                argument_name=(\n                    \"bucket_name or object_name\"\n                    if not all([bucket_name, object_name])\n                    else \"bucket_name\" if not bucket_name else \"object_name\"\n                ),\n            )\n        self._adapter.remove_object(bucket_name, object_name)\n        if hasattr(self.list_objects, \"clear_cache\"):\n            self.list_objects.clear_cache()  # Clear object list cache\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        self._handle_s3_exception(e, \"remove_object\")\n    except Exception as e:\n        self._handle_general_exception(e, \"remove_object\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.list_objects","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.list_objects(bucket_name, prefix='', *, recursive=False)</code>","text":"<p>List objects in a bucket.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Bucket name.</p> required <code>prefix</code> <code>str</code> <p>Optional prefix to filter objects.</p> <code>''</code> <code>recursive</code> <code>bool</code> <p>Whether to list objects recursively.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[MinioObjectType]</code> <p>List of objects with metadata.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If bucket_name is empty.</p> <code>NotFoundError</code> <p>If the bucket does not exist.</p> <code>PermissionDeniedError</code> <p>If permission to list objects is denied.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef list_objects(\n    self,\n    bucket_name: str,\n    prefix: str = \"\",\n    *,\n    recursive: bool = False,\n) -&gt; list[MinioObjectType]:\n    \"\"\"List objects in a bucket.\n\n    Args:\n        bucket_name: Bucket name.\n        prefix: Optional prefix to filter objects.\n        recursive: Whether to list objects recursively.\n\n    Returns:\n        list: List of objects with metadata.\n\n    Raises:\n        InvalidArgumentError: If bucket_name is empty.\n        NotFoundError: If the bucket does not exist.\n        PermissionDeniedError: If permission to list objects is denied.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name:\n            raise InvalidArgumentError(argument_name=\"bucket_name\")\n        objects = self._adapter.list_objects(bucket_name, prefix=prefix, recursive=recursive)\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        self._handle_s3_exception(e, \"list_objects\")\n    except Exception as e:\n        self._handle_general_exception(e, \"list_objects\")\n    else:\n        return [\n            {\"object_name\": obj.object_name, \"size\": obj.size, \"last_modified\": obj.last_modified}\n            for obj in objects\n        ]\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.stat_object","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.stat_object(bucket_name, object_name)</code>","text":"<p>Get object metadata.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Bucket name.</p> required <code>object_name</code> <code>str</code> <p>Object name to get stats for.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>MinioObjectType</code> <p>Object metadata including name, size, last modified date, etc.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If any required parameter is empty.</p> <code>NotFoundError</code> <p>If the bucket or object does not exist.</p> <code>PermissionDeniedError</code> <p>If permission to get stats is denied.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef stat_object(self, bucket_name: str, object_name: str) -&gt; MinioObjectType:\n    \"\"\"Get object metadata.\n\n    Args:\n        bucket_name: Bucket name.\n        object_name: Object name to get stats for.\n\n    Returns:\n        dict: Object metadata including name, size, last modified date, etc.\n\n    Raises:\n        InvalidArgumentError: If any required parameter is empty.\n        NotFoundError: If the bucket or object does not exist.\n        PermissionDeniedError: If permission to get stats is denied.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name or not object_name:\n            raise InvalidArgumentError(\n                argument_name=(\n                    \"bucket_name or object_name\"\n                    if not all([bucket_name, object_name])\n                    else \"bucket_name\" if not bucket_name else \"object_name\"\n                ),\n            )\n        obj = self._adapter.stat_object(bucket_name, object_name)\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        self._handle_s3_exception(e, \"stat_object\")\n    except Exception as e:\n        self._handle_general_exception(e, \"stat_object\")\n    else:\n        return {\n            \"object_name\": obj.object_name,\n            \"size\": obj.size,\n            \"last_modified\": obj.last_modified,\n            \"content_type\": obj.content_type,\n            \"etag\": obj.etag,\n        }\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.presigned_get_object","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.presigned_get_object(bucket_name, object_name, expires=3600)</code>","text":"<p>Generate a presigned URL for downloading an object.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Bucket name.</p> required <code>object_name</code> <code>str</code> <p>Object name to generate URL for.</p> required <code>expires</code> <code>int</code> <p>URL expiry time in seconds.</p> <code>3600</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Presigned URL for downloading the object.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If any required parameter is empty.</p> <code>NotFoundError</code> <p>If the bucket or object does not exist.</p> <code>PermissionDeniedError</code> <p>If permission to generate URL is denied.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef presigned_get_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n    \"\"\"Generate a presigned URL for downloading an object.\n\n    Args:\n        bucket_name: Bucket name.\n        object_name: Object name to generate URL for.\n        expires: URL expiry time in seconds.\n\n    Returns:\n        str: Presigned URL for downloading the object.\n\n    Raises:\n        InvalidArgumentError: If any required parameter is empty.\n        NotFoundError: If the bucket or object does not exist.\n        PermissionDeniedError: If permission to generate URL is denied.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name or not object_name:\n            raise InvalidArgumentError(\n                argument_name=(\n                    \"bucket_name or object_name\"\n                    if not all([bucket_name, object_name])\n                    else \"bucket_name\" if not bucket_name else \"object_name\"\n                ),\n            )\n        url = self._adapter.presigned_get_object(\n            bucket_name=bucket_name,\n            object_name=object_name,\n            expires=timedelta(seconds=expires),\n        )\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        self._handle_s3_exception(e, \"presigned_get_object\")\n    except Exception as e:\n        self._handle_general_exception(e, \"presigned_get_object\")\n    else:\n        return url\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.presigned_put_object","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.presigned_put_object(bucket_name, object_name, expires=3600)</code>","text":"<p>Generate a presigned URL for uploading an object.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Bucket name.</p> required <code>object_name</code> <code>str</code> <p>Object name to generate URL for.</p> required <code>expires</code> <code>int</code> <p>URL expiry time in seconds.</p> <code>3600</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Presigned URL for uploading the object.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If any required parameter is empty.</p> <code>NotFoundError</code> <p>If the bucket does not exist.</p> <code>PermissionDeniedError</code> <p>If permission to generate URL is denied.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef presigned_put_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n    \"\"\"Generate a presigned URL for uploading an object.\n\n    Args:\n        bucket_name: Bucket name.\n        object_name: Object name to generate URL for.\n        expires: URL expiry time in seconds.\n\n    Returns:\n        str: Presigned URL for uploading the object.\n\n    Raises:\n        InvalidArgumentError: If any required parameter is empty.\n        NotFoundError: If the bucket does not exist.\n        PermissionDeniedError: If permission to generate URL is denied.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name or not object_name:\n            raise InvalidArgumentError(\n                argument_name=(\n                    \"bucket_name or object_name\"\n                    if not all([bucket_name, object_name])\n                    else \"bucket_name\" if not bucket_name else \"object_name\"\n                ),\n            )\n        url = self._adapter.presigned_put_object(\n            bucket_name=bucket_name,\n            object_name=object_name,\n            expires=timedelta(seconds=expires),\n        )\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        self._handle_s3_exception(e, \"presigned_put_object\")\n    except Exception as e:\n        self._handle_general_exception(e, \"presigned_put_object\")\n    else:\n        return url\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.set_bucket_policy","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.set_bucket_policy(bucket_name, policy)</code>","text":"<p>Set bucket policy.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Bucket name.</p> required <code>policy</code> <code>str</code> <p>JSON policy string.</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If any required parameter is empty.</p> <code>NotFoundError</code> <p>If the bucket does not exist.</p> <code>PermissionDeniedError</code> <p>If permission to set policy is denied.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef set_bucket_policy(self, bucket_name: str, policy: str) -&gt; None:\n    \"\"\"Set bucket policy.\n\n    Args:\n        bucket_name: Bucket name.\n        policy: JSON policy string.\n\n    Raises:\n        InvalidArgumentError: If any required parameter is empty.\n        NotFoundError: If the bucket does not exist.\n        PermissionDeniedError: If permission to set policy is denied.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name or not policy:\n            raise InvalidArgumentError(\n                argument_name=(\n                    \"bucket_name or policy\"\n                    if not all([bucket_name, policy])\n                    else \"bucket_name\" if not bucket_name else \"policy\"\n                ),\n            )\n        self._adapter.set_bucket_policy(bucket_name, policy)\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        self._handle_s3_exception(e, \"set_bucket_policy\")\n    except Exception as e:\n        self._handle_general_exception(e, \"set_bucket_policy\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.get_bucket_policy","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.get_bucket_policy(bucket_name)</code>","text":"<p>Get bucket policy.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Bucket name.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>MinioPolicyType</code> <p>Bucket policy information.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If bucket_name is empty.</p> <code>NotFoundError</code> <p>If the bucket does not exist.</p> <code>PermissionDeniedError</code> <p>If permission to get policy is denied.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_bucket_policy(self, bucket_name: str) -&gt; MinioPolicyType:\n    \"\"\"Get bucket policy.\n\n    Args:\n        bucket_name: Bucket name.\n\n    Returns:\n        dict: Bucket policy information.\n\n    Raises:\n        InvalidArgumentError: If bucket_name is empty.\n        NotFoundError: If the bucket does not exist.\n        PermissionDeniedError: If permission to get policy is denied.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name:\n            raise InvalidArgumentError(argument_name=\"bucket_name\")\n        policy = self._adapter.get_bucket_policy(bucket_name)\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        self._handle_s3_exception(e, \"get_bucket_policy\")\n    except Exception as e:\n        self._handle_general_exception(e, \"get_bucket_policy\")\n    else:\n        return {\"policy\": policy}\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort","title":"<code>archipy.adapters.minio.ports.MinioPort</code>","text":"<p>Interface for MinIO operations providing a standardized access pattern.</p> <p>This interface defines the contract for MinIO adapters, ensuring consistent implementation of object storage operations across different adapters.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>class MinioPort:\n    \"\"\"Interface for MinIO operations providing a standardized access pattern.\n\n    This interface defines the contract for MinIO adapters, ensuring consistent\n    implementation of object storage operations across different adapters.\n    \"\"\"\n\n    # Bucket Operations\n    @abstractmethod\n    def bucket_exists(self, bucket_name: str) -&gt; bool:\n        \"\"\"Check if a bucket exists.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def make_bucket(self, bucket_name: str) -&gt; None:\n        \"\"\"Create a new bucket.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def remove_bucket(self, bucket_name: str) -&gt; None:\n        \"\"\"Remove a bucket.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def list_buckets(self) -&gt; list[MinioBucketType]:\n        \"\"\"List all buckets.\"\"\"\n        raise NotImplementedError\n\n    # Object Operations\n    @abstractmethod\n    def put_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n        \"\"\"Upload a file to a bucket.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n        \"\"\"Download an object to a file.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def remove_object(self, bucket_name: str, object_name: str) -&gt; None:\n        \"\"\"Remove an object from a bucket.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def list_objects(\n        self,\n        bucket_name: str,\n        prefix: str = \"\",\n        *,  # Force recursive to be keyword-only to avoid boolean flag issues\n        recursive: bool = False,\n    ) -&gt; list[MinioObjectType]:\n        \"\"\"List objects in a bucket.\n\n        Args:\n            bucket_name: The name of the bucket to list objects from\n            prefix: Optional prefix to filter objects by\n            recursive: Whether to list objects recursively (include sub-directories)\n\n        Returns:\n            A list of MinioObjectType objects\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def stat_object(self, bucket_name: str, object_name: str) -&gt; MinioObjectType:\n        \"\"\"Get object metadata.\"\"\"\n        raise NotImplementedError\n\n    # Presigned URL Operations\n    @abstractmethod\n    def presigned_get_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n        \"\"\"Generate a presigned URL for downloading an object.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def presigned_put_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n        \"\"\"Generate a presigned URL for uploading an object.\"\"\"\n        raise NotImplementedError\n\n    # Policy Operations\n    @abstractmethod\n    def set_bucket_policy(self, bucket_name: str, policy: str) -&gt; None:\n        \"\"\"Set bucket policy.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_bucket_policy(self, bucket_name: str) -&gt; MinioPolicyType:\n        \"\"\"Get bucket policy.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.bucket_exists","title":"<code>archipy.adapters.minio.ports.MinioPort.bucket_exists(bucket_name)</code>  <code>abstractmethod</code>","text":"<p>Check if a bucket exists.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef bucket_exists(self, bucket_name: str) -&gt; bool:\n    \"\"\"Check if a bucket exists.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.make_bucket","title":"<code>archipy.adapters.minio.ports.MinioPort.make_bucket(bucket_name)</code>  <code>abstractmethod</code>","text":"<p>Create a new bucket.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef make_bucket(self, bucket_name: str) -&gt; None:\n    \"\"\"Create a new bucket.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.remove_bucket","title":"<code>archipy.adapters.minio.ports.MinioPort.remove_bucket(bucket_name)</code>  <code>abstractmethod</code>","text":"<p>Remove a bucket.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef remove_bucket(self, bucket_name: str) -&gt; None:\n    \"\"\"Remove a bucket.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.list_buckets","title":"<code>archipy.adapters.minio.ports.MinioPort.list_buckets()</code>  <code>abstractmethod</code>","text":"<p>List all buckets.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef list_buckets(self) -&gt; list[MinioBucketType]:\n    \"\"\"List all buckets.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.put_object","title":"<code>archipy.adapters.minio.ports.MinioPort.put_object(bucket_name, object_name, file_path)</code>  <code>abstractmethod</code>","text":"<p>Upload a file to a bucket.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef put_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n    \"\"\"Upload a file to a bucket.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.get_object","title":"<code>archipy.adapters.minio.ports.MinioPort.get_object(bucket_name, object_name, file_path)</code>  <code>abstractmethod</code>","text":"<p>Download an object to a file.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef get_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n    \"\"\"Download an object to a file.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.remove_object","title":"<code>archipy.adapters.minio.ports.MinioPort.remove_object(bucket_name, object_name)</code>  <code>abstractmethod</code>","text":"<p>Remove an object from a bucket.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef remove_object(self, bucket_name: str, object_name: str) -&gt; None:\n    \"\"\"Remove an object from a bucket.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.list_objects","title":"<code>archipy.adapters.minio.ports.MinioPort.list_objects(bucket_name, prefix='', *, recursive=False)</code>  <code>abstractmethod</code>","text":"<p>List objects in a bucket.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>The name of the bucket to list objects from</p> required <code>prefix</code> <code>str</code> <p>Optional prefix to filter objects by</p> <code>''</code> <code>recursive</code> <code>bool</code> <p>Whether to list objects recursively (include sub-directories)</p> <code>False</code> <p>Returns:</p> Type Description <code>list[MinioObjectType]</code> <p>A list of MinioObjectType objects</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef list_objects(\n    self,\n    bucket_name: str,\n    prefix: str = \"\",\n    *,  # Force recursive to be keyword-only to avoid boolean flag issues\n    recursive: bool = False,\n) -&gt; list[MinioObjectType]:\n    \"\"\"List objects in a bucket.\n\n    Args:\n        bucket_name: The name of the bucket to list objects from\n        prefix: Optional prefix to filter objects by\n        recursive: Whether to list objects recursively (include sub-directories)\n\n    Returns:\n        A list of MinioObjectType objects\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.stat_object","title":"<code>archipy.adapters.minio.ports.MinioPort.stat_object(bucket_name, object_name)</code>  <code>abstractmethod</code>","text":"<p>Get object metadata.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef stat_object(self, bucket_name: str, object_name: str) -&gt; MinioObjectType:\n    \"\"\"Get object metadata.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.presigned_get_object","title":"<code>archipy.adapters.minio.ports.MinioPort.presigned_get_object(bucket_name, object_name, expires=3600)</code>  <code>abstractmethod</code>","text":"<p>Generate a presigned URL for downloading an object.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef presigned_get_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n    \"\"\"Generate a presigned URL for downloading an object.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.presigned_put_object","title":"<code>archipy.adapters.minio.ports.MinioPort.presigned_put_object(bucket_name, object_name, expires=3600)</code>  <code>abstractmethod</code>","text":"<p>Generate a presigned URL for uploading an object.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef presigned_put_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n    \"\"\"Generate a presigned URL for uploading an object.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.set_bucket_policy","title":"<code>archipy.adapters.minio.ports.MinioPort.set_bucket_policy(bucket_name, policy)</code>  <code>abstractmethod</code>","text":"<p>Set bucket policy.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef set_bucket_policy(self, bucket_name: str, policy: str) -&gt; None:\n    \"\"\"Set bucket policy.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.get_bucket_policy","title":"<code>archipy.adapters.minio.ports.MinioPort.get_bucket_policy(bucket_name)</code>  <code>abstractmethod</code>","text":"<p>Get bucket policy.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef get_bucket_policy(self, bucket_name: str) -&gt; MinioPolicyType:\n    \"\"\"Get bucket policy.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#redis","title":"Redis","text":"<p>Redis integration for caching and key-value storage.</p> <pre><code>from archipy.adapters.redis import RedisAdapter, AsyncRedisAdapter\n\n# Create a Redis adapter (uses global config)\nredis = RedisAdapter()\n</code></pre> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter","title":"<code>archipy.adapters.redis.adapters.RedisAdapter</code>","text":"<p>               Bases: <code>RedisPort</code></p> <p>Adapter for Redis operations providing a standardized interface.</p> <p>This adapter implements the RedisPort interface to provide a consistent way to interact with Redis, abstracting the underlying Redis client implementation. It supports all common Redis operations including key-value operations, lists, sets, sorted sets, hashes, and pub/sub functionality.</p> <p>The adapter maintains separate connections for read and write operations, which can be used to implement read replicas for better performance.</p> <p>Parameters:</p> Name Type Description Default <code>redis_config</code> <code>RedisConfig</code> <p>Configuration settings for Redis. If None, retrieves from global config. Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>class RedisAdapter(RedisPort):\n    \"\"\"Adapter for Redis operations providing a standardized interface.\n\n    This adapter implements the RedisPort interface to provide a consistent\n    way to interact with Redis, abstracting the underlying Redis client\n    implementation. It supports all common Redis operations including key-value\n    operations, lists, sets, sorted sets, hashes, and pub/sub functionality.\n\n    The adapter maintains separate connections for read and write operations,\n    which can be used to implement read replicas for better performance.\n\n    Args:\n        redis_config (RedisConfig, optional): Configuration settings for Redis.\n            If None, retrieves from global config. Defaults to None.\n    \"\"\"\n\n    def __init__(self, redis_config: RedisConfig | None = None) -&gt; None:\n        \"\"\"Initialize the RedisAdapter with configuration settings.\n\n        Args:\n            redis_config (RedisConfig, optional): Configuration settings for Redis.\n                If None, retrieves from global config. Defaults to None.\n        \"\"\"\n        configs: RedisConfig = BaseConfig.global_config().REDIS if redis_config is None else redis_config\n        self._set_clients(configs)\n\n    def _set_clients(self, configs: RedisConfig) -&gt; None:\n        \"\"\"Set up Redis clients for master and slave connections.\n\n        Args:\n            configs (RedisConfig): Configuration settings for Redis.\n        \"\"\"\n        if redis_master_host := configs.MASTER_HOST:\n            self.client: Redis = self._get_client(redis_master_host, configs)\n        if redis_slave_host := configs.SLAVE_HOST:\n            self.read_only_client: Redis = self._get_client(redis_slave_host, configs)\n        else:\n            self.read_only_client = self.client\n\n    @staticmethod\n    def _get_client(host: str, configs: RedisConfig) -&gt; Redis:\n        \"\"\"Create a Redis client with the specified configuration.\n\n        Args:\n            host (str): Redis host address.\n            configs (RedisConfig): Configuration settings for Redis.\n\n        Returns:\n            Redis: Configured Redis client instance.\n        \"\"\"\n        return Redis(\n            host=host,\n            port=configs.PORT,\n            db=configs.DATABASE,\n            password=configs.PASSWORD,\n            decode_responses=configs.DECODE_RESPONSES,\n            health_check_interval=configs.HEALTH_CHECK_INTERVAL,\n        )\n\n    @override\n    def pttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get the time to live in milliseconds for a key.\n\n        Args:\n            name (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: Time to live in milliseconds.\n        \"\"\"\n        return self.read_only_client.pttl(name)\n\n    @override\n    def incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n        \"\"\"Increment the integer value of a key by the given amount.\n\n        Args:\n            name (RedisKeyType): The key name.\n            amount (int): Amount to increment by. Defaults to 1.\n\n        Returns:\n            RedisResponseType: The new value after increment.\n        \"\"\"\n        return self.client.incrby(name, amount)\n\n    @override\n    def set(\n        self,\n        name: RedisKeyType,\n        value: RedisSetType,\n        ex: RedisExpiryType | None = None,\n        px: RedisExpiryType | None = None,\n        nx: bool = False,\n        xx: bool = False,\n        keepttl: bool = False,\n        get: bool = False,\n        exat: RedisAbsExpiryType | None = None,\n        pxat: RedisAbsExpiryType | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Set the value of a key with optional expiration and conditions.\n\n        Args:\n            name (RedisKeyType): The key name.\n            value (RedisSetType): The value to set.\n            ex (RedisExpiryType | None): Expire time in seconds.\n            px (RedisExpiryType | None): Expire time in milliseconds.\n            nx (bool): Only set if key doesn't exist.\n            xx (bool): Only set if key exists.\n            keepttl (bool): Retain the TTL from the previous value.\n            get (bool): Return the old value.\n            exat (RedisAbsExpiryType | None): Absolute expiration time in seconds.\n            pxat (RedisAbsExpiryType | None): Absolute expiration time in milliseconds.\n\n        Returns:\n            RedisResponseType: Result of the operation.\n        \"\"\"\n        return self.client.set(name, value, ex, px, nx, xx, keepttl, get, exat, pxat)\n\n    @override\n    def get(self, key: str) -&gt; RedisResponseType:\n        \"\"\"Get the value of a key.\n\n        Args:\n            key (str): The key name.\n\n        Returns:\n            RedisResponseType: The value of the key or None if not exists.\n        \"\"\"\n        return self.read_only_client.get(key)\n\n    @override\n    def mget(\n        self,\n        keys: RedisKeyType | Iterable[RedisKeyType],\n        *args: bytes | str,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get the values of multiple keys.\n\n        Args:\n            keys (RedisKeyType | Iterable[RedisKeyType]): Single key or iterable of keys.\n            *args (bytes | str): Additional keys.\n\n        Returns:\n            RedisResponseType: List of values.\n        \"\"\"\n        return self.read_only_client.mget(keys, *args)\n\n    @override\n    def mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n        \"\"\"Set multiple keys to their respective values.\n\n        Args:\n            mapping (Mapping[RedisKeyType, bytes | str | float]): Dictionary of key-value pairs.\n\n        Returns:\n            RedisResponseType: Always returns 'OK'.\n        \"\"\"\n        return self.client.mset(mapping)\n\n    @override\n    def keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Find all keys matching the given pattern.\n\n        Args:\n            pattern (RedisPatternType): Pattern to match keys against. Defaults to \"*\".\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: List of matching keys.\n        \"\"\"\n        return self.read_only_client.keys(pattern, **kwargs)\n\n    @override\n    def getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Set the value of a key and return its old value.\n\n        Args:\n            key (RedisKeyType): The key name.\n            value (bytes | str | float): The new value.\n\n        Returns:\n            RedisResponseType: The previous value or None.\n        \"\"\"\n        return self.client.getset(key, value)\n\n    @override\n    def getdel(self, key: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get the value of a key and delete it.\n\n        Args:\n            key (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: The value of the key or None.\n        \"\"\"\n        return self.client.getdel(key)\n\n    @override\n    def exists(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Check if one or more keys exist.\n\n        Args:\n            *names (bytes | str): Variable number of key names.\n\n        Returns:\n            RedisResponseType: Number of keys that exist.\n        \"\"\"\n        return self.read_only_client.exists(*names)\n\n    @override\n    def delete(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Delete one or more keys.\n\n        Args:\n            *names (bytes | str): Variable number of key names.\n\n        Returns:\n            RedisResponseType: Number of keys deleted.\n        \"\"\"\n        return self.client.delete(*names)\n\n    @override\n    def append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Append a value to a key.\n\n        Args:\n            key (RedisKeyType): The key name.\n            value (bytes | str | float): The value to append.\n\n        Returns:\n            RedisResponseType: Length of the string after append.\n        \"\"\"\n        return self.client.append(key, value)\n\n    @override\n    def ttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get the time to live in seconds for a key.\n\n        Args:\n            name (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: Time to live in seconds.\n        \"\"\"\n        return self.read_only_client.ttl(name)\n\n    @override\n    def type(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Determine the type stored at key.\n\n        Args:\n            name (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: Type of the key's value.\n        \"\"\"\n        return self.read_only_client.type(name)\n\n    @override\n    def llen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Get the length of a list.\n\n        Args:\n            name (str): The key name of the list.\n\n        Returns:\n            RedisIntegerResponseType: Length of the list.\n        \"\"\"\n        return self.read_only_client.llen(name)\n\n    @override\n    def lpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Remove and return elements from the left of a list.\n\n        Args:\n            name (str): The key name of the list.\n            count (int | None): Number of elements to pop. Defaults to None.\n\n        Returns:\n            Any: Popped element(s) or None if list is empty.\n        \"\"\"\n        return self.client.lpop(name, count)\n\n    @override\n    def lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Push elements to the left of a list.\n\n        Args:\n            name (str): The key name of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: Length of the list after push.\n        \"\"\"\n        return self.client.lpush(name, *values)\n\n    @override\n    def lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n        \"\"\"Get a range of elements from a list.\n\n        Args:\n            name (str): The key name of the list.\n            start (int): Start index.\n            end (int): End index.\n\n        Returns:\n            RedisListResponseType: List of elements in the specified range.\n        \"\"\"\n        return self.read_only_client.lrange(name, start, end)\n\n    @override\n    def lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Remove elements from a list.\n\n        Args:\n            name (str): The key name of the list.\n            count (int): Number of occurrences to remove.\n            value (str): Value to remove.\n\n        Returns:\n            RedisIntegerResponseType: Number of elements removed.\n        \"\"\"\n        return self.client.lrem(name, count, value)\n\n    @override\n    def lset(self, name: str, index: int, value: str) -&gt; bool:\n        \"\"\"Set the value of an element in a list by its index.\n\n        Args:\n            name (str): The key name of the list.\n            index (int): Index of the element.\n            value (str): New value.\n\n        Returns:\n            bool: True if successful.\n        \"\"\"\n        return bool(self.client.lset(name, index, value))\n\n    @override\n    def rpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Remove and return elements from the right of a list.\n\n        Args:\n            name (str): The key name of the list.\n            count (int | None): Number of elements to pop. Defaults to None.\n\n        Returns:\n            Any: Popped element(s) or None if list is empty.\n        \"\"\"\n        return self.client.rpop(name, count)\n\n    @override\n    def rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Push elements to the right of a list.\n\n        Args:\n            name (str): The key name of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: Length of the list after push.\n        \"\"\"\n        return self.client.rpush(name, *values)\n\n    @override\n    def scan(\n        self,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; RedisResponseType:\n        \"\"\"Scan keys in the database incrementally.\n\n        Args:\n            cursor (int): Cursor position. Defaults to 0.\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of keys to return. Defaults to None.\n            _type (str | None): Filter by type. Defaults to None.\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: Tuple of cursor and list of keys.\n        \"\"\"\n        return self.read_only_client.scan(cursor, match, count, _type, **kwargs)\n\n    @override\n    def scan_iter(\n        self,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; Iterator:\n        \"\"\"Iterate over keys in the database.\n\n        Args:\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of keys to return. Defaults to None.\n            _type (str | None): Filter by type. Defaults to None.\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            Iterator: Iterator over matching keys.\n        \"\"\"\n        return self.read_only_client.scan_iter(match, count, _type, **kwargs)\n\n    @override\n    def sscan(\n        self,\n        name: RedisKeyType,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Scan members of a set incrementally.\n\n        Args:\n            name (RedisKeyType): The set key name.\n            cursor (int): Cursor position. Defaults to 0.\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of elements. Defaults to None.\n\n        Returns:\n            RedisResponseType: Tuple of cursor and list of members.\n        \"\"\"\n        return self.read_only_client.sscan(name, cursor, match, count)\n\n    @override\n    def sscan_iter(\n        self,\n        name: RedisKeyType,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; Iterator:\n        \"\"\"Iterate over members of a set.\n\n        Args:\n            name (RedisKeyType): The set key name.\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of elements. Defaults to None.\n\n        Returns:\n            Iterator: Iterator over set members.\n        \"\"\"\n        return self.read_only_client.sscan_iter(name, match, count)\n\n    @override\n    def sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Add members to a set.\n\n        Args:\n            name (str): The set key name.\n            *values (bytes | str | float): Members to add.\n\n        Returns:\n            RedisIntegerResponseType: Number of elements added.\n        \"\"\"\n        return self.client.sadd(name, *values)\n\n    @override\n    def scard(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Get the number of members in a set.\n\n        Args:\n            name (str): The set key name.\n\n        Returns:\n            RedisIntegerResponseType: Number of members.\n        \"\"\"\n        return self.client.scard(name)\n\n    @override\n    def sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Check if a value is a member of a set.\n\n        Args:\n            name (str): The set key name.\n            value (str): Value to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if value is a member, False otherwise.\n        \"\"\"\n        result = self.read_only_client.sismember(name, value)\n        return result\n\n    @override\n    def smembers(self, name: str) -&gt; RedisSetResponseType:\n        \"\"\"Get all members of a set.\n\n        Args:\n            name (str): The set key name.\n\n        Returns:\n            RedisSetResponseType: Set of all members.\n        \"\"\"\n        return self.read_only_client.smembers(name)\n\n    @override\n    def spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n        \"\"\"Remove and return random members from a set.\n\n        Args:\n            name (str): The set key name.\n            count (int | None): Number of members to pop. Defaults to None.\n\n        Returns:\n            bytes | float | int | str | list | None: Popped member(s) or None.\n        \"\"\"\n        return self.client.spop(name, count)\n\n    @override\n    def srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Remove members from a set.\n\n        Args:\n            name (str): The set key name.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisIntegerResponseType: Number of members removed.\n        \"\"\"\n        return self.client.srem(name, *values)\n\n    @override\n    def sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n        \"\"\"Get the union of multiple sets.\n\n        Args:\n            keys (RedisKeyType): First set key.\n            *args (bytes | str): Additional set keys.\n\n        Returns:\n            RedisSetResponseType: Set containing union of all sets.\n        \"\"\"\n        result = self.client.sunion(keys, *args)\n        return set(result) if result else set()\n\n    @override\n    def zadd(\n        self,\n        name: RedisKeyType,\n        mapping: Mapping[RedisKeyType, bytes | str | float],\n        nx: bool = False,\n        xx: bool = False,\n        ch: bool = False,\n        incr: bool = False,\n        gt: bool = False,\n        lt: bool = False,\n    ) -&gt; RedisResponseType:\n        \"\"\"Add members to a sorted set with scores.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            mapping (Mapping[RedisKeyType, bytes | str | float]): Member-score pairs.\n            nx (bool): Only add new elements. Defaults to False.\n            xx (bool): Only update existing elements. Defaults to False.\n            ch (bool): Return number of changed elements. Defaults to False.\n            incr (bool): Increment existing scores. Defaults to False.\n            gt (bool): Only update if score is greater. Defaults to False.\n            lt (bool): Only update if score is less. Defaults to False.\n\n        Returns:\n            RedisResponseType: Number of elements added or modified.\n        \"\"\"\n        return self.client.zadd(name, mapping, nx, xx, ch, incr, gt, lt)\n\n    @override\n    def zcard(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get the number of members in a sorted set.\n\n        Args:\n            name (bytes | str): The sorted set key name.\n\n        Returns:\n            RedisResponseType: Number of members.\n        \"\"\"\n        return self.client.zcard(name)\n\n    @override\n    def zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n        \"\"\"Count members in a sorted set with scores in range.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            min (float | str): Minimum score.\n            max (float | str): Maximum score.\n\n        Returns:\n            RedisResponseType: Number of members in range.\n        \"\"\"\n        return self.client.zcount(name, min, max)\n\n    @override\n    def zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Remove and return members with highest scores from sorted set.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            count (int | None): Number of members to pop. Defaults to None.\n\n        Returns:\n            RedisResponseType: List of popped member-score pairs.\n        \"\"\"\n        return self.client.zpopmax(name, count)\n\n    @override\n    def zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Remove and return members with lowest scores from sorted set.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            count (int | None): Number of members to pop. Defaults to None.\n\n        Returns:\n            RedisResponseType: List of popped member-score pairs.\n        \"\"\"\n        return self.client.zpopmin(name, count)\n\n    @override\n    def zrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        desc: bool = False,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n        byscore: bool = False,\n        bylex: bool = False,\n        offset: int | None = None,\n        num: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get a range of members from a sorted set.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            start (int): Start index or score.\n            end (int): End index or score.\n            desc (bool): Sort in descending order. Defaults to False.\n            withscores (bool): Include scores in result. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n            byscore (bool): Range by score. Defaults to False.\n            bylex (bool): Range by lexicographical order. Defaults to False.\n            offset (int | None): Offset for byscore/bylex. Defaults to None.\n            num (int | None): Count for byscore/bylex. Defaults to None.\n\n        Returns:\n            RedisResponseType: List of members or member-score pairs.\n        \"\"\"\n        return self.client.zrange(\n            name,\n            start,\n            end,\n            desc,\n            withscores,\n            score_cast_func,\n            byscore,\n            bylex,\n            offset,\n            num,\n        )\n\n    @override\n    def zrevrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get a range of members from a sorted set in reverse order.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            start (int): Start index.\n            end (int): End index.\n            withscores (bool): Include scores in result. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n        Returns:\n            RedisResponseType: List of members or member-score pairs.\n        \"\"\"\n        return self.client.zrevrange(name, start, end, withscores, score_cast_func)\n\n    @override\n    def zrangebyscore(\n        self,\n        name: RedisKeyType,\n        min: float | str,\n        max: float | str,\n        start: int | None = None,\n        num: int | None = None,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get members from a sorted set by score range.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            min (float | str): Minimum score.\n            max (float | str): Maximum score.\n            start (int | None): Offset. Defaults to None.\n            num (int | None): Count. Defaults to None.\n            withscores (bool): Include scores in result. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n        Returns:\n            RedisResponseType: List of members or member-score pairs.\n        \"\"\"\n        return self.client.zrangebyscore(name, min, max, start, num, withscores, score_cast_func)\n\n    @override\n    def zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Get the rank of a member in a sorted set.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            value (bytes | str | float): Member to find rank for.\n\n        Returns:\n            RedisResponseType: Rank of the member or None if not found.\n        \"\"\"\n        return self.client.zrank(name, value)\n\n    @override\n    def zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Remove members from a sorted set.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisResponseType: Number of members removed.\n        \"\"\"\n        return self.client.zrem(name, *values)\n\n    @override\n    def zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Get the score of a member in a sorted set.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            value (bytes | str | float): Member to get score for.\n\n        Returns:\n            RedisResponseType: Score of the member or None if not found.\n        \"\"\"\n        return self.client.zscore(name, value)\n\n    @override\n    def hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n        \"\"\"Delete fields from a hash.\n\n        Args:\n            name (str): The hash key name.\n            *keys (str | bytes): Fields to delete.\n\n        Returns:\n            RedisIntegerResponseType: Number of fields deleted.\n        \"\"\"\n        return self.client.hdel(name, *keys)\n\n    @override\n    def hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Check if a field exists in a hash.\n\n        Args:\n            name (str): The hash key name.\n            key (str): Field to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if field exists, False otherwise.\n        \"\"\"\n        return self.read_only_client.hexists(name, key)\n\n    @override\n    def hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n        \"\"\"Get the value of a field in a hash.\n\n        Args:\n            name (str): The hash key name.\n            key (str): Field to get.\n\n        Returns:\n            Awaitable[str | None] | str | None: Value of the field or None.\n        \"\"\"\n        return self.read_only_client.hget(name, key)\n\n    @override\n    def hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n        \"\"\"Get all fields and values in a hash.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            Awaitable[dict] | dict: Dictionary of field-value pairs.\n        \"\"\"\n        return self.read_only_client.hgetall(name)\n\n    @override\n    def hkeys(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Get all fields in a hash.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            RedisListResponseType: List of field names.\n        \"\"\"\n        return self.read_only_client.hkeys(name)\n\n    @override\n    def hlen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Get the number of fields in a hash.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            RedisIntegerResponseType: Number of fields.\n        \"\"\"\n        return self.read_only_client.hlen(name)\n\n    @override\n    def hset(\n        self,\n        name: str,\n        key: str | bytes | None = None,\n        value: str | bytes | None = None,\n        mapping: dict | None = None,\n        items: list | None = None,\n    ) -&gt; RedisIntegerResponseType:\n        \"\"\"Set fields in a hash.\n\n        Args:\n            name (str): The hash key name.\n            key (str | bytes | None): Single field name. Defaults to None.\n            value (str | bytes | None): Single field value. Defaults to None.\n            mapping (dict | None): Dictionary of field-value pairs. Defaults to None.\n            items (list | None): List of field-value pairs. Defaults to None.\n\n        Returns:\n            RedisIntegerResponseType: Number of fields set.\n        \"\"\"\n        return self.client.hset(name, key, value, mapping, items)\n\n    @override\n    def hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n        \"\"\"Get values of multiple fields in a hash.\n\n        Args:\n            name (str): The hash key name.\n            keys (list): List of field names.\n            *args (str | bytes): Additional field names.\n\n        Returns:\n            RedisListResponseType: List of field values.\n        \"\"\"\n        return self.read_only_client.hmget(name, keys, *args)\n\n    @override\n    def hvals(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Get all values in a hash.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            RedisListResponseType: List of values.\n        \"\"\"\n        return self.read_only_client.hvals(name)\n\n    @override\n    def publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Publish a message to a channel.\n\n        Args:\n            channel (RedisKeyType): Channel name.\n            message (bytes | str): Message to publish.\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: Number of subscribers that received the message.\n        \"\"\"\n        return self.client.publish(channel, message, **kwargs)\n\n    @override\n    def pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"List active channels matching a pattern.\n\n        Args:\n            pattern (RedisPatternType): Pattern to match channels. Defaults to \"*\".\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: List of channel names.\n        \"\"\"\n        return self.client.pubsub_channels(pattern, **kwargs)\n\n    @override\n    def zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Increment the score of a member in a sorted set.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            amount (float): Amount to increment by.\n            value (bytes | str | float): Member to increment.\n\n        Returns:\n            RedisResponseType: New score of the member.\n        \"\"\"\n        return self.client.zincrby(name, amount, value)\n\n    @override\n    def pubsub(self, **kwargs: Any) -&gt; PubSub:\n        \"\"\"Get a PubSub object for subscribing to channels.\n\n        Args:\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            PubSub: PubSub object.\n        \"\"\"\n        return self.client.pubsub(**kwargs)\n\n    @override\n    def get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; Pipeline:\n        \"\"\"Get a pipeline object for executing multiple commands.\n\n        Args:\n            transaction (Any): Whether to use transactions. Defaults to True.\n            shard_hint (Any): Hint for sharding. Defaults to None.\n\n        Returns:\n            Pipeline: Pipeline object.\n        \"\"\"\n        return self.client.pipeline(transaction, shard_hint)\n\n    @override\n    def ping(self) -&gt; RedisResponseType:\n        \"\"\"Ping the Redis server.\n\n        Returns:\n            RedisResponseType: 'PONG' if successful.\n        \"\"\"\n        return self.client.ping()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.__init__","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.__init__(redis_config=None)</code>","text":"<p>Initialize the RedisAdapter with configuration settings.</p> <p>Parameters:</p> Name Type Description Default <code>redis_config</code> <code>RedisConfig</code> <p>Configuration settings for Redis. If None, retrieves from global config. Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>def __init__(self, redis_config: RedisConfig | None = None) -&gt; None:\n    \"\"\"Initialize the RedisAdapter with configuration settings.\n\n    Args:\n        redis_config (RedisConfig, optional): Configuration settings for Redis.\n            If None, retrieves from global config. Defaults to None.\n    \"\"\"\n    configs: RedisConfig = BaseConfig.global_config().REDIS if redis_config is None else redis_config\n    self._set_clients(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.pttl","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.pttl(name)</code>","text":"<p>Get the time to live in milliseconds for a key.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Time to live in milliseconds.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef pttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get the time to live in milliseconds for a key.\n\n    Args:\n        name (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: Time to live in milliseconds.\n    \"\"\"\n    return self.read_only_client.pttl(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.incrby","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.incrby(name, amount=1)</code>","text":"<p>Increment the integer value of a key by the given amount.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>amount</code> <code>int</code> <p>Amount to increment by. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The new value after increment.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n    \"\"\"Increment the integer value of a key by the given amount.\n\n    Args:\n        name (RedisKeyType): The key name.\n        amount (int): Amount to increment by. Defaults to 1.\n\n    Returns:\n        RedisResponseType: The new value after increment.\n    \"\"\"\n    return self.client.incrby(name, amount)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.set","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.set(name, value, ex=None, px=None, nx=False, xx=False, keepttl=False, get=False, exat=None, pxat=None)</code>","text":"<p>Set the value of a key with optional expiration and conditions.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>value</code> <code>RedisSetType</code> <p>The value to set.</p> required <code>ex</code> <code>RedisExpiryType | None</code> <p>Expire time in seconds.</p> <code>None</code> <code>px</code> <code>RedisExpiryType | None</code> <p>Expire time in milliseconds.</p> <code>None</code> <code>nx</code> <code>bool</code> <p>Only set if key doesn't exist.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>Only set if key exists.</p> <code>False</code> <code>keepttl</code> <code>bool</code> <p>Retain the TTL from the previous value.</p> <code>False</code> <code>get</code> <code>bool</code> <p>Return the old value.</p> <code>False</code> <code>exat</code> <code>RedisAbsExpiryType | None</code> <p>Absolute expiration time in seconds.</p> <code>None</code> <code>pxat</code> <code>RedisAbsExpiryType | None</code> <p>Absolute expiration time in milliseconds.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Result of the operation.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef set(\n    self,\n    name: RedisKeyType,\n    value: RedisSetType,\n    ex: RedisExpiryType | None = None,\n    px: RedisExpiryType | None = None,\n    nx: bool = False,\n    xx: bool = False,\n    keepttl: bool = False,\n    get: bool = False,\n    exat: RedisAbsExpiryType | None = None,\n    pxat: RedisAbsExpiryType | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Set the value of a key with optional expiration and conditions.\n\n    Args:\n        name (RedisKeyType): The key name.\n        value (RedisSetType): The value to set.\n        ex (RedisExpiryType | None): Expire time in seconds.\n        px (RedisExpiryType | None): Expire time in milliseconds.\n        nx (bool): Only set if key doesn't exist.\n        xx (bool): Only set if key exists.\n        keepttl (bool): Retain the TTL from the previous value.\n        get (bool): Return the old value.\n        exat (RedisAbsExpiryType | None): Absolute expiration time in seconds.\n        pxat (RedisAbsExpiryType | None): Absolute expiration time in milliseconds.\n\n    Returns:\n        RedisResponseType: Result of the operation.\n    \"\"\"\n    return self.client.set(name, value, ex, px, nx, xx, keepttl, get, exat, pxat)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.get","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.get(key)</code>","text":"<p>Get the value of a key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value of the key or None if not exists.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef get(self, key: str) -&gt; RedisResponseType:\n    \"\"\"Get the value of a key.\n\n    Args:\n        key (str): The key name.\n\n    Returns:\n        RedisResponseType: The value of the key or None if not exists.\n    \"\"\"\n    return self.read_only_client.get(key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.mget","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.mget(keys, *args)</code>","text":"<p>Get the values of multiple keys.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType | Iterable[RedisKeyType]</code> <p>Single key or iterable of keys.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional keys.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of values.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef mget(\n    self,\n    keys: RedisKeyType | Iterable[RedisKeyType],\n    *args: bytes | str,\n) -&gt; RedisResponseType:\n    \"\"\"Get the values of multiple keys.\n\n    Args:\n        keys (RedisKeyType | Iterable[RedisKeyType]): Single key or iterable of keys.\n        *args (bytes | str): Additional keys.\n\n    Returns:\n        RedisResponseType: List of values.\n    \"\"\"\n    return self.read_only_client.mget(keys, *args)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.mset","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.mset(mapping)</code>","text":"<p>Set multiple keys to their respective values.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>Dictionary of key-value pairs.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Always returns 'OK'.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n    \"\"\"Set multiple keys to their respective values.\n\n    Args:\n        mapping (Mapping[RedisKeyType, bytes | str | float]): Dictionary of key-value pairs.\n\n    Returns:\n        RedisResponseType: Always returns 'OK'.\n    \"\"\"\n    return self.client.mset(mapping)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.keys","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.keys(pattern='*', **kwargs)</code>","text":"<p>Find all keys matching the given pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>Pattern to match keys against. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of matching keys.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Find all keys matching the given pattern.\n\n    Args:\n        pattern (RedisPatternType): Pattern to match keys against. Defaults to \"*\".\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: List of matching keys.\n    \"\"\"\n    return self.read_only_client.keys(pattern, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.getset","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.getset(key, value)</code>","text":"<p>Set the value of a key and return its old value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>The new value.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The previous value or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Set the value of a key and return its old value.\n\n    Args:\n        key (RedisKeyType): The key name.\n        value (bytes | str | float): The new value.\n\n    Returns:\n        RedisResponseType: The previous value or None.\n    \"\"\"\n    return self.client.getset(key, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.getdel","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.getdel(key)</code>","text":"<p>Get the value of a key and delete it.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value of the key or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef getdel(self, key: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get the value of a key and delete it.\n\n    Args:\n        key (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: The value of the key or None.\n    \"\"\"\n    return self.client.getdel(key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.exists","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.exists(*names)</code>","text":"<p>Check if one or more keys exist.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of key names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of keys that exist.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef exists(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Check if one or more keys exist.\n\n    Args:\n        *names (bytes | str): Variable number of key names.\n\n    Returns:\n        RedisResponseType: Number of keys that exist.\n    \"\"\"\n    return self.read_only_client.exists(*names)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.delete","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.delete(*names)</code>","text":"<p>Delete one or more keys.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of key names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of keys deleted.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef delete(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Delete one or more keys.\n\n    Args:\n        *names (bytes | str): Variable number of key names.\n\n    Returns:\n        RedisResponseType: Number of keys deleted.\n    \"\"\"\n    return self.client.delete(*names)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.append","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.append(key, value)</code>","text":"<p>Append a value to a key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>The value to append.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Length of the string after append.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Append a value to a key.\n\n    Args:\n        key (RedisKeyType): The key name.\n        value (bytes | str | float): The value to append.\n\n    Returns:\n        RedisResponseType: Length of the string after append.\n    \"\"\"\n    return self.client.append(key, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.ttl","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.ttl(name)</code>","text":"<p>Get the time to live in seconds for a key.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Time to live in seconds.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef ttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get the time to live in seconds for a key.\n\n    Args:\n        name (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: Time to live in seconds.\n    \"\"\"\n    return self.read_only_client.ttl(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.type","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.type(name)</code>","text":"<p>Determine the type stored at key.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Type of the key's value.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef type(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Determine the type stored at key.\n\n    Args:\n        name (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: Type of the key's value.\n    \"\"\"\n    return self.read_only_client.type(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.llen","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.llen(name)</code>","text":"<p>Get the length of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Length of the list.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef llen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Get the length of a list.\n\n    Args:\n        name (str): The key name of the list.\n\n    Returns:\n        RedisIntegerResponseType: Length of the list.\n    \"\"\"\n    return self.read_only_client.llen(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.lpop","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.lpop(name, count=None)</code>","text":"<p>Remove and return elements from the left of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>count</code> <code>int | None</code> <p>Number of elements to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Popped element(s) or None if list is empty.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef lpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Remove and return elements from the left of a list.\n\n    Args:\n        name (str): The key name of the list.\n        count (int | None): Number of elements to pop. Defaults to None.\n\n    Returns:\n        Any: Popped element(s) or None if list is empty.\n    \"\"\"\n    return self.client.lpop(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.lpush","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.lpush(name, *values)</code>","text":"<p>Push elements to the left of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Length of the list after push.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Push elements to the left of a list.\n\n    Args:\n        name (str): The key name of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: Length of the list after push.\n    \"\"\"\n    return self.client.lpush(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.lrange","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.lrange(name, start, end)</code>","text":"<p>Get a range of elements from a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>start</code> <code>int</code> <p>Start index.</p> required <code>end</code> <code>int</code> <p>End index.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of elements in the specified range.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n    \"\"\"Get a range of elements from a list.\n\n    Args:\n        name (str): The key name of the list.\n        start (int): Start index.\n        end (int): End index.\n\n    Returns:\n        RedisListResponseType: List of elements in the specified range.\n    \"\"\"\n    return self.read_only_client.lrange(name, start, end)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.lrem","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.lrem(name, count, value)</code>","text":"<p>Remove elements from a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>count</code> <code>int</code> <p>Number of occurrences to remove.</p> required <code>value</code> <code>str</code> <p>Value to remove.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of elements removed.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Remove elements from a list.\n\n    Args:\n        name (str): The key name of the list.\n        count (int): Number of occurrences to remove.\n        value (str): Value to remove.\n\n    Returns:\n        RedisIntegerResponseType: Number of elements removed.\n    \"\"\"\n    return self.client.lrem(name, count, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.lset","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.lset(name, index, value)</code>","text":"<p>Set the value of an element in a list by its index.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>index</code> <code>int</code> <p>Index of the element.</p> required <code>value</code> <code>str</code> <p>New value.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef lset(self, name: str, index: int, value: str) -&gt; bool:\n    \"\"\"Set the value of an element in a list by its index.\n\n    Args:\n        name (str): The key name of the list.\n        index (int): Index of the element.\n        value (str): New value.\n\n    Returns:\n        bool: True if successful.\n    \"\"\"\n    return bool(self.client.lset(name, index, value))\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.rpop","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.rpop(name, count=None)</code>","text":"<p>Remove and return elements from the right of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>count</code> <code>int | None</code> <p>Number of elements to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Popped element(s) or None if list is empty.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef rpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Remove and return elements from the right of a list.\n\n    Args:\n        name (str): The key name of the list.\n        count (int | None): Number of elements to pop. Defaults to None.\n\n    Returns:\n        Any: Popped element(s) or None if list is empty.\n    \"\"\"\n    return self.client.rpop(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.rpush","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.rpush(name, *values)</code>","text":"<p>Push elements to the right of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Length of the list after push.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Push elements to the right of a list.\n\n    Args:\n        name (str): The key name of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: Length of the list after push.\n    \"\"\"\n    return self.client.rpush(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.scan","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.scan(cursor=0, match=None, count=None, _type=None, **kwargs)</code>","text":"<p>Scan keys in the database incrementally.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>int</code> <p>Cursor position. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of keys to return. Defaults to None.</p> <code>None</code> <code>_type</code> <code>str | None</code> <p>Filter by type. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Tuple of cursor and list of keys.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef scan(\n    self,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; RedisResponseType:\n    \"\"\"Scan keys in the database incrementally.\n\n    Args:\n        cursor (int): Cursor position. Defaults to 0.\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of keys to return. Defaults to None.\n        _type (str | None): Filter by type. Defaults to None.\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: Tuple of cursor and list of keys.\n    \"\"\"\n    return self.read_only_client.scan(cursor, match, count, _type, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.scan_iter","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.scan_iter(match=None, count=None, _type=None, **kwargs)</code>","text":"<p>Iterate over keys in the database.</p> <p>Parameters:</p> Name Type Description Default <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of keys to return. Defaults to None.</p> <code>None</code> <code>_type</code> <code>str | None</code> <p>Filter by type. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Iterator</code> <code>Iterator</code> <p>Iterator over matching keys.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef scan_iter(\n    self,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; Iterator:\n    \"\"\"Iterate over keys in the database.\n\n    Args:\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of keys to return. Defaults to None.\n        _type (str | None): Filter by type. Defaults to None.\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        Iterator: Iterator over matching keys.\n    \"\"\"\n    return self.read_only_client.scan_iter(match, count, _type, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.sscan","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.sscan(name, cursor=0, match=None, count=None)</code>","text":"<p>Scan members of a set incrementally.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The set key name.</p> required <code>cursor</code> <code>int</code> <p>Cursor position. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of elements. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Tuple of cursor and list of members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef sscan(\n    self,\n    name: RedisKeyType,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Scan members of a set incrementally.\n\n    Args:\n        name (RedisKeyType): The set key name.\n        cursor (int): Cursor position. Defaults to 0.\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of elements. Defaults to None.\n\n    Returns:\n        RedisResponseType: Tuple of cursor and list of members.\n    \"\"\"\n    return self.read_only_client.sscan(name, cursor, match, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.sscan_iter","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.sscan_iter(name, match=None, count=None)</code>","text":"<p>Iterate over members of a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The set key name.</p> required <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of elements. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Iterator</code> <code>Iterator</code> <p>Iterator over set members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef sscan_iter(\n    self,\n    name: RedisKeyType,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; Iterator:\n    \"\"\"Iterate over members of a set.\n\n    Args:\n        name (RedisKeyType): The set key name.\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of elements. Defaults to None.\n\n    Returns:\n        Iterator: Iterator over set members.\n    \"\"\"\n    return self.read_only_client.sscan_iter(name, match, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.sadd","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.sadd(name, *values)</code>","text":"<p>Add members to a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to add.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of elements added.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Add members to a set.\n\n    Args:\n        name (str): The set key name.\n        *values (bytes | str | float): Members to add.\n\n    Returns:\n        RedisIntegerResponseType: Number of elements added.\n    \"\"\"\n    return self.client.sadd(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.scard","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.scard(name)</code>","text":"<p>Get the number of members in a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef scard(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Get the number of members in a set.\n\n    Args:\n        name (str): The set key name.\n\n    Returns:\n        RedisIntegerResponseType: Number of members.\n    \"\"\"\n    return self.client.scard(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.sismember","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.sismember(name, value)</code>","text":"<p>Check if a value is a member of a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>value</code> <code>str</code> <p>Value to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if value is a member, False otherwise.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Check if a value is a member of a set.\n\n    Args:\n        name (str): The set key name.\n        value (str): Value to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if value is a member, False otherwise.\n    \"\"\"\n    result = self.read_only_client.sismember(name, value)\n    return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.smembers","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.smembers(name)</code>","text":"<p>Get all members of a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>Set of all members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef smembers(self, name: str) -&gt; RedisSetResponseType:\n    \"\"\"Get all members of a set.\n\n    Args:\n        name (str): The set key name.\n\n    Returns:\n        RedisSetResponseType: Set of all members.\n    \"\"\"\n    return self.read_only_client.smembers(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.spop","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.spop(name, count=None)</code>","text":"<p>Remove and return random members from a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>count</code> <code>int | None</code> <p>Number of members to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | float | int | str | list | None</code> <p>bytes | float | int | str | list | None: Popped member(s) or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n    \"\"\"Remove and return random members from a set.\n\n    Args:\n        name (str): The set key name.\n        count (int | None): Number of members to pop. Defaults to None.\n\n    Returns:\n        bytes | float | int | str | list | None: Popped member(s) or None.\n    \"\"\"\n    return self.client.spop(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.srem","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.srem(name, *values)</code>","text":"<p>Remove members from a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of members removed.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Remove members from a set.\n\n    Args:\n        name (str): The set key name.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisIntegerResponseType: Number of members removed.\n    \"\"\"\n    return self.client.srem(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.sunion","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.sunion(keys, *args)</code>","text":"<p>Get the union of multiple sets.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType</code> <p>First set key.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional set keys.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>Set containing union of all sets.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n    \"\"\"Get the union of multiple sets.\n\n    Args:\n        keys (RedisKeyType): First set key.\n        *args (bytes | str): Additional set keys.\n\n    Returns:\n        RedisSetResponseType: Set containing union of all sets.\n    \"\"\"\n    result = self.client.sunion(keys, *args)\n    return set(result) if result else set()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zadd","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zadd(name, mapping, nx=False, xx=False, ch=False, incr=False, gt=False, lt=False)</code>","text":"<p>Add members to a sorted set with scores.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>Member-score pairs.</p> required <code>nx</code> <code>bool</code> <p>Only add new elements. Defaults to False.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>Only update existing elements. Defaults to False.</p> <code>False</code> <code>ch</code> <code>bool</code> <p>Return number of changed elements. Defaults to False.</p> <code>False</code> <code>incr</code> <code>bool</code> <p>Increment existing scores. Defaults to False.</p> <code>False</code> <code>gt</code> <code>bool</code> <p>Only update if score is greater. Defaults to False.</p> <code>False</code> <code>lt</code> <code>bool</code> <p>Only update if score is less. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of elements added or modified.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zadd(\n    self,\n    name: RedisKeyType,\n    mapping: Mapping[RedisKeyType, bytes | str | float],\n    nx: bool = False,\n    xx: bool = False,\n    ch: bool = False,\n    incr: bool = False,\n    gt: bool = False,\n    lt: bool = False,\n) -&gt; RedisResponseType:\n    \"\"\"Add members to a sorted set with scores.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        mapping (Mapping[RedisKeyType, bytes | str | float]): Member-score pairs.\n        nx (bool): Only add new elements. Defaults to False.\n        xx (bool): Only update existing elements. Defaults to False.\n        ch (bool): Return number of changed elements. Defaults to False.\n        incr (bool): Increment existing scores. Defaults to False.\n        gt (bool): Only update if score is greater. Defaults to False.\n        lt (bool): Only update if score is less. Defaults to False.\n\n    Returns:\n        RedisResponseType: Number of elements added or modified.\n    \"\"\"\n    return self.client.zadd(name, mapping, nx, xx, ch, incr, gt, lt)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zcard","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zcard(name)</code>","text":"<p>Get the number of members in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The sorted set key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zcard(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get the number of members in a sorted set.\n\n    Args:\n        name (bytes | str): The sorted set key name.\n\n    Returns:\n        RedisResponseType: Number of members.\n    \"\"\"\n    return self.client.zcard(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zcount","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zcount(name, min, max)</code>","text":"<p>Count members in a sorted set with scores in range.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>min</code> <code>float | str</code> <p>Minimum score.</p> required <code>max</code> <code>float | str</code> <p>Maximum score.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of members in range.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n    \"\"\"Count members in a sorted set with scores in range.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        min (float | str): Minimum score.\n        max (float | str): Maximum score.\n\n    Returns:\n        RedisResponseType: Number of members in range.\n    \"\"\"\n    return self.client.zcount(name, min, max)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zpopmax","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zpopmax(name, count=None)</code>","text":"<p>Remove and return members with highest scores from sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>count</code> <code>int | None</code> <p>Number of members to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of popped member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Remove and return members with highest scores from sorted set.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        count (int | None): Number of members to pop. Defaults to None.\n\n    Returns:\n        RedisResponseType: List of popped member-score pairs.\n    \"\"\"\n    return self.client.zpopmax(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zpopmin","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zpopmin(name, count=None)</code>","text":"<p>Remove and return members with lowest scores from sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>count</code> <code>int | None</code> <p>Number of members to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of popped member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Remove and return members with lowest scores from sorted set.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        count (int | None): Number of members to pop. Defaults to None.\n\n    Returns:\n        RedisResponseType: List of popped member-score pairs.\n    \"\"\"\n    return self.client.zpopmin(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zrange","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zrange(name, start, end, desc=False, withscores=False, score_cast_func=float, byscore=False, bylex=False, offset=None, num=None)</code>","text":"<p>Get a range of members from a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>start</code> <code>int</code> <p>Start index or score.</p> required <code>end</code> <code>int</code> <p>End index or score.</p> required <code>desc</code> <code>bool</code> <p>Sort in descending order. Defaults to False.</p> <code>False</code> <code>withscores</code> <code>bool</code> <p>Include scores in result. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <code>byscore</code> <code>bool</code> <p>Range by score. Defaults to False.</p> <code>False</code> <code>bylex</code> <code>bool</code> <p>Range by lexicographical order. Defaults to False.</p> <code>False</code> <code>offset</code> <code>int | None</code> <p>Offset for byscore/bylex. Defaults to None.</p> <code>None</code> <code>num</code> <code>int | None</code> <p>Count for byscore/bylex. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of members or member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    desc: bool = False,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n    byscore: bool = False,\n    bylex: bool = False,\n    offset: int | None = None,\n    num: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Get a range of members from a sorted set.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        start (int): Start index or score.\n        end (int): End index or score.\n        desc (bool): Sort in descending order. Defaults to False.\n        withscores (bool): Include scores in result. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n        byscore (bool): Range by score. Defaults to False.\n        bylex (bool): Range by lexicographical order. Defaults to False.\n        offset (int | None): Offset for byscore/bylex. Defaults to None.\n        num (int | None): Count for byscore/bylex. Defaults to None.\n\n    Returns:\n        RedisResponseType: List of members or member-score pairs.\n    \"\"\"\n    return self.client.zrange(\n        name,\n        start,\n        end,\n        desc,\n        withscores,\n        score_cast_func,\n        byscore,\n        bylex,\n        offset,\n        num,\n    )\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zrevrange","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zrevrange(name, start, end, withscores=False, score_cast_func=float)</code>","text":"<p>Get a range of members from a sorted set in reverse order.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>start</code> <code>int</code> <p>Start index.</p> required <code>end</code> <code>int</code> <p>End index.</p> required <code>withscores</code> <code>bool</code> <p>Include scores in result. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of members or member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zrevrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Get a range of members from a sorted set in reverse order.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        start (int): Start index.\n        end (int): End index.\n        withscores (bool): Include scores in result. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n    Returns:\n        RedisResponseType: List of members or member-score pairs.\n    \"\"\"\n    return self.client.zrevrange(name, start, end, withscores, score_cast_func)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zrangebyscore","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=float)</code>","text":"<p>Get members from a sorted set by score range.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>min</code> <code>float | str</code> <p>Minimum score.</p> required <code>max</code> <code>float | str</code> <p>Maximum score.</p> required <code>start</code> <code>int | None</code> <p>Offset. Defaults to None.</p> <code>None</code> <code>num</code> <code>int | None</code> <p>Count. Defaults to None.</p> <code>None</code> <code>withscores</code> <code>bool</code> <p>Include scores in result. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of members or member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zrangebyscore(\n    self,\n    name: RedisKeyType,\n    min: float | str,\n    max: float | str,\n    start: int | None = None,\n    num: int | None = None,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Get members from a sorted set by score range.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        min (float | str): Minimum score.\n        max (float | str): Maximum score.\n        start (int | None): Offset. Defaults to None.\n        num (int | None): Count. Defaults to None.\n        withscores (bool): Include scores in result. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n    Returns:\n        RedisResponseType: List of members or member-score pairs.\n    \"\"\"\n    return self.client.zrangebyscore(name, min, max, start, num, withscores, score_cast_func)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zrank","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zrank(name, value)</code>","text":"<p>Get the rank of a member in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>Member to find rank for.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Rank of the member or None if not found.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Get the rank of a member in a sorted set.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        value (bytes | str | float): Member to find rank for.\n\n    Returns:\n        RedisResponseType: Rank of the member or None if not found.\n    \"\"\"\n    return self.client.zrank(name, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zrem","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zrem(name, *values)</code>","text":"<p>Remove members from a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of members removed.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Remove members from a sorted set.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisResponseType: Number of members removed.\n    \"\"\"\n    return self.client.zrem(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zscore","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zscore(name, value)</code>","text":"<p>Get the score of a member in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>Member to get score for.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Score of the member or None if not found.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Get the score of a member in a sorted set.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        value (bytes | str | float): Member to get score for.\n\n    Returns:\n        RedisResponseType: Score of the member or None if not found.\n    \"\"\"\n    return self.client.zscore(name, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hdel","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hdel(name, *keys)</code>","text":"<p>Delete fields from a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>*keys</code> <code>str | bytes</code> <p>Fields to delete.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of fields deleted.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n    \"\"\"Delete fields from a hash.\n\n    Args:\n        name (str): The hash key name.\n        *keys (str | bytes): Fields to delete.\n\n    Returns:\n        RedisIntegerResponseType: Number of fields deleted.\n    \"\"\"\n    return self.client.hdel(name, *keys)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hexists","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hexists(name, key)</code>","text":"<p>Check if a field exists in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>key</code> <code>str</code> <p>Field to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if field exists, False otherwise.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Check if a field exists in a hash.\n\n    Args:\n        name (str): The hash key name.\n        key (str): Field to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if field exists, False otherwise.\n    \"\"\"\n    return self.read_only_client.hexists(name, key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hget","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hget(name, key)</code>","text":"<p>Get the value of a field in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>key</code> <code>str</code> <p>Field to get.</p> required <p>Returns:</p> Type Description <code>Awaitable[str | None] | str | None</code> <p>Awaitable[str | None] | str | None: Value of the field or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n    \"\"\"Get the value of a field in a hash.\n\n    Args:\n        name (str): The hash key name.\n        key (str): Field to get.\n\n    Returns:\n        Awaitable[str | None] | str | None: Value of the field or None.\n    \"\"\"\n    return self.read_only_client.hget(name, key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hgetall","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hgetall(name)</code>","text":"<p>Get all fields and values in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Type Description <code>Awaitable[dict] | dict</code> <p>Awaitable[dict] | dict: Dictionary of field-value pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n    \"\"\"Get all fields and values in a hash.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        Awaitable[dict] | dict: Dictionary of field-value pairs.\n    \"\"\"\n    return self.read_only_client.hgetall(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hkeys","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hkeys(name)</code>","text":"<p>Get all fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of field names.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hkeys(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Get all fields in a hash.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        RedisListResponseType: List of field names.\n    \"\"\"\n    return self.read_only_client.hkeys(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hlen","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hlen(name)</code>","text":"<p>Get the number of fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of fields.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hlen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Get the number of fields in a hash.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        RedisIntegerResponseType: Number of fields.\n    \"\"\"\n    return self.read_only_client.hlen(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hset","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hset(name, key=None, value=None, mapping=None, items=None)</code>","text":"<p>Set fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>key</code> <code>str | bytes | None</code> <p>Single field name. Defaults to None.</p> <code>None</code> <code>value</code> <code>str | bytes | None</code> <p>Single field value. Defaults to None.</p> <code>None</code> <code>mapping</code> <code>dict | None</code> <p>Dictionary of field-value pairs. Defaults to None.</p> <code>None</code> <code>items</code> <code>list | None</code> <p>List of field-value pairs. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of fields set.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hset(\n    self,\n    name: str,\n    key: str | bytes | None = None,\n    value: str | bytes | None = None,\n    mapping: dict | None = None,\n    items: list | None = None,\n) -&gt; RedisIntegerResponseType:\n    \"\"\"Set fields in a hash.\n\n    Args:\n        name (str): The hash key name.\n        key (str | bytes | None): Single field name. Defaults to None.\n        value (str | bytes | None): Single field value. Defaults to None.\n        mapping (dict | None): Dictionary of field-value pairs. Defaults to None.\n        items (list | None): List of field-value pairs. Defaults to None.\n\n    Returns:\n        RedisIntegerResponseType: Number of fields set.\n    \"\"\"\n    return self.client.hset(name, key, value, mapping, items)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hmget","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hmget(name, keys, *args)</code>","text":"<p>Get values of multiple fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>keys</code> <code>list</code> <p>List of field names.</p> required <code>*args</code> <code>str | bytes</code> <p>Additional field names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of field values.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n    \"\"\"Get values of multiple fields in a hash.\n\n    Args:\n        name (str): The hash key name.\n        keys (list): List of field names.\n        *args (str | bytes): Additional field names.\n\n    Returns:\n        RedisListResponseType: List of field values.\n    \"\"\"\n    return self.read_only_client.hmget(name, keys, *args)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hvals","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hvals(name)</code>","text":"<p>Get all values in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of values.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hvals(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Get all values in a hash.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        RedisListResponseType: List of values.\n    \"\"\"\n    return self.read_only_client.hvals(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.publish","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.publish(channel, message, **kwargs)</code>","text":"<p>Publish a message to a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>RedisKeyType</code> <p>Channel name.</p> required <code>message</code> <code>bytes | str</code> <p>Message to publish.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of subscribers that received the message.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Publish a message to a channel.\n\n    Args:\n        channel (RedisKeyType): Channel name.\n        message (bytes | str): Message to publish.\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: Number of subscribers that received the message.\n    \"\"\"\n    return self.client.publish(channel, message, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.pubsub_channels","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.pubsub_channels(pattern='*', **kwargs)</code>","text":"<p>List active channels matching a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>Pattern to match channels. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of channel names.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"List active channels matching a pattern.\n\n    Args:\n        pattern (RedisPatternType): Pattern to match channels. Defaults to \"*\".\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: List of channel names.\n    \"\"\"\n    return self.client.pubsub_channels(pattern, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zincrby","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zincrby(name, amount, value)</code>","text":"<p>Increment the score of a member in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>amount</code> <code>float</code> <p>Amount to increment by.</p> required <code>value</code> <code>bytes | str | float</code> <p>Member to increment.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>New score of the member.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Increment the score of a member in a sorted set.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        amount (float): Amount to increment by.\n        value (bytes | str | float): Member to increment.\n\n    Returns:\n        RedisResponseType: New score of the member.\n    \"\"\"\n    return self.client.zincrby(name, amount, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.pubsub","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.pubsub(**kwargs)</code>","text":"<p>Get a PubSub object for subscribing to channels.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>PubSub</code> <code>PubSub</code> <p>PubSub object.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef pubsub(self, **kwargs: Any) -&gt; PubSub:\n    \"\"\"Get a PubSub object for subscribing to channels.\n\n    Args:\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        PubSub: PubSub object.\n    \"\"\"\n    return self.client.pubsub(**kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.get_pipeline","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.get_pipeline(transaction=True, shard_hint=None)</code>","text":"<p>Get a pipeline object for executing multiple commands.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Any</code> <p>Whether to use transactions. Defaults to True.</p> <code>True</code> <code>shard_hint</code> <code>Any</code> <p>Hint for sharding. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Pipeline</code> <code>Pipeline</code> <p>Pipeline object.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; Pipeline:\n    \"\"\"Get a pipeline object for executing multiple commands.\n\n    Args:\n        transaction (Any): Whether to use transactions. Defaults to True.\n        shard_hint (Any): Hint for sharding. Defaults to None.\n\n    Returns:\n        Pipeline: Pipeline object.\n    \"\"\"\n    return self.client.pipeline(transaction, shard_hint)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.ping","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.ping()</code>","text":"<p>Ping the Redis server.</p> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>'PONG' if successful.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef ping(self) -&gt; RedisResponseType:\n    \"\"\"Ping the Redis server.\n\n    Returns:\n        RedisResponseType: 'PONG' if successful.\n    \"\"\"\n    return self.client.ping()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter</code>","text":"<p>               Bases: <code>AsyncRedisPort</code></p> <p>Async adapter for Redis operations providing a standardized interface.</p> <p>This adapter implements the AsyncRedisPort interface to provide a consistent way to interact with Redis asynchronously, abstracting the underlying Redis client implementation. It supports all common Redis operations including key-value operations, lists, sets, sorted sets, hashes, and pub/sub functionality.</p> <p>The adapter maintains separate connections for read and write operations, which can be used to implement read replicas for better performance.</p> <p>Parameters:</p> Name Type Description Default <code>redis_config</code> <code>RedisConfig</code> <p>Configuration settings for Redis. If None, retrieves from global config. Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>class AsyncRedisAdapter(AsyncRedisPort):\n    \"\"\"Async adapter for Redis operations providing a standardized interface.\n\n    This adapter implements the AsyncRedisPort interface to provide a consistent\n    way to interact with Redis asynchronously, abstracting the underlying Redis\n    client implementation. It supports all common Redis operations including\n    key-value operations, lists, sets, sorted sets, hashes, and pub/sub functionality.\n\n    The adapter maintains separate connections for read and write operations,\n    which can be used to implement read replicas for better performance.\n\n    Args:\n        redis_config (RedisConfig, optional): Configuration settings for Redis.\n            If None, retrieves from global config. Defaults to None.\n    \"\"\"\n\n    def __init__(self, redis_config: RedisConfig | None = None) -&gt; None:\n        \"\"\"Initialize the AsyncRedisAdapter with configuration settings.\n\n        Args:\n            redis_config (RedisConfig, optional): Configuration settings for Redis.\n                If None, retrieves from global config. Defaults to None.\n        \"\"\"\n        configs: RedisConfig = BaseConfig.global_config().REDIS if redis_config is None else redis_config\n        self._set_clients(configs)\n\n    def _set_clients(self, configs: RedisConfig) -&gt; None:\n        \"\"\"Set up async Redis clients for master and slave connections.\n\n        Args:\n            configs (RedisConfig): Configuration settings for Redis.\n        \"\"\"\n        if redis_master_host := configs.MASTER_HOST:\n            self.client: AsyncRedis = self._get_client(redis_master_host, configs)\n        if redis_slave_host := configs.SLAVE_HOST:\n            self.read_only_client: AsyncRedis = self._get_client(redis_slave_host, configs)\n        else:\n            self.read_only_client = self.client\n\n    @staticmethod\n    def _get_client(host: str, configs: RedisConfig) -&gt; AsyncRedis:\n        \"\"\"Create an async Redis client with the specified configuration.\n\n        Args:\n            host (str): Redis host address.\n            configs (RedisConfig): Configuration settings for Redis.\n\n        Returns:\n            AsyncRedis: Configured async Redis client instance.\n        \"\"\"\n        return AsyncRedis(\n            host=host,\n            port=configs.PORT,\n            db=configs.DATABASE,\n            password=configs.PASSWORD,\n            decode_responses=configs.DECODE_RESPONSES,\n            health_check_interval=configs.HEALTH_CHECK_INTERVAL,\n        )\n\n    @override\n    async def pttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get the time to live in milliseconds for a key asynchronously.\n\n        Args:\n            name (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: Time to live in milliseconds.\n        \"\"\"\n        return await self.read_only_client.pttl(name)\n\n    @override\n    async def incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n        \"\"\"Increment the integer value of a key by the given amount asynchronously.\n\n        Args:\n            name (RedisKeyType): The key name.\n            amount (int): Amount to increment by. Defaults to 1.\n\n        Returns:\n            RedisResponseType: The new value after increment.\n        \"\"\"\n        return await self.client.incrby(name, amount)\n\n    @override\n    async def set(\n        self,\n        name: RedisKeyType,\n        value: RedisSetType,\n        ex: RedisExpiryType | None = None,\n        px: RedisExpiryType | None = None,\n        nx: bool = False,\n        xx: bool = False,\n        keepttl: bool = False,\n        get: bool = False,\n        exat: RedisAbsExpiryType | None = None,\n        pxat: RedisAbsExpiryType | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Set the value of a key with optional expiration asynchronously.\n\n        Args:\n            name (RedisKeyType): The key name.\n            value (RedisSetType): The value to set.\n            ex (RedisExpiryType | None): Expire time in seconds.\n            px (RedisExpiryType | None): Expire time in milliseconds.\n            nx (bool): Only set if key doesn't exist.\n            xx (bool): Only set if key exists.\n            keepttl (bool): Retain the TTL from the previous value.\n            get (bool): Return the old value.\n            exat (RedisAbsExpiryType | None): Absolute expiration time in seconds.\n            pxat (RedisAbsExpiryType | None): Absolute expiration time in milliseconds.\n\n        Returns:\n            RedisResponseType: Result of the operation.\n        \"\"\"\n        return await self.client.set(name, value, ex, px, nx, xx, keepttl, get, exat, pxat)\n\n    @override\n    async def get(self, key: str) -&gt; RedisResponseType:\n        \"\"\"Get the value of a key asynchronously.\n\n        Args:\n            key (str): The key name.\n\n        Returns:\n            RedisResponseType: The value of the key or None if not exists.\n        \"\"\"\n        return await self.read_only_client.get(key)\n\n    @override\n    async def mget(\n        self,\n        keys: RedisKeyType | Iterable[RedisKeyType],\n        *args: bytes | str,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get the values of multiple keys asynchronously.\n\n        Args:\n            keys (RedisKeyType | Iterable[RedisKeyType]): Single key or iterable of keys.\n            *args (bytes | str): Additional keys.\n\n        Returns:\n            RedisResponseType: List of values.\n        \"\"\"\n        return await self.read_only_client.mget(keys, *args)\n\n    @override\n    async def mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n        \"\"\"Set multiple keys to their values asynchronously.\n\n        Args:\n            mapping (Mapping[RedisKeyType, bytes | str | float]): Dictionary of key-value pairs.\n\n        Returns:\n            RedisResponseType: Always returns 'OK'.\n        \"\"\"\n        return await self.client.mset(mapping)\n\n    @override\n    async def keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Find all keys matching the pattern asynchronously.\n\n        Args:\n            pattern (RedisPatternType): Pattern to match keys against. Defaults to \"*\".\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: List of matching keys.\n        \"\"\"\n        return await self.read_only_client.keys(pattern, **kwargs)\n\n    @override\n    async def getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Set a key's value and return its old value asynchronously.\n\n        Args:\n            key (RedisKeyType): The key name.\n            value (bytes | str | float): The new value.\n\n        Returns:\n            RedisResponseType: The previous value or None.\n        \"\"\"\n        return await self.client.getset(key, value)\n\n    @override\n    async def getdel(self, key: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get a key's value and delete it asynchronously.\n\n        Args:\n            key (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: The value of the key or None.\n        \"\"\"\n        return await self.client.getdel(key)\n\n    @override\n    async def exists(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Check if keys exist asynchronously.\n\n        Args:\n            *names (bytes | str): Variable number of key names.\n\n        Returns:\n            RedisResponseType: Number of keys that exist.\n        \"\"\"\n        return await self.read_only_client.exists(*names)\n\n    @override\n    async def delete(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Delete keys asynchronously.\n\n        Args:\n            *names (bytes | str): Variable number of key names.\n\n        Returns:\n            RedisResponseType: Number of keys deleted.\n        \"\"\"\n        return await self.client.delete(*names)\n\n    @override\n    async def append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Append a value to a key asynchronously.\n\n        Args:\n            key (RedisKeyType): The key name.\n            value (bytes | str | float): The value to append.\n\n        Returns:\n            RedisResponseType: Length of the string after append.\n        \"\"\"\n        return await self.client.append(key, value)\n\n    @override\n    async def ttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get the time to live in seconds for a key asynchronously.\n\n        Args:\n            name (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: Time to live in seconds.\n        \"\"\"\n        return await self.read_only_client.ttl(name)\n\n    @override\n    async def type(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Determine the type stored at key asynchronously.\n\n        Args:\n            name (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: Type of the key's value.\n        \"\"\"\n        return await self.read_only_client.type(name)\n\n    @override\n    async def llen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Get the length of a list asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n\n        Returns:\n            RedisIntegerResponseType: Length of the list.\n        \"\"\"\n        return await self.read_only_client.llen(name)\n\n    @override\n    async def lpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Remove and return elements from list left asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n            count (int | None): Number of elements to pop. Defaults to None.\n\n        Returns:\n            Any: Popped element(s) or None if list is empty.\n        \"\"\"\n        return await self.client.lpop(name, count)\n\n    @override\n    async def lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Push elements to list left asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: Length of the list after push.\n        \"\"\"\n        return await self.client.lpush(name, *values)\n\n    @override\n    async def lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n        \"\"\"Get a range of elements from a list asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n            start (int): Start index.\n            end (int): End index.\n\n        Returns:\n            RedisListResponseType: List of elements in range.\n        \"\"\"\n        return await self.read_only_client.lrange(name, start, end)\n\n    @override\n    async def lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Remove elements from a list asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n            count (int): Number of occurrences to remove.\n            value (str): Value to remove.\n\n        Returns:\n            RedisIntegerResponseType: Number of elements removed.\n        \"\"\"\n        return await self.client.lrem(name, count, value)\n\n    @override\n    async def lset(self, name: str, index: int, value: str) -&gt; bool:\n        \"\"\"Set list element by index asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n            index (int): Index of the element.\n            value (str): New value.\n\n        Returns:\n            bool: True if successful.\n        \"\"\"\n        result = await self.client.lset(name, index, value)\n        return bool(result)\n\n    @override\n    async def rpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Remove and return elements from list right asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n            count (int | None): Number of elements to pop. Defaults to None.\n\n        Returns:\n            Any: Popped element(s) or None if list is empty.\n        \"\"\"\n        return await self.client.rpop(name, count)\n\n    @override\n    async def rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Push elements to list right asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: Length of the list after push.\n        \"\"\"\n        return await self.client.rpush(name, *values)\n\n    @override\n    async def scan(\n        self,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; RedisResponseType:\n        \"\"\"Scan keys in database incrementally asynchronously.\n\n        Args:\n            cursor (int): Cursor position. Defaults to 0.\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of keys. Defaults to None.\n            _type (str | None): Filter by type. Defaults to None.\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: Tuple of cursor and list of keys.\n        \"\"\"\n        return await self.read_only_client.scan(cursor, match, count, _type, **kwargs)\n\n    @override\n    async def scan_iter(\n        self,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; Iterator[Any]:\n        \"\"\"Iterate over keys in database asynchronously.\n\n        Args:\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of keys. Defaults to None.\n            _type (str | None): Filter by type. Defaults to None.\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            Iterator[Any]: Iterator over matching keys.\n        \"\"\"\n        return self.read_only_client.scan_iter(match, count, _type, **kwargs)\n\n    @override\n    async def sscan(\n        self,\n        name: RedisKeyType,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Scan set members incrementally asynchronously.\n\n        Args:\n            name (RedisKeyType): The set key name.\n            cursor (int): Cursor position. Defaults to 0.\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of elements. Defaults to None.\n\n        Returns:\n            RedisResponseType: Tuple of cursor and list of members.\n        \"\"\"\n        return await self.read_only_client.sscan(name, cursor, match, count)\n\n    @override\n    async def sscan_iter(\n        self,\n        name: RedisKeyType,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; Iterator[Any]:\n        \"\"\"Iterate over set members asynchronously.\n\n        Args:\n            name (RedisKeyType): The set key name.\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of elements. Defaults to None.\n\n        Returns:\n            Iterator[Any]: Iterator over set members.\n        \"\"\"\n        return self.read_only_client.sscan_iter(name, match, count)\n\n    @override\n    async def sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Add members to a set asynchronously.\n\n        Args:\n            name (str): The set key name.\n            *values (bytes | str | float): Members to add.\n\n        Returns:\n            RedisIntegerResponseType: Number of elements added.\n        \"\"\"\n        return await self.client.sadd(name, *values)\n\n    @override\n    async def scard(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Get number of members in a set asynchronously.\n\n        Args:\n            name (str): The set key name.\n\n        Returns:\n            RedisIntegerResponseType: Number of members.\n        \"\"\"\n        return await self.client.scard(name)\n\n    @override\n    async def sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Check if value is in set asynchronously.\n\n        Args:\n            name (str): The set key name.\n            value (str): Value to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if value is member, False otherwise.\n        \"\"\"\n        result = await self.read_only_client.sismember(name, value)\n        return result\n\n    @override\n    async def smembers(self, name: str) -&gt; RedisSetResponseType:\n        \"\"\"Get all members of a set asynchronously.\n\n        Args:\n            name (str): The set key name.\n\n        Returns:\n            RedisSetResponseType: Set of all members.\n        \"\"\"\n        return await self.read_only_client.smembers(name)\n\n    @override\n    async def spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n        \"\"\"Remove and return random set members asynchronously.\n\n        Args:\n            name (str): The set key name.\n            count (int | None): Number of members to pop. Defaults to None.\n\n        Returns:\n            bytes | float | int | str | list | None: Popped member(s) or None.\n        \"\"\"\n        return await self.client.spop(name, count)\n\n    @override\n    async def srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Remove members from a set asynchronously.\n\n        Args:\n            name (str): The set key name.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisIntegerResponseType: Number of members removed.\n        \"\"\"\n        return await self.client.srem(name, *values)\n\n    @override\n    async def sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n        \"\"\"Get union of multiple sets asynchronously.\n\n        Args:\n            keys (RedisKeyType): First set key.\n            *args (bytes | str): Additional set keys.\n\n        Returns:\n            RedisSetResponseType: Set containing union of all sets.\n        \"\"\"\n        result = await self.client.sunion(keys, *args)\n        return set(result) if result else set()\n\n    @override\n    async def zadd(\n        self,\n        name: RedisKeyType,\n        mapping: Mapping[RedisKeyType, bytes | str | float],\n        nx: bool = False,\n        xx: bool = False,\n        ch: bool = False,\n        incr: bool = False,\n        gt: bool = False,\n        lt: bool = False,\n    ) -&gt; RedisResponseType:\n        \"\"\"Add members to sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            mapping (Mapping[RedisKeyType, bytes | str | float]): Member-score pairs.\n            nx (bool): Only add new elements. Defaults to False.\n            xx (bool): Only update existing. Defaults to False.\n            ch (bool): Return changed count. Defaults to False.\n            incr (bool): Increment scores. Defaults to False.\n            gt (bool): Only if greater. Defaults to False.\n            lt (bool): Only if less. Defaults to False.\n\n        Returns:\n            RedisResponseType: Number of elements added or modified.\n        \"\"\"\n        return await self.client.zadd(name, mapping, nx, xx, ch, incr, gt, lt)\n\n    @override\n    async def zcard(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get number of members in sorted set asynchronously.\n\n        Args:\n            name (bytes | str): The sorted set key name.\n\n        Returns:\n            RedisResponseType: Number of members.\n        \"\"\"\n        return await self.client.zcard(name)\n\n    @override\n    async def zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n        \"\"\"Count members in score range asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            min (float | str): Minimum score.\n            max (float | str): Maximum score.\n\n        Returns:\n            RedisResponseType: Number of members in range.\n        \"\"\"\n        return await self.client.zcount(name, min, max)\n\n    @override\n    async def zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Pop highest scored members asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            count (int | None): Number to pop. Defaults to None.\n\n        Returns:\n            RedisResponseType: List of popped member-score pairs.\n        \"\"\"\n        return await self.client.zpopmax(name, count)\n\n    @override\n    async def zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Pop lowest scored members asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            count (int | None): Number to pop. Defaults to None.\n\n        Returns:\n            RedisResponseType: List of popped member-score pairs.\n        \"\"\"\n        return await self.client.zpopmin(name, count)\n\n    @override\n    async def zrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        desc: bool = False,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n        byscore: bool = False,\n        bylex: bool = False,\n        offset: int | None = None,\n        num: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get range from sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            start (int): Start index or score.\n            end (int): End index or score.\n            desc (bool): Descending order. Defaults to False.\n            withscores (bool): Include scores. Defaults to False.\n            score_cast_func (RedisScoreCastType): Score cast function. Defaults to float.\n            byscore (bool): Range by score. Defaults to False.\n            bylex (bool): Range by lex. Defaults to False.\n            offset (int | None): Offset for byscore/bylex. Defaults to None.\n            num (int | None): Count for byscore/bylex. Defaults to None.\n\n        Returns:\n            RedisResponseType: List of members or member-score pairs.\n        \"\"\"\n        return await self.client.zrange(\n            name,\n            start,\n            end,\n            desc,\n            withscores,\n            score_cast_func,\n            byscore,\n            bylex,\n            offset,\n            num,\n        )\n\n    @override\n    async def zrevrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get reverse range from sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            start (int): Start index.\n            end (int): End index.\n            withscores (bool): Include scores. Defaults to False.\n            score_cast_func (RedisScoreCastType): Score cast function. Defaults to float.\n\n        Returns:\n            RedisResponseType: List of members or member-score pairs.\n        \"\"\"\n        return await self.client.zrevrange(name, start, end, withscores, score_cast_func)\n\n    @override\n    async def zrangebyscore(\n        self,\n        name: RedisKeyType,\n        min: float | str,\n        max: float | str,\n        start: int | None = None,\n        num: int | None = None,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get members by score range asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            min (float | str): Minimum score.\n            max (float | str): Maximum score.\n            start (int | None): Offset. Defaults to None.\n            num (int | None): Count. Defaults to None.\n            withscores (bool): Include scores. Defaults to False.\n            score_cast_func (RedisScoreCastType): Score cast function. Defaults to float.\n\n        Returns:\n            RedisResponseType: List of members or member-score pairs.\n        \"\"\"\n        return await self.client.zrangebyscore(name, min, max, start, num, withscores, score_cast_func)\n\n    @override\n    async def zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Get rank of member in sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            value (bytes | str | float): Member to find rank for.\n\n        Returns:\n            RedisResponseType: Rank or None if not found.\n        \"\"\"\n        return await self.client.zrank(name, value)\n\n    @override\n    async def zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Remove members from sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisResponseType: Number of members removed.\n        \"\"\"\n        return await self.client.zrem(name, *values)\n\n    @override\n    async def zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Get score of member in sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            value (bytes | str | float): Member to get score for.\n\n        Returns:\n            RedisResponseType: Score or None if not found.\n        \"\"\"\n        return await self.client.zscore(name, value)\n\n    @override\n    async def hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n        \"\"\"Delete fields from hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n            *keys (str | bytes): Fields to delete.\n\n        Returns:\n            RedisIntegerResponseType: Number of fields deleted.\n        \"\"\"\n        return await self.client.hdel(name, *keys)\n\n    @override\n    async def hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Check if field exists in hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n            key (str): Field to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if exists, False otherwise.\n        \"\"\"\n        return await self.read_only_client.hexists(name, key)\n\n    @override\n    async def hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n        \"\"\"Get field value from hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n            key (str): Field to get.\n\n        Returns:\n            Awaitable[str | None] | str | None: Value or None.\n        \"\"\"\n        return await self.read_only_client.hget(name, key)\n\n    @override\n    async def hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n        \"\"\"Get all fields and values from hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            Awaitable[dict] | dict: Dictionary of field-value pairs.\n        \"\"\"\n        return await self.read_only_client.hgetall(name)\n\n    @override\n    async def hkeys(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Get all fields from hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            RedisListResponseType: List of field names.\n        \"\"\"\n        return await self.read_only_client.hkeys(name)\n\n    @override\n    async def hlen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Get number of fields in hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            RedisIntegerResponseType: Number of fields.\n        \"\"\"\n        return await self.read_only_client.hlen(name)\n\n    @override\n    async def hset(\n        self,\n        name: str,\n        key: str | bytes | None = None,\n        value: str | bytes | None = None,\n        mapping: dict | None = None,\n        items: list | None = None,\n    ) -&gt; RedisIntegerResponseType:\n        \"\"\"Set fields in hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n            key (str | bytes | None): Single field name. Defaults to None.\n            value (str | bytes | None): Single field value. Defaults to None.\n            mapping (dict | None): Field-value pairs dict. Defaults to None.\n            items (list | None): Field-value pairs list. Defaults to None.\n\n        Returns:\n            RedisIntegerResponseType: Number of fields set.\n        \"\"\"\n        return await self.client.hset(name, key, value, mapping, items)\n\n    @override\n    async def hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n        \"\"\"Get multiple field values from hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n            keys (list): List of field names.\n            *args (str | bytes): Additional field names.\n\n        Returns:\n            RedisListResponseType: List of field values.\n        \"\"\"\n        return await self.read_only_client.hmget(name, keys, *args)\n\n    @override\n    async def hvals(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Get all values from hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            RedisListResponseType: List of values.\n        \"\"\"\n        return await self.read_only_client.hvals(name)\n\n    @override\n    async def publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Publish message to channel asynchronously.\n\n        Args:\n            channel (RedisKeyType): Channel name.\n            message (bytes | str): Message to publish.\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: Number of subscribers received message.\n        \"\"\"\n        return await self.client.publish(channel, message, **kwargs)\n\n    @override\n    async def pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"List active channels matching pattern asynchronously.\n\n        Args:\n            pattern (RedisPatternType): Pattern to match. Defaults to \"*\".\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: List of channel names.\n        \"\"\"\n        return await self.client.pubsub_channels(pattern, **kwargs)\n\n    @override\n    async def zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Increment member score in sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            amount (float): Amount to increment by.\n            value (bytes | str | float): Member to increment.\n\n        Returns:\n            RedisResponseType: New score of the member.\n        \"\"\"\n        return await self.client.zincrby(name, amount, value)\n\n    @override\n    async def pubsub(self, **kwargs: Any) -&gt; AsyncPubSub:\n        \"\"\"Get PubSub object for channel subscription asynchronously.\n\n        Args:\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            AsyncPubSub: PubSub object.\n        \"\"\"\n        return self.client.pubsub(**kwargs)\n\n    @override\n    async def get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; AsyncPipeline:\n        \"\"\"Get pipeline for multiple commands asynchronously.\n\n        Args:\n            transaction (Any): Use transactions. Defaults to True.\n            shard_hint (Any): Sharding hint. Defaults to None.\n\n        Returns:\n            AsyncPipeline: Pipeline object.\n        \"\"\"\n        return self.client.pipeline(transaction, shard_hint)\n\n    @override\n    async def ping(self) -&gt; RedisResponseType:\n        \"\"\"Ping the Redis server asynchronously.\n\n        Returns:\n            RedisResponseType: 'PONG' if successful.\n        \"\"\"\n        return await self.client.ping()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.__init__","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.__init__(redis_config=None)</code>","text":"<p>Initialize the AsyncRedisAdapter with configuration settings.</p> <p>Parameters:</p> Name Type Description Default <code>redis_config</code> <code>RedisConfig</code> <p>Configuration settings for Redis. If None, retrieves from global config. Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>def __init__(self, redis_config: RedisConfig | None = None) -&gt; None:\n    \"\"\"Initialize the AsyncRedisAdapter with configuration settings.\n\n    Args:\n        redis_config (RedisConfig, optional): Configuration settings for Redis.\n            If None, retrieves from global config. Defaults to None.\n    \"\"\"\n    configs: RedisConfig = BaseConfig.global_config().REDIS if redis_config is None else redis_config\n    self._set_clients(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.pttl","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.pttl(name)</code>  <code>async</code>","text":"<p>Get the time to live in milliseconds for a key asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Time to live in milliseconds.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def pttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get the time to live in milliseconds for a key asynchronously.\n\n    Args:\n        name (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: Time to live in milliseconds.\n    \"\"\"\n    return await self.read_only_client.pttl(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.incrby","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.incrby(name, amount=1)</code>  <code>async</code>","text":"<p>Increment the integer value of a key by the given amount asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>amount</code> <code>int</code> <p>Amount to increment by. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The new value after increment.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n    \"\"\"Increment the integer value of a key by the given amount asynchronously.\n\n    Args:\n        name (RedisKeyType): The key name.\n        amount (int): Amount to increment by. Defaults to 1.\n\n    Returns:\n        RedisResponseType: The new value after increment.\n    \"\"\"\n    return await self.client.incrby(name, amount)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.set","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.set(name, value, ex=None, px=None, nx=False, xx=False, keepttl=False, get=False, exat=None, pxat=None)</code>  <code>async</code>","text":"<p>Set the value of a key with optional expiration asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>value</code> <code>RedisSetType</code> <p>The value to set.</p> required <code>ex</code> <code>RedisExpiryType | None</code> <p>Expire time in seconds.</p> <code>None</code> <code>px</code> <code>RedisExpiryType | None</code> <p>Expire time in milliseconds.</p> <code>None</code> <code>nx</code> <code>bool</code> <p>Only set if key doesn't exist.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>Only set if key exists.</p> <code>False</code> <code>keepttl</code> <code>bool</code> <p>Retain the TTL from the previous value.</p> <code>False</code> <code>get</code> <code>bool</code> <p>Return the old value.</p> <code>False</code> <code>exat</code> <code>RedisAbsExpiryType | None</code> <p>Absolute expiration time in seconds.</p> <code>None</code> <code>pxat</code> <code>RedisAbsExpiryType | None</code> <p>Absolute expiration time in milliseconds.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Result of the operation.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def set(\n    self,\n    name: RedisKeyType,\n    value: RedisSetType,\n    ex: RedisExpiryType | None = None,\n    px: RedisExpiryType | None = None,\n    nx: bool = False,\n    xx: bool = False,\n    keepttl: bool = False,\n    get: bool = False,\n    exat: RedisAbsExpiryType | None = None,\n    pxat: RedisAbsExpiryType | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Set the value of a key with optional expiration asynchronously.\n\n    Args:\n        name (RedisKeyType): The key name.\n        value (RedisSetType): The value to set.\n        ex (RedisExpiryType | None): Expire time in seconds.\n        px (RedisExpiryType | None): Expire time in milliseconds.\n        nx (bool): Only set if key doesn't exist.\n        xx (bool): Only set if key exists.\n        keepttl (bool): Retain the TTL from the previous value.\n        get (bool): Return the old value.\n        exat (RedisAbsExpiryType | None): Absolute expiration time in seconds.\n        pxat (RedisAbsExpiryType | None): Absolute expiration time in milliseconds.\n\n    Returns:\n        RedisResponseType: Result of the operation.\n    \"\"\"\n    return await self.client.set(name, value, ex, px, nx, xx, keepttl, get, exat, pxat)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.get","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.get(key)</code>  <code>async</code>","text":"<p>Get the value of a key asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value of the key or None if not exists.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def get(self, key: str) -&gt; RedisResponseType:\n    \"\"\"Get the value of a key asynchronously.\n\n    Args:\n        key (str): The key name.\n\n    Returns:\n        RedisResponseType: The value of the key or None if not exists.\n    \"\"\"\n    return await self.read_only_client.get(key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.mget","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.mget(keys, *args)</code>  <code>async</code>","text":"<p>Get the values of multiple keys asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType | Iterable[RedisKeyType]</code> <p>Single key or iterable of keys.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional keys.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of values.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def mget(\n    self,\n    keys: RedisKeyType | Iterable[RedisKeyType],\n    *args: bytes | str,\n) -&gt; RedisResponseType:\n    \"\"\"Get the values of multiple keys asynchronously.\n\n    Args:\n        keys (RedisKeyType | Iterable[RedisKeyType]): Single key or iterable of keys.\n        *args (bytes | str): Additional keys.\n\n    Returns:\n        RedisResponseType: List of values.\n    \"\"\"\n    return await self.read_only_client.mget(keys, *args)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.mset","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.mset(mapping)</code>  <code>async</code>","text":"<p>Set multiple keys to their values asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>Dictionary of key-value pairs.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Always returns 'OK'.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n    \"\"\"Set multiple keys to their values asynchronously.\n\n    Args:\n        mapping (Mapping[RedisKeyType, bytes | str | float]): Dictionary of key-value pairs.\n\n    Returns:\n        RedisResponseType: Always returns 'OK'.\n    \"\"\"\n    return await self.client.mset(mapping)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.keys","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.keys(pattern='*', **kwargs)</code>  <code>async</code>","text":"<p>Find all keys matching the pattern asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>Pattern to match keys against. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of matching keys.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Find all keys matching the pattern asynchronously.\n\n    Args:\n        pattern (RedisPatternType): Pattern to match keys against. Defaults to \"*\".\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: List of matching keys.\n    \"\"\"\n    return await self.read_only_client.keys(pattern, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.getset","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.getset(key, value)</code>  <code>async</code>","text":"<p>Set a key's value and return its old value asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>The new value.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The previous value or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Set a key's value and return its old value asynchronously.\n\n    Args:\n        key (RedisKeyType): The key name.\n        value (bytes | str | float): The new value.\n\n    Returns:\n        RedisResponseType: The previous value or None.\n    \"\"\"\n    return await self.client.getset(key, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.getdel","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.getdel(key)</code>  <code>async</code>","text":"<p>Get a key's value and delete it asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value of the key or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def getdel(self, key: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get a key's value and delete it asynchronously.\n\n    Args:\n        key (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: The value of the key or None.\n    \"\"\"\n    return await self.client.getdel(key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.exists","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.exists(*names)</code>  <code>async</code>","text":"<p>Check if keys exist asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of key names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of keys that exist.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def exists(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Check if keys exist asynchronously.\n\n    Args:\n        *names (bytes | str): Variable number of key names.\n\n    Returns:\n        RedisResponseType: Number of keys that exist.\n    \"\"\"\n    return await self.read_only_client.exists(*names)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.delete","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.delete(*names)</code>  <code>async</code>","text":"<p>Delete keys asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of key names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of keys deleted.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def delete(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Delete keys asynchronously.\n\n    Args:\n        *names (bytes | str): Variable number of key names.\n\n    Returns:\n        RedisResponseType: Number of keys deleted.\n    \"\"\"\n    return await self.client.delete(*names)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.append","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.append(key, value)</code>  <code>async</code>","text":"<p>Append a value to a key asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>The value to append.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Length of the string after append.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Append a value to a key asynchronously.\n\n    Args:\n        key (RedisKeyType): The key name.\n        value (bytes | str | float): The value to append.\n\n    Returns:\n        RedisResponseType: Length of the string after append.\n    \"\"\"\n    return await self.client.append(key, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.ttl","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.ttl(name)</code>  <code>async</code>","text":"<p>Get the time to live in seconds for a key asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Time to live in seconds.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def ttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get the time to live in seconds for a key asynchronously.\n\n    Args:\n        name (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: Time to live in seconds.\n    \"\"\"\n    return await self.read_only_client.ttl(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.type","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.type(name)</code>  <code>async</code>","text":"<p>Determine the type stored at key asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Type of the key's value.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def type(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Determine the type stored at key asynchronously.\n\n    Args:\n        name (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: Type of the key's value.\n    \"\"\"\n    return await self.read_only_client.type(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.llen","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.llen(name)</code>  <code>async</code>","text":"<p>Get the length of a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Length of the list.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def llen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Get the length of a list asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n\n    Returns:\n        RedisIntegerResponseType: Length of the list.\n    \"\"\"\n    return await self.read_only_client.llen(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.lpop","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.lpop(name, count=None)</code>  <code>async</code>","text":"<p>Remove and return elements from list left asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>count</code> <code>int | None</code> <p>Number of elements to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Popped element(s) or None if list is empty.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def lpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Remove and return elements from list left asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n        count (int | None): Number of elements to pop. Defaults to None.\n\n    Returns:\n        Any: Popped element(s) or None if list is empty.\n    \"\"\"\n    return await self.client.lpop(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.lpush","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.lpush(name, *values)</code>  <code>async</code>","text":"<p>Push elements to list left asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Length of the list after push.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Push elements to list left asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: Length of the list after push.\n    \"\"\"\n    return await self.client.lpush(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.lrange","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.lrange(name, start, end)</code>  <code>async</code>","text":"<p>Get a range of elements from a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>start</code> <code>int</code> <p>Start index.</p> required <code>end</code> <code>int</code> <p>End index.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of elements in range.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n    \"\"\"Get a range of elements from a list asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n        start (int): Start index.\n        end (int): End index.\n\n    Returns:\n        RedisListResponseType: List of elements in range.\n    \"\"\"\n    return await self.read_only_client.lrange(name, start, end)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.lrem","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.lrem(name, count, value)</code>  <code>async</code>","text":"<p>Remove elements from a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>count</code> <code>int</code> <p>Number of occurrences to remove.</p> required <code>value</code> <code>str</code> <p>Value to remove.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of elements removed.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Remove elements from a list asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n        count (int): Number of occurrences to remove.\n        value (str): Value to remove.\n\n    Returns:\n        RedisIntegerResponseType: Number of elements removed.\n    \"\"\"\n    return await self.client.lrem(name, count, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.lset","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.lset(name, index, value)</code>  <code>async</code>","text":"<p>Set list element by index asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>index</code> <code>int</code> <p>Index of the element.</p> required <code>value</code> <code>str</code> <p>New value.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def lset(self, name: str, index: int, value: str) -&gt; bool:\n    \"\"\"Set list element by index asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n        index (int): Index of the element.\n        value (str): New value.\n\n    Returns:\n        bool: True if successful.\n    \"\"\"\n    result = await self.client.lset(name, index, value)\n    return bool(result)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.rpop","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.rpop(name, count=None)</code>  <code>async</code>","text":"<p>Remove and return elements from list right asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>count</code> <code>int | None</code> <p>Number of elements to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Popped element(s) or None if list is empty.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def rpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Remove and return elements from list right asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n        count (int | None): Number of elements to pop. Defaults to None.\n\n    Returns:\n        Any: Popped element(s) or None if list is empty.\n    \"\"\"\n    return await self.client.rpop(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.rpush","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.rpush(name, *values)</code>  <code>async</code>","text":"<p>Push elements to list right asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Length of the list after push.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Push elements to list right asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: Length of the list after push.\n    \"\"\"\n    return await self.client.rpush(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.scan","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.scan(cursor=0, match=None, count=None, _type=None, **kwargs)</code>  <code>async</code>","text":"<p>Scan keys in database incrementally asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>int</code> <p>Cursor position. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of keys. Defaults to None.</p> <code>None</code> <code>_type</code> <code>str | None</code> <p>Filter by type. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Tuple of cursor and list of keys.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def scan(\n    self,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; RedisResponseType:\n    \"\"\"Scan keys in database incrementally asynchronously.\n\n    Args:\n        cursor (int): Cursor position. Defaults to 0.\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of keys. Defaults to None.\n        _type (str | None): Filter by type. Defaults to None.\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: Tuple of cursor and list of keys.\n    \"\"\"\n    return await self.read_only_client.scan(cursor, match, count, _type, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.scan_iter","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.scan_iter(match=None, count=None, _type=None, **kwargs)</code>  <code>async</code>","text":"<p>Iterate over keys in database asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of keys. Defaults to None.</p> <code>None</code> <code>_type</code> <code>str | None</code> <p>Filter by type. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Iterator[Any]</code> <p>Iterator[Any]: Iterator over matching keys.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def scan_iter(\n    self,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; Iterator[Any]:\n    \"\"\"Iterate over keys in database asynchronously.\n\n    Args:\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of keys. Defaults to None.\n        _type (str | None): Filter by type. Defaults to None.\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        Iterator[Any]: Iterator over matching keys.\n    \"\"\"\n    return self.read_only_client.scan_iter(match, count, _type, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.sscan","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.sscan(name, cursor=0, match=None, count=None)</code>  <code>async</code>","text":"<p>Scan set members incrementally asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The set key name.</p> required <code>cursor</code> <code>int</code> <p>Cursor position. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of elements. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Tuple of cursor and list of members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def sscan(\n    self,\n    name: RedisKeyType,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Scan set members incrementally asynchronously.\n\n    Args:\n        name (RedisKeyType): The set key name.\n        cursor (int): Cursor position. Defaults to 0.\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of elements. Defaults to None.\n\n    Returns:\n        RedisResponseType: Tuple of cursor and list of members.\n    \"\"\"\n    return await self.read_only_client.sscan(name, cursor, match, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.sscan_iter","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.sscan_iter(name, match=None, count=None)</code>  <code>async</code>","text":"<p>Iterate over set members asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The set key name.</p> required <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of elements. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[Any]</code> <p>Iterator[Any]: Iterator over set members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def sscan_iter(\n    self,\n    name: RedisKeyType,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; Iterator[Any]:\n    \"\"\"Iterate over set members asynchronously.\n\n    Args:\n        name (RedisKeyType): The set key name.\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of elements. Defaults to None.\n\n    Returns:\n        Iterator[Any]: Iterator over set members.\n    \"\"\"\n    return self.read_only_client.sscan_iter(name, match, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.sadd","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.sadd(name, *values)</code>  <code>async</code>","text":"<p>Add members to a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to add.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of elements added.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Add members to a set asynchronously.\n\n    Args:\n        name (str): The set key name.\n        *values (bytes | str | float): Members to add.\n\n    Returns:\n        RedisIntegerResponseType: Number of elements added.\n    \"\"\"\n    return await self.client.sadd(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.scard","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.scard(name)</code>  <code>async</code>","text":"<p>Get number of members in a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def scard(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Get number of members in a set asynchronously.\n\n    Args:\n        name (str): The set key name.\n\n    Returns:\n        RedisIntegerResponseType: Number of members.\n    \"\"\"\n    return await self.client.scard(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.sismember","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.sismember(name, value)</code>  <code>async</code>","text":"<p>Check if value is in set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>value</code> <code>str</code> <p>Value to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if value is member, False otherwise.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Check if value is in set asynchronously.\n\n    Args:\n        name (str): The set key name.\n        value (str): Value to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if value is member, False otherwise.\n    \"\"\"\n    result = await self.read_only_client.sismember(name, value)\n    return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.smembers","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.smembers(name)</code>  <code>async</code>","text":"<p>Get all members of a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>Set of all members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def smembers(self, name: str) -&gt; RedisSetResponseType:\n    \"\"\"Get all members of a set asynchronously.\n\n    Args:\n        name (str): The set key name.\n\n    Returns:\n        RedisSetResponseType: Set of all members.\n    \"\"\"\n    return await self.read_only_client.smembers(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.spop","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.spop(name, count=None)</code>  <code>async</code>","text":"<p>Remove and return random set members asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>count</code> <code>int | None</code> <p>Number of members to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | float | int | str | list | None</code> <p>bytes | float | int | str | list | None: Popped member(s) or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n    \"\"\"Remove and return random set members asynchronously.\n\n    Args:\n        name (str): The set key name.\n        count (int | None): Number of members to pop. Defaults to None.\n\n    Returns:\n        bytes | float | int | str | list | None: Popped member(s) or None.\n    \"\"\"\n    return await self.client.spop(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.srem","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.srem(name, *values)</code>  <code>async</code>","text":"<p>Remove members from a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of members removed.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Remove members from a set asynchronously.\n\n    Args:\n        name (str): The set key name.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisIntegerResponseType: Number of members removed.\n    \"\"\"\n    return await self.client.srem(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.sunion","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.sunion(keys, *args)</code>  <code>async</code>","text":"<p>Get union of multiple sets asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType</code> <p>First set key.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional set keys.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>Set containing union of all sets.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n    \"\"\"Get union of multiple sets asynchronously.\n\n    Args:\n        keys (RedisKeyType): First set key.\n        *args (bytes | str): Additional set keys.\n\n    Returns:\n        RedisSetResponseType: Set containing union of all sets.\n    \"\"\"\n    result = await self.client.sunion(keys, *args)\n    return set(result) if result else set()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zadd","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zadd(name, mapping, nx=False, xx=False, ch=False, incr=False, gt=False, lt=False)</code>  <code>async</code>","text":"<p>Add members to sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>Member-score pairs.</p> required <code>nx</code> <code>bool</code> <p>Only add new elements. Defaults to False.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>Only update existing. Defaults to False.</p> <code>False</code> <code>ch</code> <code>bool</code> <p>Return changed count. Defaults to False.</p> <code>False</code> <code>incr</code> <code>bool</code> <p>Increment scores. Defaults to False.</p> <code>False</code> <code>gt</code> <code>bool</code> <p>Only if greater. Defaults to False.</p> <code>False</code> <code>lt</code> <code>bool</code> <p>Only if less. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of elements added or modified.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zadd(\n    self,\n    name: RedisKeyType,\n    mapping: Mapping[RedisKeyType, bytes | str | float],\n    nx: bool = False,\n    xx: bool = False,\n    ch: bool = False,\n    incr: bool = False,\n    gt: bool = False,\n    lt: bool = False,\n) -&gt; RedisResponseType:\n    \"\"\"Add members to sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        mapping (Mapping[RedisKeyType, bytes | str | float]): Member-score pairs.\n        nx (bool): Only add new elements. Defaults to False.\n        xx (bool): Only update existing. Defaults to False.\n        ch (bool): Return changed count. Defaults to False.\n        incr (bool): Increment scores. Defaults to False.\n        gt (bool): Only if greater. Defaults to False.\n        lt (bool): Only if less. Defaults to False.\n\n    Returns:\n        RedisResponseType: Number of elements added or modified.\n    \"\"\"\n    return await self.client.zadd(name, mapping, nx, xx, ch, incr, gt, lt)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zcard","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zcard(name)</code>  <code>async</code>","text":"<p>Get number of members in sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The sorted set key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zcard(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get number of members in sorted set asynchronously.\n\n    Args:\n        name (bytes | str): The sorted set key name.\n\n    Returns:\n        RedisResponseType: Number of members.\n    \"\"\"\n    return await self.client.zcard(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zcount","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zcount(name, min, max)</code>  <code>async</code>","text":"<p>Count members in score range asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>min</code> <code>float | str</code> <p>Minimum score.</p> required <code>max</code> <code>float | str</code> <p>Maximum score.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of members in range.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n    \"\"\"Count members in score range asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        min (float | str): Minimum score.\n        max (float | str): Maximum score.\n\n    Returns:\n        RedisResponseType: Number of members in range.\n    \"\"\"\n    return await self.client.zcount(name, min, max)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zpopmax","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zpopmax(name, count=None)</code>  <code>async</code>","text":"<p>Pop highest scored members asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>count</code> <code>int | None</code> <p>Number to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of popped member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Pop highest scored members asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        count (int | None): Number to pop. Defaults to None.\n\n    Returns:\n        RedisResponseType: List of popped member-score pairs.\n    \"\"\"\n    return await self.client.zpopmax(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zpopmin","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zpopmin(name, count=None)</code>  <code>async</code>","text":"<p>Pop lowest scored members asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>count</code> <code>int | None</code> <p>Number to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of popped member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Pop lowest scored members asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        count (int | None): Number to pop. Defaults to None.\n\n    Returns:\n        RedisResponseType: List of popped member-score pairs.\n    \"\"\"\n    return await self.client.zpopmin(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zrange","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zrange(name, start, end, desc=False, withscores=False, score_cast_func=float, byscore=False, bylex=False, offset=None, num=None)</code>  <code>async</code>","text":"<p>Get range from sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>start</code> <code>int</code> <p>Start index or score.</p> required <code>end</code> <code>int</code> <p>End index or score.</p> required <code>desc</code> <code>bool</code> <p>Descending order. Defaults to False.</p> <code>False</code> <code>withscores</code> <code>bool</code> <p>Include scores. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Score cast function. Defaults to float.</p> <code>float</code> <code>byscore</code> <code>bool</code> <p>Range by score. Defaults to False.</p> <code>False</code> <code>bylex</code> <code>bool</code> <p>Range by lex. Defaults to False.</p> <code>False</code> <code>offset</code> <code>int | None</code> <p>Offset for byscore/bylex. Defaults to None.</p> <code>None</code> <code>num</code> <code>int | None</code> <p>Count for byscore/bylex. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of members or member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    desc: bool = False,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n    byscore: bool = False,\n    bylex: bool = False,\n    offset: int | None = None,\n    num: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Get range from sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        start (int): Start index or score.\n        end (int): End index or score.\n        desc (bool): Descending order. Defaults to False.\n        withscores (bool): Include scores. Defaults to False.\n        score_cast_func (RedisScoreCastType): Score cast function. Defaults to float.\n        byscore (bool): Range by score. Defaults to False.\n        bylex (bool): Range by lex. Defaults to False.\n        offset (int | None): Offset for byscore/bylex. Defaults to None.\n        num (int | None): Count for byscore/bylex. Defaults to None.\n\n    Returns:\n        RedisResponseType: List of members or member-score pairs.\n    \"\"\"\n    return await self.client.zrange(\n        name,\n        start,\n        end,\n        desc,\n        withscores,\n        score_cast_func,\n        byscore,\n        bylex,\n        offset,\n        num,\n    )\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zrevrange","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zrevrange(name, start, end, withscores=False, score_cast_func=float)</code>  <code>async</code>","text":"<p>Get reverse range from sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>start</code> <code>int</code> <p>Start index.</p> required <code>end</code> <code>int</code> <p>End index.</p> required <code>withscores</code> <code>bool</code> <p>Include scores. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Score cast function. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of members or member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zrevrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Get reverse range from sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        start (int): Start index.\n        end (int): End index.\n        withscores (bool): Include scores. Defaults to False.\n        score_cast_func (RedisScoreCastType): Score cast function. Defaults to float.\n\n    Returns:\n        RedisResponseType: List of members or member-score pairs.\n    \"\"\"\n    return await self.client.zrevrange(name, start, end, withscores, score_cast_func)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zrangebyscore","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=float)</code>  <code>async</code>","text":"<p>Get members by score range asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>min</code> <code>float | str</code> <p>Minimum score.</p> required <code>max</code> <code>float | str</code> <p>Maximum score.</p> required <code>start</code> <code>int | None</code> <p>Offset. Defaults to None.</p> <code>None</code> <code>num</code> <code>int | None</code> <p>Count. Defaults to None.</p> <code>None</code> <code>withscores</code> <code>bool</code> <p>Include scores. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Score cast function. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of members or member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zrangebyscore(\n    self,\n    name: RedisKeyType,\n    min: float | str,\n    max: float | str,\n    start: int | None = None,\n    num: int | None = None,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Get members by score range asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        min (float | str): Minimum score.\n        max (float | str): Maximum score.\n        start (int | None): Offset. Defaults to None.\n        num (int | None): Count. Defaults to None.\n        withscores (bool): Include scores. Defaults to False.\n        score_cast_func (RedisScoreCastType): Score cast function. Defaults to float.\n\n    Returns:\n        RedisResponseType: List of members or member-score pairs.\n    \"\"\"\n    return await self.client.zrangebyscore(name, min, max, start, num, withscores, score_cast_func)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zrank","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zrank(name, value)</code>  <code>async</code>","text":"<p>Get rank of member in sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>Member to find rank for.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Rank or None if not found.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Get rank of member in sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        value (bytes | str | float): Member to find rank for.\n\n    Returns:\n        RedisResponseType: Rank or None if not found.\n    \"\"\"\n    return await self.client.zrank(name, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zrem","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zrem(name, *values)</code>  <code>async</code>","text":"<p>Remove members from sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of members removed.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Remove members from sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisResponseType: Number of members removed.\n    \"\"\"\n    return await self.client.zrem(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zscore","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zscore(name, value)</code>  <code>async</code>","text":"<p>Get score of member in sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>Member to get score for.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Score or None if not found.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Get score of member in sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        value (bytes | str | float): Member to get score for.\n\n    Returns:\n        RedisResponseType: Score or None if not found.\n    \"\"\"\n    return await self.client.zscore(name, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hdel","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hdel(name, *keys)</code>  <code>async</code>","text":"<p>Delete fields from hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>*keys</code> <code>str | bytes</code> <p>Fields to delete.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of fields deleted.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n    \"\"\"Delete fields from hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n        *keys (str | bytes): Fields to delete.\n\n    Returns:\n        RedisIntegerResponseType: Number of fields deleted.\n    \"\"\"\n    return await self.client.hdel(name, *keys)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hexists","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hexists(name, key)</code>  <code>async</code>","text":"<p>Check if field exists in hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>key</code> <code>str</code> <p>Field to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if exists, False otherwise.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Check if field exists in hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n        key (str): Field to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if exists, False otherwise.\n    \"\"\"\n    return await self.read_only_client.hexists(name, key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hget","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hget(name, key)</code>  <code>async</code>","text":"<p>Get field value from hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>key</code> <code>str</code> <p>Field to get.</p> required <p>Returns:</p> Type Description <code>Awaitable[str | None] | str | None</code> <p>Awaitable[str | None] | str | None: Value or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n    \"\"\"Get field value from hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n        key (str): Field to get.\n\n    Returns:\n        Awaitable[str | None] | str | None: Value or None.\n    \"\"\"\n    return await self.read_only_client.hget(name, key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hgetall","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hgetall(name)</code>  <code>async</code>","text":"<p>Get all fields and values from hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Type Description <code>Awaitable[dict] | dict</code> <p>Awaitable[dict] | dict: Dictionary of field-value pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n    \"\"\"Get all fields and values from hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        Awaitable[dict] | dict: Dictionary of field-value pairs.\n    \"\"\"\n    return await self.read_only_client.hgetall(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hkeys","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hkeys(name)</code>  <code>async</code>","text":"<p>Get all fields from hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of field names.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hkeys(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Get all fields from hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        RedisListResponseType: List of field names.\n    \"\"\"\n    return await self.read_only_client.hkeys(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hlen","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hlen(name)</code>  <code>async</code>","text":"<p>Get number of fields in hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of fields.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hlen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Get number of fields in hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        RedisIntegerResponseType: Number of fields.\n    \"\"\"\n    return await self.read_only_client.hlen(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hset","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hset(name, key=None, value=None, mapping=None, items=None)</code>  <code>async</code>","text":"<p>Set fields in hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>key</code> <code>str | bytes | None</code> <p>Single field name. Defaults to None.</p> <code>None</code> <code>value</code> <code>str | bytes | None</code> <p>Single field value. Defaults to None.</p> <code>None</code> <code>mapping</code> <code>dict | None</code> <p>Field-value pairs dict. Defaults to None.</p> <code>None</code> <code>items</code> <code>list | None</code> <p>Field-value pairs list. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of fields set.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hset(\n    self,\n    name: str,\n    key: str | bytes | None = None,\n    value: str | bytes | None = None,\n    mapping: dict | None = None,\n    items: list | None = None,\n) -&gt; RedisIntegerResponseType:\n    \"\"\"Set fields in hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n        key (str | bytes | None): Single field name. Defaults to None.\n        value (str | bytes | None): Single field value. Defaults to None.\n        mapping (dict | None): Field-value pairs dict. Defaults to None.\n        items (list | None): Field-value pairs list. Defaults to None.\n\n    Returns:\n        RedisIntegerResponseType: Number of fields set.\n    \"\"\"\n    return await self.client.hset(name, key, value, mapping, items)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hmget","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hmget(name, keys, *args)</code>  <code>async</code>","text":"<p>Get multiple field values from hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>keys</code> <code>list</code> <p>List of field names.</p> required <code>*args</code> <code>str | bytes</code> <p>Additional field names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of field values.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n    \"\"\"Get multiple field values from hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n        keys (list): List of field names.\n        *args (str | bytes): Additional field names.\n\n    Returns:\n        RedisListResponseType: List of field values.\n    \"\"\"\n    return await self.read_only_client.hmget(name, keys, *args)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hvals","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hvals(name)</code>  <code>async</code>","text":"<p>Get all values from hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of values.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hvals(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Get all values from hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        RedisListResponseType: List of values.\n    \"\"\"\n    return await self.read_only_client.hvals(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.publish","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.publish(channel, message, **kwargs)</code>  <code>async</code>","text":"<p>Publish message to channel asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>RedisKeyType</code> <p>Channel name.</p> required <code>message</code> <code>bytes | str</code> <p>Message to publish.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of subscribers received message.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Publish message to channel asynchronously.\n\n    Args:\n        channel (RedisKeyType): Channel name.\n        message (bytes | str): Message to publish.\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: Number of subscribers received message.\n    \"\"\"\n    return await self.client.publish(channel, message, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.pubsub_channels","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.pubsub_channels(pattern='*', **kwargs)</code>  <code>async</code>","text":"<p>List active channels matching pattern asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>Pattern to match. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of channel names.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"List active channels matching pattern asynchronously.\n\n    Args:\n        pattern (RedisPatternType): Pattern to match. Defaults to \"*\".\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: List of channel names.\n    \"\"\"\n    return await self.client.pubsub_channels(pattern, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zincrby","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zincrby(name, amount, value)</code>  <code>async</code>","text":"<p>Increment member score in sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>amount</code> <code>float</code> <p>Amount to increment by.</p> required <code>value</code> <code>bytes | str | float</code> <p>Member to increment.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>New score of the member.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Increment member score in sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        amount (float): Amount to increment by.\n        value (bytes | str | float): Member to increment.\n\n    Returns:\n        RedisResponseType: New score of the member.\n    \"\"\"\n    return await self.client.zincrby(name, amount, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.pubsub","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.pubsub(**kwargs)</code>  <code>async</code>","text":"<p>Get PubSub object for channel subscription asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>AsyncPubSub</code> <code>PubSub</code> <p>PubSub object.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def pubsub(self, **kwargs: Any) -&gt; AsyncPubSub:\n    \"\"\"Get PubSub object for channel subscription asynchronously.\n\n    Args:\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        AsyncPubSub: PubSub object.\n    \"\"\"\n    return self.client.pubsub(**kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.get_pipeline","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.get_pipeline(transaction=True, shard_hint=None)</code>  <code>async</code>","text":"<p>Get pipeline for multiple commands asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Any</code> <p>Use transactions. Defaults to True.</p> <code>True</code> <code>shard_hint</code> <code>Any</code> <p>Sharding hint. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>AsyncPipeline</code> <code>Pipeline</code> <p>Pipeline object.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; AsyncPipeline:\n    \"\"\"Get pipeline for multiple commands asynchronously.\n\n    Args:\n        transaction (Any): Use transactions. Defaults to True.\n        shard_hint (Any): Sharding hint. Defaults to None.\n\n    Returns:\n        AsyncPipeline: Pipeline object.\n    \"\"\"\n    return self.client.pipeline(transaction, shard_hint)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.ping","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.ping()</code>  <code>async</code>","text":"<p>Ping the Redis server asynchronously.</p> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>'PONG' if successful.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def ping(self) -&gt; RedisResponseType:\n    \"\"\"Ping the Redis server asynchronously.\n\n    Returns:\n        RedisResponseType: 'PONG' if successful.\n    \"\"\"\n    return await self.client.ping()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort","title":"<code>archipy.adapters.redis.ports.RedisPort</code>","text":"<p>Interface for Redis operations providing a standardized access pattern.</p> <p>This interface defines the contract for Redis adapters, ensuring consistent implementation of Redis operations across different adapters. It covers all essential Redis functionality including key-value operations, collections (lists, sets, sorted sets, hashes), and pub/sub capabilities.</p> <p>Implementing classes should provide concrete implementations for all methods, typically by wrapping a Redis client library.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>class RedisPort:\n    \"\"\"Interface for Redis operations providing a standardized access pattern.\n\n    This interface defines the contract for Redis adapters, ensuring consistent\n    implementation of Redis operations across different adapters. It covers all\n    essential Redis functionality including key-value operations, collections\n    (lists, sets, sorted sets, hashes), and pub/sub capabilities.\n\n    Implementing classes should provide concrete implementations for all\n    methods, typically by wrapping a Redis client library.\n    \"\"\"\n\n    @abstractmethod\n    def ping(self) -&gt; RedisResponseType:\n        \"\"\"Tests the connection to the Redis server.\n\n        Returns:\n            RedisResponseType: The response from the server, typically \"PONG\".\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def pttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the remaining time to live of a key in milliseconds.\n\n        Args:\n            name (bytes | str): The key to check.\n\n        Returns:\n            RedisResponseType: The time to live in milliseconds, or -1 if no TTL, -2 if key doesn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n        \"\"\"Increments the integer value of a key by the given amount.\n\n        Args:\n            name (RedisKeyType): The key to increment.\n            amount (int): The amount to increment by. Defaults to 1.\n\n        Returns:\n            RedisResponseType: The new value after incrementing.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def set(\n        self,\n        name: RedisKeyType,\n        value: RedisSetType,\n        ex: RedisExpiryType | None = None,\n        px: RedisExpiryType | None = None,\n        nx: bool = False,\n        xx: bool = False,\n        keepttl: bool = False,\n        get: bool = False,\n        exat: RedisAbsExpiryType | None = None,\n        pxat: RedisAbsExpiryType | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Sets a key to a value with optional expiration and conditions.\n\n        Args:\n            name (RedisKeyType): The key to set.\n            value (RedisSetType): The value to set for the key.\n            ex (RedisExpiryType, optional): Expiration time in seconds or timedelta.\n            px (RedisExpiryType, optional): Expiration time in milliseconds or timedelta.\n            nx (bool): If True, set only if the key does not exist. Defaults to False.\n            xx (bool): If True, set only if the key already exists. Defaults to False.\n            keepttl (bool): If True, retain the existing TTL. Defaults to False.\n            get (bool): If True, return the old value before setting. Defaults to False.\n            exat (RedisAbsExpiryType, optional): Absolute expiration time as Unix timestamp or datetime.\n            pxat (RedisAbsExpiryType, optional): Absolute expiration time in milliseconds or datetime.\n\n        Returns:\n            RedisResponseType: The result of the operation, often \"OK\" or the old value if get=True.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get(self, key: str) -&gt; RedisResponseType:\n        \"\"\"Retrieves the value of a key.\n\n        Args:\n            key (str): The key to retrieve.\n\n        Returns:\n            RedisResponseType: The value associated with the key, or None if the key doesn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def mget(\n        self,\n        keys: RedisKeyType | Iterable[RedisKeyType],\n        *args: bytes | str,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets the values of multiple keys.\n\n        Args:\n            keys (RedisKeyType | Iterable[RedisKeyType]): A single key or iterable of keys.\n            *args (bytes | str): Additional keys.\n\n        Returns:\n            RedisResponseType: A list of values corresponding to the keys.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n        \"\"\"Sets multiple keys to their respective values.\n\n        Args:\n            mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of keys to values.\n\n        Returns:\n            RedisResponseType: Typically \"OK\" on success.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Returns all keys matching a pattern.\n\n        Args:\n            pattern (RedisPatternType): The pattern to match keys against. Defaults to \"*\".\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: A list of matching keys.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Sets a key to a value and returns its old value.\n\n        Args:\n            key (RedisKeyType): The key to set.\n            value (bytes | str | float): The new value to set.\n\n        Returns:\n            RedisResponseType: The old value of the key, or None if it didn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def getdel(self, key: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the value of a key and deletes it.\n\n        Args:\n            key (bytes | str): The key to get and delete.\n\n        Returns:\n            RedisResponseType: The value of the key before deletion, or None if it didn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def exists(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Checks if one or more keys exist.\n\n        Args:\n            *names (bytes | str): Variable number of keys to check.\n\n        Returns:\n            RedisResponseType: The number of keys that exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def delete(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Deletes one or more keys.\n\n        Args:\n            *names (bytes | str): Variable number of keys to delete.\n\n        Returns:\n            RedisResponseType: The number of keys deleted.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Appends a value to a key's string value.\n\n        Args:\n            key (RedisKeyType): The key to append to.\n            value (bytes | str | float): The value to append.\n\n        Returns:\n            RedisResponseType: The length of the string after appending.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def ttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the remaining time to live of a key in seconds.\n\n        Args:\n            name (bytes | str): The key to check.\n\n        Returns:\n            RedisResponseType: The time to live in seconds, or -1 if no TTL, -2 if key doesn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def type(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Determines the type of value stored at a key.\n\n        Args:\n            name (bytes | str): The key to check.\n\n        Returns:\n            RedisResponseType: The type of the key's value (e.g., \"string\", \"list\", etc.).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def llen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Gets the length of a list.\n\n        Args:\n            name (str): The key of the list.\n\n        Returns:\n            RedisIntegerResponseType: The number of items in the list.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def lpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Removes and returns the first element(s) of a list.\n\n        Args:\n            name (str): The key of the list.\n            count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n        Returns:\n            Any: The popped element(s), or None if the list is empty.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Pushes one or more values to the start of a list.\n\n        Args:\n            name (str): The key of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: The length of the list after the push.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n        \"\"\"Gets a range of elements from a list.\n\n        Args:\n            name (str): The key of the list.\n            start (int): The starting index (inclusive).\n            end (int): The ending index (inclusive).\n\n        Returns:\n            RedisListResponseType: A list of elements in the specified range.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Removes occurrences of a value from a list.\n\n        Args:\n            name (str): The key of the list.\n            count (int): Number of occurrences to remove (0 for all).\n            value (str): The value to remove.\n\n        Returns:\n            RedisIntegerResponseType: The number of elements removed.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def lset(self, name: str, index: int, value: str) -&gt; bool:\n        \"\"\"Sets the value of an element in a list by index.\n\n        Args:\n            name (str): The key of the list.\n            index (int): The index to set.\n            value (str): The new value.\n\n        Returns:\n            bool: True if successful.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def rpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Removes and returns the last element(s) of a list.\n\n        Args:\n            name (str): The key of the list.\n            count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n        Returns:\n            Any: The popped element(s), or None if the list is empty.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Pushes one or more values to the end of a list.\n\n        Args:\n            name (str): The key of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: The length of the list after the push.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def scan(\n        self,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; RedisResponseType:\n        \"\"\"Iterates over keys in the database incrementally.\n\n        Args:\n            cursor (int): The cursor position to start scanning. Defaults to 0.\n            match (bytes | str, optional): Pattern to match keys against.\n            count (int, optional): Hint for number of keys to return per iteration.\n            _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: A tuple of (new_cursor, list_of_keys).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def scan_iter(\n        self,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; Iterator:\n        \"\"\"Provides an iterator over keys in the database.\n\n        Args:\n            match (bytes | str, optional): Pattern to match keys against.\n            count (int, optional): Hint for number of keys to return per iteration.\n            _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            Iterator: An iterator yielding keys.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def sscan(\n        self,\n        name: RedisKeyType,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Iterates over members of a set incrementally.\n\n        Args:\n            name (RedisKeyType): The key of the set.\n            cursor (int): The cursor position to start scanning. Defaults to 0.\n            match (bytes | str, optional): Pattern to match members against.\n            count (int, optional): Hint for number of members to return per iteration.\n\n        Returns:\n            RedisResponseType: A tuple of (new_cursor, list_of_members).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def sscan_iter(\n        self,\n        name: RedisKeyType,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; Iterator:\n        \"\"\"Provides an iterator over members of a set.\n\n        Args:\n            name (RedisKeyType): The key of the set.\n            match (bytes | str, optional): Pattern to match members against.\n            count (int, optional): Hint for number of members to return per iteration.\n\n        Returns:\n            Iterator: An iterator yielding set members.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Adds one or more members to a set.\n\n        Args:\n            name (str): The key of the set.\n            *values (bytes | str | float): Members to add.\n\n        Returns:\n            RedisIntegerResponseType: The number of members added (excluding duplicates).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def scard(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Gets the number of members in a set.\n\n        Args:\n            name (str): The key of the set.\n\n        Returns:\n            RedisIntegerResponseType: The cardinality (size) of the set.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Checks if a value is a member of a set.\n\n        Args:\n            name (str): The key of the set.\n            value (str): The value to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if the value is a member, False otherwise.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def smembers(self, name: str) -&gt; RedisSetResponseType:\n        \"\"\"Gets all members of a set.\n\n        Args:\n            name (str): The key of the set.\n\n        Returns:\n            RedisSetResponseType: A set of all members.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n        \"\"\"Removes and returns one or more random members from a set.\n\n        Args:\n            name (str): The key of the set.\n            count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n        Returns:\n            bytes | float | int | str | list | None: The popped member(s), or None if the set is empty.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Removes one or more members from a set.\n\n        Args:\n            name (str): The key of the set.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisIntegerResponseType: The number of members removed.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n        \"\"\"Gets the union of multiple sets.\n\n        Args:\n            keys (RedisKeyType): Name of the first key.\n            *args (bytes | str): Additional key names.\n\n        Returns:\n            RedisSetResponseType: A set containing members of the resulting union.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zadd(\n        self,\n        name: RedisKeyType,\n        mapping: Mapping[RedisKeyType, bytes | str | float],\n        nx: bool = False,\n        xx: bool = False,\n        ch: bool = False,\n        incr: bool = False,\n        gt: bool = False,\n        lt: bool = False,\n    ) -&gt; RedisResponseType:\n        \"\"\"Adds members with scores to a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of members to scores.\n            nx (bool): If True, only add new elements. Defaults to False.\n            xx (bool): If True, only update existing elements. Defaults to False.\n            ch (bool): If True, return the number of changed elements. Defaults to False.\n            incr (bool): If True, increment scores instead of setting. Defaults to False.\n            gt (bool): If True, only update if new score is greater. Defaults to False.\n            lt (bool): If True, only update if new score is less. Defaults to False.\n\n        Returns:\n            RedisResponseType: The number of elements added or updated.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zcard(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the number of members in a sorted set.\n\n        Args:\n            name (bytes | str): The key of the sorted set.\n\n        Returns:\n            RedisResponseType: The cardinality (size) of the sorted set.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n        \"\"\"Counts members in a sorted set within a score range.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            min (float | str): The minimum score (inclusive).\n            max (float | str): The maximum score (inclusive).\n\n        Returns:\n            RedisResponseType: The number of members within the score range.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Removes and returns members with the highest scores from a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n        Returns:\n            RedisResponseType: A list of (member, score) tuples popped.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Removes and returns members with the lowest scores from a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n        Returns:\n            RedisResponseType: A list of (member, score) tuples popped.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        desc: bool = False,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n        byscore: bool = False,\n        bylex: bool = False,\n        offset: int | None = None,\n        num: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets a range of members from a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            start (int): The starting index or score (depending on byscore).\n            end (int): The ending index or score (depending on byscore).\n            desc (bool): If True, sort in descending order. Defaults to False.\n            withscores (bool): If True, return scores with members. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n            byscore (bool): If True, range by score instead of rank. Defaults to False.\n            bylex (bool): If True, range by lexicographical order. Defaults to False.\n            offset (int, optional): Offset for byscore or bylex.\n            num (int, optional): Number of elements for byscore or bylex.\n\n        Returns:\n            RedisResponseType: A list of members (and scores if withscores=True).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zrevrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets a range of members from a sorted set in reverse order.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            start (int): The starting index.\n            end (int): The ending index.\n            withscores (bool): If True, return scores with members. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n        Returns:\n            RedisResponseType: A list of members (and scores if withscores=True).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zrangebyscore(\n        self,\n        name: RedisKeyType,\n        min: float | str,\n        max: float | str,\n        start: int | None = None,\n        num: int | None = None,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets members from a sorted set by score range.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            min (float | str): The minimum score (inclusive).\n            max (float | str): The maximum score (inclusive).\n            start (int, optional): Starting offset.\n            num (int, optional): Number of elements to return.\n            withscores (bool): If True, return scores with members. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n        Returns:\n            RedisResponseType: A list of members (and scores if withscores=True).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Gets the rank of a member in a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            value (bytes | str | float): The member to find.\n\n        Returns:\n            RedisResponseType: The rank (index) of the member, or None if not found.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Removes one or more members from a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisResponseType: The number of members removed.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Gets the score of a member in a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            value (bytes | str | float): The member to check.\n\n        Returns:\n            RedisResponseType: The score of the member, or None if not found.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n        \"\"\"Deletes one or more fields from a hash.\n\n        Args:\n            name (str): The key of the hash.\n            *keys (str | bytes): Fields to delete.\n\n        Returns:\n            RedisIntegerResponseType: The number of fields deleted.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Checks if a field exists in a hash.\n\n        Args:\n            name (str): The key of the hash.\n            key (str): The field to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if the field exists, False otherwise.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n        \"\"\"Gets the value of a field in a hash.\n\n        Args:\n            name (str): The key of the hash.\n            key (str): The field to get.\n\n        Returns:\n            Awaitable[str | None] | str | None: The value of the field, or None if not found.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n        \"\"\"Gets all fields and values in a hash.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            Awaitable[dict] | dict: A dictionary of field/value pairs.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hkeys(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Gets all fields in a hash.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            RedisListResponseType: A list of fields in the hash.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hlen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Gets the number of fields in a hash.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            RedisIntegerResponseType: The number of fields in the hash.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hset(\n        self,\n        name: str,\n        key: str | bytes | None = None,\n        value: str | bytes | None = None,\n        mapping: dict | None = None,\n        items: list | None = None,\n    ) -&gt; RedisIntegerResponseType:\n        \"\"\"Sets one or more fields in a hash.\n\n        Args:\n            name (str): The key of the hash.\n            key (str | bytes, optional): A single field to set.\n            value (str | bytes, optional): The value for the single field.\n            mapping (dict, optional): A dictionary of field/value pairs.\n            items (list, optional): A list of field/value pairs.\n\n        Returns:\n            RedisIntegerResponseType: The number of fields added or updated.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n        \"\"\"Gets the values of multiple fields in a hash.\n\n        Args:\n            name (str): The key of the hash.\n            keys (list): A list of fields to get.\n            *args (str | bytes): Additional fields to get.\n\n        Returns:\n            RedisListResponseType: A list of values for the specified fields.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hvals(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Gets all values in a hash.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            RedisListResponseType: A list of values in the hash.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Publishes a message to a channel.\n\n        Args:\n            channel (RedisKeyType): The channel to publish to.\n            message (bytes | str): The message to publish.\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: The number of subscribers that received the message.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Lists active channels matching a pattern.\n\n        Args:\n            pattern (RedisPatternType): The pattern to match channels. Defaults to \"*\".\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: A list of active channels.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Increments the score of a member in a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            amount (float): The amount to increment by.\n            value (bytes | str | float): The member to increment.\n\n        Returns:\n            RedisResponseType: The new score of the member.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def pubsub(self, **kwargs: Any) -&gt; Any:\n        \"\"\"Returns a pub/sub object for subscribing to channels.\n\n        Args:\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            Any: A pub/sub object.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; Any:\n        \"\"\"Returns a pipeline object for batching commands.\n\n        Args:\n            transaction (Any): If True, execute commands in a transaction. Defaults to True.\n            shard_hint (Any, optional): Hint for sharding in clustered Redis.\n\n        Returns:\n            Any: A pipeline object.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.ping","title":"<code>archipy.adapters.redis.ports.RedisPort.ping()</code>  <code>abstractmethod</code>","text":"<p>Tests the connection to the Redis server.</p> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The response from the server, typically \"PONG\".</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef ping(self) -&gt; RedisResponseType:\n    \"\"\"Tests the connection to the Redis server.\n\n    Returns:\n        RedisResponseType: The response from the server, typically \"PONG\".\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.pttl","title":"<code>archipy.adapters.redis.ports.RedisPort.pttl(name)</code>  <code>abstractmethod</code>","text":"<p>Gets the remaining time to live of a key in milliseconds.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The time to live in milliseconds, or -1 if no TTL, -2 if key doesn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef pttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the remaining time to live of a key in milliseconds.\n\n    Args:\n        name (bytes | str): The key to check.\n\n    Returns:\n        RedisResponseType: The time to live in milliseconds, or -1 if no TTL, -2 if key doesn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.incrby","title":"<code>archipy.adapters.redis.ports.RedisPort.incrby(name, amount=1)</code>  <code>abstractmethod</code>","text":"<p>Increments the integer value of a key by the given amount.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key to increment.</p> required <code>amount</code> <code>int</code> <p>The amount to increment by. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The new value after incrementing.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n    \"\"\"Increments the integer value of a key by the given amount.\n\n    Args:\n        name (RedisKeyType): The key to increment.\n        amount (int): The amount to increment by. Defaults to 1.\n\n    Returns:\n        RedisResponseType: The new value after incrementing.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.set","title":"<code>archipy.adapters.redis.ports.RedisPort.set(name, value, ex=None, px=None, nx=False, xx=False, keepttl=False, get=False, exat=None, pxat=None)</code>  <code>abstractmethod</code>","text":"<p>Sets a key to a value with optional expiration and conditions.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key to set.</p> required <code>value</code> <code>RedisSetType</code> <p>The value to set for the key.</p> required <code>ex</code> <code>RedisExpiryType</code> <p>Expiration time in seconds or timedelta.</p> <code>None</code> <code>px</code> <code>RedisExpiryType</code> <p>Expiration time in milliseconds or timedelta.</p> <code>None</code> <code>nx</code> <code>bool</code> <p>If True, set only if the key does not exist. Defaults to False.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>If True, set only if the key already exists. Defaults to False.</p> <code>False</code> <code>keepttl</code> <code>bool</code> <p>If True, retain the existing TTL. Defaults to False.</p> <code>False</code> <code>get</code> <code>bool</code> <p>If True, return the old value before setting. Defaults to False.</p> <code>False</code> <code>exat</code> <code>RedisAbsExpiryType</code> <p>Absolute expiration time as Unix timestamp or datetime.</p> <code>None</code> <code>pxat</code> <code>RedisAbsExpiryType</code> <p>Absolute expiration time in milliseconds or datetime.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The result of the operation, often \"OK\" or the old value if get=True.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef set(\n    self,\n    name: RedisKeyType,\n    value: RedisSetType,\n    ex: RedisExpiryType | None = None,\n    px: RedisExpiryType | None = None,\n    nx: bool = False,\n    xx: bool = False,\n    keepttl: bool = False,\n    get: bool = False,\n    exat: RedisAbsExpiryType | None = None,\n    pxat: RedisAbsExpiryType | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Sets a key to a value with optional expiration and conditions.\n\n    Args:\n        name (RedisKeyType): The key to set.\n        value (RedisSetType): The value to set for the key.\n        ex (RedisExpiryType, optional): Expiration time in seconds or timedelta.\n        px (RedisExpiryType, optional): Expiration time in milliseconds or timedelta.\n        nx (bool): If True, set only if the key does not exist. Defaults to False.\n        xx (bool): If True, set only if the key already exists. Defaults to False.\n        keepttl (bool): If True, retain the existing TTL. Defaults to False.\n        get (bool): If True, return the old value before setting. Defaults to False.\n        exat (RedisAbsExpiryType, optional): Absolute expiration time as Unix timestamp or datetime.\n        pxat (RedisAbsExpiryType, optional): Absolute expiration time in milliseconds or datetime.\n\n    Returns:\n        RedisResponseType: The result of the operation, often \"OK\" or the old value if get=True.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.get","title":"<code>archipy.adapters.redis.ports.RedisPort.get(key)</code>  <code>abstractmethod</code>","text":"<p>Retrieves the value of a key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to retrieve.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value associated with the key, or None if the key doesn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef get(self, key: str) -&gt; RedisResponseType:\n    \"\"\"Retrieves the value of a key.\n\n    Args:\n        key (str): The key to retrieve.\n\n    Returns:\n        RedisResponseType: The value associated with the key, or None if the key doesn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.mget","title":"<code>archipy.adapters.redis.ports.RedisPort.mget(keys, *args)</code>  <code>abstractmethod</code>","text":"<p>Gets the values of multiple keys.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType | Iterable[RedisKeyType]</code> <p>A single key or iterable of keys.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional keys.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of values corresponding to the keys.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef mget(\n    self,\n    keys: RedisKeyType | Iterable[RedisKeyType],\n    *args: bytes | str,\n) -&gt; RedisResponseType:\n    \"\"\"Gets the values of multiple keys.\n\n    Args:\n        keys (RedisKeyType | Iterable[RedisKeyType]): A single key or iterable of keys.\n        *args (bytes | str): Additional keys.\n\n    Returns:\n        RedisResponseType: A list of values corresponding to the keys.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.mset","title":"<code>archipy.adapters.redis.ports.RedisPort.mset(mapping)</code>  <code>abstractmethod</code>","text":"<p>Sets multiple keys to their respective values.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>A mapping of keys to values.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Typically \"OK\" on success.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n    \"\"\"Sets multiple keys to their respective values.\n\n    Args:\n        mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of keys to values.\n\n    Returns:\n        RedisResponseType: Typically \"OK\" on success.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.keys","title":"<code>archipy.adapters.redis.ports.RedisPort.keys(pattern='*', **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Returns all keys matching a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>The pattern to match keys against. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of matching keys.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Returns all keys matching a pattern.\n\n    Args:\n        pattern (RedisPatternType): The pattern to match keys against. Defaults to \"*\".\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: A list of matching keys.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.getset","title":"<code>archipy.adapters.redis.ports.RedisPort.getset(key, value)</code>  <code>abstractmethod</code>","text":"<p>Sets a key to a value and returns its old value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key to set.</p> required <code>value</code> <code>bytes | str | float</code> <p>The new value to set.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The old value of the key, or None if it didn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Sets a key to a value and returns its old value.\n\n    Args:\n        key (RedisKeyType): The key to set.\n        value (bytes | str | float): The new value to set.\n\n    Returns:\n        RedisResponseType: The old value of the key, or None if it didn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.getdel","title":"<code>archipy.adapters.redis.ports.RedisPort.getdel(key)</code>  <code>abstractmethod</code>","text":"<p>Gets the value of a key and deletes it.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes | str</code> <p>The key to get and delete.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value of the key before deletion, or None if it didn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef getdel(self, key: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the value of a key and deletes it.\n\n    Args:\n        key (bytes | str): The key to get and delete.\n\n    Returns:\n        RedisResponseType: The value of the key before deletion, or None if it didn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.exists","title":"<code>archipy.adapters.redis.ports.RedisPort.exists(*names)</code>  <code>abstractmethod</code>","text":"<p>Checks if one or more keys exist.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of keys to check.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of keys that exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef exists(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Checks if one or more keys exist.\n\n    Args:\n        *names (bytes | str): Variable number of keys to check.\n\n    Returns:\n        RedisResponseType: The number of keys that exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.delete","title":"<code>archipy.adapters.redis.ports.RedisPort.delete(*names)</code>  <code>abstractmethod</code>","text":"<p>Deletes one or more keys.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of keys to delete.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of keys deleted.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef delete(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Deletes one or more keys.\n\n    Args:\n        *names (bytes | str): Variable number of keys to delete.\n\n    Returns:\n        RedisResponseType: The number of keys deleted.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.append","title":"<code>archipy.adapters.redis.ports.RedisPort.append(key, value)</code>  <code>abstractmethod</code>","text":"<p>Appends a value to a key's string value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key to append to.</p> required <code>value</code> <code>bytes | str | float</code> <p>The value to append.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The length of the string after appending.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Appends a value to a key's string value.\n\n    Args:\n        key (RedisKeyType): The key to append to.\n        value (bytes | str | float): The value to append.\n\n    Returns:\n        RedisResponseType: The length of the string after appending.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.ttl","title":"<code>archipy.adapters.redis.ports.RedisPort.ttl(name)</code>  <code>abstractmethod</code>","text":"<p>Gets the remaining time to live of a key in seconds.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The time to live in seconds, or -1 if no TTL, -2 if key doesn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef ttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the remaining time to live of a key in seconds.\n\n    Args:\n        name (bytes | str): The key to check.\n\n    Returns:\n        RedisResponseType: The time to live in seconds, or -1 if no TTL, -2 if key doesn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.type","title":"<code>archipy.adapters.redis.ports.RedisPort.type(name)</code>  <code>abstractmethod</code>","text":"<p>Determines the type of value stored at a key.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The type of the key's value (e.g., \"string\", \"list\", etc.).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef type(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Determines the type of value stored at a key.\n\n    Args:\n        name (bytes | str): The key to check.\n\n    Returns:\n        RedisResponseType: The type of the key's value (e.g., \"string\", \"list\", etc.).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.llen","title":"<code>archipy.adapters.redis.ports.RedisPort.llen(name)</code>  <code>abstractmethod</code>","text":"<p>Gets the length of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of items in the list.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef llen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Gets the length of a list.\n\n    Args:\n        name (str): The key of the list.\n\n    Returns:\n        RedisIntegerResponseType: The number of items in the list.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.lpop","title":"<code>archipy.adapters.redis.ports.RedisPort.lpop(name, count=None)</code>  <code>abstractmethod</code>","text":"<p>Removes and returns the first element(s) of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>Number of elements to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The popped element(s), or None if the list is empty.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef lpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Removes and returns the first element(s) of a list.\n\n    Args:\n        name (str): The key of the list.\n        count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n    Returns:\n        Any: The popped element(s), or None if the list is empty.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.lpush","title":"<code>archipy.adapters.redis.ports.RedisPort.lpush(name, *values)</code>  <code>abstractmethod</code>","text":"<p>Pushes one or more values to the start of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The length of the list after the push.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Pushes one or more values to the start of a list.\n\n    Args:\n        name (str): The key of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: The length of the list after the push.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.lrange","title":"<code>archipy.adapters.redis.ports.RedisPort.lrange(name, start, end)</code>  <code>abstractmethod</code>","text":"<p>Gets a range of elements from a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>start</code> <code>int</code> <p>The starting index (inclusive).</p> required <code>end</code> <code>int</code> <p>The ending index (inclusive).</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of elements in the specified range.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n    \"\"\"Gets a range of elements from a list.\n\n    Args:\n        name (str): The key of the list.\n        start (int): The starting index (inclusive).\n        end (int): The ending index (inclusive).\n\n    Returns:\n        RedisListResponseType: A list of elements in the specified range.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.lrem","title":"<code>archipy.adapters.redis.ports.RedisPort.lrem(name, count, value)</code>  <code>abstractmethod</code>","text":"<p>Removes occurrences of a value from a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>Number of occurrences to remove (0 for all).</p> required <code>value</code> <code>str</code> <p>The value to remove.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of elements removed.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Removes occurrences of a value from a list.\n\n    Args:\n        name (str): The key of the list.\n        count (int): Number of occurrences to remove (0 for all).\n        value (str): The value to remove.\n\n    Returns:\n        RedisIntegerResponseType: The number of elements removed.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.lset","title":"<code>archipy.adapters.redis.ports.RedisPort.lset(name, index, value)</code>  <code>abstractmethod</code>","text":"<p>Sets the value of an element in a list by index.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>index</code> <code>int</code> <p>The index to set.</p> required <code>value</code> <code>str</code> <p>The new value.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef lset(self, name: str, index: int, value: str) -&gt; bool:\n    \"\"\"Sets the value of an element in a list by index.\n\n    Args:\n        name (str): The key of the list.\n        index (int): The index to set.\n        value (str): The new value.\n\n    Returns:\n        bool: True if successful.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.rpop","title":"<code>archipy.adapters.redis.ports.RedisPort.rpop(name, count=None)</code>  <code>abstractmethod</code>","text":"<p>Removes and returns the last element(s) of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>Number of elements to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The popped element(s), or None if the list is empty.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef rpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Removes and returns the last element(s) of a list.\n\n    Args:\n        name (str): The key of the list.\n        count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n    Returns:\n        Any: The popped element(s), or None if the list is empty.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.rpush","title":"<code>archipy.adapters.redis.ports.RedisPort.rpush(name, *values)</code>  <code>abstractmethod</code>","text":"<p>Pushes one or more values to the end of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The length of the list after the push.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Pushes one or more values to the end of a list.\n\n    Args:\n        name (str): The key of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: The length of the list after the push.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.scan","title":"<code>archipy.adapters.redis.ports.RedisPort.scan(cursor=0, match=None, count=None, _type=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Iterates over keys in the database incrementally.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>int</code> <p>The cursor position to start scanning. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str</code> <p>Pattern to match keys against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of keys to return per iteration.</p> <code>None</code> <code>_type</code> <code>str</code> <p>Filter by type (e.g., \"string\", \"list\").</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A tuple of (new_cursor, list_of_keys).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef scan(\n    self,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; RedisResponseType:\n    \"\"\"Iterates over keys in the database incrementally.\n\n    Args:\n        cursor (int): The cursor position to start scanning. Defaults to 0.\n        match (bytes | str, optional): Pattern to match keys against.\n        count (int, optional): Hint for number of keys to return per iteration.\n        _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: A tuple of (new_cursor, list_of_keys).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.scan_iter","title":"<code>archipy.adapters.redis.ports.RedisPort.scan_iter(match=None, count=None, _type=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Provides an iterator over keys in the database.</p> <p>Parameters:</p> Name Type Description Default <code>match</code> <code>bytes | str</code> <p>Pattern to match keys against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of keys to return per iteration.</p> <code>None</code> <code>_type</code> <code>str</code> <p>Filter by type (e.g., \"string\", \"list\").</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Iterator</code> <code>Iterator</code> <p>An iterator yielding keys.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef scan_iter(\n    self,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; Iterator:\n    \"\"\"Provides an iterator over keys in the database.\n\n    Args:\n        match (bytes | str, optional): Pattern to match keys against.\n        count (int, optional): Hint for number of keys to return per iteration.\n        _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        Iterator: An iterator yielding keys.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.sscan","title":"<code>archipy.adapters.redis.ports.RedisPort.sscan(name, cursor=0, match=None, count=None)</code>  <code>abstractmethod</code>","text":"<p>Iterates over members of a set incrementally.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the set.</p> required <code>cursor</code> <code>int</code> <p>The cursor position to start scanning. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str</code> <p>Pattern to match members against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of members to return per iteration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A tuple of (new_cursor, list_of_members).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef sscan(\n    self,\n    name: RedisKeyType,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Iterates over members of a set incrementally.\n\n    Args:\n        name (RedisKeyType): The key of the set.\n        cursor (int): The cursor position to start scanning. Defaults to 0.\n        match (bytes | str, optional): Pattern to match members against.\n        count (int, optional): Hint for number of members to return per iteration.\n\n    Returns:\n        RedisResponseType: A tuple of (new_cursor, list_of_members).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.sscan_iter","title":"<code>archipy.adapters.redis.ports.RedisPort.sscan_iter(name, match=None, count=None)</code>  <code>abstractmethod</code>","text":"<p>Provides an iterator over members of a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the set.</p> required <code>match</code> <code>bytes | str</code> <p>Pattern to match members against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of members to return per iteration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Iterator</code> <code>Iterator</code> <p>An iterator yielding set members.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef sscan_iter(\n    self,\n    name: RedisKeyType,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; Iterator:\n    \"\"\"Provides an iterator over members of a set.\n\n    Args:\n        name (RedisKeyType): The key of the set.\n        match (bytes | str, optional): Pattern to match members against.\n        count (int, optional): Hint for number of members to return per iteration.\n\n    Returns:\n        Iterator: An iterator yielding set members.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.sadd","title":"<code>archipy.adapters.redis.ports.RedisPort.sadd(name, *values)</code>  <code>abstractmethod</code>","text":"<p>Adds one or more members to a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to add.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of members added (excluding duplicates).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Adds one or more members to a set.\n\n    Args:\n        name (str): The key of the set.\n        *values (bytes | str | float): Members to add.\n\n    Returns:\n        RedisIntegerResponseType: The number of members added (excluding duplicates).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.scard","title":"<code>archipy.adapters.redis.ports.RedisPort.scard(name)</code>  <code>abstractmethod</code>","text":"<p>Gets the number of members in a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The cardinality (size) of the set.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef scard(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Gets the number of members in a set.\n\n    Args:\n        name (str): The key of the set.\n\n    Returns:\n        RedisIntegerResponseType: The cardinality (size) of the set.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.sismember","title":"<code>archipy.adapters.redis.ports.RedisPort.sismember(name, value)</code>  <code>abstractmethod</code>","text":"<p>Checks if a value is a member of a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>value</code> <code>str</code> <p>The value to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if the value is a member, False otherwise.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Checks if a value is a member of a set.\n\n    Args:\n        name (str): The key of the set.\n        value (str): The value to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if the value is a member, False otherwise.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.smembers","title":"<code>archipy.adapters.redis.ports.RedisPort.smembers(name)</code>  <code>abstractmethod</code>","text":"<p>Gets all members of a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>A set of all members.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef smembers(self, name: str) -&gt; RedisSetResponseType:\n    \"\"\"Gets all members of a set.\n\n    Args:\n        name (str): The key of the set.\n\n    Returns:\n        RedisSetResponseType: A set of all members.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.spop","title":"<code>archipy.adapters.redis.ports.RedisPort.spop(name, count=None)</code>  <code>abstractmethod</code>","text":"<p>Removes and returns one or more random members from a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>count</code> <code>int</code> <p>Number of members to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | float | int | str | list | None</code> <p>bytes | float | int | str | list | None: The popped member(s), or None if the set is empty.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n    \"\"\"Removes and returns one or more random members from a set.\n\n    Args:\n        name (str): The key of the set.\n        count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n    Returns:\n        bytes | float | int | str | list | None: The popped member(s), or None if the set is empty.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.srem","title":"<code>archipy.adapters.redis.ports.RedisPort.srem(name, *values)</code>  <code>abstractmethod</code>","text":"<p>Removes one or more members from a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of members removed.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Removes one or more members from a set.\n\n    Args:\n        name (str): The key of the set.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisIntegerResponseType: The number of members removed.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.sunion","title":"<code>archipy.adapters.redis.ports.RedisPort.sunion(keys, *args)</code>  <code>abstractmethod</code>","text":"<p>Gets the union of multiple sets.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType</code> <p>Name of the first key.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional key names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>A set containing members of the resulting union.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n    \"\"\"Gets the union of multiple sets.\n\n    Args:\n        keys (RedisKeyType): Name of the first key.\n        *args (bytes | str): Additional key names.\n\n    Returns:\n        RedisSetResponseType: A set containing members of the resulting union.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zadd","title":"<code>archipy.adapters.redis.ports.RedisPort.zadd(name, mapping, nx=False, xx=False, ch=False, incr=False, gt=False, lt=False)</code>  <code>abstractmethod</code>","text":"<p>Adds members with scores to a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>A mapping of members to scores.</p> required <code>nx</code> <code>bool</code> <p>If True, only add new elements. Defaults to False.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>If True, only update existing elements. Defaults to False.</p> <code>False</code> <code>ch</code> <code>bool</code> <p>If True, return the number of changed elements. Defaults to False.</p> <code>False</code> <code>incr</code> <code>bool</code> <p>If True, increment scores instead of setting. Defaults to False.</p> <code>False</code> <code>gt</code> <code>bool</code> <p>If True, only update if new score is greater. Defaults to False.</p> <code>False</code> <code>lt</code> <code>bool</code> <p>If True, only update if new score is less. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of elements added or updated.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zadd(\n    self,\n    name: RedisKeyType,\n    mapping: Mapping[RedisKeyType, bytes | str | float],\n    nx: bool = False,\n    xx: bool = False,\n    ch: bool = False,\n    incr: bool = False,\n    gt: bool = False,\n    lt: bool = False,\n) -&gt; RedisResponseType:\n    \"\"\"Adds members with scores to a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of members to scores.\n        nx (bool): If True, only add new elements. Defaults to False.\n        xx (bool): If True, only update existing elements. Defaults to False.\n        ch (bool): If True, return the number of changed elements. Defaults to False.\n        incr (bool): If True, increment scores instead of setting. Defaults to False.\n        gt (bool): If True, only update if new score is greater. Defaults to False.\n        lt (bool): If True, only update if new score is less. Defaults to False.\n\n    Returns:\n        RedisResponseType: The number of elements added or updated.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zcard","title":"<code>archipy.adapters.redis.ports.RedisPort.zcard(name)</code>  <code>abstractmethod</code>","text":"<p>Gets the number of members in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key of the sorted set.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The cardinality (size) of the sorted set.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zcard(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the number of members in a sorted set.\n\n    Args:\n        name (bytes | str): The key of the sorted set.\n\n    Returns:\n        RedisResponseType: The cardinality (size) of the sorted set.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zcount","title":"<code>archipy.adapters.redis.ports.RedisPort.zcount(name, min, max)</code>  <code>abstractmethod</code>","text":"<p>Counts members in a sorted set within a score range.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>min</code> <code>float | str</code> <p>The minimum score (inclusive).</p> required <code>max</code> <code>float | str</code> <p>The maximum score (inclusive).</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of members within the score range.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n    \"\"\"Counts members in a sorted set within a score range.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        min (float | str): The minimum score (inclusive).\n        max (float | str): The maximum score (inclusive).\n\n    Returns:\n        RedisResponseType: The number of members within the score range.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zpopmax","title":"<code>archipy.adapters.redis.ports.RedisPort.zpopmax(name, count=None)</code>  <code>abstractmethod</code>","text":"<p>Removes and returns members with the highest scores from a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>count</code> <code>int</code> <p>Number of members to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of (member, score) tuples popped.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Removes and returns members with the highest scores from a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n    Returns:\n        RedisResponseType: A list of (member, score) tuples popped.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zpopmin","title":"<code>archipy.adapters.redis.ports.RedisPort.zpopmin(name, count=None)</code>  <code>abstractmethod</code>","text":"<p>Removes and returns members with the lowest scores from a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>count</code> <code>int</code> <p>Number of members to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of (member, score) tuples popped.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Removes and returns members with the lowest scores from a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n    Returns:\n        RedisResponseType: A list of (member, score) tuples popped.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zrange","title":"<code>archipy.adapters.redis.ports.RedisPort.zrange(name, start, end, desc=False, withscores=False, score_cast_func=float, byscore=False, bylex=False, offset=None, num=None)</code>  <code>abstractmethod</code>","text":"<p>Gets a range of members from a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>start</code> <code>int</code> <p>The starting index or score (depending on byscore).</p> required <code>end</code> <code>int</code> <p>The ending index or score (depending on byscore).</p> required <code>desc</code> <code>bool</code> <p>If True, sort in descending order. Defaults to False.</p> <code>False</code> <code>withscores</code> <code>bool</code> <p>If True, return scores with members. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <code>byscore</code> <code>bool</code> <p>If True, range by score instead of rank. Defaults to False.</p> <code>False</code> <code>bylex</code> <code>bool</code> <p>If True, range by lexicographical order. Defaults to False.</p> <code>False</code> <code>offset</code> <code>int</code> <p>Offset for byscore or bylex.</p> <code>None</code> <code>num</code> <code>int</code> <p>Number of elements for byscore or bylex.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of members (and scores if withscores=True).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    desc: bool = False,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n    byscore: bool = False,\n    bylex: bool = False,\n    offset: int | None = None,\n    num: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Gets a range of members from a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        start (int): The starting index or score (depending on byscore).\n        end (int): The ending index or score (depending on byscore).\n        desc (bool): If True, sort in descending order. Defaults to False.\n        withscores (bool): If True, return scores with members. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n        byscore (bool): If True, range by score instead of rank. Defaults to False.\n        bylex (bool): If True, range by lexicographical order. Defaults to False.\n        offset (int, optional): Offset for byscore or bylex.\n        num (int, optional): Number of elements for byscore or bylex.\n\n    Returns:\n        RedisResponseType: A list of members (and scores if withscores=True).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zrevrange","title":"<code>archipy.adapters.redis.ports.RedisPort.zrevrange(name, start, end, withscores=False, score_cast_func=float)</code>  <code>abstractmethod</code>","text":"<p>Gets a range of members from a sorted set in reverse order.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>start</code> <code>int</code> <p>The starting index.</p> required <code>end</code> <code>int</code> <p>The ending index.</p> required <code>withscores</code> <code>bool</code> <p>If True, return scores with members. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of members (and scores if withscores=True).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zrevrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Gets a range of members from a sorted set in reverse order.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        start (int): The starting index.\n        end (int): The ending index.\n        withscores (bool): If True, return scores with members. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n    Returns:\n        RedisResponseType: A list of members (and scores if withscores=True).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zrangebyscore","title":"<code>archipy.adapters.redis.ports.RedisPort.zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=float)</code>  <code>abstractmethod</code>","text":"<p>Gets members from a sorted set by score range.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>min</code> <code>float | str</code> <p>The minimum score (inclusive).</p> required <code>max</code> <code>float | str</code> <p>The maximum score (inclusive).</p> required <code>start</code> <code>int</code> <p>Starting offset.</p> <code>None</code> <code>num</code> <code>int</code> <p>Number of elements to return.</p> <code>None</code> <code>withscores</code> <code>bool</code> <p>If True, return scores with members. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of members (and scores if withscores=True).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zrangebyscore(\n    self,\n    name: RedisKeyType,\n    min: float | str,\n    max: float | str,\n    start: int | None = None,\n    num: int | None = None,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Gets members from a sorted set by score range.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        min (float | str): The minimum score (inclusive).\n        max (float | str): The maximum score (inclusive).\n        start (int, optional): Starting offset.\n        num (int, optional): Number of elements to return.\n        withscores (bool): If True, return scores with members. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n    Returns:\n        RedisResponseType: A list of members (and scores if withscores=True).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zrank","title":"<code>archipy.adapters.redis.ports.RedisPort.zrank(name, value)</code>  <code>abstractmethod</code>","text":"<p>Gets the rank of a member in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>value</code> <code>bytes | str | float</code> <p>The member to find.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The rank (index) of the member, or None if not found.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Gets the rank of a member in a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        value (bytes | str | float): The member to find.\n\n    Returns:\n        RedisResponseType: The rank (index) of the member, or None if not found.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zrem","title":"<code>archipy.adapters.redis.ports.RedisPort.zrem(name, *values)</code>  <code>abstractmethod</code>","text":"<p>Removes one or more members from a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of members removed.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Removes one or more members from a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisResponseType: The number of members removed.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zscore","title":"<code>archipy.adapters.redis.ports.RedisPort.zscore(name, value)</code>  <code>abstractmethod</code>","text":"<p>Gets the score of a member in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>value</code> <code>bytes | str | float</code> <p>The member to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The score of the member, or None if not found.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Gets the score of a member in a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        value (bytes | str | float): The member to check.\n\n    Returns:\n        RedisResponseType: The score of the member, or None if not found.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hdel","title":"<code>archipy.adapters.redis.ports.RedisPort.hdel(name, *keys)</code>  <code>abstractmethod</code>","text":"<p>Deletes one or more fields from a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>*keys</code> <code>str | bytes</code> <p>Fields to delete.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of fields deleted.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n    \"\"\"Deletes one or more fields from a hash.\n\n    Args:\n        name (str): The key of the hash.\n        *keys (str | bytes): Fields to delete.\n\n    Returns:\n        RedisIntegerResponseType: The number of fields deleted.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hexists","title":"<code>archipy.adapters.redis.ports.RedisPort.hexists(name, key)</code>  <code>abstractmethod</code>","text":"<p>Checks if a field exists in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>key</code> <code>str</code> <p>The field to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if the field exists, False otherwise.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Checks if a field exists in a hash.\n\n    Args:\n        name (str): The key of the hash.\n        key (str): The field to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if the field exists, False otherwise.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hget","title":"<code>archipy.adapters.redis.ports.RedisPort.hget(name, key)</code>  <code>abstractmethod</code>","text":"<p>Gets the value of a field in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>key</code> <code>str</code> <p>The field to get.</p> required <p>Returns:</p> Type Description <code>Awaitable[str | None] | str | None</code> <p>Awaitable[str | None] | str | None: The value of the field, or None if not found.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n    \"\"\"Gets the value of a field in a hash.\n\n    Args:\n        name (str): The key of the hash.\n        key (str): The field to get.\n\n    Returns:\n        Awaitable[str | None] | str | None: The value of the field, or None if not found.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hgetall","title":"<code>archipy.adapters.redis.ports.RedisPort.hgetall(name)</code>  <code>abstractmethod</code>","text":"<p>Gets all fields and values in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Type Description <code>Awaitable[dict] | dict</code> <p>Awaitable[dict] | dict: A dictionary of field/value pairs.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n    \"\"\"Gets all fields and values in a hash.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        Awaitable[dict] | dict: A dictionary of field/value pairs.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hkeys","title":"<code>archipy.adapters.redis.ports.RedisPort.hkeys(name)</code>  <code>abstractmethod</code>","text":"<p>Gets all fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of fields in the hash.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hkeys(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Gets all fields in a hash.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        RedisListResponseType: A list of fields in the hash.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hlen","title":"<code>archipy.adapters.redis.ports.RedisPort.hlen(name)</code>  <code>abstractmethod</code>","text":"<p>Gets the number of fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of fields in the hash.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hlen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Gets the number of fields in a hash.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        RedisIntegerResponseType: The number of fields in the hash.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hset","title":"<code>archipy.adapters.redis.ports.RedisPort.hset(name, key=None, value=None, mapping=None, items=None)</code>  <code>abstractmethod</code>","text":"<p>Sets one or more fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>key</code> <code>str | bytes</code> <p>A single field to set.</p> <code>None</code> <code>value</code> <code>str | bytes</code> <p>The value for the single field.</p> <code>None</code> <code>mapping</code> <code>dict</code> <p>A dictionary of field/value pairs.</p> <code>None</code> <code>items</code> <code>list</code> <p>A list of field/value pairs.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of fields added or updated.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hset(\n    self,\n    name: str,\n    key: str | bytes | None = None,\n    value: str | bytes | None = None,\n    mapping: dict | None = None,\n    items: list | None = None,\n) -&gt; RedisIntegerResponseType:\n    \"\"\"Sets one or more fields in a hash.\n\n    Args:\n        name (str): The key of the hash.\n        key (str | bytes, optional): A single field to set.\n        value (str | bytes, optional): The value for the single field.\n        mapping (dict, optional): A dictionary of field/value pairs.\n        items (list, optional): A list of field/value pairs.\n\n    Returns:\n        RedisIntegerResponseType: The number of fields added or updated.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hmget","title":"<code>archipy.adapters.redis.ports.RedisPort.hmget(name, keys, *args)</code>  <code>abstractmethod</code>","text":"<p>Gets the values of multiple fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>keys</code> <code>list</code> <p>A list of fields to get.</p> required <code>*args</code> <code>str | bytes</code> <p>Additional fields to get.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of values for the specified fields.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n    \"\"\"Gets the values of multiple fields in a hash.\n\n    Args:\n        name (str): The key of the hash.\n        keys (list): A list of fields to get.\n        *args (str | bytes): Additional fields to get.\n\n    Returns:\n        RedisListResponseType: A list of values for the specified fields.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hvals","title":"<code>archipy.adapters.redis.ports.RedisPort.hvals(name)</code>  <code>abstractmethod</code>","text":"<p>Gets all values in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of values in the hash.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hvals(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Gets all values in a hash.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        RedisListResponseType: A list of values in the hash.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.publish","title":"<code>archipy.adapters.redis.ports.RedisPort.publish(channel, message, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Publishes a message to a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>RedisKeyType</code> <p>The channel to publish to.</p> required <code>message</code> <code>bytes | str</code> <p>The message to publish.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of subscribers that received the message.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Publishes a message to a channel.\n\n    Args:\n        channel (RedisKeyType): The channel to publish to.\n        message (bytes | str): The message to publish.\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: The number of subscribers that received the message.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.pubsub_channels","title":"<code>archipy.adapters.redis.ports.RedisPort.pubsub_channels(pattern='*', **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Lists active channels matching a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>The pattern to match channels. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of active channels.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Lists active channels matching a pattern.\n\n    Args:\n        pattern (RedisPatternType): The pattern to match channels. Defaults to \"*\".\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: A list of active channels.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zincrby","title":"<code>archipy.adapters.redis.ports.RedisPort.zincrby(name, amount, value)</code>  <code>abstractmethod</code>","text":"<p>Increments the score of a member in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>amount</code> <code>float</code> <p>The amount to increment by.</p> required <code>value</code> <code>bytes | str | float</code> <p>The member to increment.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The new score of the member.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Increments the score of a member in a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        amount (float): The amount to increment by.\n        value (bytes | str | float): The member to increment.\n\n    Returns:\n        RedisResponseType: The new score of the member.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.pubsub","title":"<code>archipy.adapters.redis.ports.RedisPort.pubsub(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Returns a pub/sub object for subscribing to channels.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>A pub/sub object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef pubsub(self, **kwargs: Any) -&gt; Any:\n    \"\"\"Returns a pub/sub object for subscribing to channels.\n\n    Args:\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        Any: A pub/sub object.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.get_pipeline","title":"<code>archipy.adapters.redis.ports.RedisPort.get_pipeline(transaction=True, shard_hint=None)</code>  <code>abstractmethod</code>","text":"<p>Returns a pipeline object for batching commands.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Any</code> <p>If True, execute commands in a transaction. Defaults to True.</p> <code>True</code> <code>shard_hint</code> <code>Any</code> <p>Hint for sharding in clustered Redis.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>A pipeline object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; Any:\n    \"\"\"Returns a pipeline object for batching commands.\n\n    Args:\n        transaction (Any): If True, execute commands in a transaction. Defaults to True.\n        shard_hint (Any, optional): Hint for sharding in clustered Redis.\n\n    Returns:\n        Any: A pipeline object.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort</code>","text":"<p>Interface for asynchronous Redis operations providing a standardized access pattern.</p> <p>This interface defines the contract for asynchronous Redis adapters, ensuring consistent implementation of Redis operations across different adapters. It covers all essential Redis functionality including key-value operations, collections (lists, sets, sorted sets, hashes), and pub/sub capabilities.</p> <p>Implementing classes should provide concrete implementations for all methods, typically by wrapping an asynchronous Redis client library.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>class AsyncRedisPort:\n    \"\"\"Interface for asynchronous Redis operations providing a standardized access pattern.\n\n    This interface defines the contract for asynchronous Redis adapters, ensuring consistent\n    implementation of Redis operations across different adapters. It covers all\n    essential Redis functionality including key-value operations, collections\n    (lists, sets, sorted sets, hashes), and pub/sub capabilities.\n\n    Implementing classes should provide concrete implementations for all\n    methods, typically by wrapping an asynchronous Redis client library.\n    \"\"\"\n\n    @abstractmethod\n    async def ping(self) -&gt; RedisResponseType:\n        \"\"\"Tests the connection to the Redis server asynchronously.\n\n        Returns:\n            RedisResponseType: The response from the server, typically \"PONG\".\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def pttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the remaining time to live of a key in milliseconds asynchronously.\n\n        Args:\n            name (bytes | str): The key to check.\n\n        Returns:\n            RedisResponseType: The time to live in milliseconds, or -1 if no TTL, -2 if key doesn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n        \"\"\"Increments the integer value of a key by the given amount asynchronously.\n\n        Args:\n            name (RedisKeyType): The key to increment.\n            amount (int): The amount to increment by. Defaults to 1.\n\n        Returns:\n            RedisResponseType: The new value after incrementing.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def set(\n        self,\n        name: RedisKeyType,\n        value: RedisSetType,\n        ex: RedisExpiryType | None = None,\n        px: RedisExpiryType | None = None,\n        nx: bool = False,\n        xx: bool = False,\n        keepttl: bool = False,\n        get: bool = False,\n        exat: RedisAbsExpiryType | None = None,\n        pxat: RedisAbsExpiryType | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Sets a key to a value with optional expiration and conditions asynchronously.\n\n        Args:\n            name (RedisKeyType): The key to set.\n            value (RedisSetType): The value to set for the key.\n            ex (RedisExpiryType, optional): Expiration time in seconds or timedelta.\n            px (RedisExpiryType, optional): Expiration time in milliseconds or timedelta.\n            nx (bool): If True, set only if the key does not exist. Defaults to False.\n            xx (bool): If True, set only if the key already exists. Defaults to False.\n            keepttl (bool): If True, retain the existing TTL. Defaults to False.\n            get (bool): If True, return the old value before setting. Defaults to False.\n            exat (RedisAbsExpiryType, optional): Absolute expiration time as Unix timestamp or datetime.\n            pxat (RedisAbsExpiryType, optional): Absolute expiration time in milliseconds or datetime.\n\n        Returns:\n            RedisResponseType: The result of the operation, often \"OK\" or the old value if get=True.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get(self, key: str) -&gt; RedisResponseType:\n        \"\"\"Retrieves the value of a key asynchronously.\n\n        Args:\n            key (str): The key to retrieve.\n\n        Returns:\n            RedisResponseType: The value associated with the key, or None if the key doesn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def mget(\n        self,\n        keys: RedisKeyType | Iterable[RedisKeyType],\n        *args: bytes | str,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets the values of multiple keys asynchronously.\n\n        Args:\n            keys (RedisKeyType | Iterable[RedisKeyType]): A single key or iterable of keys.\n            *args (bytes | str): Additional keys.\n\n        Returns:\n            RedisResponseType: A list of values corresponding to the keys.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n        \"\"\"Sets multiple keys to their respective values asynchronously.\n\n        Args:\n            mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of keys to values.\n\n        Returns:\n            RedisResponseType: Typically \"OK\" on success.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Returns all keys matching a pattern asynchronously.\n\n        Args:\n            pattern (RedisPatternType): The pattern to match keys against. Defaults to \"*\".\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: A list of matching keys.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Sets a key to a value and returns its old value asynchronously.\n\n        Args:\n            key (RedisKeyType): The key to set.\n            value (bytes | str | float): The new value to set.\n\n        Returns:\n            RedisResponseType: The old value of the key, or None if it didn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def getdel(self, key: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the value of a key and deletes it asynchronously.\n\n        Args:\n            key (bytes | str): The key to get and delete.\n\n        Returns:\n            RedisResponseType: The value of the key before deletion, or None if it didn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def exists(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Checks if one or more keys exist asynchronously.\n\n        Args:\n            *names (bytes | str): Variable number of keys to check.\n\n        Returns:\n            RedisResponseType: The number of keys that exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def delete(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Deletes one or more keys asynchronously.\n\n        Args:\n            *names (bytes | str): Variable number of keys to delete.\n\n        Returns:\n            RedisResponseType: The number of keys deleted.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Appends a value to a key's string value asynchronously.\n\n        Args:\n            key (RedisKeyType): The key to append to.\n            value (bytes | str | float): The value to append.\n\n        Returns:\n            RedisResponseType: The length of the string after appending.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def ttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the remaining time to live of a key in seconds asynchronously.\n\n        Args:\n            name (bytes | str): The key to check.\n\n        Returns:\n            RedisResponseType: The time to live in seconds, or -1 if no TTL, -2 if key doesn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def type(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Determines the type of value stored at a key asynchronously.\n\n        Args:\n            name (bytes | str): The key to check.\n\n        Returns:\n            RedisResponseType: The type of the key's value (e.g., \"string\", \"list\", etc.).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def llen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Gets the length of a list asynchronously.\n\n        Args:\n            name (str): The key of the list.\n\n        Returns:\n            RedisIntegerResponseType: The number of items in the list.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def lpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Removes and returns the first element(s) of a list asynchronously.\n\n        Args:\n            name (str): The key of the list.\n            count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n        Returns:\n            Any: The popped element(s), or None if the list is empty.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Pushes one or more values to the start of a list asynchronously.\n\n        Args:\n            name (str): The key of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: The length of the list after the push.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n        \"\"\"Gets a range of elements from a list asynchronously.\n\n        Args:\n            name (str): The key of the list.\n            start (int): The starting index (inclusive).\n            end (int): The ending index (inclusive).\n\n        Returns:\n            RedisListResponseType: A list of elements in the specified range.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Removes occurrences of a value from a list asynchronously.\n\n        Args:\n            name (str): The key of the list.\n            count (int): Number of occurrences to remove (0 for all).\n            value (str): The value to remove.\n\n        Returns:\n            RedisIntegerResponseType: The number of elements removed.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def lset(self, name: str, index: int, value: str) -&gt; bool:\n        \"\"\"Sets the value of an element in a list by index asynchronously.\n\n        Args:\n            name (str): The key of the list.\n            index (int): The index to set.\n            value (str): The new value.\n\n        Returns:\n            bool: True if successful.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def rpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Removes and returns the last element(s) of a list asynchronously.\n\n        Args:\n            name (str): The key of the list.\n            count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n        Returns:\n            Any: The popped element(s), or None if the list is empty.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Pushes one or more values to the end of a list asynchronously.\n\n        Args:\n            name (str): The key of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: The length of the list after the push.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def scan(\n        self,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; RedisResponseType:\n        \"\"\"Iterates over keys in the database incrementally asynchronously.\n\n        Args:\n            cursor (int): The cursor position to start scanning. Defaults to 0.\n            match (bytes | str, optional): Pattern to match keys against.\n            count (int, optional): Hint for number of keys to return per iteration.\n            _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: A tuple of (new_cursor, list_of_keys).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def scan_iter(\n        self,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; Iterator:\n        \"\"\"Provides an iterator over keys in the database asynchronously.\n\n        Args:\n            match (bytes | str, optional): Pattern to match keys against.\n            count (int, optional): Hint for number of keys to return per iteration.\n            _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            Iterator: An iterator yielding keys.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def sscan(\n        self,\n        name: RedisKeyType,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Iterates over members of a set incrementally asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the set.\n            cursor (int): The cursor position to start scanning. Defaults to 0.\n            match (bytes | str, optional): Pattern to match members against.\n            count (int, optional): Hint for number of members to return per iteration.\n\n        Returns:\n            RedisResponseType: A tuple of (new_cursor, list_of_members).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def sscan_iter(\n        self,\n        name: RedisKeyType,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; Iterator:\n        \"\"\"Provides an iterator over members of a set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the set.\n            match (bytes | str, optional): Pattern to match members against.\n            count (int, optional): Hint for number of members to return per iteration.\n\n        Returns:\n            Iterator: An iterator yielding set members.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Adds one or more members to a set asynchronously.\n\n        Args:\n            name (str): The key of the set.\n            *values (bytes | str | float): Members to add.\n\n        Returns:\n            RedisIntegerResponseType: The number of members added (excluding duplicates).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def scard(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Gets the number of members in a set asynchronously.\n\n        Args:\n            name (str): The key of the set.\n\n        Returns:\n            RedisIntegerResponseType: The cardinality (size) of the set.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Checks if a value is a member of a set asynchronously.\n\n        Args:\n            name (str): The key of the set.\n            value (str): The value to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if the value is a member, False otherwise.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def smembers(self, name: str) -&gt; RedisSetResponseType:\n        \"\"\"Gets all members of a set asynchronously.\n\n        Args:\n            name (str): The key of the set.\n\n        Returns:\n            RedisSetResponseType: A set of all members.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n        \"\"\"Removes and returns one or more random members from a set asynchronously.\n\n        Args:\n            name (str): The key of the set.\n            count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n        Returns:\n            bytes | float | int | str | list | None: The popped member(s), or None if the set is empty.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Removes one or more members from a set asynchronously.\n\n        Args:\n            name (str): The key of the set.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisIntegerResponseType: The number of members removed.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n        \"\"\"Gets the union of multiple sets asynchronously.\n\n        Args:\n            keys (RedisKeyType): Name of the first key.\n            *args (bytes | str): Additional key names.\n\n        Returns:\n            RedisSetResponseType: A set containing members of the resulting union.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zadd(\n        self,\n        name: RedisKeyType,\n        mapping: Mapping[RedisKeyType, bytes | str | float],\n        nx: bool = False,\n        xx: bool = False,\n        ch: bool = False,\n        incr: bool = False,\n        gt: bool = False,\n        lt: bool = False,\n    ) -&gt; RedisResponseType:\n        \"\"\"Adds members with scores to a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of members to scores.\n            nx (bool): If True, only add new elements. Defaults to False.\n            xx (bool): If True, only update existing elements. Defaults to False.\n            ch (bool): If True, return the number of changed elements. Defaults to False.\n            incr (bool): If True, increment scores instead of setting. Defaults to False.\n            gt (bool): If True, only update if new score is greater. Defaults to False.\n            lt (bool): If True, only update if new score is less. Defaults to False.\n\n        Returns:\n            RedisResponseType: The number of elements added or updated.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zcard(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the number of members in a sorted set asynchronously.\n\n        Args:\n            name (bytes | str): The key of the sorted set.\n\n        Returns:\n            RedisResponseType: The cardinality (size) of the sorted set.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n        \"\"\"Counts members in a sorted set within a score range asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            min (float | str): The minimum score (inclusive).\n            max (float | str): The maximum score (inclusive).\n\n        Returns:\n            RedisResponseType: The number of members within the score range.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Removes and returns members with the highest scores from a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n        Returns:\n            RedisResponseType: A list of (member, score) tuples popped.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Removes and returns members with the lowest scores from a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n        Returns:\n            RedisResponseType: A list of (member, score) tuples popped.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        desc: bool = False,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n        byscore: bool = False,\n        bylex: bool = False,\n        offset: int | None = None,\n        num: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets a range of members from a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            start (int): The starting index or score (depending on byscore).\n            end (int): The ending index or score (depending on byscore).\n            desc (bool): If True, sort in descending order. Defaults to False.\n            withscores (bool): If True, return scores with members. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n            byscore (bool): If True, range by score instead of rank. Defaults to False.\n            bylex (bool): If True, range by lexicographical order. Defaults to False.\n            offset (int, optional): Offset for byscore or bylex.\n            num (int, optional): Number of elements for byscore or bylex.\n\n        Returns:\n            RedisResponseType: A list of members (and scores if withscores=True).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zrevrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets a range of members from a sorted set in reverse order asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            start (int): The starting index.\n            end (int): The ending index.\n            withscores (bool): If True, return scores with members. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n        Returns:\n            RedisResponseType: A list of members (and scores if withscores=True).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zrangebyscore(\n        self,\n        name: RedisKeyType,\n        min: float | str,\n        max: float | str,\n        start: int | None = None,\n        num: int | None = None,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets members from a sorted set by score range asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            min (float | str): The minimum score (inclusive).\n            max (float | str): The maximum score (inclusive).\n            start (int, optional): Starting offset.\n            num (int, optional): Number of elements to return.\n            withscores (bool): If True, return scores with members. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n        Returns:\n            RedisResponseType: A list of members (and scores if withscores=True).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Gets the rank of a member in a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            value (bytes | str | float): The member to find.\n\n        Returns:\n            RedisResponseType: The rank (index) of the member, or None if not found.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Removes one or more members from a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisResponseType: The number of members removed.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Gets the score of a member in a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            value (bytes | str | float): The member to check.\n\n        Returns:\n            RedisResponseType: The score of the member, or None if not found.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n        \"\"\"Deletes one or more fields from a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n            *keys (str | bytes): Fields to delete.\n\n        Returns:\n            RedisIntegerResponseType: The number of fields deleted.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Checks if a field exists in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n            key (str): The field to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if the field exists, False otherwise.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n        \"\"\"Gets the value of a field in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n            key (str): The field to get.\n\n        Returns:\n            Awaitable[str | None] | str | None: The value of the field, or None if not found.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n        \"\"\"Gets all fields and values in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            Awaitable[dict] | dict: A dictionary of field/value pairs.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hkeys(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Gets all fields in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            RedisListResponseType: A list of fields in the hash.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hlen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Gets the number of fields in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            RedisIntegerResponseType: The number of fields in the hash.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hset(\n        self,\n        name: str,\n        key: str | bytes | None = None,\n        value: str | bytes | None = None,\n        mapping: dict | None = None,\n        items: list | None = None,\n    ) -&gt; RedisIntegerResponseType:\n        \"\"\"Sets one or more fields in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n            key (str | bytes, optional): A single field to set.\n            value (str | bytes, optional): The value for the single field.\n            mapping (dict, optional): A dictionary of field/value pairs.\n            items (list, optional): A list of field/value pairs.\n\n        Returns:\n            RedisIntegerResponseType: The number of fields added or updated.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n        \"\"\"Gets the values of multiple fields in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n            keys (list): A list of fields to get.\n            *args (str | bytes): Additional fields to get.\n\n        Returns:\n            RedisListResponseType: A list of values for the specified fields.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hvals(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Gets all values in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            RedisListResponseType: A list of values in the hash.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Publishes a message to a channel asynchronously.\n\n        Args:\n            channel (RedisKeyType): The channel to publish to.\n            message (bytes | str): The message to publish.\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: The number of subscribers that received the message.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Lists active channels matching a pattern asynchronously.\n\n        Args:\n            pattern (RedisPatternType): The pattern to match channels. Defaults to \"*\".\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: A list of active channels.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Increments the score of a member in a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            amount (float): The amount to increment by.\n            value (bytes | str | float): The member to increment.\n\n        Returns:\n            RedisResponseType: The new score of the member.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def pubsub(self, **kwargs: Any) -&gt; Any:\n        \"\"\"Returns a pub/sub object for subscribing to channels asynchronously.\n\n        Args:\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            Any: A pub/sub object.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; Any:\n        \"\"\"Returns a pipeline object for batching commands asynchronously.\n\n        Args:\n            transaction (Any): If True, execute commands in a transaction. Defaults to True.\n            shard_hint (Any, optional): Hint for sharding in clustered Redis.\n\n        Returns:\n            Any: A pipeline object.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.ping","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.ping()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Tests the connection to the Redis server asynchronously.</p> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The response from the server, typically \"PONG\".</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def ping(self) -&gt; RedisResponseType:\n    \"\"\"Tests the connection to the Redis server asynchronously.\n\n    Returns:\n        RedisResponseType: The response from the server, typically \"PONG\".\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.pttl","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.pttl(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the remaining time to live of a key in milliseconds asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The time to live in milliseconds, or -1 if no TTL, -2 if key doesn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def pttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the remaining time to live of a key in milliseconds asynchronously.\n\n    Args:\n        name (bytes | str): The key to check.\n\n    Returns:\n        RedisResponseType: The time to live in milliseconds, or -1 if no TTL, -2 if key doesn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.incrby","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.incrby(name, amount=1)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Increments the integer value of a key by the given amount asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key to increment.</p> required <code>amount</code> <code>int</code> <p>The amount to increment by. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The new value after incrementing.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n    \"\"\"Increments the integer value of a key by the given amount asynchronously.\n\n    Args:\n        name (RedisKeyType): The key to increment.\n        amount (int): The amount to increment by. Defaults to 1.\n\n    Returns:\n        RedisResponseType: The new value after incrementing.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.set","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.set(name, value, ex=None, px=None, nx=False, xx=False, keepttl=False, get=False, exat=None, pxat=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Sets a key to a value with optional expiration and conditions asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key to set.</p> required <code>value</code> <code>RedisSetType</code> <p>The value to set for the key.</p> required <code>ex</code> <code>RedisExpiryType</code> <p>Expiration time in seconds or timedelta.</p> <code>None</code> <code>px</code> <code>RedisExpiryType</code> <p>Expiration time in milliseconds or timedelta.</p> <code>None</code> <code>nx</code> <code>bool</code> <p>If True, set only if the key does not exist. Defaults to False.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>If True, set only if the key already exists. Defaults to False.</p> <code>False</code> <code>keepttl</code> <code>bool</code> <p>If True, retain the existing TTL. Defaults to False.</p> <code>False</code> <code>get</code> <code>bool</code> <p>If True, return the old value before setting. Defaults to False.</p> <code>False</code> <code>exat</code> <code>RedisAbsExpiryType</code> <p>Absolute expiration time as Unix timestamp or datetime.</p> <code>None</code> <code>pxat</code> <code>RedisAbsExpiryType</code> <p>Absolute expiration time in milliseconds or datetime.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The result of the operation, often \"OK\" or the old value if get=True.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def set(\n    self,\n    name: RedisKeyType,\n    value: RedisSetType,\n    ex: RedisExpiryType | None = None,\n    px: RedisExpiryType | None = None,\n    nx: bool = False,\n    xx: bool = False,\n    keepttl: bool = False,\n    get: bool = False,\n    exat: RedisAbsExpiryType | None = None,\n    pxat: RedisAbsExpiryType | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Sets a key to a value with optional expiration and conditions asynchronously.\n\n    Args:\n        name (RedisKeyType): The key to set.\n        value (RedisSetType): The value to set for the key.\n        ex (RedisExpiryType, optional): Expiration time in seconds or timedelta.\n        px (RedisExpiryType, optional): Expiration time in milliseconds or timedelta.\n        nx (bool): If True, set only if the key does not exist. Defaults to False.\n        xx (bool): If True, set only if the key already exists. Defaults to False.\n        keepttl (bool): If True, retain the existing TTL. Defaults to False.\n        get (bool): If True, return the old value before setting. Defaults to False.\n        exat (RedisAbsExpiryType, optional): Absolute expiration time as Unix timestamp or datetime.\n        pxat (RedisAbsExpiryType, optional): Absolute expiration time in milliseconds or datetime.\n\n    Returns:\n        RedisResponseType: The result of the operation, often \"OK\" or the old value if get=True.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.get","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.get(key)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Retrieves the value of a key asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to retrieve.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value associated with the key, or None if the key doesn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def get(self, key: str) -&gt; RedisResponseType:\n    \"\"\"Retrieves the value of a key asynchronously.\n\n    Args:\n        key (str): The key to retrieve.\n\n    Returns:\n        RedisResponseType: The value associated with the key, or None if the key doesn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.mget","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.mget(keys, *args)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the values of multiple keys asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType | Iterable[RedisKeyType]</code> <p>A single key or iterable of keys.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional keys.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of values corresponding to the keys.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def mget(\n    self,\n    keys: RedisKeyType | Iterable[RedisKeyType],\n    *args: bytes | str,\n) -&gt; RedisResponseType:\n    \"\"\"Gets the values of multiple keys asynchronously.\n\n    Args:\n        keys (RedisKeyType | Iterable[RedisKeyType]): A single key or iterable of keys.\n        *args (bytes | str): Additional keys.\n\n    Returns:\n        RedisResponseType: A list of values corresponding to the keys.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.mset","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.mset(mapping)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Sets multiple keys to their respective values asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>A mapping of keys to values.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Typically \"OK\" on success.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n    \"\"\"Sets multiple keys to their respective values asynchronously.\n\n    Args:\n        mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of keys to values.\n\n    Returns:\n        RedisResponseType: Typically \"OK\" on success.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.keys","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.keys(pattern='*', **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Returns all keys matching a pattern asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>The pattern to match keys against. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of matching keys.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Returns all keys matching a pattern asynchronously.\n\n    Args:\n        pattern (RedisPatternType): The pattern to match keys against. Defaults to \"*\".\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: A list of matching keys.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.getset","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.getset(key, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Sets a key to a value and returns its old value asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key to set.</p> required <code>value</code> <code>bytes | str | float</code> <p>The new value to set.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The old value of the key, or None if it didn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Sets a key to a value and returns its old value asynchronously.\n\n    Args:\n        key (RedisKeyType): The key to set.\n        value (bytes | str | float): The new value to set.\n\n    Returns:\n        RedisResponseType: The old value of the key, or None if it didn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.getdel","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.getdel(key)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the value of a key and deletes it asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes | str</code> <p>The key to get and delete.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value of the key before deletion, or None if it didn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def getdel(self, key: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the value of a key and deletes it asynchronously.\n\n    Args:\n        key (bytes | str): The key to get and delete.\n\n    Returns:\n        RedisResponseType: The value of the key before deletion, or None if it didn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.exists","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.exists(*names)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Checks if one or more keys exist asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of keys to check.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of keys that exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def exists(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Checks if one or more keys exist asynchronously.\n\n    Args:\n        *names (bytes | str): Variable number of keys to check.\n\n    Returns:\n        RedisResponseType: The number of keys that exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.delete","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.delete(*names)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Deletes one or more keys asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of keys to delete.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of keys deleted.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def delete(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Deletes one or more keys asynchronously.\n\n    Args:\n        *names (bytes | str): Variable number of keys to delete.\n\n    Returns:\n        RedisResponseType: The number of keys deleted.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.append","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.append(key, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Appends a value to a key's string value asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key to append to.</p> required <code>value</code> <code>bytes | str | float</code> <p>The value to append.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The length of the string after appending.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Appends a value to a key's string value asynchronously.\n\n    Args:\n        key (RedisKeyType): The key to append to.\n        value (bytes | str | float): The value to append.\n\n    Returns:\n        RedisResponseType: The length of the string after appending.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.ttl","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.ttl(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the remaining time to live of a key in seconds asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The time to live in seconds, or -1 if no TTL, -2 if key doesn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def ttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the remaining time to live of a key in seconds asynchronously.\n\n    Args:\n        name (bytes | str): The key to check.\n\n    Returns:\n        RedisResponseType: The time to live in seconds, or -1 if no TTL, -2 if key doesn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.type","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.type(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Determines the type of value stored at a key asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The type of the key's value (e.g., \"string\", \"list\", etc.).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def type(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Determines the type of value stored at a key asynchronously.\n\n    Args:\n        name (bytes | str): The key to check.\n\n    Returns:\n        RedisResponseType: The type of the key's value (e.g., \"string\", \"list\", etc.).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.llen","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.llen(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the length of a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of items in the list.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def llen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Gets the length of a list asynchronously.\n\n    Args:\n        name (str): The key of the list.\n\n    Returns:\n        RedisIntegerResponseType: The number of items in the list.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.lpop","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.lpop(name, count=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes and returns the first element(s) of a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>Number of elements to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The popped element(s), or None if the list is empty.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def lpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Removes and returns the first element(s) of a list asynchronously.\n\n    Args:\n        name (str): The key of the list.\n        count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n    Returns:\n        Any: The popped element(s), or None if the list is empty.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.lpush","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.lpush(name, *values)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Pushes one or more values to the start of a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The length of the list after the push.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Pushes one or more values to the start of a list asynchronously.\n\n    Args:\n        name (str): The key of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: The length of the list after the push.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.lrange","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.lrange(name, start, end)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets a range of elements from a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>start</code> <code>int</code> <p>The starting index (inclusive).</p> required <code>end</code> <code>int</code> <p>The ending index (inclusive).</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of elements in the specified range.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n    \"\"\"Gets a range of elements from a list asynchronously.\n\n    Args:\n        name (str): The key of the list.\n        start (int): The starting index (inclusive).\n        end (int): The ending index (inclusive).\n\n    Returns:\n        RedisListResponseType: A list of elements in the specified range.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.lrem","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.lrem(name, count, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes occurrences of a value from a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>Number of occurrences to remove (0 for all).</p> required <code>value</code> <code>str</code> <p>The value to remove.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of elements removed.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Removes occurrences of a value from a list asynchronously.\n\n    Args:\n        name (str): The key of the list.\n        count (int): Number of occurrences to remove (0 for all).\n        value (str): The value to remove.\n\n    Returns:\n        RedisIntegerResponseType: The number of elements removed.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.lset","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.lset(name, index, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Sets the value of an element in a list by index asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>index</code> <code>int</code> <p>The index to set.</p> required <code>value</code> <code>str</code> <p>The new value.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def lset(self, name: str, index: int, value: str) -&gt; bool:\n    \"\"\"Sets the value of an element in a list by index asynchronously.\n\n    Args:\n        name (str): The key of the list.\n        index (int): The index to set.\n        value (str): The new value.\n\n    Returns:\n        bool: True if successful.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.rpop","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.rpop(name, count=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes and returns the last element(s) of a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>Number of elements to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The popped element(s), or None if the list is empty.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def rpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Removes and returns the last element(s) of a list asynchronously.\n\n    Args:\n        name (str): The key of the list.\n        count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n    Returns:\n        Any: The popped element(s), or None if the list is empty.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.rpush","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.rpush(name, *values)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Pushes one or more values to the end of a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The length of the list after the push.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Pushes one or more values to the end of a list asynchronously.\n\n    Args:\n        name (str): The key of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: The length of the list after the push.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.scan","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.scan(cursor=0, match=None, count=None, _type=None, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Iterates over keys in the database incrementally asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>int</code> <p>The cursor position to start scanning. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str</code> <p>Pattern to match keys against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of keys to return per iteration.</p> <code>None</code> <code>_type</code> <code>str</code> <p>Filter by type (e.g., \"string\", \"list\").</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A tuple of (new_cursor, list_of_keys).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def scan(\n    self,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; RedisResponseType:\n    \"\"\"Iterates over keys in the database incrementally asynchronously.\n\n    Args:\n        cursor (int): The cursor position to start scanning. Defaults to 0.\n        match (bytes | str, optional): Pattern to match keys against.\n        count (int, optional): Hint for number of keys to return per iteration.\n        _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: A tuple of (new_cursor, list_of_keys).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.scan_iter","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.scan_iter(match=None, count=None, _type=None, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Provides an iterator over keys in the database asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>match</code> <code>bytes | str</code> <p>Pattern to match keys against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of keys to return per iteration.</p> <code>None</code> <code>_type</code> <code>str</code> <p>Filter by type (e.g., \"string\", \"list\").</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Iterator</code> <code>Iterator</code> <p>An iterator yielding keys.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def scan_iter(\n    self,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; Iterator:\n    \"\"\"Provides an iterator over keys in the database asynchronously.\n\n    Args:\n        match (bytes | str, optional): Pattern to match keys against.\n        count (int, optional): Hint for number of keys to return per iteration.\n        _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        Iterator: An iterator yielding keys.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.sscan","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.sscan(name, cursor=0, match=None, count=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Iterates over members of a set incrementally asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the set.</p> required <code>cursor</code> <code>int</code> <p>The cursor position to start scanning. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str</code> <p>Pattern to match members against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of members to return per iteration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A tuple of (new_cursor, list_of_members).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def sscan(\n    self,\n    name: RedisKeyType,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Iterates over members of a set incrementally asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the set.\n        cursor (int): The cursor position to start scanning. Defaults to 0.\n        match (bytes | str, optional): Pattern to match members against.\n        count (int, optional): Hint for number of members to return per iteration.\n\n    Returns:\n        RedisResponseType: A tuple of (new_cursor, list_of_members).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.sscan_iter","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.sscan_iter(name, match=None, count=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Provides an iterator over members of a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the set.</p> required <code>match</code> <code>bytes | str</code> <p>Pattern to match members against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of members to return per iteration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Iterator</code> <code>Iterator</code> <p>An iterator yielding set members.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def sscan_iter(\n    self,\n    name: RedisKeyType,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; Iterator:\n    \"\"\"Provides an iterator over members of a set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the set.\n        match (bytes | str, optional): Pattern to match members against.\n        count (int, optional): Hint for number of members to return per iteration.\n\n    Returns:\n        Iterator: An iterator yielding set members.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.sadd","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.sadd(name, *values)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Adds one or more members to a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to add.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of members added (excluding duplicates).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Adds one or more members to a set asynchronously.\n\n    Args:\n        name (str): The key of the set.\n        *values (bytes | str | float): Members to add.\n\n    Returns:\n        RedisIntegerResponseType: The number of members added (excluding duplicates).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.scard","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.scard(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the number of members in a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The cardinality (size) of the set.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def scard(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Gets the number of members in a set asynchronously.\n\n    Args:\n        name (str): The key of the set.\n\n    Returns:\n        RedisIntegerResponseType: The cardinality (size) of the set.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.sismember","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.sismember(name, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Checks if a value is a member of a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>value</code> <code>str</code> <p>The value to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if the value is a member, False otherwise.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Checks if a value is a member of a set asynchronously.\n\n    Args:\n        name (str): The key of the set.\n        value (str): The value to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if the value is a member, False otherwise.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.smembers","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.smembers(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets all members of a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>A set of all members.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def smembers(self, name: str) -&gt; RedisSetResponseType:\n    \"\"\"Gets all members of a set asynchronously.\n\n    Args:\n        name (str): The key of the set.\n\n    Returns:\n        RedisSetResponseType: A set of all members.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.spop","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.spop(name, count=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes and returns one or more random members from a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>count</code> <code>int</code> <p>Number of members to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | float | int | str | list | None</code> <p>bytes | float | int | str | list | None: The popped member(s), or None if the set is empty.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n    \"\"\"Removes and returns one or more random members from a set asynchronously.\n\n    Args:\n        name (str): The key of the set.\n        count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n    Returns:\n        bytes | float | int | str | list | None: The popped member(s), or None if the set is empty.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.srem","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.srem(name, *values)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes one or more members from a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of members removed.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Removes one or more members from a set asynchronously.\n\n    Args:\n        name (str): The key of the set.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisIntegerResponseType: The number of members removed.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.sunion","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.sunion(keys, *args)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the union of multiple sets asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType</code> <p>Name of the first key.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional key names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>A set containing members of the resulting union.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n    \"\"\"Gets the union of multiple sets asynchronously.\n\n    Args:\n        keys (RedisKeyType): Name of the first key.\n        *args (bytes | str): Additional key names.\n\n    Returns:\n        RedisSetResponseType: A set containing members of the resulting union.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zadd","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zadd(name, mapping, nx=False, xx=False, ch=False, incr=False, gt=False, lt=False)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Adds members with scores to a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>A mapping of members to scores.</p> required <code>nx</code> <code>bool</code> <p>If True, only add new elements. Defaults to False.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>If True, only update existing elements. Defaults to False.</p> <code>False</code> <code>ch</code> <code>bool</code> <p>If True, return the number of changed elements. Defaults to False.</p> <code>False</code> <code>incr</code> <code>bool</code> <p>If True, increment scores instead of setting. Defaults to False.</p> <code>False</code> <code>gt</code> <code>bool</code> <p>If True, only update if new score is greater. Defaults to False.</p> <code>False</code> <code>lt</code> <code>bool</code> <p>If True, only update if new score is less. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of elements added or updated.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zadd(\n    self,\n    name: RedisKeyType,\n    mapping: Mapping[RedisKeyType, bytes | str | float],\n    nx: bool = False,\n    xx: bool = False,\n    ch: bool = False,\n    incr: bool = False,\n    gt: bool = False,\n    lt: bool = False,\n) -&gt; RedisResponseType:\n    \"\"\"Adds members with scores to a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of members to scores.\n        nx (bool): If True, only add new elements. Defaults to False.\n        xx (bool): If True, only update existing elements. Defaults to False.\n        ch (bool): If True, return the number of changed elements. Defaults to False.\n        incr (bool): If True, increment scores instead of setting. Defaults to False.\n        gt (bool): If True, only update if new score is greater. Defaults to False.\n        lt (bool): If True, only update if new score is less. Defaults to False.\n\n    Returns:\n        RedisResponseType: The number of elements added or updated.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zcard","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zcard(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the number of members in a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key of the sorted set.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The cardinality (size) of the sorted set.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zcard(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the number of members in a sorted set asynchronously.\n\n    Args:\n        name (bytes | str): The key of the sorted set.\n\n    Returns:\n        RedisResponseType: The cardinality (size) of the sorted set.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zcount","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zcount(name, min, max)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Counts members in a sorted set within a score range asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>min</code> <code>float | str</code> <p>The minimum score (inclusive).</p> required <code>max</code> <code>float | str</code> <p>The maximum score (inclusive).</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of members within the score range.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n    \"\"\"Counts members in a sorted set within a score range asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        min (float | str): The minimum score (inclusive).\n        max (float | str): The maximum score (inclusive).\n\n    Returns:\n        RedisResponseType: The number of members within the score range.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zpopmax","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zpopmax(name, count=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes and returns members with the highest scores from a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>count</code> <code>int</code> <p>Number of members to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of (member, score) tuples popped.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Removes and returns members with the highest scores from a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n    Returns:\n        RedisResponseType: A list of (member, score) tuples popped.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zpopmin","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zpopmin(name, count=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes and returns members with the lowest scores from a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>count</code> <code>int</code> <p>Number of members to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of (member, score) tuples popped.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Removes and returns members with the lowest scores from a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n    Returns:\n        RedisResponseType: A list of (member, score) tuples popped.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zrange","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zrange(name, start, end, desc=False, withscores=False, score_cast_func=float, byscore=False, bylex=False, offset=None, num=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets a range of members from a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>start</code> <code>int</code> <p>The starting index or score (depending on byscore).</p> required <code>end</code> <code>int</code> <p>The ending index or score (depending on byscore).</p> required <code>desc</code> <code>bool</code> <p>If True, sort in descending order. Defaults to False.</p> <code>False</code> <code>withscores</code> <code>bool</code> <p>If True, return scores with members. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <code>byscore</code> <code>bool</code> <p>If True, range by score instead of rank. Defaults to False.</p> <code>False</code> <code>bylex</code> <code>bool</code> <p>If True, range by lexicographical order. Defaults to False.</p> <code>False</code> <code>offset</code> <code>int</code> <p>Offset for byscore or bylex.</p> <code>None</code> <code>num</code> <code>int</code> <p>Number of elements for byscore or bylex.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of members (and scores if withscores=True).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    desc: bool = False,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n    byscore: bool = False,\n    bylex: bool = False,\n    offset: int | None = None,\n    num: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Gets a range of members from a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        start (int): The starting index or score (depending on byscore).\n        end (int): The ending index or score (depending on byscore).\n        desc (bool): If True, sort in descending order. Defaults to False.\n        withscores (bool): If True, return scores with members. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n        byscore (bool): If True, range by score instead of rank. Defaults to False.\n        bylex (bool): If True, range by lexicographical order. Defaults to False.\n        offset (int, optional): Offset for byscore or bylex.\n        num (int, optional): Number of elements for byscore or bylex.\n\n    Returns:\n        RedisResponseType: A list of members (and scores if withscores=True).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zrevrange","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zrevrange(name, start, end, withscores=False, score_cast_func=float)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets a range of members from a sorted set in reverse order asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>start</code> <code>int</code> <p>The starting index.</p> required <code>end</code> <code>int</code> <p>The ending index.</p> required <code>withscores</code> <code>bool</code> <p>If True, return scores with members. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of members (and scores if withscores=True).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zrevrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Gets a range of members from a sorted set in reverse order asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        start (int): The starting index.\n        end (int): The ending index.\n        withscores (bool): If True, return scores with members. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n    Returns:\n        RedisResponseType: A list of members (and scores if withscores=True).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zrangebyscore","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=float)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets members from a sorted set by score range asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>min</code> <code>float | str</code> <p>The minimum score (inclusive).</p> required <code>max</code> <code>float | str</code> <p>The maximum score (inclusive).</p> required <code>start</code> <code>int</code> <p>Starting offset.</p> <code>None</code> <code>num</code> <code>int</code> <p>Number of elements to return.</p> <code>None</code> <code>withscores</code> <code>bool</code> <p>If True, return scores with members. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of members (and scores if withscores=True).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zrangebyscore(\n    self,\n    name: RedisKeyType,\n    min: float | str,\n    max: float | str,\n    start: int | None = None,\n    num: int | None = None,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Gets members from a sorted set by score range asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        min (float | str): The minimum score (inclusive).\n        max (float | str): The maximum score (inclusive).\n        start (int, optional): Starting offset.\n        num (int, optional): Number of elements to return.\n        withscores (bool): If True, return scores with members. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n    Returns:\n        RedisResponseType: A list of members (and scores if withscores=True).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zrank","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zrank(name, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the rank of a member in a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>value</code> <code>bytes | str | float</code> <p>The member to find.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The rank (index) of the member, or None if not found.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Gets the rank of a member in a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        value (bytes | str | float): The member to find.\n\n    Returns:\n        RedisResponseType: The rank (index) of the member, or None if not found.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zrem","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zrem(name, *values)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes one or more members from a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of members removed.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Removes one or more members from a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisResponseType: The number of members removed.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zscore","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zscore(name, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the score of a member in a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>value</code> <code>bytes | str | float</code> <p>The member to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The score of the member, or None if not found.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Gets the score of a member in a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        value (bytes | str | float): The member to check.\n\n    Returns:\n        RedisResponseType: The score of the member, or None if not found.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hdel","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hdel(name, *keys)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Deletes one or more fields from a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>*keys</code> <code>str | bytes</code> <p>Fields to delete.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of fields deleted.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n    \"\"\"Deletes one or more fields from a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n        *keys (str | bytes): Fields to delete.\n\n    Returns:\n        RedisIntegerResponseType: The number of fields deleted.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hexists","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hexists(name, key)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Checks if a field exists in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>key</code> <code>str</code> <p>The field to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if the field exists, False otherwise.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Checks if a field exists in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n        key (str): The field to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if the field exists, False otherwise.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hget","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hget(name, key)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the value of a field in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>key</code> <code>str</code> <p>The field to get.</p> required <p>Returns:</p> Type Description <code>Awaitable[str | None] | str | None</code> <p>Awaitable[str | None] | str | None: The value of the field, or None if not found.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n    \"\"\"Gets the value of a field in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n        key (str): The field to get.\n\n    Returns:\n        Awaitable[str | None] | str | None: The value of the field, or None if not found.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hgetall","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hgetall(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets all fields and values in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Type Description <code>Awaitable[dict] | dict</code> <p>Awaitable[dict] | dict: A dictionary of field/value pairs.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n    \"\"\"Gets all fields and values in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        Awaitable[dict] | dict: A dictionary of field/value pairs.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hkeys","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hkeys(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets all fields in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of fields in the hash.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hkeys(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Gets all fields in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        RedisListResponseType: A list of fields in the hash.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hlen","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hlen(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the number of fields in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of fields in the hash.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hlen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Gets the number of fields in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        RedisIntegerResponseType: The number of fields in the hash.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hset","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hset(name, key=None, value=None, mapping=None, items=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Sets one or more fields in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>key</code> <code>str | bytes</code> <p>A single field to set.</p> <code>None</code> <code>value</code> <code>str | bytes</code> <p>The value for the single field.</p> <code>None</code> <code>mapping</code> <code>dict</code> <p>A dictionary of field/value pairs.</p> <code>None</code> <code>items</code> <code>list</code> <p>A list of field/value pairs.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of fields added or updated.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hset(\n    self,\n    name: str,\n    key: str | bytes | None = None,\n    value: str | bytes | None = None,\n    mapping: dict | None = None,\n    items: list | None = None,\n) -&gt; RedisIntegerResponseType:\n    \"\"\"Sets one or more fields in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n        key (str | bytes, optional): A single field to set.\n        value (str | bytes, optional): The value for the single field.\n        mapping (dict, optional): A dictionary of field/value pairs.\n        items (list, optional): A list of field/value pairs.\n\n    Returns:\n        RedisIntegerResponseType: The number of fields added or updated.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hmget","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hmget(name, keys, *args)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the values of multiple fields in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>keys</code> <code>list</code> <p>A list of fields to get.</p> required <code>*args</code> <code>str | bytes</code> <p>Additional fields to get.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of values for the specified fields.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n    \"\"\"Gets the values of multiple fields in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n        keys (list): A list of fields to get.\n        *args (str | bytes): Additional fields to get.\n\n    Returns:\n        RedisListResponseType: A list of values for the specified fields.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hvals","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hvals(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets all values in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of values in the hash.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hvals(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Gets all values in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        RedisListResponseType: A list of values in the hash.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.publish","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.publish(channel, message, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Publishes a message to a channel asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>RedisKeyType</code> <p>The channel to publish to.</p> required <code>message</code> <code>bytes | str</code> <p>The message to publish.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of subscribers that received the message.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Publishes a message to a channel asynchronously.\n\n    Args:\n        channel (RedisKeyType): The channel to publish to.\n        message (bytes | str): The message to publish.\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: The number of subscribers that received the message.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.pubsub_channels","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.pubsub_channels(pattern='*', **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Lists active channels matching a pattern asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>The pattern to match channels. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of active channels.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Lists active channels matching a pattern asynchronously.\n\n    Args:\n        pattern (RedisPatternType): The pattern to match channels. Defaults to \"*\".\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: A list of active channels.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zincrby","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zincrby(name, amount, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Increments the score of a member in a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>amount</code> <code>float</code> <p>The amount to increment by.</p> required <code>value</code> <code>bytes | str | float</code> <p>The member to increment.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The new score of the member.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Increments the score of a member in a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        amount (float): The amount to increment by.\n        value (bytes | str | float): The member to increment.\n\n    Returns:\n        RedisResponseType: The new score of the member.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.pubsub","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.pubsub(**kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Returns a pub/sub object for subscribing to channels asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>A pub/sub object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def pubsub(self, **kwargs: Any) -&gt; Any:\n    \"\"\"Returns a pub/sub object for subscribing to channels asynchronously.\n\n    Args:\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        Any: A pub/sub object.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.get_pipeline","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.get_pipeline(transaction=True, shard_hint=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Returns a pipeline object for batching commands asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Any</code> <p>If True, execute commands in a transaction. Defaults to True.</p> <code>True</code> <code>shard_hint</code> <code>Any</code> <p>Hint for sharding in clustered Redis.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>A pipeline object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; Any:\n    \"\"\"Returns a pipeline object for batching commands asynchronously.\n\n    Args:\n        transaction (Any): If True, execute commands in a transaction. Defaults to True.\n        shard_hint (Any, optional): Hint for sharding in clustered Redis.\n\n    Returns:\n        Any: A pipeline object.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#kafka","title":"Kafka","text":"<p>Kafka integration for message streaming and event-driven architectures.</p> <pre><code>from archipy.adapters.kafka import KafkaAdapter\n\n# Create a Kafka adapter\nkafka = KafkaAdapter()  # Uses global config by default\n\n# Publish a message\nkafka.publish(\"my-topic\", \"Hello, Kafka!\")\n\n# Consume messages\ndef process_message(message: dict[str, Any]) -&gt; None:\n    print(f\"Received: {message['value']}\")\n\nkafka.consume(\"my-topic\", process_message)\n</code></pre> <p>For detailed examples and usage guidelines, see the Kafka Adapter Examples.</p> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaExceptionHandlerMixin","title":"<code>archipy.adapters.kafka.adapters.KafkaExceptionHandlerMixin</code>","text":"<p>Mixin class to handle Kafka exceptions in a consistent way.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>class KafkaExceptionHandlerMixin:\n    \"\"\"Mixin class to handle Kafka exceptions in a consistent way.\"\"\"\n\n    @classmethod\n    def _handle_kafka_exception(cls, exception: Exception, operation: str) -&gt; None:\n        \"\"\"Handle Kafka exceptions and map them to appropriate application errors.\n\n        Args:\n            exception: The original exception\n            operation: The name of the operation that failed\n\n        Raises:\n            Various application-specific errors based on the exception type/content\n        \"\"\"\n        error_msg = str(exception).lower()\n\n        # Configuration errors\n        if \"configuration\" in error_msg:\n            raise ConfigurationError(config_key=\"kafka\") from exception\n\n        # Invalid argument errors\n        if \"invalid\" in error_msg:\n            raise InvalidArgumentError(argument_name=operation) from exception\n\n        # Timeout errors\n        if \"timeout\" in error_msg:\n            # Extract timeout value if available\n            timeout = None\n            if hasattr(exception, \"args\") and len(exception.args) &gt; 1:\n                try:\n                    timeout = int(exception.args[1])\n                except (IndexError, ValueError):\n                    pass\n            raise ConnectionTimeoutError(service=\"Kafka\", timeout=timeout) from exception\n\n        # Network/connectivity errors\n        if \"network\" in error_msg:\n            raise NetworkError(service=\"Kafka\") from exception\n\n        # Service availability errors\n        if \"unavailable\" in error_msg or \"connection\" in error_msg:\n            raise ServiceUnavailableError(service=\"Kafka\") from exception\n        raise InternalError(additional_data={\"operation\": operation}) from exception\n\n    @classmethod\n    def _handle_producer_exception(cls, exception: Exception, operation: str) -&gt; None:\n        \"\"\"Handle producer-specific exceptions.\n\n        Args:\n            exception: The original exception\n            operation: The name of the operation that failed\n\n        Raises:\n            ResourceExhaustedError: If the producer queue is full\n            Various other errors from _handle_kafka_exception\n        \"\"\"\n        # Producer-specific error handling\n        if isinstance(exception, BufferError):\n            raise ResourceExhaustedError(resource_type=\"producer_queue\") from exception\n\n        # Fall back to general Kafka error handling\n        cls._handle_kafka_exception(exception, operation)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaAdminAdapter","title":"<code>archipy.adapters.kafka.adapters.KafkaAdminAdapter</code>","text":"<p>               Bases: <code>KafkaAdminPort</code>, <code>KafkaExceptionHandlerMixin</code></p> <p>Synchronous Kafka admin adapter.</p> <p>This adapter provides synchronous administrative operations for Kafka topics. It implements the KafkaAdminPort interface and handles topic creation, deletion, and listing operations.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>class KafkaAdminAdapter(KafkaAdminPort, KafkaExceptionHandlerMixin):\n    \"\"\"Synchronous Kafka admin adapter.\n\n    This adapter provides synchronous administrative operations for Kafka topics.\n    It implements the KafkaAdminPort interface and handles topic creation, deletion,\n    and listing operations.\n    \"\"\"\n\n    def __init__(self, kafka_configs: KafkaConfig | None = None) -&gt; None:\n        \"\"\"Initializes the admin adapter with Kafka configuration.\n\n        Args:\n            kafka_configs (KafkaConfig | None, optional): Kafka configuration. If None,\n                uses global config. Defaults to None.\n\n        Raises:\n            ConfigurationError: If there is an error in the Kafka configuration.\n            InternalError: If there is an error initializing the admin client.\n        \"\"\"\n        configs: KafkaConfig = kafka_configs or BaseConfig.global_config().KAFKA\n        try:\n            broker_list_csv = \",\".join(configs.BROKERS_LIST)\n            config = {\"bootstrap.servers\": broker_list_csv}\n            if configs.USERNAME and configs.PASSWORD and configs.SSL_CA_FILE:\n                config |= {\n                    \"sasl.username\": configs.USERNAME,\n                    \"sasl.password\": configs.PASSWORD.get_secret_value(),\n                    \"security.protocol\": configs.SECURITY_PROTOCOL,\n                    \"sasl.mechanism\": configs.SASL_MECHANISM,\n                    \"ssl.ca.location\": configs.SSL_CA_FILE,\n                    \"ssl.certificate.location\": configs.SSL_CERT_FILE,\n                    \"ssl.key.location\": configs.SSL_KEY_FILE,\n                    \"ssl.endpoint.identification.algorithm\": \"none\",\n                }\n            self.adapter: AdminClient = AdminClient(config)\n        except Exception as e:\n            self._handle_kafka_exception(e, \"KafkaAdmin_init\")\n\n    @override\n    def create_topic(self, topic: str, num_partitions: int = 1, replication_factor: int = 1) -&gt; None:\n        \"\"\"Creates a new Kafka topic.\n\n        Args:\n            topic (str): Name of the topic to create.\n            num_partitions (int, optional): Number of partitions for the topic. Defaults to 1.\n            replication_factor (int, optional): Replication factor for the topic. Defaults to 1.\n\n        Raises:\n            InvalidArgumentError: If the topic name or partition configuration is invalid.\n            ServiceUnavailableError: If the Kafka service is unavailable during topic creation.\n            InternalError: If there is an internal error creating the topic.\n        \"\"\"\n        try:\n            new_topic = NewTopic(topic, num_partitions, replication_factor)\n            self.adapter.create_topics([new_topic])\n        except Exception as e:\n            self._handle_kafka_exception(e, \"create_topic\")\n\n    @override\n    def delete_topic(self, topics: list[str]) -&gt; None:\n        \"\"\"Deletes one or more Kafka topics.\n\n        Args:\n            topics (list[str]): List of topic names to delete.\n\n        Raises:\n            InvalidArgumentError: If the topics list is invalid.\n            ServiceUnavailableError: If the Kafka service is unavailable during topic deletion.\n            InternalError: If there is an internal error deleting the topics.\n        \"\"\"\n        try:\n            self.adapter.delete_topics(topics)\n            logger.debug(\"Deleted topics: %s\", topics)\n        except Exception as e:\n            self._handle_kafka_exception(e, \"delete_topic\")\n\n    @override\n    def list_topics(self, topic: str | None = None, timeout: int = 1) -&gt; ClusterMetadata:\n        \"\"\"Lists Kafka topics.\n\n        Args:\n            topic (str | None, optional): Specific topic to list. If None, lists all topics.\n                Defaults to None.\n            timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n        Returns:\n            ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n        Raises:\n            ConnectionTimeoutError: If the operation times out.\n            ServiceUnavailableError: If the Kafka service is unavailable.\n            UnavailableError: If there is an unknown issue accessing Kafka.\n        \"\"\"\n        try:\n            result = self.adapter.list_topics(topic=topic, timeout=timeout)\n        except Exception as e:\n            self._handle_kafka_exception(e, \"list_topics\")\n        else:\n            return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaAdminAdapter.__init__","title":"<code>archipy.adapters.kafka.adapters.KafkaAdminAdapter.__init__(kafka_configs=None)</code>","text":"<p>Initializes the admin adapter with Kafka configuration.</p> <p>Parameters:</p> Name Type Description Default <code>kafka_configs</code> <code>KafkaConfig | None</code> <p>Kafka configuration. If None, uses global config. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If there is an error in the Kafka configuration.</p> <code>InternalError</code> <p>If there is an error initializing the admin client.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>def __init__(self, kafka_configs: KafkaConfig | None = None) -&gt; None:\n    \"\"\"Initializes the admin adapter with Kafka configuration.\n\n    Args:\n        kafka_configs (KafkaConfig | None, optional): Kafka configuration. If None,\n            uses global config. Defaults to None.\n\n    Raises:\n        ConfigurationError: If there is an error in the Kafka configuration.\n        InternalError: If there is an error initializing the admin client.\n    \"\"\"\n    configs: KafkaConfig = kafka_configs or BaseConfig.global_config().KAFKA\n    try:\n        broker_list_csv = \",\".join(configs.BROKERS_LIST)\n        config = {\"bootstrap.servers\": broker_list_csv}\n        if configs.USERNAME and configs.PASSWORD and configs.SSL_CA_FILE:\n            config |= {\n                \"sasl.username\": configs.USERNAME,\n                \"sasl.password\": configs.PASSWORD.get_secret_value(),\n                \"security.protocol\": configs.SECURITY_PROTOCOL,\n                \"sasl.mechanism\": configs.SASL_MECHANISM,\n                \"ssl.ca.location\": configs.SSL_CA_FILE,\n                \"ssl.certificate.location\": configs.SSL_CERT_FILE,\n                \"ssl.key.location\": configs.SSL_KEY_FILE,\n                \"ssl.endpoint.identification.algorithm\": \"none\",\n            }\n        self.adapter: AdminClient = AdminClient(config)\n    except Exception as e:\n        self._handle_kafka_exception(e, \"KafkaAdmin_init\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaAdminAdapter.create_topic","title":"<code>archipy.adapters.kafka.adapters.KafkaAdminAdapter.create_topic(topic, num_partitions=1, replication_factor=1)</code>","text":"<p>Creates a new Kafka topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>Name of the topic to create.</p> required <code>num_partitions</code> <code>int</code> <p>Number of partitions for the topic. Defaults to 1.</p> <code>1</code> <code>replication_factor</code> <code>int</code> <p>Replication factor for the topic. Defaults to 1.</p> <code>1</code> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the topic name or partition configuration is invalid.</p> <code>ServiceUnavailableError</code> <p>If the Kafka service is unavailable during topic creation.</p> <code>InternalError</code> <p>If there is an internal error creating the topic.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef create_topic(self, topic: str, num_partitions: int = 1, replication_factor: int = 1) -&gt; None:\n    \"\"\"Creates a new Kafka topic.\n\n    Args:\n        topic (str): Name of the topic to create.\n        num_partitions (int, optional): Number of partitions for the topic. Defaults to 1.\n        replication_factor (int, optional): Replication factor for the topic. Defaults to 1.\n\n    Raises:\n        InvalidArgumentError: If the topic name or partition configuration is invalid.\n        ServiceUnavailableError: If the Kafka service is unavailable during topic creation.\n        InternalError: If there is an internal error creating the topic.\n    \"\"\"\n    try:\n        new_topic = NewTopic(topic, num_partitions, replication_factor)\n        self.adapter.create_topics([new_topic])\n    except Exception as e:\n        self._handle_kafka_exception(e, \"create_topic\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaAdminAdapter.delete_topic","title":"<code>archipy.adapters.kafka.adapters.KafkaAdminAdapter.delete_topic(topics)</code>","text":"<p>Deletes one or more Kafka topics.</p> <p>Parameters:</p> Name Type Description Default <code>topics</code> <code>list[str]</code> <p>List of topic names to delete.</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the topics list is invalid.</p> <code>ServiceUnavailableError</code> <p>If the Kafka service is unavailable during topic deletion.</p> <code>InternalError</code> <p>If there is an internal error deleting the topics.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef delete_topic(self, topics: list[str]) -&gt; None:\n    \"\"\"Deletes one or more Kafka topics.\n\n    Args:\n        topics (list[str]): List of topic names to delete.\n\n    Raises:\n        InvalidArgumentError: If the topics list is invalid.\n        ServiceUnavailableError: If the Kafka service is unavailable during topic deletion.\n        InternalError: If there is an internal error deleting the topics.\n    \"\"\"\n    try:\n        self.adapter.delete_topics(topics)\n        logger.debug(\"Deleted topics: %s\", topics)\n    except Exception as e:\n        self._handle_kafka_exception(e, \"delete_topic\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaAdminAdapter.list_topics","title":"<code>archipy.adapters.kafka.adapters.KafkaAdminAdapter.list_topics(topic=None, timeout=1)</code>","text":"<p>Lists Kafka topics.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str | None</code> <p>Specific topic to list. If None, lists all topics. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>ClusterMetadata</code> <code>ClusterMetadata</code> <p>Metadata about the Kafka cluster and topics.</p> <p>Raises:</p> Type Description <code>ConnectionTimeoutError</code> <p>If the operation times out.</p> <code>ServiceUnavailableError</code> <p>If the Kafka service is unavailable.</p> <code>UnavailableError</code> <p>If there is an unknown issue accessing Kafka.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef list_topics(self, topic: str | None = None, timeout: int = 1) -&gt; ClusterMetadata:\n    \"\"\"Lists Kafka topics.\n\n    Args:\n        topic (str | None, optional): Specific topic to list. If None, lists all topics.\n            Defaults to None.\n        timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n    Returns:\n        ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n    Raises:\n        ConnectionTimeoutError: If the operation times out.\n        ServiceUnavailableError: If the Kafka service is unavailable.\n        UnavailableError: If there is an unknown issue accessing Kafka.\n    \"\"\"\n    try:\n        result = self.adapter.list_topics(topic=topic, timeout=timeout)\n    except Exception as e:\n        self._handle_kafka_exception(e, \"list_topics\")\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaConsumerAdapter","title":"<code>archipy.adapters.kafka.adapters.KafkaConsumerAdapter</code>","text":"<p>               Bases: <code>KafkaConsumerPort</code>, <code>KafkaExceptionHandlerMixin</code></p> <p>Synchronous Kafka consumer adapter.</p> <p>This adapter provides synchronous message consumption from Kafka topics. It implements the KafkaConsumerPort interface and handles message polling, batch consumption, and offset management.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>class KafkaConsumerAdapter(KafkaConsumerPort, KafkaExceptionHandlerMixin):\n    \"\"\"Synchronous Kafka consumer adapter.\n\n    This adapter provides synchronous message consumption from Kafka topics.\n    It implements the KafkaConsumerPort interface and handles message polling,\n    batch consumption, and offset management.\n    \"\"\"\n\n    def __init__(\n        self,\n        group_id: str,\n        topic_list: list[str] | None = None,\n        partition_list: list[TopicPartition] | None = None,\n        kafka_configs: KafkaConfig | None = None,\n    ) -&gt; None:\n        \"\"\"Initializes the consumer adapter with Kafka configuration and subscription.\n\n        Args:\n            group_id (str): Consumer group ID.\n            topic_list (list[str] | None, optional): List of topics to subscribe to.\n                Defaults to None.\n            partition_list (list[TopicPartition] | None, optional): List of partitions\n                to assign. Defaults to None.\n            kafka_configs (KafkaConfig | None, optional): Kafka configuration. If None,\n                uses global config. Defaults to None.\n\n        Raises:\n            InvalidArgumentError: If both topic_list and partition_list are provided or\n                neither is provided.\n            InternalError: If there is an error initializing the consumer.\n        \"\"\"\n        configs: KafkaConfig = kafka_configs or BaseConfig.global_config().KAFKA\n        self._adapter: Consumer = self._get_adapter(group_id, configs)\n        if topic_list and not partition_list:\n            self.subscribe(topic_list)\n        elif not topic_list and partition_list:\n            self.assign(partition_list)\n        else:\n            logger.error(\"Invalid topic or partition list\")\n            raise InvalidArgumentError(\n                argument_name=\"topic_list or partition_list\",\n                additional_data={\"reason\": \"Exactly one of topic_list or partition_list must be provided\"},\n            )\n\n    @classmethod\n    def _get_adapter(cls, group_id: str, configs: KafkaConfig) -&gt; Consumer:\n        \"\"\"Creates and configures a Kafka Consumer instance.\n\n        Args:\n            group_id (str): Consumer group ID.\n            configs (KafkaConfig): Kafka configuration.\n\n        Returns:\n            Consumer: Configured Kafka Consumer instance.\n\n        Raises:\n            ConfigurationError: If there is an error in the Kafka configuration.\n            InternalError: If there is an error creating the consumer.\n        \"\"\"\n        try:\n            broker_list_csv = \",\".join(configs.BROKERS_LIST)\n            config = {\n                \"bootstrap.servers\": broker_list_csv,\n                \"group.id\": group_id,\n                \"session.timeout.ms\": configs.SESSION_TIMEOUT_MS,\n                \"auto.offset.reset\": configs.AUTO_OFFSET_RESET,\n                \"enable.auto.commit\": configs.ENABLE_AUTO_COMMIT,\n                \"fetch.min.bytes\": configs.FETCH_MIN_BYTES,\n                \"heartbeat.interval.ms\": configs.HEARTBEAT_INTERVAL_MS,\n                \"isolation.level\": configs.ISOLATION_LEVEL,\n                \"max.poll.interval.ms\": configs.MAX_POLL_INTERVAL_MS,\n                \"partition.assignment.strategy\": configs.PARTITION_ASSIGNMENT_STRATEGY,\n                \"fetch.max.bytes\": configs.FETCH_MAX_BYTES,\n                \"max.partition.fetch.bytes\": configs.MAX_PARTITION_FETCH_BYTES,\n            }\n            if configs.USERNAME and configs.PASSWORD and configs.SSL_CA_FILE:\n                config |= {\n                    \"sasl.username\": configs.USERNAME,\n                    \"sasl.password\": configs.PASSWORD.get_secret_value(),\n                    \"security.protocol\": configs.SECURITY_PROTOCOL,\n                    \"sasl.mechanism\": configs.SASL_MECHANISM,\n                    \"ssl.ca.location\": configs.SSL_CA_FILE,\n                    \"ssl.certificate.location\": configs.SSL_CERT_FILE,\n                    \"ssl.key.location\": configs.SSL_KEY_FILE,\n                    \"ssl.endpoint.identification.algorithm\": \"none\",\n                }\n            consumer = Consumer(config)\n        except Exception as e:\n            cls._handle_kafka_exception(e, \"KafkaConsumer_init\")\n        else:\n            return consumer\n\n    @override\n    def batch_consume(self, messages_number: int = 500, timeout: int = 1) -&gt; list[Message]:\n        \"\"\"Consumes a batch of messages from subscribed topics.\n\n        Args:\n            messages_number (int, optional): Maximum number of messages to consume.\n                Defaults to 500.\n            timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n        Returns:\n            list[Message]: List of consumed messages.\n\n        Raises:\n            ConnectionTimeoutError: If the operation times out.\n            ServiceUnavailableError: If Kafka is unavailable.\n            InternalError: If there is an error consuming messages.\n        \"\"\"\n        try:\n            result_list: list[Message] = []\n            messages: list[Message] = self._adapter.consume(num_messages=messages_number, timeout=timeout)\n            for message in messages:\n                if message.error():\n                    logger.error(\"Consumer error: %s\", message.error())\n                    continue\n                logger.debug(\"Message consumed: %s\", message)\n                message.set_value(message.value())\n                result_list.append(message)\n        except Exception as e:\n            self._handle_kafka_exception(e, \"batch_consume\")\n        else:\n            return result_list\n\n    @override\n    def poll(self, timeout: int = 1) -&gt; Message | None:\n        \"\"\"Polls for a single message from subscribed topics.\n\n        Args:\n            timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n        Returns:\n            Message | None: The consumed message or None if no message was received.\n\n        Raises:\n            ConnectionTimeoutError: If the operation times out.\n            ServiceUnavailableError: If Kafka is unavailable.\n            InternalError: If there is an error polling for messages.\n        \"\"\"\n        try:\n            message: Message | None = self._adapter.poll(timeout)\n            if message is None:\n                logger.debug(\"No message received\")\n                return None\n            if message.error():\n                logger.error(\"Consumer error: %s\", message.error())\n                return None\n            logger.debug(\"Message consumed: %s\", message)\n            message.set_value(message.value())\n        except Exception as e:\n            self._handle_kafka_exception(e, \"poll\")\n        else:\n            return message\n\n    @override\n    def commit(self, message: Message, asynchronous: bool = True) -&gt; None | list[TopicPartition]:\n        \"\"\"Commits the offset for a message.\n\n        Args:\n            message (Message): The message to commit.\n            asynchronous (bool, optional): Whether to commit asynchronously. Defaults to True.\n\n        Returns:\n            None | list[TopicPartition]: None for async commits, list of TopicPartition for sync commits.\n\n        Raises:\n            InvalidArgumentError: If the message is invalid.\n            ServiceUnavailableError: If Kafka is unavailable.\n            InternalError: If there is an error committing the offset.\n        \"\"\"\n        try:\n            if asynchronous:\n                self._adapter.commit(message=message, asynchronous=True)\n                result = None\n            else:\n                result = self._adapter.commit(message=message, asynchronous=False)\n        except Exception as e:\n            self._handle_kafka_exception(e, \"commit\")\n        else:\n            return result\n\n    @override\n    def subscribe(self, topic_list: list[str]) -&gt; None:\n        \"\"\"Subscribes to a list of topics.\n\n        Args:\n            topic_list (list[str]): List of topics to subscribe to.\n\n        Raises:\n            InvalidArgumentError: If the topic list is invalid.\n            ServiceUnavailableError: If Kafka is unavailable.\n            InternalError: If there is an error subscribing to topics.\n        \"\"\"\n        try:\n            self._adapter.subscribe(topic_list)\n        except Exception as e:\n            self._handle_kafka_exception(e, \"subscribe\")\n\n    @override\n    def assign(self, partition_list: list[TopicPartition]) -&gt; None:\n        \"\"\"Assigns the consumer to a list of topic partitions.\n\n        Args:\n            partition_list (list[TopicPartition]): List of partitions to assign.\n\n        Raises:\n            InvalidArgumentError: If the partition list is invalid.\n            ServiceUnavailableError: If Kafka is unavailable.\n            InternalError: If there is an error assigning partitions.\n        \"\"\"\n        try:\n            self._adapter.assign(partition_list)\n        except Exception as e:\n            self._handle_kafka_exception(e, \"assign\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaConsumerAdapter.__init__","title":"<code>archipy.adapters.kafka.adapters.KafkaConsumerAdapter.__init__(group_id, topic_list=None, partition_list=None, kafka_configs=None)</code>","text":"<p>Initializes the consumer adapter with Kafka configuration and subscription.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>str</code> <p>Consumer group ID.</p> required <code>topic_list</code> <code>list[str] | None</code> <p>List of topics to subscribe to. Defaults to None.</p> <code>None</code> <code>partition_list</code> <code>list[TopicPartition] | None</code> <p>List of partitions to assign. Defaults to None.</p> <code>None</code> <code>kafka_configs</code> <code>KafkaConfig | None</code> <p>Kafka configuration. If None, uses global config. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If both topic_list and partition_list are provided or neither is provided.</p> <code>InternalError</code> <p>If there is an error initializing the consumer.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>def __init__(\n    self,\n    group_id: str,\n    topic_list: list[str] | None = None,\n    partition_list: list[TopicPartition] | None = None,\n    kafka_configs: KafkaConfig | None = None,\n) -&gt; None:\n    \"\"\"Initializes the consumer adapter with Kafka configuration and subscription.\n\n    Args:\n        group_id (str): Consumer group ID.\n        topic_list (list[str] | None, optional): List of topics to subscribe to.\n            Defaults to None.\n        partition_list (list[TopicPartition] | None, optional): List of partitions\n            to assign. Defaults to None.\n        kafka_configs (KafkaConfig | None, optional): Kafka configuration. If None,\n            uses global config. Defaults to None.\n\n    Raises:\n        InvalidArgumentError: If both topic_list and partition_list are provided or\n            neither is provided.\n        InternalError: If there is an error initializing the consumer.\n    \"\"\"\n    configs: KafkaConfig = kafka_configs or BaseConfig.global_config().KAFKA\n    self._adapter: Consumer = self._get_adapter(group_id, configs)\n    if topic_list and not partition_list:\n        self.subscribe(topic_list)\n    elif not topic_list and partition_list:\n        self.assign(partition_list)\n    else:\n        logger.error(\"Invalid topic or partition list\")\n        raise InvalidArgumentError(\n            argument_name=\"topic_list or partition_list\",\n            additional_data={\"reason\": \"Exactly one of topic_list or partition_list must be provided\"},\n        )\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaConsumerAdapter.batch_consume","title":"<code>archipy.adapters.kafka.adapters.KafkaConsumerAdapter.batch_consume(messages_number=500, timeout=1)</code>","text":"<p>Consumes a batch of messages from subscribed topics.</p> <p>Parameters:</p> Name Type Description Default <code>messages_number</code> <code>int</code> <p>Maximum number of messages to consume. Defaults to 500.</p> <code>500</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>list[Message]</code> <p>list[Message]: List of consumed messages.</p> <p>Raises:</p> Type Description <code>ConnectionTimeoutError</code> <p>If the operation times out.</p> <code>ServiceUnavailableError</code> <p>If Kafka is unavailable.</p> <code>InternalError</code> <p>If there is an error consuming messages.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef batch_consume(self, messages_number: int = 500, timeout: int = 1) -&gt; list[Message]:\n    \"\"\"Consumes a batch of messages from subscribed topics.\n\n    Args:\n        messages_number (int, optional): Maximum number of messages to consume.\n            Defaults to 500.\n        timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n    Returns:\n        list[Message]: List of consumed messages.\n\n    Raises:\n        ConnectionTimeoutError: If the operation times out.\n        ServiceUnavailableError: If Kafka is unavailable.\n        InternalError: If there is an error consuming messages.\n    \"\"\"\n    try:\n        result_list: list[Message] = []\n        messages: list[Message] = self._adapter.consume(num_messages=messages_number, timeout=timeout)\n        for message in messages:\n            if message.error():\n                logger.error(\"Consumer error: %s\", message.error())\n                continue\n            logger.debug(\"Message consumed: %s\", message)\n            message.set_value(message.value())\n            result_list.append(message)\n    except Exception as e:\n        self._handle_kafka_exception(e, \"batch_consume\")\n    else:\n        return result_list\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaConsumerAdapter.poll","title":"<code>archipy.adapters.kafka.adapters.KafkaConsumerAdapter.poll(timeout=1)</code>","text":"<p>Polls for a single message from subscribed topics.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Message | None</code> <p>Message | None: The consumed message or None if no message was received.</p> <p>Raises:</p> Type Description <code>ConnectionTimeoutError</code> <p>If the operation times out.</p> <code>ServiceUnavailableError</code> <p>If Kafka is unavailable.</p> <code>InternalError</code> <p>If there is an error polling for messages.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef poll(self, timeout: int = 1) -&gt; Message | None:\n    \"\"\"Polls for a single message from subscribed topics.\n\n    Args:\n        timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n    Returns:\n        Message | None: The consumed message or None if no message was received.\n\n    Raises:\n        ConnectionTimeoutError: If the operation times out.\n        ServiceUnavailableError: If Kafka is unavailable.\n        InternalError: If there is an error polling for messages.\n    \"\"\"\n    try:\n        message: Message | None = self._adapter.poll(timeout)\n        if message is None:\n            logger.debug(\"No message received\")\n            return None\n        if message.error():\n            logger.error(\"Consumer error: %s\", message.error())\n            return None\n        logger.debug(\"Message consumed: %s\", message)\n        message.set_value(message.value())\n    except Exception as e:\n        self._handle_kafka_exception(e, \"poll\")\n    else:\n        return message\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaConsumerAdapter.commit","title":"<code>archipy.adapters.kafka.adapters.KafkaConsumerAdapter.commit(message, asynchronous=True)</code>","text":"<p>Commits the offset for a message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>The message to commit.</p> required <code>asynchronous</code> <code>bool</code> <p>Whether to commit asynchronously. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>None | list[TopicPartition]</code> <p>None | list[TopicPartition]: None for async commits, list of TopicPartition for sync commits.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the message is invalid.</p> <code>ServiceUnavailableError</code> <p>If Kafka is unavailable.</p> <code>InternalError</code> <p>If there is an error committing the offset.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef commit(self, message: Message, asynchronous: bool = True) -&gt; None | list[TopicPartition]:\n    \"\"\"Commits the offset for a message.\n\n    Args:\n        message (Message): The message to commit.\n        asynchronous (bool, optional): Whether to commit asynchronously. Defaults to True.\n\n    Returns:\n        None | list[TopicPartition]: None for async commits, list of TopicPartition for sync commits.\n\n    Raises:\n        InvalidArgumentError: If the message is invalid.\n        ServiceUnavailableError: If Kafka is unavailable.\n        InternalError: If there is an error committing the offset.\n    \"\"\"\n    try:\n        if asynchronous:\n            self._adapter.commit(message=message, asynchronous=True)\n            result = None\n        else:\n            result = self._adapter.commit(message=message, asynchronous=False)\n    except Exception as e:\n        self._handle_kafka_exception(e, \"commit\")\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaConsumerAdapter.subscribe","title":"<code>archipy.adapters.kafka.adapters.KafkaConsumerAdapter.subscribe(topic_list)</code>","text":"<p>Subscribes to a list of topics.</p> <p>Parameters:</p> Name Type Description Default <code>topic_list</code> <code>list[str]</code> <p>List of topics to subscribe to.</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the topic list is invalid.</p> <code>ServiceUnavailableError</code> <p>If Kafka is unavailable.</p> <code>InternalError</code> <p>If there is an error subscribing to topics.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef subscribe(self, topic_list: list[str]) -&gt; None:\n    \"\"\"Subscribes to a list of topics.\n\n    Args:\n        topic_list (list[str]): List of topics to subscribe to.\n\n    Raises:\n        InvalidArgumentError: If the topic list is invalid.\n        ServiceUnavailableError: If Kafka is unavailable.\n        InternalError: If there is an error subscribing to topics.\n    \"\"\"\n    try:\n        self._adapter.subscribe(topic_list)\n    except Exception as e:\n        self._handle_kafka_exception(e, \"subscribe\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaConsumerAdapter.assign","title":"<code>archipy.adapters.kafka.adapters.KafkaConsumerAdapter.assign(partition_list)</code>","text":"<p>Assigns the consumer to a list of topic partitions.</p> <p>Parameters:</p> Name Type Description Default <code>partition_list</code> <code>list[TopicPartition]</code> <p>List of partitions to assign.</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the partition list is invalid.</p> <code>ServiceUnavailableError</code> <p>If Kafka is unavailable.</p> <code>InternalError</code> <p>If there is an error assigning partitions.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef assign(self, partition_list: list[TopicPartition]) -&gt; None:\n    \"\"\"Assigns the consumer to a list of topic partitions.\n\n    Args:\n        partition_list (list[TopicPartition]): List of partitions to assign.\n\n    Raises:\n        InvalidArgumentError: If the partition list is invalid.\n        ServiceUnavailableError: If Kafka is unavailable.\n        InternalError: If there is an error assigning partitions.\n    \"\"\"\n    try:\n        self._adapter.assign(partition_list)\n    except Exception as e:\n        self._handle_kafka_exception(e, \"assign\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaProducerAdapter","title":"<code>archipy.adapters.kafka.adapters.KafkaProducerAdapter</code>","text":"<p>               Bases: <code>KafkaProducerPort</code>, <code>KafkaExceptionHandlerMixin</code></p> <p>Synchronous Kafka producer adapter.</p> <p>This adapter provides synchronous message production to Kafka topics. It implements the KafkaProducerPort interface and handles message production.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>class KafkaProducerAdapter(KafkaProducerPort, KafkaExceptionHandlerMixin):\n    \"\"\"Synchronous Kafka producer adapter.\n\n    This adapter provides synchronous message production to Kafka topics.\n    It implements the KafkaProducerPort interface and handles message production.\n    \"\"\"\n\n    def __init__(self, topic_name: str, kafka_configs: KafkaConfig | None = None) -&gt; None:\n        \"\"\"Initializes the producer adapter with Kafka configuration.\n\n        Args:\n            topic_name (str): Default topic name to produce messages to.\n            kafka_configs (KafkaConfig | None, optional): Kafka configuration. If None,\n                uses global config. Defaults to None.\n\n        Raises:\n            ConfigurationError: If there is an error in the Kafka configuration.\n            InternalError: If there is an error initializing the producer.\n        \"\"\"\n        self._topic_name = topic_name\n        configs: KafkaConfig = kafka_configs or BaseConfig.global_config().KAFKA\n        self._adapter: Producer = self._get_adapter(configs)\n\n    @classmethod\n    def _get_adapter(cls, configs: KafkaConfig) -&gt; Producer:\n        \"\"\"Creates and configures a Kafka Producer instance.\n\n        Args:\n            configs (KafkaConfig): Kafka configuration.\n\n        Returns:\n            Producer: Configured Kafka Producer instance.\n\n        Raises:\n            ConfigurationError: If there is an error in the Kafka configuration.\n            InternalError: If there is an error creating the producer.\n        \"\"\"\n        try:\n            broker_list_csv = \",\".join(configs.BROKERS_LIST)\n            config = {\n                \"bootstrap.servers\": broker_list_csv,\n                \"linger.ms\": configs.LINGER_MS,\n                \"batch.size\": configs.BATCH_SIZE,\n                \"acks\": configs.ACKS,\n                \"request.timeout.ms\": configs.REQUEST_TIMEOUT_MS,\n                \"delivery.timeout.ms\": configs.DELIVERY_TIMEOUT_MS,\n                \"compression.type\": configs.COMPRESSION_TYPE or \"none\",\n                \"max.in.flight.requests.per.connection\": configs.MAX_IN_FLIGHT_REQUESTS,\n                \"retries\": configs.RETRIES,\n                \"enable.idempotence\": configs.ENABLE_IDEMPOTENCE,\n                \"queue.buffering.max.messages\": configs.QUEUE_BUFFERING_MAX_MESSAGES,\n                \"statistics.interval.ms\": configs.STATISTICS_INTERVAL_MS,\n            }\n            if configs.TRANSACTIONAL_ID:\n                config[\"transactional.id\"] = configs.TRANSACTIONAL_ID\n            if configs.USERNAME and configs.PASSWORD and configs.SSL_CA_FILE:\n                config |= {\n                    \"sasl.username\": configs.USERNAME,\n                    \"sasl.password\": configs.PASSWORD.get_secret_value(),\n                    \"security.protocol\": configs.SECURITY_PROTOCOL,\n                    \"sasl.mechanism\": configs.SASL_MECHANISM,\n                    \"ssl.ca.location\": configs.SSL_CA_FILE,\n                    \"ssl.certificate.location\": configs.SSL_CERT_FILE,\n                    \"ssl.key.location\": configs.SSL_KEY_FILE,\n                    \"ssl.endpoint.identification.algorithm\": \"none\",\n                }\n            producer = Producer(config)\n        except Exception as e:\n            cls._handle_kafka_exception(e, \"KafkaProducer_init\")\n        else:\n            return producer\n\n    @staticmethod\n    def _pre_process_message(message: str | bytes) -&gt; bytes:\n        \"\"\"Pre-processes a message to ensure it's in the correct format.\n\n        Args:\n            message (str | bytes): The message to pre-process.\n\n        Returns:\n            bytes: The pre-processed message as bytes.\n        \"\"\"\n        if isinstance(message, str):\n            return message.encode(\"utf-8\")\n        return message\n\n    @staticmethod\n    def _delivery_callback(error: KafkaError | None, message: Message) -&gt; None:\n        \"\"\"Callback for message delivery confirmation.\n\n        Args:\n            error (KafkaError | None): Error that occurred during delivery, or None if successful.\n            message (Message): The delivered message.\n        \"\"\"\n        if error:\n            logger.error(\"Message delivery failed: %s: %s\", error, message.value())\n        else:\n            logger.debug(\n                \"Message delivered to %s [%d] at offset %d\",\n                message.topic(),\n                message.partition(),\n                message.offset(),\n            )\n\n    @override\n    def produce(self, message: str | bytes) -&gt; None:\n        \"\"\"Produces a message to the configured topic.\n\n        Args:\n            message (str | bytes): The message to produce.\n\n        Raises:\n            NetworkError: If there is a network error producing the message.\n            ResourceExhaustedError: If the producer queue is full.\n            InternalError: If there is an error producing the message.\n        \"\"\"\n        try:\n            processed_message = self._pre_process_message(message)\n            self._adapter.produce(\n                topic=self._topic_name,\n                value=processed_message,\n                callback=self._delivery_callback,\n            )\n        except Exception as e:\n            self._handle_producer_exception(e, \"produce\")\n\n    @override\n    def flush(self, timeout: int | None = None) -&gt; None:\n        \"\"\"Flushes the producer queue.\n\n        Args:\n            timeout (int | None, optional): Timeout in seconds for the operation. Defaults to None.\n\n        Raises:\n            ConnectionTimeoutError: If the operation times out.\n            ServiceUnavailableError: If Kafka is unavailable.\n            InternalError: If there is an error flushing the queue.\n        \"\"\"\n        try:\n            remaining_messages = self._adapter.flush(timeout=timeout)\n            if remaining_messages &gt; 0:\n                logger.warning(\"%d messages left in the queue after flush\", remaining_messages)\n        except Exception as e:\n            self._handle_kafka_exception(e, \"flush\")\n\n    @override\n    def validate_healthiness(self) -&gt; None:\n        \"\"\"Validates the health of the Kafka connection.\n\n        Raises:\n            UnavailableError: If the Kafka service is unavailable.\n        \"\"\"\n        try:\n            self.list_topics(timeout=1)\n        except Exception as e:\n            raise UnavailableError(service=\"Kafka\") from e\n\n    @override\n    def list_topics(self, topic: str | None = None, timeout: int = 1) -&gt; ClusterMetadata:\n        \"\"\"Lists Kafka topics.\n\n        Args:\n            topic (str | None, optional): Specific topic to list. If None, lists all topics.\n                Defaults to None.\n            timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n        Returns:\n            ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n        Raises:\n            ConnectionTimeoutError: If the operation times out.\n            ServiceUnavailableError: If the Kafka service is unavailable.\n            UnavailableError: If there is an unknown issue accessing Kafka.\n        \"\"\"\n        try:\n            result = self._adapter.list_topics(topic=topic, timeout=timeout)\n        except Exception as e:\n            self._handle_kafka_exception(e, \"list_topics\")\n        else:\n            return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaProducerAdapter.__init__","title":"<code>archipy.adapters.kafka.adapters.KafkaProducerAdapter.__init__(topic_name, kafka_configs=None)</code>","text":"<p>Initializes the producer adapter with Kafka configuration.</p> <p>Parameters:</p> Name Type Description Default <code>topic_name</code> <code>str</code> <p>Default topic name to produce messages to.</p> required <code>kafka_configs</code> <code>KafkaConfig | None</code> <p>Kafka configuration. If None, uses global config. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If there is an error in the Kafka configuration.</p> <code>InternalError</code> <p>If there is an error initializing the producer.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>def __init__(self, topic_name: str, kafka_configs: KafkaConfig | None = None) -&gt; None:\n    \"\"\"Initializes the producer adapter with Kafka configuration.\n\n    Args:\n        topic_name (str): Default topic name to produce messages to.\n        kafka_configs (KafkaConfig | None, optional): Kafka configuration. If None,\n            uses global config. Defaults to None.\n\n    Raises:\n        ConfigurationError: If there is an error in the Kafka configuration.\n        InternalError: If there is an error initializing the producer.\n    \"\"\"\n    self._topic_name = topic_name\n    configs: KafkaConfig = kafka_configs or BaseConfig.global_config().KAFKA\n    self._adapter: Producer = self._get_adapter(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaProducerAdapter.produce","title":"<code>archipy.adapters.kafka.adapters.KafkaProducerAdapter.produce(message)</code>","text":"<p>Produces a message to the configured topic.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str | bytes</code> <p>The message to produce.</p> required <p>Raises:</p> Type Description <code>NetworkError</code> <p>If there is a network error producing the message.</p> <code>ResourceExhaustedError</code> <p>If the producer queue is full.</p> <code>InternalError</code> <p>If there is an error producing the message.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef produce(self, message: str | bytes) -&gt; None:\n    \"\"\"Produces a message to the configured topic.\n\n    Args:\n        message (str | bytes): The message to produce.\n\n    Raises:\n        NetworkError: If there is a network error producing the message.\n        ResourceExhaustedError: If the producer queue is full.\n        InternalError: If there is an error producing the message.\n    \"\"\"\n    try:\n        processed_message = self._pre_process_message(message)\n        self._adapter.produce(\n            topic=self._topic_name,\n            value=processed_message,\n            callback=self._delivery_callback,\n        )\n    except Exception as e:\n        self._handle_producer_exception(e, \"produce\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaProducerAdapter.flush","title":"<code>archipy.adapters.kafka.adapters.KafkaProducerAdapter.flush(timeout=None)</code>","text":"<p>Flushes the producer queue.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int | None</code> <p>Timeout in seconds for the operation. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ConnectionTimeoutError</code> <p>If the operation times out.</p> <code>ServiceUnavailableError</code> <p>If Kafka is unavailable.</p> <code>InternalError</code> <p>If there is an error flushing the queue.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef flush(self, timeout: int | None = None) -&gt; None:\n    \"\"\"Flushes the producer queue.\n\n    Args:\n        timeout (int | None, optional): Timeout in seconds for the operation. Defaults to None.\n\n    Raises:\n        ConnectionTimeoutError: If the operation times out.\n        ServiceUnavailableError: If Kafka is unavailable.\n        InternalError: If there is an error flushing the queue.\n    \"\"\"\n    try:\n        remaining_messages = self._adapter.flush(timeout=timeout)\n        if remaining_messages &gt; 0:\n            logger.warning(\"%d messages left in the queue after flush\", remaining_messages)\n    except Exception as e:\n        self._handle_kafka_exception(e, \"flush\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaProducerAdapter.validate_healthiness","title":"<code>archipy.adapters.kafka.adapters.KafkaProducerAdapter.validate_healthiness()</code>","text":"<p>Validates the health of the Kafka connection.</p> <p>Raises:</p> Type Description <code>UnavailableError</code> <p>If the Kafka service is unavailable.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef validate_healthiness(self) -&gt; None:\n    \"\"\"Validates the health of the Kafka connection.\n\n    Raises:\n        UnavailableError: If the Kafka service is unavailable.\n    \"\"\"\n    try:\n        self.list_topics(timeout=1)\n    except Exception as e:\n        raise UnavailableError(service=\"Kafka\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaProducerAdapter.list_topics","title":"<code>archipy.adapters.kafka.adapters.KafkaProducerAdapter.list_topics(topic=None, timeout=1)</code>","text":"<p>Lists Kafka topics.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str | None</code> <p>Specific topic to list. If None, lists all topics. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>ClusterMetadata</code> <code>ClusterMetadata</code> <p>Metadata about the Kafka cluster and topics.</p> <p>Raises:</p> Type Description <code>ConnectionTimeoutError</code> <p>If the operation times out.</p> <code>ServiceUnavailableError</code> <p>If the Kafka service is unavailable.</p> <code>UnavailableError</code> <p>If there is an unknown issue accessing Kafka.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef list_topics(self, topic: str | None = None, timeout: int = 1) -&gt; ClusterMetadata:\n    \"\"\"Lists Kafka topics.\n\n    Args:\n        topic (str | None, optional): Specific topic to list. If None, lists all topics.\n            Defaults to None.\n        timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n    Returns:\n        ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n    Raises:\n        ConnectionTimeoutError: If the operation times out.\n        ServiceUnavailableError: If the Kafka service is unavailable.\n        UnavailableError: If there is an unknown issue accessing Kafka.\n    \"\"\"\n    try:\n        result = self._adapter.list_topics(topic=topic, timeout=timeout)\n    except Exception as e:\n        self._handle_kafka_exception(e, \"list_topics\")\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaAdminPort","title":"<code>archipy.adapters.kafka.ports.KafkaAdminPort</code>","text":"<p>Interface for Kafka admin operations.</p> <p>This interface defines the contract for performing administrative operations on Kafka topics.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>class KafkaAdminPort:\n    \"\"\"Interface for Kafka admin operations.\n\n    This interface defines the contract for performing administrative operations on Kafka topics.\n    \"\"\"\n\n    @abstractmethod\n    def create_topic(self, topic: str, num_partitions: int = 1, replication_factor: int = 1) -&gt; None:\n        \"\"\"Creates a new Kafka topic.\n\n        Args:\n            topic (str): Name of the topic to create.\n            num_partitions (int, optional): Number of partitions for the topic. Defaults to 1.\n            replication_factor (int, optional): Replication factor for the topic. Defaults to 1.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def delete_topic(self, topics: list[str]) -&gt; None:\n        \"\"\"Deletes one or more Kafka topics.\n\n        Args:\n            topics (list[str]): List of topic names to delete.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def list_topics(self, topic: str | None = None, timeout: int = 1) -&gt; ClusterMetadata:\n        \"\"\"Lists Kafka topics.\n\n        Args:\n            topic (str | None, optional): Specific topic to list. If None, lists all topics.\n                Defaults to None.\n            timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n        Returns:\n            ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaAdminPort.create_topic","title":"<code>archipy.adapters.kafka.ports.KafkaAdminPort.create_topic(topic, num_partitions=1, replication_factor=1)</code>  <code>abstractmethod</code>","text":"<p>Creates a new Kafka topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>Name of the topic to create.</p> required <code>num_partitions</code> <code>int</code> <p>Number of partitions for the topic. Defaults to 1.</p> <code>1</code> <code>replication_factor</code> <code>int</code> <p>Replication factor for the topic. Defaults to 1.</p> <code>1</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef create_topic(self, topic: str, num_partitions: int = 1, replication_factor: int = 1) -&gt; None:\n    \"\"\"Creates a new Kafka topic.\n\n    Args:\n        topic (str): Name of the topic to create.\n        num_partitions (int, optional): Number of partitions for the topic. Defaults to 1.\n        replication_factor (int, optional): Replication factor for the topic. Defaults to 1.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaAdminPort.delete_topic","title":"<code>archipy.adapters.kafka.ports.KafkaAdminPort.delete_topic(topics)</code>  <code>abstractmethod</code>","text":"<p>Deletes one or more Kafka topics.</p> <p>Parameters:</p> Name Type Description Default <code>topics</code> <code>list[str]</code> <p>List of topic names to delete.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef delete_topic(self, topics: list[str]) -&gt; None:\n    \"\"\"Deletes one or more Kafka topics.\n\n    Args:\n        topics (list[str]): List of topic names to delete.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaAdminPort.list_topics","title":"<code>archipy.adapters.kafka.ports.KafkaAdminPort.list_topics(topic=None, timeout=1)</code>  <code>abstractmethod</code>","text":"<p>Lists Kafka topics.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str | None</code> <p>Specific topic to list. If None, lists all topics. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>ClusterMetadata</code> <code>ClusterMetadata</code> <p>Metadata about the Kafka cluster and topics.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef list_topics(self, topic: str | None = None, timeout: int = 1) -&gt; ClusterMetadata:\n    \"\"\"Lists Kafka topics.\n\n    Args:\n        topic (str | None, optional): Specific topic to list. If None, lists all topics.\n            Defaults to None.\n        timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n    Returns:\n        ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaConsumerPort","title":"<code>archipy.adapters.kafka.ports.KafkaConsumerPort</code>","text":"<p>Interface for Kafka consumer operations.</p> <p>This interface defines the contract for consuming messages from Kafka topics.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>class KafkaConsumerPort:\n    \"\"\"Interface for Kafka consumer operations.\n\n    This interface defines the contract for consuming messages from Kafka topics.\n    \"\"\"\n\n    @abstractmethod\n    def batch_consume(self, messages_number: int, timeout: int) -&gt; list[Message]:\n        \"\"\"Consumes a batch of messages from subscribed topics.\n\n        Args:\n            messages_number (int): Maximum number of messages to consume.\n            timeout (int): Timeout in seconds for the operation.\n\n        Returns:\n            list[Message]: List of consumed messages.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def poll(self, timeout: int) -&gt; Message | None:\n        \"\"\"Polls for a single message from subscribed topics.\n\n        Args:\n            timeout (int): Timeout in seconds for the operation.\n\n        Returns:\n            Message | None: The consumed message or None if no message was received.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def commit(self, message: Message, asynchronous: bool) -&gt; None | list[TopicPartition]:\n        \"\"\"Commits the offset of a consumed message.\n\n        Args:\n            message (Message): The message whose offset should be committed.\n            asynchronous (bool): Whether to commit asynchronously.\n\n        Returns:\n            None | list[TopicPartition]: None for synchronous commits, or list of committed\n                partitions for asynchronous commits.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def subscribe(self, topic_list: list[str]) -&gt; None:\n        \"\"\"Subscribes to a list of topics.\n\n        Args:\n            topic_list (list[str]): List of topic names to subscribe to.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def assign(self, partition_list: list[TopicPartition]) -&gt; None:\n        \"\"\"Assigns specific partitions to the consumer.\n\n        Args:\n            partition_list (list[TopicPartition]): List of partitions to assign.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaConsumerPort.batch_consume","title":"<code>archipy.adapters.kafka.ports.KafkaConsumerPort.batch_consume(messages_number, timeout)</code>  <code>abstractmethod</code>","text":"<p>Consumes a batch of messages from subscribed topics.</p> <p>Parameters:</p> Name Type Description Default <code>messages_number</code> <code>int</code> <p>Maximum number of messages to consume.</p> required <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation.</p> required <p>Returns:</p> Type Description <code>list[Message]</code> <p>list[Message]: List of consumed messages.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef batch_consume(self, messages_number: int, timeout: int) -&gt; list[Message]:\n    \"\"\"Consumes a batch of messages from subscribed topics.\n\n    Args:\n        messages_number (int): Maximum number of messages to consume.\n        timeout (int): Timeout in seconds for the operation.\n\n    Returns:\n        list[Message]: List of consumed messages.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaConsumerPort.poll","title":"<code>archipy.adapters.kafka.ports.KafkaConsumerPort.poll(timeout)</code>  <code>abstractmethod</code>","text":"<p>Polls for a single message from subscribed topics.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation.</p> required <p>Returns:</p> Type Description <code>Message | None</code> <p>Message | None: The consumed message or None if no message was received.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef poll(self, timeout: int) -&gt; Message | None:\n    \"\"\"Polls for a single message from subscribed topics.\n\n    Args:\n        timeout (int): Timeout in seconds for the operation.\n\n    Returns:\n        Message | None: The consumed message or None if no message was received.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaConsumerPort.commit","title":"<code>archipy.adapters.kafka.ports.KafkaConsumerPort.commit(message, asynchronous)</code>  <code>abstractmethod</code>","text":"<p>Commits the offset of a consumed message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>The message whose offset should be committed.</p> required <code>asynchronous</code> <code>bool</code> <p>Whether to commit asynchronously.</p> required <p>Returns:</p> Type Description <code>None | list[TopicPartition]</code> <p>None | list[TopicPartition]: None for synchronous commits, or list of committed partitions for asynchronous commits.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef commit(self, message: Message, asynchronous: bool) -&gt; None | list[TopicPartition]:\n    \"\"\"Commits the offset of a consumed message.\n\n    Args:\n        message (Message): The message whose offset should be committed.\n        asynchronous (bool): Whether to commit asynchronously.\n\n    Returns:\n        None | list[TopicPartition]: None for synchronous commits, or list of committed\n            partitions for asynchronous commits.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaConsumerPort.subscribe","title":"<code>archipy.adapters.kafka.ports.KafkaConsumerPort.subscribe(topic_list)</code>  <code>abstractmethod</code>","text":"<p>Subscribes to a list of topics.</p> <p>Parameters:</p> Name Type Description Default <code>topic_list</code> <code>list[str]</code> <p>List of topic names to subscribe to.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef subscribe(self, topic_list: list[str]) -&gt; None:\n    \"\"\"Subscribes to a list of topics.\n\n    Args:\n        topic_list (list[str]): List of topic names to subscribe to.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaConsumerPort.assign","title":"<code>archipy.adapters.kafka.ports.KafkaConsumerPort.assign(partition_list)</code>  <code>abstractmethod</code>","text":"<p>Assigns specific partitions to the consumer.</p> <p>Parameters:</p> Name Type Description Default <code>partition_list</code> <code>list[TopicPartition]</code> <p>List of partitions to assign.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef assign(self, partition_list: list[TopicPartition]) -&gt; None:\n    \"\"\"Assigns specific partitions to the consumer.\n\n    Args:\n        partition_list (list[TopicPartition]): List of partitions to assign.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaProducerPort","title":"<code>archipy.adapters.kafka.ports.KafkaProducerPort</code>","text":"<p>Interface for Kafka producer operations.</p> <p>This interface defines the contract for producing messages to Kafka topics.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>class KafkaProducerPort:\n    \"\"\"Interface for Kafka producer operations.\n\n    This interface defines the contract for producing messages to Kafka topics.\n    \"\"\"\n\n    @abstractmethod\n    def produce(self, message: str | bytes) -&gt; None:\n        \"\"\"Produces a message to the configured topic.\n\n        Args:\n            message (str | bytes): The message to produce.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def flush(self, timeout: int | None) -&gt; None:\n        \"\"\"Flushes any pending messages to the broker.\n\n        Args:\n            timeout (int | None): Maximum time to wait for messages to be delivered.\n                If None, wait indefinitely.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def validate_healthiness(self) -&gt; None:\n        \"\"\"Validates the health of the producer connection.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def list_topics(self, topic: str | None, timeout: int) -&gt; ClusterMetadata:\n        \"\"\"Lists Kafka topics.\n\n        Args:\n            topic (str | None): Specific topic to list. If None, lists all topics.\n            timeout (int): Timeout in seconds for the operation.\n\n        Returns:\n            ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaProducerPort.produce","title":"<code>archipy.adapters.kafka.ports.KafkaProducerPort.produce(message)</code>  <code>abstractmethod</code>","text":"<p>Produces a message to the configured topic.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str | bytes</code> <p>The message to produce.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef produce(self, message: str | bytes) -&gt; None:\n    \"\"\"Produces a message to the configured topic.\n\n    Args:\n        message (str | bytes): The message to produce.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaProducerPort.flush","title":"<code>archipy.adapters.kafka.ports.KafkaProducerPort.flush(timeout)</code>  <code>abstractmethod</code>","text":"<p>Flushes any pending messages to the broker.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int | None</code> <p>Maximum time to wait for messages to be delivered. If None, wait indefinitely.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef flush(self, timeout: int | None) -&gt; None:\n    \"\"\"Flushes any pending messages to the broker.\n\n    Args:\n        timeout (int | None): Maximum time to wait for messages to be delivered.\n            If None, wait indefinitely.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaProducerPort.validate_healthiness","title":"<code>archipy.adapters.kafka.ports.KafkaProducerPort.validate_healthiness()</code>  <code>abstractmethod</code>","text":"<p>Validates the health of the producer connection.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef validate_healthiness(self) -&gt; None:\n    \"\"\"Validates the health of the producer connection.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaProducerPort.list_topics","title":"<code>archipy.adapters.kafka.ports.KafkaProducerPort.list_topics(topic, timeout)</code>  <code>abstractmethod</code>","text":"<p>Lists Kafka topics.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str | None</code> <p>Specific topic to list. If None, lists all topics.</p> required <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation.</p> required <p>Returns:</p> Name Type Description <code>ClusterMetadata</code> <code>ClusterMetadata</code> <p>Metadata about the Kafka cluster and topics.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef list_topics(self, topic: str | None, timeout: int) -&gt; ClusterMetadata:\n    \"\"\"Lists Kafka topics.\n\n    Args:\n        topic (str | None): Specific topic to list. If None, lists all topics.\n        timeout (int): Timeout in seconds for the operation.\n\n    Returns:\n        ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#payment-gateways","title":"Payment Gateways","text":"<p>Integrations with various payment processing services for online transactions.</p>"},{"location":"api_reference/adapters/#parsian-shaparak","title":"Parsian Shaparak","text":"<p>Parsian Shaparak payment gateway adapter for processing online payments in Iran.</p> <pre><code>from archipy.adapters.internet_payment_gateways.ir.parsian.adapters import (\n    ParsianShaparakPaymentAdapter,\n    PaymentRequestDTO,\n    ConfirmRequestDTO\n)\n\n# Create a Parsian Shaparak payment adapter\npayment_adapter = ParsianShaparakPaymentAdapter()  # Uses global config by default\n\n# Create payment request\npayment_request = PaymentRequestDTO(\n    amount=10000,  # Amount in IRR\n    order_id=12345,  # Your unique order ID\n    callback_url=\"https://your-app.com/payment/callback\",\n)\n\n# Send payment request\npayment_response = payment_adapter.initiate_payment(payment_request)\n\nif payment_response.status == 0:  # 0 means success\n    # Redirect user to payment page\n    payment_url = f\"https://pec.shaparak.ir/NewIPG/?Token={payment_response.token}\"\n</code></pre> <p>For detailed examples and usage guidelines, see the Parsian Payment Gateway Examples.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.PaymentRequestDTO","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.PaymentRequestDTO</code>","text":"<p>               Bases: <code>BaseDTO</code></p> <p>DTO for initiating a payment request.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>class PaymentRequestDTO(BaseDTO):\n    \"\"\"DTO for initiating a payment request.\"\"\"\n\n    amount: int = Field(..., gt=0, description=\"Transaction amount in IRR\")\n    order_id: int = Field(..., gt=0, description=\"Unique order identifier\")\n    callback_url: HttpUrl = Field(..., description=\"URL to redirect after payment\")\n    additional_data: str | None = Field(None, description=\"Additional transaction data\")\n    originator: str | None = Field(None, description=\"Transaction originator\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.PaymentResponseDTO","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.PaymentResponseDTO</code>","text":"<p>               Bases: <code>BaseDTO</code></p> <p>DTO for payment response.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>class PaymentResponseDTO(BaseDTO):\n    \"\"\"DTO for payment response.\"\"\"\n\n    token: int | None = Field(None, description=\"Transaction token\")\n    status: int | None = Field(None, description=\"Transaction status code\")\n    message: str | None = Field(None, description=\"Status message or error description\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ConfirmRequestDTO","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ConfirmRequestDTO</code>","text":"<p>               Bases: <code>BaseDTO</code></p> <p>DTO for confirming a payment.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>class ConfirmRequestDTO(BaseDTO):\n    \"\"\"DTO for confirming a payment.\"\"\"\n\n    token: int = Field(..., gt=0, description=\"Transaction token\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ConfirmResponseDTO","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ConfirmResponseDTO</code>","text":"<p>               Bases: <code>BaseDTO</code></p> <p>DTO for confirm payment response.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>class ConfirmResponseDTO(BaseDTO):\n    \"\"\"DTO for confirm payment response.\"\"\"\n\n    status: int | None = Field(None, description=\"Transaction status code\")\n    rrn: int | None = Field(None, description=\"Retrieval Reference Number\")\n    card_number_masked: str | None = Field(None, description=\"Masked card number\")\n    token: int | None = Field(None, description=\"Transaction token\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ConfirmWithAmountRequestDTO","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ConfirmWithAmountRequestDTO</code>","text":"<p>               Bases: <code>BaseDTO</code></p> <p>DTO for confirming a payment with amount and order verification.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>class ConfirmWithAmountRequestDTO(BaseDTO):\n    \"\"\"DTO for confirming a payment with amount and order verification.\"\"\"\n\n    token: int = Field(..., gt=0, description=\"Transaction token\")\n    order_id: int = Field(..., gt=0, description=\"Unique order identifier\")\n    amount: int = Field(..., gt=0, description=\"Transaction amount in IRR\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ConfirmWithAmountResponseDTO","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ConfirmWithAmountResponseDTO</code>","text":"<p>               Bases: <code>BaseDTO</code></p> <p>DTO for confirm payment with amount response.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>class ConfirmWithAmountResponseDTO(BaseDTO):\n    \"\"\"DTO for confirm payment with amount response.\"\"\"\n\n    status: int | None = Field(None, description=\"Transaction status code\")\n    rrn: int | None = Field(None, description=\"Retrieval Reference Number\")\n    card_number_masked: str | None = Field(None, description=\"Masked card number\")\n    token: int | None = Field(None, description=\"Transaction token\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ReverseRequestDTO","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ReverseRequestDTO</code>","text":"<p>               Bases: <code>BaseDTO</code></p> <p>DTO for reversing a payment.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>class ReverseRequestDTO(BaseDTO):\n    \"\"\"DTO for reversing a payment.\"\"\"\n\n    token: int = Field(..., gt=0, description=\"Transaction token\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ReverseResponseDTO","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ReverseResponseDTO</code>","text":"<p>               Bases: <code>BaseDTO</code></p> <p>DTO for reverse payment response.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>class ReverseResponseDTO(BaseDTO):\n    \"\"\"DTO for reverse payment response.\"\"\"\n\n    status: int | None = Field(None, description=\"Transaction status code\")\n    message: str | None = Field(None, description=\"Status message or error description\")\n    token: int | None = Field(None, description=\"Transaction token\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter</code>","text":"<p>Adapter for interacting with Parsian Shaparak payment gateway services.</p> <p>Provides methods for initiating payments, confirming transactions, and reversing payments through the Parsian Shaparak payment gateway SOAP services. Supports proxy configuration for environments where direct connections are not possible.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>class ParsianShaparakPaymentAdapter:\n    \"\"\"Adapter for interacting with Parsian Shaparak payment gateway services.\n\n    Provides methods for initiating payments, confirming transactions, and reversing\n    payments through the Parsian Shaparak payment gateway SOAP services. Supports\n    proxy configuration for environments where direct connections are not possible.\n    \"\"\"\n\n    def __init__(self, config: ParsianShaparakConfig | None = None) -&gt; None:\n        \"\"\"Initialize the adapter with Parsian Shaparak configuration.\n\n        Args:\n            config (ParsianShaparakConfig | None): Configuration for Parsian Shaparak services.\n                If None, uses global config. Includes optional proxy configuration via\n                the PROXIES field.\n\n        Raises:\n            ValueError: If LOGIN_ACCOUNT is not a valid string.\n        \"\"\"\n        configs = BaseConfig.global_config().PARSIAN_SHAPARAK if config is None else config\n        if not configs.LOGIN_ACCOUNT or not isinstance(configs.LOGIN_ACCOUNT, str):\n            raise ValueError(\"LOGIN_ACCOUNT must be a non-empty string\")\n\n        self.login_account = configs.LOGIN_ACCOUNT\n        transport = None\n        if configs.PROXIES:\n            session = requests.Session()\n            session.proxies = configs.PROXIES\n            transport = Transport(session=session)\n\n        # Initialize SOAP clients\n        self.sale_client = zeep.Client(wsdl=configs.PAYMENT_WSDL_URL, transport=transport)\n        self.confirm_client = zeep.Client(wsdl=configs.CONFIRM_WSDL_URL, transport=transport)\n        self.reversal_client = zeep.Client(wsdl=configs.REVERSAL_WSDL_URL, transport=transport)\n\n    def initiate_payment(self, request: PaymentRequestDTO) -&gt; PaymentResponseDTO:\n        \"\"\"Initiate a payment request.\n\n        Args:\n            request (PaymentRequestDTO): Payment request data.\n\n        Returns:\n            PaymentResponseDTO: Response containing token, status, and message.\n\n        Raises:\n            UnavailableError: If a SOAP fault occurs during the request.\n            InternalError: If an unexpected error occurs during the request.\n        \"\"\"\n        try:\n            request_data = {\n                \"LoginAccount\": self.login_account,\n                \"Amount\": request.amount,\n                \"OrderId\": request.order_id,\n                \"CallBackUrl\": str(request.callback_url),\n                \"AdditionalData\": request.additional_data,\n                \"Originator\": request.originator,\n            }\n\n            logger.debug(f\"Initiating payment: {request_data}\")\n            response = self.sale_client.service.SalePaymentRequest(requestData=request_data)\n            result = PaymentResponseDTO(\n                token=response.Token,\n                status=response.Status,\n                message=response.Message,\n            )\n            logger.debug(f\"Payment response: {result}\")\n        except Fault as exception:\n            raise UnavailableError(service=\"Parsian Shaparak Sale Service\") from exception\n        except Exception as exception:\n            raise InternalError() from exception\n        else:\n            return result\n\n    def confirm_payment(self, request: ConfirmRequestDTO) -&gt; ConfirmResponseDTO:\n        \"\"\"Confirm a payment transaction.\n\n        Args:\n            request (ConfirmRequestDTO): Confirm request data.\n\n        Returns:\n            ConfirmResponseDTO: Response containing status, RRN, card number, and token.\n\n        Raises:\n            UnavailableError: If a SOAP fault occurs during the request.\n            InternalError: If an unexpected error occurs during the request.\n        \"\"\"\n        try:\n            request_data = {\"LoginAccount\": self.login_account, \"Token\": request.token}\n\n            logger.debug(f\"Confirming payment: {request_data}\")\n            response = self.confirm_client.service.ConfirmPayment(requestData=request_data)\n            result = ConfirmResponseDTO(\n                status=response.Status,\n                rrn=response.RRN,\n                card_number_masked=response.CardNumberMasked,\n                token=response.Token,\n            )\n            logger.debug(f\"Confirm response: {result}\")\n        except Fault as exception:\n            raise UnavailableError(service=\"Parsian Shaparak Confirm Service\") from exception\n        except Exception as exception:\n            raise InternalError() from exception\n        else:\n            return result\n\n    def confirm_payment_with_amount(self, request: ConfirmWithAmountRequestDTO) -&gt; ConfirmWithAmountResponseDTO:\n        \"\"\"Confirm a payment transaction with amount and order verification.\n\n        Args:\n            request (ConfirmWithAmountRequestDTO): Confirm with amount request data.\n\n        Returns:\n            ConfirmWithAmountResponseDTO: Response containing status, RRN, card number, and token.\n\n        Raises:\n            UnavailableError: If a SOAP fault occurs during the request.\n            InternalError: If an unexpected error occurs during the request.\n        \"\"\"\n        try:\n            request_data = {\n                \"LoginAccount\": self.login_account,\n                \"Token\": request.token,\n                \"OrderId\": request.order_id,\n                \"Amount\": request.amount,\n            }\n\n            logger.debug(f\"Confirming payment with amount: {request_data}\")\n            response = self.confirm_client.service.ConfirmPaymentWithAmount(requestData=request_data)\n            result = ConfirmWithAmountResponseDTO(\n                status=response.Status,\n                rrn=response.RRN,\n                card_number_masked=response.CardNumberMasked,\n                token=response.Token,\n            )\n            logger.debug(f\"Confirm with amount response: {result}\")\n        except Fault as exception:\n            raise UnavailableError(service=\"Parsian Shaparak Confirm Service\") from exception\n        except Exception as exception:\n            raise InternalError() from exception\n        else:\n            return result\n\n    def reverse_payment(self, request: ReverseRequestDTO) -&gt; ReverseResponseDTO:\n        \"\"\"Request a reversal of a confirmed transaction.\n\n        Args:\n            request (ReverseRequestDTO): Reverse request data.\n\n        Returns:\n            ReverseResponseDTO: Response containing status, message, and token.\n\n        Raises:\n            UnavailableError: If a SOAP fault occurs during the request.\n            InternalError: If an unexpected error occurs during the request.\n        \"\"\"\n        try:\n            request_data = {\"LoginAccount\": self.login_account, \"Token\": request.token}\n\n            logger.debug(f\"Reversing payment: {request_data}\")\n            response = self.reversal_client.service.ReversalRequest(requestData=request_data)\n            result = ReverseResponseDTO(\n                status=response.Status,\n                message=response.Message,\n                token=response.Token,\n            )\n            logger.debug(f\"Reversal response: {result}\")\n        except Fault as exception:\n            raise UnavailableError(service=\"Parsian Shaparak Reversal Service\") from exception\n        except Exception as exception:\n            raise InternalError() from exception\n        else:\n            return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter.__init__","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter.__init__(config=None)</code>","text":"<p>Initialize the adapter with Parsian Shaparak configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ParsianShaparakConfig | None</code> <p>Configuration for Parsian Shaparak services. If None, uses global config. Includes optional proxy configuration via the PROXIES field.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If LOGIN_ACCOUNT is not a valid string.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>def __init__(self, config: ParsianShaparakConfig | None = None) -&gt; None:\n    \"\"\"Initialize the adapter with Parsian Shaparak configuration.\n\n    Args:\n        config (ParsianShaparakConfig | None): Configuration for Parsian Shaparak services.\n            If None, uses global config. Includes optional proxy configuration via\n            the PROXIES field.\n\n    Raises:\n        ValueError: If LOGIN_ACCOUNT is not a valid string.\n    \"\"\"\n    configs = BaseConfig.global_config().PARSIAN_SHAPARAK if config is None else config\n    if not configs.LOGIN_ACCOUNT or not isinstance(configs.LOGIN_ACCOUNT, str):\n        raise ValueError(\"LOGIN_ACCOUNT must be a non-empty string\")\n\n    self.login_account = configs.LOGIN_ACCOUNT\n    transport = None\n    if configs.PROXIES:\n        session = requests.Session()\n        session.proxies = configs.PROXIES\n        transport = Transport(session=session)\n\n    # Initialize SOAP clients\n    self.sale_client = zeep.Client(wsdl=configs.PAYMENT_WSDL_URL, transport=transport)\n    self.confirm_client = zeep.Client(wsdl=configs.CONFIRM_WSDL_URL, transport=transport)\n    self.reversal_client = zeep.Client(wsdl=configs.REVERSAL_WSDL_URL, transport=transport)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter.initiate_payment","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter.initiate_payment(request)</code>","text":"<p>Initiate a payment request.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>PaymentRequestDTO</code> <p>Payment request data.</p> required <p>Returns:</p> Name Type Description <code>PaymentResponseDTO</code> <code>PaymentResponseDTO</code> <p>Response containing token, status, and message.</p> <p>Raises:</p> Type Description <code>UnavailableError</code> <p>If a SOAP fault occurs during the request.</p> <code>InternalError</code> <p>If an unexpected error occurs during the request.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>def initiate_payment(self, request: PaymentRequestDTO) -&gt; PaymentResponseDTO:\n    \"\"\"Initiate a payment request.\n\n    Args:\n        request (PaymentRequestDTO): Payment request data.\n\n    Returns:\n        PaymentResponseDTO: Response containing token, status, and message.\n\n    Raises:\n        UnavailableError: If a SOAP fault occurs during the request.\n        InternalError: If an unexpected error occurs during the request.\n    \"\"\"\n    try:\n        request_data = {\n            \"LoginAccount\": self.login_account,\n            \"Amount\": request.amount,\n            \"OrderId\": request.order_id,\n            \"CallBackUrl\": str(request.callback_url),\n            \"AdditionalData\": request.additional_data,\n            \"Originator\": request.originator,\n        }\n\n        logger.debug(f\"Initiating payment: {request_data}\")\n        response = self.sale_client.service.SalePaymentRequest(requestData=request_data)\n        result = PaymentResponseDTO(\n            token=response.Token,\n            status=response.Status,\n            message=response.Message,\n        )\n        logger.debug(f\"Payment response: {result}\")\n    except Fault as exception:\n        raise UnavailableError(service=\"Parsian Shaparak Sale Service\") from exception\n    except Exception as exception:\n        raise InternalError() from exception\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter.confirm_payment","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter.confirm_payment(request)</code>","text":"<p>Confirm a payment transaction.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>ConfirmRequestDTO</code> <p>Confirm request data.</p> required <p>Returns:</p> Name Type Description <code>ConfirmResponseDTO</code> <code>ConfirmResponseDTO</code> <p>Response containing status, RRN, card number, and token.</p> <p>Raises:</p> Type Description <code>UnavailableError</code> <p>If a SOAP fault occurs during the request.</p> <code>InternalError</code> <p>If an unexpected error occurs during the request.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>def confirm_payment(self, request: ConfirmRequestDTO) -&gt; ConfirmResponseDTO:\n    \"\"\"Confirm a payment transaction.\n\n    Args:\n        request (ConfirmRequestDTO): Confirm request data.\n\n    Returns:\n        ConfirmResponseDTO: Response containing status, RRN, card number, and token.\n\n    Raises:\n        UnavailableError: If a SOAP fault occurs during the request.\n        InternalError: If an unexpected error occurs during the request.\n    \"\"\"\n    try:\n        request_data = {\"LoginAccount\": self.login_account, \"Token\": request.token}\n\n        logger.debug(f\"Confirming payment: {request_data}\")\n        response = self.confirm_client.service.ConfirmPayment(requestData=request_data)\n        result = ConfirmResponseDTO(\n            status=response.Status,\n            rrn=response.RRN,\n            card_number_masked=response.CardNumberMasked,\n            token=response.Token,\n        )\n        logger.debug(f\"Confirm response: {result}\")\n    except Fault as exception:\n        raise UnavailableError(service=\"Parsian Shaparak Confirm Service\") from exception\n    except Exception as exception:\n        raise InternalError() from exception\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter.confirm_payment_with_amount","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter.confirm_payment_with_amount(request)</code>","text":"<p>Confirm a payment transaction with amount and order verification.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>ConfirmWithAmountRequestDTO</code> <p>Confirm with amount request data.</p> required <p>Returns:</p> Name Type Description <code>ConfirmWithAmountResponseDTO</code> <code>ConfirmWithAmountResponseDTO</code> <p>Response containing status, RRN, card number, and token.</p> <p>Raises:</p> Type Description <code>UnavailableError</code> <p>If a SOAP fault occurs during the request.</p> <code>InternalError</code> <p>If an unexpected error occurs during the request.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>def confirm_payment_with_amount(self, request: ConfirmWithAmountRequestDTO) -&gt; ConfirmWithAmountResponseDTO:\n    \"\"\"Confirm a payment transaction with amount and order verification.\n\n    Args:\n        request (ConfirmWithAmountRequestDTO): Confirm with amount request data.\n\n    Returns:\n        ConfirmWithAmountResponseDTO: Response containing status, RRN, card number, and token.\n\n    Raises:\n        UnavailableError: If a SOAP fault occurs during the request.\n        InternalError: If an unexpected error occurs during the request.\n    \"\"\"\n    try:\n        request_data = {\n            \"LoginAccount\": self.login_account,\n            \"Token\": request.token,\n            \"OrderId\": request.order_id,\n            \"Amount\": request.amount,\n        }\n\n        logger.debug(f\"Confirming payment with amount: {request_data}\")\n        response = self.confirm_client.service.ConfirmPaymentWithAmount(requestData=request_data)\n        result = ConfirmWithAmountResponseDTO(\n            status=response.Status,\n            rrn=response.RRN,\n            card_number_masked=response.CardNumberMasked,\n            token=response.Token,\n        )\n        logger.debug(f\"Confirm with amount response: {result}\")\n    except Fault as exception:\n        raise UnavailableError(service=\"Parsian Shaparak Confirm Service\") from exception\n    except Exception as exception:\n        raise InternalError() from exception\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter.reverse_payment","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter.reverse_payment(request)</code>","text":"<p>Request a reversal of a confirmed transaction.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>ReverseRequestDTO</code> <p>Reverse request data.</p> required <p>Returns:</p> Name Type Description <code>ReverseResponseDTO</code> <code>ReverseResponseDTO</code> <p>Response containing status, message, and token.</p> <p>Raises:</p> Type Description <code>UnavailableError</code> <p>If a SOAP fault occurs during the request.</p> <code>InternalError</code> <p>If an unexpected error occurs during the request.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>def reverse_payment(self, request: ReverseRequestDTO) -&gt; ReverseResponseDTO:\n    \"\"\"Request a reversal of a confirmed transaction.\n\n    Args:\n        request (ReverseRequestDTO): Reverse request data.\n\n    Returns:\n        ReverseResponseDTO: Response containing status, message, and token.\n\n    Raises:\n        UnavailableError: If a SOAP fault occurs during the request.\n        InternalError: If an unexpected error occurs during the request.\n    \"\"\"\n    try:\n        request_data = {\"LoginAccount\": self.login_account, \"Token\": request.token}\n\n        logger.debug(f\"Reversing payment: {request_data}\")\n        response = self.reversal_client.service.ReversalRequest(requestData=request_data)\n        result = ReverseResponseDTO(\n            status=response.Status,\n            message=response.Message,\n            token=response.Token,\n        )\n        logger.debug(f\"Reversal response: {result}\")\n    except Fault as exception:\n        raise UnavailableError(service=\"Parsian Shaparak Reversal Service\") from exception\n    except Exception as exception:\n        raise InternalError() from exception\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#temporal","title":"Temporal","text":"<p>Temporal workflow orchestration adapter for durable workflow execution and activity coordination.</p> <pre><code>from archipy.adapters.temporal.adapters import TemporalAdapter\nfrom archipy.adapters.temporal.worker import TemporalWorkerManager\nfrom archipy.adapters.temporal.base import BaseWorkflow, BaseActivity\n\n# Create a Temporal adapter\ntemporal_adapter = TemporalAdapter()  # Uses global config by default\n\n# Start a workflow execution\nworkflow_handle = await temporal_adapter.start_workflow(\n    workflow=\"MyWorkflow\",\n    arg={\"input\": \"data\"},\n    workflow_id=\"unique-workflow-id\",\n    task_queue=\"my-task-queue\"\n)\n\n# Execute a workflow and wait for completion\nresult = await temporal_adapter.execute_workflow(\n    workflow=\"MyWorkflow\",\n    arg={\"input\": \"data\"},\n    workflow_id=\"unique-workflow-id-2\",\n    task_queue=\"my-task-queue\"\n)\n\n# Signal a workflow\nawait temporal_adapter.signal_workflow(\n    workflow_id=\"unique-workflow-id\",\n    signal_name=\"update_signal\",\n    arg={\"update\": \"data\"}\n)\n\n# Query a workflow\nquery_result = await temporal_adapter.query_workflow(\n    workflow_id=\"unique-workflow-id\",\n    query_name=\"get_status\"\n)\n\n# Worker management\nworker_manager = TemporalWorkerManager()\n\n# Start a worker\nworker_handle = await worker_manager.start_worker(\n    task_queue=\"my-task-queue\",\n    workflows=[MyWorkflow],\n    activities=[my_activity_instance]\n)\n</code></pre> <p>For detailed examples and usage guidelines, see the Temporal Examples.</p>"},{"location":"api_reference/adapters/#temporal-adapter","title":"Temporal Adapter","text":"<p>Temporal adapter implementation for workflow orchestration.</p> <p>This module provides concrete implementations of the Temporal port interfaces, integrating with the Temporal workflow engine while following ArchiPy patterns and conventions.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.adapters.TemporalAdapter","title":"<code>archipy.adapters.temporal.adapters.TemporalAdapter</code>","text":"<p>               Bases: <code>TemporalPort</code></p> <p>Temporal workflow adapter implementing the TemporalPort interface.</p> <p>This adapter provides a standardized interface for interacting with Temporal workflow orchestration services, following ArchiPy architecture patterns. It handles client connections, TLS configuration, and workflow lifecycle management.</p> <p>Parameters:</p> Name Type Description Default <code>temporal_config</code> <code>TemporalConfig</code> <p>Configuration settings for Temporal. If None, retrieves from global config. Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/temporal/adapters.py</code> <pre><code>class TemporalAdapter(TemporalPort):\n    \"\"\"Temporal workflow adapter implementing the TemporalPort interface.\n\n    This adapter provides a standardized interface for interacting with Temporal\n    workflow orchestration services, following ArchiPy architecture patterns.\n    It handles client connections, TLS configuration, and workflow lifecycle\n    management.\n\n    Args:\n        temporal_config (TemporalConfig, optional): Configuration settings for Temporal.\n            If None, retrieves from global config. Defaults to None.\n    \"\"\"\n\n    def __init__(self, temporal_config: TemporalConfig | None = None) -&gt; None:\n        \"\"\"Initialize the TemporalAdapter with configuration settings.\n\n        Args:\n            temporal_config (TemporalConfig, optional): Configuration settings for Temporal.\n                If None, retrieves from global config. Defaults to None.\n        \"\"\"\n        # Get temporal config from the global config or use provided one\n        if temporal_config is None:\n            global_config = BaseConfig.global_config()\n            if hasattr(global_config, \"TEMPORAL\"):\n                self.config = global_config.TEMPORAL\n            else:\n                # Create a default config if none exists\n                from archipy.configs.config_template import TemporalConfig\n\n                self.config = TemporalConfig()\n        else:\n            self.config = temporal_config\n        self._client: Client | None = None\n\n    async def get_client(self) -&gt; Client:\n        \"\"\"Get or create the Temporal client connection.\n\n        Returns:\n            Client: The Temporal client instance.\n\n        Raises:\n            ConnectionError: If unable to connect to Temporal server.\n        \"\"\"\n        if self._client is None:\n            try:\n                tls_config = self._build_tls_config() if self._has_tls_config() else None\n\n                self._client = await Client.connect(\n                    f\"{self.config.HOST}:{self.config.PORT}\",\n                    namespace=self.config.NAMESPACE,\n                    tls=tls_config,\n                )\n            except Exception as error:\n                raise BaseError(\n                    additional_data={\n                        \"server\": f\"{self.config.HOST}:{self.config.PORT}\",\n                        \"namespace\": self.config.NAMESPACE,\n                        \"original_error\": str(error),\n                    },\n                ) from error\n\n        return self._client\n\n    def _has_tls_config(self) -&gt; bool:\n        \"\"\"Check if TLS configuration is provided.\n\n        Returns:\n            bool: True if TLS configuration is complete, False otherwise.\n        \"\"\"\n        return all(\n            [\n                self.config.TLS_CA_CERT,\n                self.config.TLS_CLIENT_CERT,\n                self.config.TLS_CLIENT_KEY,\n            ],\n        )\n\n    def _build_tls_config(self) -&gt; TLSConfig:\n        \"\"\"Build TLS configuration for secure connections.\n\n        Returns:\n            TLSConfig: The TLS configuration object.\n\n        Raises:\n            InvalidArgumentError: If TLS configuration is incomplete.\n        \"\"\"\n        if not self._has_tls_config():\n            raise InvalidArgumentError(\n                additional_data={\n                    \"ca_cert\": bool(self.config.TLS_CA_CERT),\n                    \"client_cert\": bool(self.config.TLS_CLIENT_CERT),\n                    \"client_key\": bool(self.config.TLS_CLIENT_KEY),\n                },\n            )\n\n        try:\n            with open(self.config.TLS_CA_CERT, \"rb\") as f:\n                ca_cert_data = f.read()\n\n            client_cert_data = None\n            client_key_data = None\n\n            if self.config.TLS_CLIENT_CERT:\n                with open(self.config.TLS_CLIENT_CERT, \"rb\") as f:\n                    client_cert_data = f.read()\n\n            if self.config.TLS_CLIENT_KEY:\n                with open(self.config.TLS_CLIENT_KEY, \"rb\") as f:\n                    client_key_data = f.read()\n\n            return TLSConfig(\n                server_root_ca_cert=ca_cert_data,\n                client_cert=client_cert_data,\n                client_private_key=client_key_data,\n            )\n        except OSError as error:\n            raise InvalidArgumentError(additional_data={\"original_error\": str(error)}) from error\n\n    def _build_retry_policy(self) -&gt; RetryPolicy:\n        \"\"\"Build default retry policy from configuration.\n\n        Returns:\n            RetryPolicy: The configured retry policy.\n        \"\"\"\n        return RetryPolicy(\n            maximum_attempts=self.config.RETRY_MAXIMUM_ATTEMPTS,\n            backoff_coefficient=self.config.RETRY_BACKOFF_COEFFICIENT,\n            maximum_interval=timedelta(seconds=self.config.RETRY_MAXIMUM_INTERVAL),\n        )\n\n    @override\n    async def start_workflow(\n        self,\n        workflow: str | Callable,\n        arg: Any = None,\n        workflow_id: str | None = None,\n        task_queue: str | None = None,\n        execution_timeout: int | None = None,\n        run_timeout: int | None = None,\n        task_timeout: int | None = None,\n        memo: dict[str, Any] | None = None,\n        search_attributes: dict[str, Any] | None = None,\n    ) -&gt; WorkflowHandle[T, Any]:\n        \"\"\"Start a workflow execution asynchronously.\n\n        Args:\n            workflow (str | Callable): The workflow function or workflow type name.\n            arg (Any, optional): Input argument for the workflow. Defaults to None.\n            workflow_id (str, optional): Unique identifier for the workflow execution.\n                If None, a UUID will be generated. Defaults to None.\n            task_queue (str, optional): Task queue name for workflow execution.\n                If None, uses the default task queue. Defaults to None.\n            execution_timeout (int, optional): Maximum workflow execution time in seconds.\n                Overrides config default. Defaults to None.\n            run_timeout (int, optional): Maximum single workflow run time in seconds.\n                Overrides config default. Defaults to None.\n            task_timeout (int, optional): Maximum workflow task processing time in seconds.\n                Overrides config default. Defaults to None.\n            memo (dict[str, Any], optional): Non-indexed metadata for the workflow.\n                Defaults to None.\n            search_attributes (dict[str, Any], optional): Indexed metadata for workflow search.\n                Defaults to None.\n\n        Returns:\n            WorkflowHandle[T, Any]: Handle to the started workflow execution.\n        \"\"\"\n        client = await self.get_client()\n\n        workflow_id = workflow_id or str(uuid4())\n        task_queue = task_queue or self.config.TASK_QUEUE\n\n        return await client.start_workflow(\n            workflow,\n            arg,\n            id=workflow_id,\n            task_queue=task_queue,\n            execution_timeout=timedelta(seconds=execution_timeout or self.config.WORKFLOW_EXECUTION_TIMEOUT),\n            run_timeout=timedelta(seconds=run_timeout or self.config.WORKFLOW_RUN_TIMEOUT),\n            task_timeout=timedelta(seconds=task_timeout or self.config.WORKFLOW_TASK_TIMEOUT),\n            retry_policy=self._build_retry_policy(),\n            memo=memo,\n            search_attributes=search_attributes,\n        )\n\n    @override\n    async def execute_workflow(\n        self,\n        workflow: str | Callable,\n        arg: Any = None,\n        workflow_id: str | None = None,\n        task_queue: str | None = None,\n        execution_timeout: int | None = None,\n        run_timeout: int | None = None,\n        task_timeout: int | None = None,\n    ) -&gt; T:\n        \"\"\"Execute a workflow and wait for its completion.\n\n        Args:\n            workflow (str | Callable): The workflow function or workflow type name.\n            arg (Any, optional): Input argument for the workflow. Defaults to None.\n            workflow_id (str, optional): Unique identifier for the workflow execution.\n                If None, a UUID will be generated. Defaults to None.\n            task_queue (str, optional): Task queue name for workflow execution.\n                If None, uses the default task queue. Defaults to None.\n            execution_timeout (int, optional): Maximum workflow execution time in seconds.\n                Overrides config default. Defaults to None.\n            run_timeout (int, optional): Maximum single workflow run time in seconds.\n                Overrides config default. Defaults to None.\n            task_timeout (int, optional): Maximum workflow task processing time in seconds.\n                Overrides config default. Defaults to None.\n\n        Returns:\n            T: The workflow execution result.\n        \"\"\"\n        client = await self.get_client()\n\n        workflow_id = workflow_id or str(uuid4())\n        task_queue = task_queue or self.config.TASK_QUEUE\n\n        return await client.execute_workflow(\n            workflow,\n            arg,\n            id=workflow_id,\n            task_queue=task_queue,\n            execution_timeout=timedelta(seconds=execution_timeout or self.config.WORKFLOW_EXECUTION_TIMEOUT),\n            run_timeout=timedelta(seconds=run_timeout or self.config.WORKFLOW_RUN_TIMEOUT),\n            task_timeout=timedelta(seconds=task_timeout or self.config.WORKFLOW_TASK_TIMEOUT),\n            retry_policy=self._build_retry_policy(),\n        )\n\n    @override\n    async def get_workflow_handle(self, workflow_id: str, run_id: str | None = None) -&gt; WorkflowHandle[T, Any]:\n        \"\"\"Get a handle to an existing workflow execution.\n\n        Args:\n            workflow_id (str): The unique identifier of the workflow execution.\n            run_id (str, optional): The specific run identifier within the workflow.\n                If None, gets the latest run. Defaults to None.\n\n        Returns:\n            WorkflowHandle[T, Any]: Handle to the workflow execution.\n        \"\"\"\n        client = await self.get_client()\n        return client.get_workflow_handle(workflow_id, run_id=run_id)\n\n    @override\n    async def cancel_workflow(self, workflow_id: str, run_id: str | None = None, reason: str | None = None) -&gt; None:\n        \"\"\"Cancel a running workflow execution.\n\n        Args:\n            workflow_id (str): The unique identifier of the workflow execution.\n            run_id (str, optional): The specific run identifier within the workflow.\n                If None, cancels the latest run. Defaults to None.\n            reason (str, optional): Reason for cancellation. Defaults to None.\n        \"\"\"\n        handle = await self.get_workflow_handle(workflow_id, run_id)\n        await handle.cancel()\n\n    @override\n    async def terminate_workflow(self, workflow_id: str, run_id: str | None = None, reason: str | None = None) -&gt; None:\n        \"\"\"Terminate a running workflow execution immediately.\n\n        Args:\n            workflow_id (str): The unique identifier of the workflow execution.\n            run_id (str, optional): The specific run identifier within the workflow.\n                If None, terminates the latest run. Defaults to None.\n            reason (str, optional): Reason for termination. Defaults to None.\n        \"\"\"\n        handle = await self.get_workflow_handle(workflow_id, run_id)\n        await handle.terminate(reason=reason)\n\n    @override\n    async def signal_workflow(\n        self,\n        workflow_id: str,\n        signal_name: str,\n        arg: Any = None,\n        run_id: str | None = None,\n    ) -&gt; None:\n        \"\"\"Send a signal to a running workflow execution.\n\n        Args:\n            workflow_id (str): The unique identifier of the workflow execution.\n            signal_name (str): The name of the signal to send.\n            arg (Any, optional): Argument to pass with the signal. Defaults to None.\n            run_id (str, optional): The specific run identifier within the workflow.\n                If None, signals the latest run. Defaults to None.\n        \"\"\"\n        handle = await self.get_workflow_handle(workflow_id, run_id)\n        await handle.signal(signal_name, arg)\n\n    @override\n    async def query_workflow(\n        self,\n        workflow_id: str,\n        query_name: str,\n        arg: Any = None,\n        run_id: str | None = None,\n    ) -&gt; Any:\n        \"\"\"Query a running workflow execution for information.\n\n        Args:\n            workflow_id (str): The unique identifier of the workflow execution.\n            query_name (str): The name of the query to execute.\n            arg (Any, optional): Argument to pass with the query. Defaults to None.\n            run_id (str, optional): The specific run identifier within the workflow.\n                If None, queries the latest run. Defaults to None.\n\n        Returns:\n            Any: The query result from the workflow.\n        \"\"\"\n        handle = await self.get_workflow_handle(workflow_id, run_id)\n        return await handle.query(query_name, arg)\n\n    @override\n    async def list_workflows(\n        self,\n        query: str | None = None,\n        page_size: int | None = None,\n        next_page_token: bytes | None = None,\n    ) -&gt; Any:\n        \"\"\"List workflow executions matching the given criteria.\n\n        Args:\n            query (str, optional): List filter query in Temporal SQL syntax.\n                Defaults to None (no filter).\n            page_size (int, optional): Maximum number of results per page.\n                Defaults to None (server default).\n            next_page_token (bytes, optional): Token for pagination.\n                Defaults to None (first page).\n\n        Returns:\n            Any: List of workflow executions with pagination info.\n        \"\"\"\n        client = await self.get_client()\n        # list_workflows returns an async iterator, not awaitable\n        workflows_iter = client.list_workflows(\n            query=query,\n            page_size=page_size or 100,\n            next_page_token=next_page_token,\n        )\n        # Convert to list for compatibility\n        workflows = []\n        async for workflow in workflows_iter:\n            workflows.append(workflow)\n        return workflows\n\n    @override\n    async def describe_workflow(self, workflow_id: str, run_id: str | None = None) -&gt; Any:\n        \"\"\"Get detailed information about a workflow execution.\n\n        Args:\n            workflow_id (str): The unique identifier of the workflow execution.\n            run_id (str, optional): The specific run identifier within the workflow.\n                If None, describes the latest run. Defaults to None.\n\n        Returns:\n            Any: Detailed workflow execution information.\n        \"\"\"\n        handle = await self.get_workflow_handle(workflow_id, run_id)\n        return await handle.describe()\n\n    @override\n    async def close(self) -&gt; None:\n        \"\"\"Close the Temporal client connection.\n\n        Performs cleanup of resources and closes the connection to the Temporal server.\n        Should be called when the adapter is no longer needed.\n        \"\"\"\n        if self._client:\n            # Temporal client doesn't have a close method, just clear the reference\n            self._client = None\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.adapters.TemporalAdapter.__init__","title":"<code>archipy.adapters.temporal.adapters.TemporalAdapter.__init__(temporal_config=None)</code>","text":"<p>Initialize the TemporalAdapter with configuration settings.</p> <p>Parameters:</p> Name Type Description Default <code>temporal_config</code> <code>TemporalConfig</code> <p>Configuration settings for Temporal. If None, retrieves from global config. Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/temporal/adapters.py</code> <pre><code>def __init__(self, temporal_config: TemporalConfig | None = None) -&gt; None:\n    \"\"\"Initialize the TemporalAdapter with configuration settings.\n\n    Args:\n        temporal_config (TemporalConfig, optional): Configuration settings for Temporal.\n            If None, retrieves from global config. Defaults to None.\n    \"\"\"\n    # Get temporal config from the global config or use provided one\n    if temporal_config is None:\n        global_config = BaseConfig.global_config()\n        if hasattr(global_config, \"TEMPORAL\"):\n            self.config = global_config.TEMPORAL\n        else:\n            # Create a default config if none exists\n            from archipy.configs.config_template import TemporalConfig\n\n            self.config = TemporalConfig()\n    else:\n        self.config = temporal_config\n    self._client: Client | None = None\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.adapters.TemporalAdapter.get_client","title":"<code>archipy.adapters.temporal.adapters.TemporalAdapter.get_client()</code>  <code>async</code>","text":"<p>Get or create the Temporal client connection.</p> <p>Returns:</p> Name Type Description <code>Client</code> <code>Client</code> <p>The Temporal client instance.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If unable to connect to Temporal server.</p> Source code in <code>archipy/adapters/temporal/adapters.py</code> <pre><code>async def get_client(self) -&gt; Client:\n    \"\"\"Get or create the Temporal client connection.\n\n    Returns:\n        Client: The Temporal client instance.\n\n    Raises:\n        ConnectionError: If unable to connect to Temporal server.\n    \"\"\"\n    if self._client is None:\n        try:\n            tls_config = self._build_tls_config() if self._has_tls_config() else None\n\n            self._client = await Client.connect(\n                f\"{self.config.HOST}:{self.config.PORT}\",\n                namespace=self.config.NAMESPACE,\n                tls=tls_config,\n            )\n        except Exception as error:\n            raise BaseError(\n                additional_data={\n                    \"server\": f\"{self.config.HOST}:{self.config.PORT}\",\n                    \"namespace\": self.config.NAMESPACE,\n                    \"original_error\": str(error),\n                },\n            ) from error\n\n    return self._client\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.adapters.TemporalAdapter.start_workflow","title":"<code>archipy.adapters.temporal.adapters.TemporalAdapter.start_workflow(workflow, arg=None, workflow_id=None, task_queue=None, execution_timeout=None, run_timeout=None, task_timeout=None, memo=None, search_attributes=None)</code>  <code>async</code>","text":"<p>Start a workflow execution asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>workflow</code> <code>str | Callable</code> <p>The workflow function or workflow type name.</p> required <code>arg</code> <code>Any</code> <p>Input argument for the workflow. Defaults to None.</p> <code>None</code> <code>workflow_id</code> <code>str</code> <p>Unique identifier for the workflow execution. If None, a UUID will be generated. Defaults to None.</p> <code>None</code> <code>task_queue</code> <code>str</code> <p>Task queue name for workflow execution. If None, uses the default task queue. Defaults to None.</p> <code>None</code> <code>execution_timeout</code> <code>int</code> <p>Maximum workflow execution time in seconds. Overrides config default. Defaults to None.</p> <code>None</code> <code>run_timeout</code> <code>int</code> <p>Maximum single workflow run time in seconds. Overrides config default. Defaults to None.</p> <code>None</code> <code>task_timeout</code> <code>int</code> <p>Maximum workflow task processing time in seconds. Overrides config default. Defaults to None.</p> <code>None</code> <code>memo</code> <code>dict[str, Any]</code> <p>Non-indexed metadata for the workflow. Defaults to None.</p> <code>None</code> <code>search_attributes</code> <code>dict[str, Any]</code> <p>Indexed metadata for workflow search. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>WorkflowHandle[T, Any]</code> <p>WorkflowHandle[T, Any]: Handle to the started workflow execution.</p> Source code in <code>archipy/adapters/temporal/adapters.py</code> <pre><code>@override\nasync def start_workflow(\n    self,\n    workflow: str | Callable,\n    arg: Any = None,\n    workflow_id: str | None = None,\n    task_queue: str | None = None,\n    execution_timeout: int | None = None,\n    run_timeout: int | None = None,\n    task_timeout: int | None = None,\n    memo: dict[str, Any] | None = None,\n    search_attributes: dict[str, Any] | None = None,\n) -&gt; WorkflowHandle[T, Any]:\n    \"\"\"Start a workflow execution asynchronously.\n\n    Args:\n        workflow (str | Callable): The workflow function or workflow type name.\n        arg (Any, optional): Input argument for the workflow. Defaults to None.\n        workflow_id (str, optional): Unique identifier for the workflow execution.\n            If None, a UUID will be generated. Defaults to None.\n        task_queue (str, optional): Task queue name for workflow execution.\n            If None, uses the default task queue. Defaults to None.\n        execution_timeout (int, optional): Maximum workflow execution time in seconds.\n            Overrides config default. Defaults to None.\n        run_timeout (int, optional): Maximum single workflow run time in seconds.\n            Overrides config default. Defaults to None.\n        task_timeout (int, optional): Maximum workflow task processing time in seconds.\n            Overrides config default. Defaults to None.\n        memo (dict[str, Any], optional): Non-indexed metadata for the workflow.\n            Defaults to None.\n        search_attributes (dict[str, Any], optional): Indexed metadata for workflow search.\n            Defaults to None.\n\n    Returns:\n        WorkflowHandle[T, Any]: Handle to the started workflow execution.\n    \"\"\"\n    client = await self.get_client()\n\n    workflow_id = workflow_id or str(uuid4())\n    task_queue = task_queue or self.config.TASK_QUEUE\n\n    return await client.start_workflow(\n        workflow,\n        arg,\n        id=workflow_id,\n        task_queue=task_queue,\n        execution_timeout=timedelta(seconds=execution_timeout or self.config.WORKFLOW_EXECUTION_TIMEOUT),\n        run_timeout=timedelta(seconds=run_timeout or self.config.WORKFLOW_RUN_TIMEOUT),\n        task_timeout=timedelta(seconds=task_timeout or self.config.WORKFLOW_TASK_TIMEOUT),\n        retry_policy=self._build_retry_policy(),\n        memo=memo,\n        search_attributes=search_attributes,\n    )\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.adapters.TemporalAdapter.execute_workflow","title":"<code>archipy.adapters.temporal.adapters.TemporalAdapter.execute_workflow(workflow, arg=None, workflow_id=None, task_queue=None, execution_timeout=None, run_timeout=None, task_timeout=None)</code>  <code>async</code>","text":"<p>Execute a workflow and wait for its completion.</p> <p>Parameters:</p> Name Type Description Default <code>workflow</code> <code>str | Callable</code> <p>The workflow function or workflow type name.</p> required <code>arg</code> <code>Any</code> <p>Input argument for the workflow. Defaults to None.</p> <code>None</code> <code>workflow_id</code> <code>str</code> <p>Unique identifier for the workflow execution. If None, a UUID will be generated. Defaults to None.</p> <code>None</code> <code>task_queue</code> <code>str</code> <p>Task queue name for workflow execution. If None, uses the default task queue. Defaults to None.</p> <code>None</code> <code>execution_timeout</code> <code>int</code> <p>Maximum workflow execution time in seconds. Overrides config default. Defaults to None.</p> <code>None</code> <code>run_timeout</code> <code>int</code> <p>Maximum single workflow run time in seconds. Overrides config default. Defaults to None.</p> <code>None</code> <code>task_timeout</code> <code>int</code> <p>Maximum workflow task processing time in seconds. Overrides config default. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The workflow execution result.</p> Source code in <code>archipy/adapters/temporal/adapters.py</code> <pre><code>@override\nasync def execute_workflow(\n    self,\n    workflow: str | Callable,\n    arg: Any = None,\n    workflow_id: str | None = None,\n    task_queue: str | None = None,\n    execution_timeout: int | None = None,\n    run_timeout: int | None = None,\n    task_timeout: int | None = None,\n) -&gt; T:\n    \"\"\"Execute a workflow and wait for its completion.\n\n    Args:\n        workflow (str | Callable): The workflow function or workflow type name.\n        arg (Any, optional): Input argument for the workflow. Defaults to None.\n        workflow_id (str, optional): Unique identifier for the workflow execution.\n            If None, a UUID will be generated. Defaults to None.\n        task_queue (str, optional): Task queue name for workflow execution.\n            If None, uses the default task queue. Defaults to None.\n        execution_timeout (int, optional): Maximum workflow execution time in seconds.\n            Overrides config default. Defaults to None.\n        run_timeout (int, optional): Maximum single workflow run time in seconds.\n            Overrides config default. Defaults to None.\n        task_timeout (int, optional): Maximum workflow task processing time in seconds.\n            Overrides config default. Defaults to None.\n\n    Returns:\n        T: The workflow execution result.\n    \"\"\"\n    client = await self.get_client()\n\n    workflow_id = workflow_id or str(uuid4())\n    task_queue = task_queue or self.config.TASK_QUEUE\n\n    return await client.execute_workflow(\n        workflow,\n        arg,\n        id=workflow_id,\n        task_queue=task_queue,\n        execution_timeout=timedelta(seconds=execution_timeout or self.config.WORKFLOW_EXECUTION_TIMEOUT),\n        run_timeout=timedelta(seconds=run_timeout or self.config.WORKFLOW_RUN_TIMEOUT),\n        task_timeout=timedelta(seconds=task_timeout or self.config.WORKFLOW_TASK_TIMEOUT),\n        retry_policy=self._build_retry_policy(),\n    )\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.adapters.TemporalAdapter.get_workflow_handle","title":"<code>archipy.adapters.temporal.adapters.TemporalAdapter.get_workflow_handle(workflow_id, run_id=None)</code>  <code>async</code>","text":"<p>Get a handle to an existing workflow execution.</p> <p>Parameters:</p> Name Type Description Default <code>workflow_id</code> <code>str</code> <p>The unique identifier of the workflow execution.</p> required <code>run_id</code> <code>str</code> <p>The specific run identifier within the workflow. If None, gets the latest run. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>WorkflowHandle[T, Any]</code> <p>WorkflowHandle[T, Any]: Handle to the workflow execution.</p> Source code in <code>archipy/adapters/temporal/adapters.py</code> <pre><code>@override\nasync def get_workflow_handle(self, workflow_id: str, run_id: str | None = None) -&gt; WorkflowHandle[T, Any]:\n    \"\"\"Get a handle to an existing workflow execution.\n\n    Args:\n        workflow_id (str): The unique identifier of the workflow execution.\n        run_id (str, optional): The specific run identifier within the workflow.\n            If None, gets the latest run. Defaults to None.\n\n    Returns:\n        WorkflowHandle[T, Any]: Handle to the workflow execution.\n    \"\"\"\n    client = await self.get_client()\n    return client.get_workflow_handle(workflow_id, run_id=run_id)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.adapters.TemporalAdapter.cancel_workflow","title":"<code>archipy.adapters.temporal.adapters.TemporalAdapter.cancel_workflow(workflow_id, run_id=None, reason=None)</code>  <code>async</code>","text":"<p>Cancel a running workflow execution.</p> <p>Parameters:</p> Name Type Description Default <code>workflow_id</code> <code>str</code> <p>The unique identifier of the workflow execution.</p> required <code>run_id</code> <code>str</code> <p>The specific run identifier within the workflow. If None, cancels the latest run. Defaults to None.</p> <code>None</code> <code>reason</code> <code>str</code> <p>Reason for cancellation. Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/temporal/adapters.py</code> <pre><code>@override\nasync def cancel_workflow(self, workflow_id: str, run_id: str | None = None, reason: str | None = None) -&gt; None:\n    \"\"\"Cancel a running workflow execution.\n\n    Args:\n        workflow_id (str): The unique identifier of the workflow execution.\n        run_id (str, optional): The specific run identifier within the workflow.\n            If None, cancels the latest run. Defaults to None.\n        reason (str, optional): Reason for cancellation. Defaults to None.\n    \"\"\"\n    handle = await self.get_workflow_handle(workflow_id, run_id)\n    await handle.cancel()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.adapters.TemporalAdapter.terminate_workflow","title":"<code>archipy.adapters.temporal.adapters.TemporalAdapter.terminate_workflow(workflow_id, run_id=None, reason=None)</code>  <code>async</code>","text":"<p>Terminate a running workflow execution immediately.</p> <p>Parameters:</p> Name Type Description Default <code>workflow_id</code> <code>str</code> <p>The unique identifier of the workflow execution.</p> required <code>run_id</code> <code>str</code> <p>The specific run identifier within the workflow. If None, terminates the latest run. Defaults to None.</p> <code>None</code> <code>reason</code> <code>str</code> <p>Reason for termination. Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/temporal/adapters.py</code> <pre><code>@override\nasync def terminate_workflow(self, workflow_id: str, run_id: str | None = None, reason: str | None = None) -&gt; None:\n    \"\"\"Terminate a running workflow execution immediately.\n\n    Args:\n        workflow_id (str): The unique identifier of the workflow execution.\n        run_id (str, optional): The specific run identifier within the workflow.\n            If None, terminates the latest run. Defaults to None.\n        reason (str, optional): Reason for termination. Defaults to None.\n    \"\"\"\n    handle = await self.get_workflow_handle(workflow_id, run_id)\n    await handle.terminate(reason=reason)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.adapters.TemporalAdapter.signal_workflow","title":"<code>archipy.adapters.temporal.adapters.TemporalAdapter.signal_workflow(workflow_id, signal_name, arg=None, run_id=None)</code>  <code>async</code>","text":"<p>Send a signal to a running workflow execution.</p> <p>Parameters:</p> Name Type Description Default <code>workflow_id</code> <code>str</code> <p>The unique identifier of the workflow execution.</p> required <code>signal_name</code> <code>str</code> <p>The name of the signal to send.</p> required <code>arg</code> <code>Any</code> <p>Argument to pass with the signal. Defaults to None.</p> <code>None</code> <code>run_id</code> <code>str</code> <p>The specific run identifier within the workflow. If None, signals the latest run. Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/temporal/adapters.py</code> <pre><code>@override\nasync def signal_workflow(\n    self,\n    workflow_id: str,\n    signal_name: str,\n    arg: Any = None,\n    run_id: str | None = None,\n) -&gt; None:\n    \"\"\"Send a signal to a running workflow execution.\n\n    Args:\n        workflow_id (str): The unique identifier of the workflow execution.\n        signal_name (str): The name of the signal to send.\n        arg (Any, optional): Argument to pass with the signal. Defaults to None.\n        run_id (str, optional): The specific run identifier within the workflow.\n            If None, signals the latest run. Defaults to None.\n    \"\"\"\n    handle = await self.get_workflow_handle(workflow_id, run_id)\n    await handle.signal(signal_name, arg)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.adapters.TemporalAdapter.query_workflow","title":"<code>archipy.adapters.temporal.adapters.TemporalAdapter.query_workflow(workflow_id, query_name, arg=None, run_id=None)</code>  <code>async</code>","text":"<p>Query a running workflow execution for information.</p> <p>Parameters:</p> Name Type Description Default <code>workflow_id</code> <code>str</code> <p>The unique identifier of the workflow execution.</p> required <code>query_name</code> <code>str</code> <p>The name of the query to execute.</p> required <code>arg</code> <code>Any</code> <p>Argument to pass with the query. Defaults to None.</p> <code>None</code> <code>run_id</code> <code>str</code> <p>The specific run identifier within the workflow. If None, queries the latest run. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The query result from the workflow.</p> Source code in <code>archipy/adapters/temporal/adapters.py</code> <pre><code>@override\nasync def query_workflow(\n    self,\n    workflow_id: str,\n    query_name: str,\n    arg: Any = None,\n    run_id: str | None = None,\n) -&gt; Any:\n    \"\"\"Query a running workflow execution for information.\n\n    Args:\n        workflow_id (str): The unique identifier of the workflow execution.\n        query_name (str): The name of the query to execute.\n        arg (Any, optional): Argument to pass with the query. Defaults to None.\n        run_id (str, optional): The specific run identifier within the workflow.\n            If None, queries the latest run. Defaults to None.\n\n    Returns:\n        Any: The query result from the workflow.\n    \"\"\"\n    handle = await self.get_workflow_handle(workflow_id, run_id)\n    return await handle.query(query_name, arg)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.adapters.TemporalAdapter.list_workflows","title":"<code>archipy.adapters.temporal.adapters.TemporalAdapter.list_workflows(query=None, page_size=None, next_page_token=None)</code>  <code>async</code>","text":"<p>List workflow executions matching the given criteria.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>List filter query in Temporal SQL syntax. Defaults to None (no filter).</p> <code>None</code> <code>page_size</code> <code>int</code> <p>Maximum number of results per page. Defaults to None (server default).</p> <code>None</code> <code>next_page_token</code> <code>bytes</code> <p>Token for pagination. Defaults to None (first page).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>List of workflow executions with pagination info.</p> Source code in <code>archipy/adapters/temporal/adapters.py</code> <pre><code>@override\nasync def list_workflows(\n    self,\n    query: str | None = None,\n    page_size: int | None = None,\n    next_page_token: bytes | None = None,\n) -&gt; Any:\n    \"\"\"List workflow executions matching the given criteria.\n\n    Args:\n        query (str, optional): List filter query in Temporal SQL syntax.\n            Defaults to None (no filter).\n        page_size (int, optional): Maximum number of results per page.\n            Defaults to None (server default).\n        next_page_token (bytes, optional): Token for pagination.\n            Defaults to None (first page).\n\n    Returns:\n        Any: List of workflow executions with pagination info.\n    \"\"\"\n    client = await self.get_client()\n    # list_workflows returns an async iterator, not awaitable\n    workflows_iter = client.list_workflows(\n        query=query,\n        page_size=page_size or 100,\n        next_page_token=next_page_token,\n    )\n    # Convert to list for compatibility\n    workflows = []\n    async for workflow in workflows_iter:\n        workflows.append(workflow)\n    return workflows\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.adapters.TemporalAdapter.describe_workflow","title":"<code>archipy.adapters.temporal.adapters.TemporalAdapter.describe_workflow(workflow_id, run_id=None)</code>  <code>async</code>","text":"<p>Get detailed information about a workflow execution.</p> <p>Parameters:</p> Name Type Description Default <code>workflow_id</code> <code>str</code> <p>The unique identifier of the workflow execution.</p> required <code>run_id</code> <code>str</code> <p>The specific run identifier within the workflow. If None, describes the latest run. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Detailed workflow execution information.</p> Source code in <code>archipy/adapters/temporal/adapters.py</code> <pre><code>@override\nasync def describe_workflow(self, workflow_id: str, run_id: str | None = None) -&gt; Any:\n    \"\"\"Get detailed information about a workflow execution.\n\n    Args:\n        workflow_id (str): The unique identifier of the workflow execution.\n        run_id (str, optional): The specific run identifier within the workflow.\n            If None, describes the latest run. Defaults to None.\n\n    Returns:\n        Any: Detailed workflow execution information.\n    \"\"\"\n    handle = await self.get_workflow_handle(workflow_id, run_id)\n    return await handle.describe()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.adapters.TemporalAdapter.close","title":"<code>archipy.adapters.temporal.adapters.TemporalAdapter.close()</code>  <code>async</code>","text":"<p>Close the Temporal client connection.</p> <p>Performs cleanup of resources and closes the connection to the Temporal server. Should be called when the adapter is no longer needed.</p> Source code in <code>archipy/adapters/temporal/adapters.py</code> <pre><code>@override\nasync def close(self) -&gt; None:\n    \"\"\"Close the Temporal client connection.\n\n    Performs cleanup of resources and closes the connection to the Temporal server.\n    Should be called when the adapter is no longer needed.\n    \"\"\"\n    if self._client:\n        # Temporal client doesn't have a close method, just clear the reference\n        self._client = None\n</code></pre>"},{"location":"api_reference/adapters/#temporal-ports","title":"Temporal Ports","text":"<p>Port interfaces for Temporal workflow orchestration.</p> <p>This module defines the abstract interfaces for Temporal workflow and activity operations, providing a standardized contract for workflow orchestration within the ArchiPy architecture.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.ports.TemporalPort","title":"<code>archipy.adapters.temporal.ports.TemporalPort</code>","text":"<p>Interface for Temporal workflow operations providing a standardized access pattern.</p> <p>This interface defines the contract for Temporal adapters, ensuring consistent implementation of workflow operations across different adapters. It covers workflow lifecycle management, execution control, and query operations.</p> <p>Implementing classes should provide concrete implementations for all methods, typically by wrapping a Temporal client library.</p> Source code in <code>archipy/adapters/temporal/ports.py</code> <pre><code>class TemporalPort:\n    \"\"\"Interface for Temporal workflow operations providing a standardized access pattern.\n\n    This interface defines the contract for Temporal adapters, ensuring consistent\n    implementation of workflow operations across different adapters. It covers\n    workflow lifecycle management, execution control, and query operations.\n\n    Implementing classes should provide concrete implementations for all\n    methods, typically by wrapping a Temporal client library.\n    \"\"\"\n\n    @abstractmethod\n    async def start_workflow(\n        self,\n        workflow: str | Callable,\n        arg: Any = None,\n        workflow_id: str | None = None,\n        task_queue: str | None = None,\n        execution_timeout: int | None = None,\n        run_timeout: int | None = None,\n        task_timeout: int | None = None,\n        memo: dict[str, Any] | None = None,\n        search_attributes: dict[str, Any] | None = None,\n    ) -&gt; Any:  # WorkflowHandle\n        \"\"\"Start a workflow execution asynchronously.\n\n        Args:\n            workflow (str | Callable): The workflow function or workflow type name.\n            arg (Any, optional): Input argument for the workflow. Defaults to None.\n            workflow_id (str, optional): Unique identifier for the workflow execution.\n                If None, a UUID will be generated. Defaults to None.\n            task_queue (str, optional): Task queue name for workflow execution.\n                If None, uses the default task queue. Defaults to None.\n            execution_timeout (int, optional): Maximum workflow execution time in seconds.\n                Overrides config default. Defaults to None.\n            run_timeout (int, optional): Maximum single workflow run time in seconds.\n                Overrides config default. Defaults to None.\n            task_timeout (int, optional): Maximum workflow task processing time in seconds.\n                Overrides config default. Defaults to None.\n            memo (dict[str, Any], optional): Non-indexed metadata for the workflow.\n                Defaults to None.\n            search_attributes (dict[str, Any], optional): Indexed metadata for workflow search.\n                Defaults to None.\n\n        Returns:\n            WorkflowHandle[T, Any]: Handle to the started workflow execution.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def execute_workflow(\n        self,\n        workflow: str | Callable,\n        arg: Any = None,\n        workflow_id: str | None = None,\n        task_queue: str | None = None,\n        execution_timeout: int | None = None,\n        run_timeout: int | None = None,\n        task_timeout: int | None = None,\n    ) -&gt; T:\n        \"\"\"Execute a workflow and wait for its completion.\n\n        Args:\n            workflow (str | Callable): The workflow function or workflow type name.\n            arg (Any, optional): Input argument for the workflow. Defaults to None.\n            workflow_id (str, optional): Unique identifier for the workflow execution.\n                If None, a UUID will be generated. Defaults to None.\n            task_queue (str, optional): Task queue name for workflow execution.\n                If None, uses the default task queue. Defaults to None.\n            execution_timeout (int, optional): Maximum workflow execution time in seconds.\n                Overrides config default. Defaults to None.\n            run_timeout (int, optional): Maximum single workflow run time in seconds.\n                Overrides config default. Defaults to None.\n            task_timeout (int, optional): Maximum workflow task processing time in seconds.\n                Overrides config default. Defaults to None.\n\n        Returns:\n            T: The workflow execution result.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_workflow_handle(self, workflow_id: str, run_id: str | None = None) -&gt; Any:  # WorkflowHandle\n        \"\"\"Get a handle to an existing workflow execution.\n\n        Args:\n            workflow_id (str): The unique identifier of the workflow execution.\n            run_id (str, optional): The specific run identifier within the workflow.\n                If None, gets the latest run. Defaults to None.\n\n        Returns:\n            WorkflowHandle[T, Any]: Handle to the workflow execution.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def cancel_workflow(self, workflow_id: str, run_id: str | None = None, reason: str | None = None) -&gt; None:\n        \"\"\"Cancel a running workflow execution.\n\n        Args:\n            workflow_id (str): The unique identifier of the workflow execution.\n            run_id (str, optional): The specific run identifier within the workflow.\n                If None, cancels the latest run. Defaults to None.\n            reason (str, optional): Reason for cancellation. Defaults to None.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def terminate_workflow(self, workflow_id: str, run_id: str | None = None, reason: str | None = None) -&gt; None:\n        \"\"\"Terminate a running workflow execution immediately.\n\n        Args:\n            workflow_id (str): The unique identifier of the workflow execution.\n            run_id (str, optional): The specific run identifier within the workflow.\n                If None, terminates the latest run. Defaults to None.\n            reason (str, optional): Reason for termination. Defaults to None.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def signal_workflow(\n        self,\n        workflow_id: str,\n        signal_name: str,\n        arg: Any = None,\n        run_id: str | None = None,\n    ) -&gt; None:\n        \"\"\"Send a signal to a running workflow execution.\n\n        Args:\n            workflow_id (str): The unique identifier of the workflow execution.\n            signal_name (str): The name of the signal to send.\n            arg (Any, optional): Argument to pass with the signal. Defaults to None.\n            run_id (str, optional): The specific run identifier within the workflow.\n                If None, signals the latest run. Defaults to None.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def query_workflow(\n        self,\n        workflow_id: str,\n        query_name: str,\n        arg: Any = None,\n        run_id: str | None = None,\n    ) -&gt; Any:\n        \"\"\"Query a running workflow execution for information.\n\n        Args:\n            workflow_id (str): The unique identifier of the workflow execution.\n            query_name (str): The name of the query to execute.\n            arg (Any, optional): Argument to pass with the query. Defaults to None.\n            run_id (str, optional): The specific run identifier within the workflow.\n                If None, queries the latest run. Defaults to None.\n\n        Returns:\n            Any: The query result from the workflow.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def list_workflows(\n        self,\n        query: str | None = None,\n        page_size: int | None = None,\n        next_page_token: bytes | None = None,\n    ) -&gt; \"WorkflowListResponse\":\n        \"\"\"List workflow executions matching the given criteria.\n\n        Args:\n            query (str, optional): List filter query in Temporal SQL syntax.\n                Defaults to None (no filter).\n            page_size (int, optional): Maximum number of results per page.\n                Defaults to None (server default).\n            next_page_token (bytes, optional): Token for pagination.\n                Defaults to None (first page).\n\n        Returns:\n            WorkflowListResponse: List of workflow executions with pagination info.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def describe_workflow(self, workflow_id: str, run_id: str | None = None) -&gt; \"WorkflowDescription\":\n        \"\"\"Get detailed information about a workflow execution.\n\n        Args:\n            workflow_id (str): The unique identifier of the workflow execution.\n            run_id (str, optional): The specific run identifier within the workflow.\n                If None, describes the latest run. Defaults to None.\n\n        Returns:\n            WorkflowDescription: Detailed workflow execution information.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def close(self) -&gt; None:\n        \"\"\"Close the Temporal client connection.\n\n        Performs cleanup of resources and closes the connection to the Temporal server.\n        Should be called when the adapter is no longer needed.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.ports.TemporalPort.start_workflow","title":"<code>archipy.adapters.temporal.ports.TemporalPort.start_workflow(workflow, arg=None, workflow_id=None, task_queue=None, execution_timeout=None, run_timeout=None, task_timeout=None, memo=None, search_attributes=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Start a workflow execution asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>workflow</code> <code>str | Callable</code> <p>The workflow function or workflow type name.</p> required <code>arg</code> <code>Any</code> <p>Input argument for the workflow. Defaults to None.</p> <code>None</code> <code>workflow_id</code> <code>str</code> <p>Unique identifier for the workflow execution. If None, a UUID will be generated. Defaults to None.</p> <code>None</code> <code>task_queue</code> <code>str</code> <p>Task queue name for workflow execution. If None, uses the default task queue. Defaults to None.</p> <code>None</code> <code>execution_timeout</code> <code>int</code> <p>Maximum workflow execution time in seconds. Overrides config default. Defaults to None.</p> <code>None</code> <code>run_timeout</code> <code>int</code> <p>Maximum single workflow run time in seconds. Overrides config default. Defaults to None.</p> <code>None</code> <code>task_timeout</code> <code>int</code> <p>Maximum workflow task processing time in seconds. Overrides config default. Defaults to None.</p> <code>None</code> <code>memo</code> <code>dict[str, Any]</code> <p>Non-indexed metadata for the workflow. Defaults to None.</p> <code>None</code> <code>search_attributes</code> <code>dict[str, Any]</code> <p>Indexed metadata for workflow search. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>WorkflowHandle[T, Any]: Handle to the started workflow execution.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/temporal/ports.py</code> <pre><code>@abstractmethod\nasync def start_workflow(\n    self,\n    workflow: str | Callable,\n    arg: Any = None,\n    workflow_id: str | None = None,\n    task_queue: str | None = None,\n    execution_timeout: int | None = None,\n    run_timeout: int | None = None,\n    task_timeout: int | None = None,\n    memo: dict[str, Any] | None = None,\n    search_attributes: dict[str, Any] | None = None,\n) -&gt; Any:  # WorkflowHandle\n    \"\"\"Start a workflow execution asynchronously.\n\n    Args:\n        workflow (str | Callable): The workflow function or workflow type name.\n        arg (Any, optional): Input argument for the workflow. Defaults to None.\n        workflow_id (str, optional): Unique identifier for the workflow execution.\n            If None, a UUID will be generated. Defaults to None.\n        task_queue (str, optional): Task queue name for workflow execution.\n            If None, uses the default task queue. Defaults to None.\n        execution_timeout (int, optional): Maximum workflow execution time in seconds.\n            Overrides config default. Defaults to None.\n        run_timeout (int, optional): Maximum single workflow run time in seconds.\n            Overrides config default. Defaults to None.\n        task_timeout (int, optional): Maximum workflow task processing time in seconds.\n            Overrides config default. Defaults to None.\n        memo (dict[str, Any], optional): Non-indexed metadata for the workflow.\n            Defaults to None.\n        search_attributes (dict[str, Any], optional): Indexed metadata for workflow search.\n            Defaults to None.\n\n    Returns:\n        WorkflowHandle[T, Any]: Handle to the started workflow execution.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.ports.TemporalPort.execute_workflow","title":"<code>archipy.adapters.temporal.ports.TemporalPort.execute_workflow(workflow, arg=None, workflow_id=None, task_queue=None, execution_timeout=None, run_timeout=None, task_timeout=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Execute a workflow and wait for its completion.</p> <p>Parameters:</p> Name Type Description Default <code>workflow</code> <code>str | Callable</code> <p>The workflow function or workflow type name.</p> required <code>arg</code> <code>Any</code> <p>Input argument for the workflow. Defaults to None.</p> <code>None</code> <code>workflow_id</code> <code>str</code> <p>Unique identifier for the workflow execution. If None, a UUID will be generated. Defaults to None.</p> <code>None</code> <code>task_queue</code> <code>str</code> <p>Task queue name for workflow execution. If None, uses the default task queue. Defaults to None.</p> <code>None</code> <code>execution_timeout</code> <code>int</code> <p>Maximum workflow execution time in seconds. Overrides config default. Defaults to None.</p> <code>None</code> <code>run_timeout</code> <code>int</code> <p>Maximum single workflow run time in seconds. Overrides config default. Defaults to None.</p> <code>None</code> <code>task_timeout</code> <code>int</code> <p>Maximum workflow task processing time in seconds. Overrides config default. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The workflow execution result.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/temporal/ports.py</code> <pre><code>@abstractmethod\nasync def execute_workflow(\n    self,\n    workflow: str | Callable,\n    arg: Any = None,\n    workflow_id: str | None = None,\n    task_queue: str | None = None,\n    execution_timeout: int | None = None,\n    run_timeout: int | None = None,\n    task_timeout: int | None = None,\n) -&gt; T:\n    \"\"\"Execute a workflow and wait for its completion.\n\n    Args:\n        workflow (str | Callable): The workflow function or workflow type name.\n        arg (Any, optional): Input argument for the workflow. Defaults to None.\n        workflow_id (str, optional): Unique identifier for the workflow execution.\n            If None, a UUID will be generated. Defaults to None.\n        task_queue (str, optional): Task queue name for workflow execution.\n            If None, uses the default task queue. Defaults to None.\n        execution_timeout (int, optional): Maximum workflow execution time in seconds.\n            Overrides config default. Defaults to None.\n        run_timeout (int, optional): Maximum single workflow run time in seconds.\n            Overrides config default. Defaults to None.\n        task_timeout (int, optional): Maximum workflow task processing time in seconds.\n            Overrides config default. Defaults to None.\n\n    Returns:\n        T: The workflow execution result.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.ports.TemporalPort.get_workflow_handle","title":"<code>archipy.adapters.temporal.ports.TemporalPort.get_workflow_handle(workflow_id, run_id=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get a handle to an existing workflow execution.</p> <p>Parameters:</p> Name Type Description Default <code>workflow_id</code> <code>str</code> <p>The unique identifier of the workflow execution.</p> required <code>run_id</code> <code>str</code> <p>The specific run identifier within the workflow. If None, gets the latest run. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>WorkflowHandle[T, Any]: Handle to the workflow execution.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/temporal/ports.py</code> <pre><code>@abstractmethod\nasync def get_workflow_handle(self, workflow_id: str, run_id: str | None = None) -&gt; Any:  # WorkflowHandle\n    \"\"\"Get a handle to an existing workflow execution.\n\n    Args:\n        workflow_id (str): The unique identifier of the workflow execution.\n        run_id (str, optional): The specific run identifier within the workflow.\n            If None, gets the latest run. Defaults to None.\n\n    Returns:\n        WorkflowHandle[T, Any]: Handle to the workflow execution.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.ports.TemporalPort.cancel_workflow","title":"<code>archipy.adapters.temporal.ports.TemporalPort.cancel_workflow(workflow_id, run_id=None, reason=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Cancel a running workflow execution.</p> <p>Parameters:</p> Name Type Description Default <code>workflow_id</code> <code>str</code> <p>The unique identifier of the workflow execution.</p> required <code>run_id</code> <code>str</code> <p>The specific run identifier within the workflow. If None, cancels the latest run. Defaults to None.</p> <code>None</code> <code>reason</code> <code>str</code> <p>Reason for cancellation. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/temporal/ports.py</code> <pre><code>@abstractmethod\nasync def cancel_workflow(self, workflow_id: str, run_id: str | None = None, reason: str | None = None) -&gt; None:\n    \"\"\"Cancel a running workflow execution.\n\n    Args:\n        workflow_id (str): The unique identifier of the workflow execution.\n        run_id (str, optional): The specific run identifier within the workflow.\n            If None, cancels the latest run. Defaults to None.\n        reason (str, optional): Reason for cancellation. Defaults to None.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.ports.TemporalPort.terminate_workflow","title":"<code>archipy.adapters.temporal.ports.TemporalPort.terminate_workflow(workflow_id, run_id=None, reason=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Terminate a running workflow execution immediately.</p> <p>Parameters:</p> Name Type Description Default <code>workflow_id</code> <code>str</code> <p>The unique identifier of the workflow execution.</p> required <code>run_id</code> <code>str</code> <p>The specific run identifier within the workflow. If None, terminates the latest run. Defaults to None.</p> <code>None</code> <code>reason</code> <code>str</code> <p>Reason for termination. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/temporal/ports.py</code> <pre><code>@abstractmethod\nasync def terminate_workflow(self, workflow_id: str, run_id: str | None = None, reason: str | None = None) -&gt; None:\n    \"\"\"Terminate a running workflow execution immediately.\n\n    Args:\n        workflow_id (str): The unique identifier of the workflow execution.\n        run_id (str, optional): The specific run identifier within the workflow.\n            If None, terminates the latest run. Defaults to None.\n        reason (str, optional): Reason for termination. Defaults to None.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.ports.TemporalPort.signal_workflow","title":"<code>archipy.adapters.temporal.ports.TemporalPort.signal_workflow(workflow_id, signal_name, arg=None, run_id=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Send a signal to a running workflow execution.</p> <p>Parameters:</p> Name Type Description Default <code>workflow_id</code> <code>str</code> <p>The unique identifier of the workflow execution.</p> required <code>signal_name</code> <code>str</code> <p>The name of the signal to send.</p> required <code>arg</code> <code>Any</code> <p>Argument to pass with the signal. Defaults to None.</p> <code>None</code> <code>run_id</code> <code>str</code> <p>The specific run identifier within the workflow. If None, signals the latest run. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/temporal/ports.py</code> <pre><code>@abstractmethod\nasync def signal_workflow(\n    self,\n    workflow_id: str,\n    signal_name: str,\n    arg: Any = None,\n    run_id: str | None = None,\n) -&gt; None:\n    \"\"\"Send a signal to a running workflow execution.\n\n    Args:\n        workflow_id (str): The unique identifier of the workflow execution.\n        signal_name (str): The name of the signal to send.\n        arg (Any, optional): Argument to pass with the signal. Defaults to None.\n        run_id (str, optional): The specific run identifier within the workflow.\n            If None, signals the latest run. Defaults to None.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.ports.TemporalPort.query_workflow","title":"<code>archipy.adapters.temporal.ports.TemporalPort.query_workflow(workflow_id, query_name, arg=None, run_id=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Query a running workflow execution for information.</p> <p>Parameters:</p> Name Type Description Default <code>workflow_id</code> <code>str</code> <p>The unique identifier of the workflow execution.</p> required <code>query_name</code> <code>str</code> <p>The name of the query to execute.</p> required <code>arg</code> <code>Any</code> <p>Argument to pass with the query. Defaults to None.</p> <code>None</code> <code>run_id</code> <code>str</code> <p>The specific run identifier within the workflow. If None, queries the latest run. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The query result from the workflow.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/temporal/ports.py</code> <pre><code>@abstractmethod\nasync def query_workflow(\n    self,\n    workflow_id: str,\n    query_name: str,\n    arg: Any = None,\n    run_id: str | None = None,\n) -&gt; Any:\n    \"\"\"Query a running workflow execution for information.\n\n    Args:\n        workflow_id (str): The unique identifier of the workflow execution.\n        query_name (str): The name of the query to execute.\n        arg (Any, optional): Argument to pass with the query. Defaults to None.\n        run_id (str, optional): The specific run identifier within the workflow.\n            If None, queries the latest run. Defaults to None.\n\n    Returns:\n        Any: The query result from the workflow.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.ports.TemporalPort.list_workflows","title":"<code>archipy.adapters.temporal.ports.TemporalPort.list_workflows(query=None, page_size=None, next_page_token=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>List workflow executions matching the given criteria.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>List filter query in Temporal SQL syntax. Defaults to None (no filter).</p> <code>None</code> <code>page_size</code> <code>int</code> <p>Maximum number of results per page. Defaults to None (server default).</p> <code>None</code> <code>next_page_token</code> <code>bytes</code> <p>Token for pagination. Defaults to None (first page).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>WorkflowListResponse</code> <code>WorkflowListResponse</code> <p>List of workflow executions with pagination info.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/temporal/ports.py</code> <pre><code>@abstractmethod\nasync def list_workflows(\n    self,\n    query: str | None = None,\n    page_size: int | None = None,\n    next_page_token: bytes | None = None,\n) -&gt; \"WorkflowListResponse\":\n    \"\"\"List workflow executions matching the given criteria.\n\n    Args:\n        query (str, optional): List filter query in Temporal SQL syntax.\n            Defaults to None (no filter).\n        page_size (int, optional): Maximum number of results per page.\n            Defaults to None (server default).\n        next_page_token (bytes, optional): Token for pagination.\n            Defaults to None (first page).\n\n    Returns:\n        WorkflowListResponse: List of workflow executions with pagination info.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.ports.TemporalPort.describe_workflow","title":"<code>archipy.adapters.temporal.ports.TemporalPort.describe_workflow(workflow_id, run_id=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get detailed information about a workflow execution.</p> <p>Parameters:</p> Name Type Description Default <code>workflow_id</code> <code>str</code> <p>The unique identifier of the workflow execution.</p> required <code>run_id</code> <code>str</code> <p>The specific run identifier within the workflow. If None, describes the latest run. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>WorkflowDescription</code> <code>WorkflowDescription</code> <p>Detailed workflow execution information.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/temporal/ports.py</code> <pre><code>@abstractmethod\nasync def describe_workflow(self, workflow_id: str, run_id: str | None = None) -&gt; \"WorkflowDescription\":\n    \"\"\"Get detailed information about a workflow execution.\n\n    Args:\n        workflow_id (str): The unique identifier of the workflow execution.\n        run_id (str, optional): The specific run identifier within the workflow.\n            If None, describes the latest run. Defaults to None.\n\n    Returns:\n        WorkflowDescription: Detailed workflow execution information.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.ports.TemporalPort.close","title":"<code>archipy.adapters.temporal.ports.TemporalPort.close()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Close the Temporal client connection.</p> <p>Performs cleanup of resources and closes the connection to the Temporal server. Should be called when the adapter is no longer needed.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/temporal/ports.py</code> <pre><code>@abstractmethod\nasync def close(self) -&gt; None:\n    \"\"\"Close the Temporal client connection.\n\n    Performs cleanup of resources and closes the connection to the Temporal server.\n    Should be called when the adapter is no longer needed.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.ports.WorkerPort","title":"<code>archipy.adapters.temporal.ports.WorkerPort</code>","text":"<p>Interface for Temporal worker operations providing a standardized access pattern.</p> <p>This interface defines the contract for Temporal worker management, ensuring consistent implementation of worker lifecycle operations. Workers are responsible for executing workflows and activities.</p> <p>Implementing classes should provide concrete implementations for all methods, typically by wrapping a Temporal worker.</p> Source code in <code>archipy/adapters/temporal/ports.py</code> <pre><code>class WorkerPort:\n    \"\"\"Interface for Temporal worker operations providing a standardized access pattern.\n\n    This interface defines the contract for Temporal worker management, ensuring consistent\n    implementation of worker lifecycle operations. Workers are responsible for executing\n    workflows and activities.\n\n    Implementing classes should provide concrete implementations for all\n    methods, typically by wrapping a Temporal worker.\n    \"\"\"\n\n    @abstractmethod\n    async def start_worker(\n        self,\n        task_queue: str,\n        workflows: list[type] | None = None,\n        activities: list[object] | None = None,\n        build_id: str | None = None,\n        identity: str | None = None,\n        max_concurrent_workflow_tasks: int | None = None,\n        max_concurrent_activities: int | None = None,\n    ) -&gt; \"WorkerHandle\":\n        \"\"\"Start a Temporal worker for the specified task queue.\n\n        Args:\n            task_queue (str): The task queue this worker will poll from.\n            workflows (list[type], optional): List of workflow classes to register.\n                Defaults to None.\n            activities (list[object], optional): List of activity instances to register.\n                Defaults to None.\n            build_id (str, optional): Build identifier for worker versioning.\n                Defaults to None.\n            identity (str, optional): Unique worker identity. If None, auto-generated.\n                Defaults to None.\n            max_concurrent_workflow_tasks (int, optional): Maximum concurrent workflow tasks.\n                Defaults to None (server default).\n            max_concurrent_activities (int, optional): Maximum concurrent activity tasks.\n                Defaults to None (server default).\n\n        Returns:\n            WorkerHandle: Handle to the started worker.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def stop_worker(self, worker_handle: \"WorkerHandle\") -&gt; None:\n        \"\"\"Stop a running Temporal worker.\n\n        Args:\n            worker_handle (WorkerHandle): Handle to the worker to stop.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def shutdown_all_workers(self) -&gt; None:\n        \"\"\"Shutdown all workers managed by this port.\n\n        Performs graceful shutdown of all active workers, waiting for current\n        tasks to complete before terminating.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.ports.WorkerPort.start_worker","title":"<code>archipy.adapters.temporal.ports.WorkerPort.start_worker(task_queue, workflows=None, activities=None, build_id=None, identity=None, max_concurrent_workflow_tasks=None, max_concurrent_activities=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Start a Temporal worker for the specified task queue.</p> <p>Parameters:</p> Name Type Description Default <code>task_queue</code> <code>str</code> <p>The task queue this worker will poll from.</p> required <code>workflows</code> <code>list[type]</code> <p>List of workflow classes to register. Defaults to None.</p> <code>None</code> <code>activities</code> <code>list[object]</code> <p>List of activity instances to register. Defaults to None.</p> <code>None</code> <code>build_id</code> <code>str</code> <p>Build identifier for worker versioning. Defaults to None.</p> <code>None</code> <code>identity</code> <code>str</code> <p>Unique worker identity. If None, auto-generated. Defaults to None.</p> <code>None</code> <code>max_concurrent_workflow_tasks</code> <code>int</code> <p>Maximum concurrent workflow tasks. Defaults to None (server default).</p> <code>None</code> <code>max_concurrent_activities</code> <code>int</code> <p>Maximum concurrent activity tasks. Defaults to None (server default).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>WorkerHandle</code> <code>WorkerHandle</code> <p>Handle to the started worker.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/temporal/ports.py</code> <pre><code>@abstractmethod\nasync def start_worker(\n    self,\n    task_queue: str,\n    workflows: list[type] | None = None,\n    activities: list[object] | None = None,\n    build_id: str | None = None,\n    identity: str | None = None,\n    max_concurrent_workflow_tasks: int | None = None,\n    max_concurrent_activities: int | None = None,\n) -&gt; \"WorkerHandle\":\n    \"\"\"Start a Temporal worker for the specified task queue.\n\n    Args:\n        task_queue (str): The task queue this worker will poll from.\n        workflows (list[type], optional): List of workflow classes to register.\n            Defaults to None.\n        activities (list[object], optional): List of activity instances to register.\n            Defaults to None.\n        build_id (str, optional): Build identifier for worker versioning.\n            Defaults to None.\n        identity (str, optional): Unique worker identity. If None, auto-generated.\n            Defaults to None.\n        max_concurrent_workflow_tasks (int, optional): Maximum concurrent workflow tasks.\n            Defaults to None (server default).\n        max_concurrent_activities (int, optional): Maximum concurrent activity tasks.\n            Defaults to None (server default).\n\n    Returns:\n        WorkerHandle: Handle to the started worker.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.ports.WorkerPort.stop_worker","title":"<code>archipy.adapters.temporal.ports.WorkerPort.stop_worker(worker_handle)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Stop a running Temporal worker.</p> <p>Parameters:</p> Name Type Description Default <code>worker_handle</code> <code>WorkerHandle</code> <p>Handle to the worker to stop.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/temporal/ports.py</code> <pre><code>@abstractmethod\nasync def stop_worker(self, worker_handle: \"WorkerHandle\") -&gt; None:\n    \"\"\"Stop a running Temporal worker.\n\n    Args:\n        worker_handle (WorkerHandle): Handle to the worker to stop.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.ports.WorkerPort.shutdown_all_workers","title":"<code>archipy.adapters.temporal.ports.WorkerPort.shutdown_all_workers()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Shutdown all workers managed by this port.</p> <p>Performs graceful shutdown of all active workers, waiting for current tasks to complete before terminating.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/temporal/ports.py</code> <pre><code>@abstractmethod\nasync def shutdown_all_workers(self) -&gt; None:\n    \"\"\"Shutdown all workers managed by this port.\n\n    Performs graceful shutdown of all active workers, waiting for current\n    tasks to complete before terminating.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.ports.WorkflowHandle","title":"<code>archipy.adapters.temporal.ports.WorkflowHandle</code>","text":"<p>Type stub for workflow handle.</p> Source code in <code>archipy/adapters/temporal/ports.py</code> <pre><code>class WorkflowHandle:\n    \"\"\"Type stub for workflow handle.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.ports.WorkflowListResponse","title":"<code>archipy.adapters.temporal.ports.WorkflowListResponse</code>","text":"<p>Type stub for workflow list response.</p> Source code in <code>archipy/adapters/temporal/ports.py</code> <pre><code>class WorkflowListResponse:\n    \"\"\"Type stub for workflow list response.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.ports.WorkflowDescription","title":"<code>archipy.adapters.temporal.ports.WorkflowDescription</code>","text":"<p>Type stub for workflow description.</p> Source code in <code>archipy/adapters/temporal/ports.py</code> <pre><code>class WorkflowDescription:\n    \"\"\"Type stub for workflow description.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.ports.WorkerHandle","title":"<code>archipy.adapters.temporal.ports.WorkerHandle</code>","text":"<p>Type stub for worker handle.</p> Source code in <code>archipy/adapters/temporal/ports.py</code> <pre><code>class WorkerHandle:\n    \"\"\"Type stub for worker handle.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api_reference/adapters/#temporal-worker-manager","title":"Temporal Worker Manager","text":"<p>Worker management for Temporal workflow execution.</p> <p>This module provides worker management functionality for Temporal workflow orchestration, including worker lifecycle management, task queue assignment, and integration with ArchiPy service adapters.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.worker.WorkerHandle","title":"<code>archipy.adapters.temporal.worker.WorkerHandle</code>","text":"<p>Handle for managing a Temporal worker instance.</p> <p>Provides methods to control and monitor a running Temporal worker, including starting, stopping, and querying worker status.</p> <p>Attributes:</p> Name Type Description <code>worker_id</code> <code>str</code> <p>Unique identifier for this worker instance.</p> <code>task_queue</code> <code>str</code> <p>The task queue this worker polls from.</p> <code>workflows</code> <code>list[type]</code> <p>List of workflow types registered with this worker.</p> <code>activities</code> <code>list[object]</code> <p>List of activity instances registered with this worker.</p> <code>build_id</code> <code>str | None</code> <p>Build identifier for worker versioning.</p> <code>identity</code> <code>str | None</code> <p>Worker identity for debugging and monitoring.</p> <code>max_concurrent_workflow_tasks</code> <code>int</code> <p>Maximum concurrent workflow tasks.</p> <code>max_concurrent_activities</code> <code>int</code> <p>Maximum concurrent activity tasks.</p> Source code in <code>archipy/adapters/temporal/worker.py</code> <pre><code>class WorkerHandle:\n    \"\"\"Handle for managing a Temporal worker instance.\n\n    Provides methods to control and monitor a running Temporal worker,\n    including starting, stopping, and querying worker status.\n\n    Attributes:\n        worker_id (str): Unique identifier for this worker instance.\n        task_queue (str): The task queue this worker polls from.\n        workflows (list[type]): List of workflow types registered with this worker.\n        activities (list[object]): List of activity instances registered with this worker.\n        build_id (str | None): Build identifier for worker versioning.\n        identity (str | None): Worker identity for debugging and monitoring.\n        max_concurrent_workflow_tasks (int): Maximum concurrent workflow tasks.\n        max_concurrent_activities (int): Maximum concurrent activity tasks.\n    \"\"\"\n\n    def __init__(\n        self,\n        worker: Worker,\n        worker_id: str,\n        task_queue: str,\n        workflows: list[type] | None = None,\n        activities: list[object] | None = None,\n        build_id: str | None = None,\n        identity: str | None = None,\n        max_concurrent_workflow_tasks: int | None = None,\n        max_concurrent_activities: int | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the worker handle.\n\n        Args:\n            worker (Worker): The Temporal worker instance.\n            worker_id (str): Unique identifier for this worker instance.\n            task_queue (str): The task queue this worker polls from.\n            workflows (list[type], optional): List of workflow types. Defaults to None.\n            activities (list[object], optional): List of activity instances. Defaults to None.\n            build_id (str, optional): Build identifier for worker versioning. Defaults to None.\n            identity (str, optional): Worker identity. Defaults to None.\n            max_concurrent_workflow_tasks (int, optional): Maximum concurrent workflow tasks.\n                Defaults to None.\n            max_concurrent_activities (int, optional): Maximum concurrent activity tasks.\n                Defaults to None.\n        \"\"\"\n        self._worker = worker\n        self.worker_id = worker_id\n        self.task_queue = task_queue\n        self.workflows = workflows or []\n        self.activities = activities or []\n        self.build_id = build_id\n        self.identity = identity\n        self.max_concurrent_workflow_tasks = max_concurrent_workflow_tasks\n        self.max_concurrent_activities = max_concurrent_activities\n        self._running = False\n        self._logger = logging.getLogger(__name__)\n\n    async def start(self) -&gt; None:\n        \"\"\"Start the worker to begin polling for tasks.\n\n        Raises:\n            WorkerConnectionError: If the worker fails to start.\n        \"\"\"\n        try:\n            self._logger.info(\n                \"Starting worker\",\n                extra={\n                    \"worker_id\": self.worker_id,\n                    \"task_queue\": self.task_queue,\n                    \"identity\": self.identity,\n                },\n            )\n\n            # Start the worker in the background\n            task = asyncio.create_task(self._worker.run())\n            # Store task reference to avoid it being garbage collected\n            self._background_task = task\n            self._running = True\n\n            self._logger.info(\n                \"Worker started successfully\",\n                extra={\n                    \"worker_id\": self.worker_id,\n                    \"task_queue\": self.task_queue,\n                },\n            )\n\n        except Exception as error:\n            raise WorkerConnectionError(\n                additional_data={\n                    \"message\": f\"Failed to start worker for task queue '{self.task_queue}'\",\n                    \"task_queue\": self.task_queue,\n                    \"worker_id\": self.worker_id,\n                    \"error\": str(error),\n                },\n            ) from error\n\n    async def stop(self, grace_period: int = 30) -&gt; None:\n        \"\"\"Stop the worker gracefully.\n\n        Args:\n            grace_period (int): Maximum time to wait for graceful shutdown in seconds.\n                Defaults to 30.\n\n        Raises:\n            WorkerShutdownError: If the worker fails to stop gracefully.\n        \"\"\"\n        if not self._running:\n            return\n\n        try:\n            self._logger.info(\n                \"Stopping worker\",\n                extra={\n                    \"worker_id\": self.worker_id,\n                    \"task_queue\": self.task_queue,\n                    \"grace_period\": grace_period,\n                },\n            )\n\n            # Signal shutdown and wait for graceful completion\n            await asyncio.wait_for(self._worker.shutdown(), timeout=grace_period)\n            self._running = False\n\n            self._logger.info(\n                \"Worker stopped successfully\",\n                extra={\n                    \"worker_id\": self.worker_id,\n                    \"task_queue\": self.task_queue,\n                },\n            )\n\n        except TimeoutError as error:\n            raise WorkerShutdownError(\n                additional_data={\n                    \"message\": f\"Worker shutdown timeout after {grace_period} seconds\",\n                    \"worker_identity\": self.identity,\n                    \"task_queue\": self.task_queue,\n                    \"worker_id\": self.worker_id,\n                    \"grace_period\": grace_period,\n                },\n            ) from error\n        except Exception as error:\n            raise WorkerShutdownError(\n                additional_data={\n                    \"message\": f\"Failed to stop worker for task queue '{self.task_queue}'\",\n                    \"worker_identity\": self.identity,\n                    \"task_queue\": self.task_queue,\n                    \"worker_id\": self.worker_id,\n                    \"error\": str(error),\n                },\n            ) from error\n\n    async def wait_until_stopped(self) -&gt; None:\n        \"\"\"Wait until the worker is stopped.\"\"\"\n        await self._background_task\n\n    @property\n    def is_running(self) -&gt; bool:\n        \"\"\"Check if the worker is currently running.\n\n        Returns:\n            bool: True if the worker is running, False otherwise.\n        \"\"\"\n        return self._running\n\n    def get_stats(self) -&gt; dict[str, Any]:\n        \"\"\"Get worker statistics and status information.\n\n        Returns:\n            dict[str, Any]: Worker statistics and status.\n        \"\"\"\n        return {\n            \"worker_id\": self.worker_id,\n            \"task_queue\": self.task_queue,\n            \"identity\": self.identity,\n            \"build_id\": self.build_id,\n            \"is_running\": self.is_running,\n            \"workflow_count\": len(self.workflows),\n            \"activity_count\": len(self.activities),\n            \"max_concurrent_workflow_tasks\": self.max_concurrent_workflow_tasks,\n            \"max_concurrent_activities\": self.max_concurrent_activities,\n        }\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.worker.WorkerHandle.is_running","title":"<code>archipy.adapters.temporal.worker.WorkerHandle.is_running</code>  <code>property</code>","text":"<p>Check if the worker is currently running.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the worker is running, False otherwise.</p>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.worker.WorkerHandle.__init__","title":"<code>archipy.adapters.temporal.worker.WorkerHandle.__init__(worker, worker_id, task_queue, workflows=None, activities=None, build_id=None, identity=None, max_concurrent_workflow_tasks=None, max_concurrent_activities=None)</code>","text":"<p>Initialize the worker handle.</p> <p>Parameters:</p> Name Type Description Default <code>worker</code> <code>Worker</code> <p>The Temporal worker instance.</p> required <code>worker_id</code> <code>str</code> <p>Unique identifier for this worker instance.</p> required <code>task_queue</code> <code>str</code> <p>The task queue this worker polls from.</p> required <code>workflows</code> <code>list[type]</code> <p>List of workflow types. Defaults to None.</p> <code>None</code> <code>activities</code> <code>list[object]</code> <p>List of activity instances. Defaults to None.</p> <code>None</code> <code>build_id</code> <code>str</code> <p>Build identifier for worker versioning. Defaults to None.</p> <code>None</code> <code>identity</code> <code>str</code> <p>Worker identity. Defaults to None.</p> <code>None</code> <code>max_concurrent_workflow_tasks</code> <code>int</code> <p>Maximum concurrent workflow tasks. Defaults to None.</p> <code>None</code> <code>max_concurrent_activities</code> <code>int</code> <p>Maximum concurrent activity tasks. Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/temporal/worker.py</code> <pre><code>def __init__(\n    self,\n    worker: Worker,\n    worker_id: str,\n    task_queue: str,\n    workflows: list[type] | None = None,\n    activities: list[object] | None = None,\n    build_id: str | None = None,\n    identity: str | None = None,\n    max_concurrent_workflow_tasks: int | None = None,\n    max_concurrent_activities: int | None = None,\n) -&gt; None:\n    \"\"\"Initialize the worker handle.\n\n    Args:\n        worker (Worker): The Temporal worker instance.\n        worker_id (str): Unique identifier for this worker instance.\n        task_queue (str): The task queue this worker polls from.\n        workflows (list[type], optional): List of workflow types. Defaults to None.\n        activities (list[object], optional): List of activity instances. Defaults to None.\n        build_id (str, optional): Build identifier for worker versioning. Defaults to None.\n        identity (str, optional): Worker identity. Defaults to None.\n        max_concurrent_workflow_tasks (int, optional): Maximum concurrent workflow tasks.\n            Defaults to None.\n        max_concurrent_activities (int, optional): Maximum concurrent activity tasks.\n            Defaults to None.\n    \"\"\"\n    self._worker = worker\n    self.worker_id = worker_id\n    self.task_queue = task_queue\n    self.workflows = workflows or []\n    self.activities = activities or []\n    self.build_id = build_id\n    self.identity = identity\n    self.max_concurrent_workflow_tasks = max_concurrent_workflow_tasks\n    self.max_concurrent_activities = max_concurrent_activities\n    self._running = False\n    self._logger = logging.getLogger(__name__)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.worker.WorkerHandle.start","title":"<code>archipy.adapters.temporal.worker.WorkerHandle.start()</code>  <code>async</code>","text":"<p>Start the worker to begin polling for tasks.</p> <p>Raises:</p> Type Description <code>WorkerConnectionError</code> <p>If the worker fails to start.</p> Source code in <code>archipy/adapters/temporal/worker.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"Start the worker to begin polling for tasks.\n\n    Raises:\n        WorkerConnectionError: If the worker fails to start.\n    \"\"\"\n    try:\n        self._logger.info(\n            \"Starting worker\",\n            extra={\n                \"worker_id\": self.worker_id,\n                \"task_queue\": self.task_queue,\n                \"identity\": self.identity,\n            },\n        )\n\n        # Start the worker in the background\n        task = asyncio.create_task(self._worker.run())\n        # Store task reference to avoid it being garbage collected\n        self._background_task = task\n        self._running = True\n\n        self._logger.info(\n            \"Worker started successfully\",\n            extra={\n                \"worker_id\": self.worker_id,\n                \"task_queue\": self.task_queue,\n            },\n        )\n\n    except Exception as error:\n        raise WorkerConnectionError(\n            additional_data={\n                \"message\": f\"Failed to start worker for task queue '{self.task_queue}'\",\n                \"task_queue\": self.task_queue,\n                \"worker_id\": self.worker_id,\n                \"error\": str(error),\n            },\n        ) from error\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.worker.WorkerHandle.stop","title":"<code>archipy.adapters.temporal.worker.WorkerHandle.stop(grace_period=30)</code>  <code>async</code>","text":"<p>Stop the worker gracefully.</p> <p>Parameters:</p> Name Type Description Default <code>grace_period</code> <code>int</code> <p>Maximum time to wait for graceful shutdown in seconds. Defaults to 30.</p> <code>30</code> <p>Raises:</p> Type Description <code>WorkerShutdownError</code> <p>If the worker fails to stop gracefully.</p> Source code in <code>archipy/adapters/temporal/worker.py</code> <pre><code>async def stop(self, grace_period: int = 30) -&gt; None:\n    \"\"\"Stop the worker gracefully.\n\n    Args:\n        grace_period (int): Maximum time to wait for graceful shutdown in seconds.\n            Defaults to 30.\n\n    Raises:\n        WorkerShutdownError: If the worker fails to stop gracefully.\n    \"\"\"\n    if not self._running:\n        return\n\n    try:\n        self._logger.info(\n            \"Stopping worker\",\n            extra={\n                \"worker_id\": self.worker_id,\n                \"task_queue\": self.task_queue,\n                \"grace_period\": grace_period,\n            },\n        )\n\n        # Signal shutdown and wait for graceful completion\n        await asyncio.wait_for(self._worker.shutdown(), timeout=grace_period)\n        self._running = False\n\n        self._logger.info(\n            \"Worker stopped successfully\",\n            extra={\n                \"worker_id\": self.worker_id,\n                \"task_queue\": self.task_queue,\n            },\n        )\n\n    except TimeoutError as error:\n        raise WorkerShutdownError(\n            additional_data={\n                \"message\": f\"Worker shutdown timeout after {grace_period} seconds\",\n                \"worker_identity\": self.identity,\n                \"task_queue\": self.task_queue,\n                \"worker_id\": self.worker_id,\n                \"grace_period\": grace_period,\n            },\n        ) from error\n    except Exception as error:\n        raise WorkerShutdownError(\n            additional_data={\n                \"message\": f\"Failed to stop worker for task queue '{self.task_queue}'\",\n                \"worker_identity\": self.identity,\n                \"task_queue\": self.task_queue,\n                \"worker_id\": self.worker_id,\n                \"error\": str(error),\n            },\n        ) from error\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.worker.WorkerHandle.wait_until_stopped","title":"<code>archipy.adapters.temporal.worker.WorkerHandle.wait_until_stopped()</code>  <code>async</code>","text":"<p>Wait until the worker is stopped.</p> Source code in <code>archipy/adapters/temporal/worker.py</code> <pre><code>async def wait_until_stopped(self) -&gt; None:\n    \"\"\"Wait until the worker is stopped.\"\"\"\n    await self._background_task\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.worker.WorkerHandle.get_stats","title":"<code>archipy.adapters.temporal.worker.WorkerHandle.get_stats()</code>","text":"<p>Get worker statistics and status information.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Worker statistics and status.</p> Source code in <code>archipy/adapters/temporal/worker.py</code> <pre><code>def get_stats(self) -&gt; dict[str, Any]:\n    \"\"\"Get worker statistics and status information.\n\n    Returns:\n        dict[str, Any]: Worker statistics and status.\n    \"\"\"\n    return {\n        \"worker_id\": self.worker_id,\n        \"task_queue\": self.task_queue,\n        \"identity\": self.identity,\n        \"build_id\": self.build_id,\n        \"is_running\": self.is_running,\n        \"workflow_count\": len(self.workflows),\n        \"activity_count\": len(self.activities),\n        \"max_concurrent_workflow_tasks\": self.max_concurrent_workflow_tasks,\n        \"max_concurrent_activities\": self.max_concurrent_activities,\n    }\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.worker.TemporalWorkerManager","title":"<code>archipy.adapters.temporal.worker.TemporalWorkerManager</code>","text":"<p>               Bases: <code>WorkerPort</code></p> <p>Manager for Temporal worker lifecycle and operations.</p> <p>This class provides a high-level interface for managing Temporal workers, including creation, configuration, and lifecycle management. It integrates with ArchiPy configuration and service patterns.</p> <p>Parameters:</p> Name Type Description Default <code>temporal_config</code> <code>TemporalConfig</code> <p>Configuration settings for Temporal. If None, retrieves from global config. Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/temporal/worker.py</code> <pre><code>class TemporalWorkerManager(WorkerPort):\n    \"\"\"Manager for Temporal worker lifecycle and operations.\n\n    This class provides a high-level interface for managing Temporal workers,\n    including creation, configuration, and lifecycle management. It integrates\n    with ArchiPy configuration and service patterns.\n\n    Args:\n        temporal_config (TemporalConfig, optional): Configuration settings for Temporal.\n            If None, retrieves from global config. Defaults to None.\n    \"\"\"\n\n    def __init__(self, temporal_config: TemporalConfig | None = None) -&gt; None:\n        \"\"\"Initialize the worker manager.\n\n        Args:\n            temporal_config (TemporalConfig, optional): Configuration settings for Temporal.\n                If None, retrieves from global config. Defaults to None.\n        \"\"\"\n        # Get temporal config from the global config or use provided one\n        if temporal_config is None:\n            global_config = BaseConfig.global_config()\n            if hasattr(global_config, \"TEMPORAL\"):\n                self.config = global_config.TEMPORAL\n            else:\n                # Create a default config if none exists\n                from archipy.configs.config_template import TemporalConfig\n\n                self.config = TemporalConfig()\n        else:\n            self.config = temporal_config\n        self._temporal_adapter = TemporalAdapter(temporal_config)\n        self._workers: dict[str, WorkerHandle] = {}\n        self._logger = logging.getLogger(__name__)\n\n    async def _get_client(self) -&gt; Client:\n        \"\"\"Get the Temporal client from the adapter.\n\n        Returns:\n            Client: The Temporal client instance.\n        \"\"\"\n        return await self._temporal_adapter.get_client()\n\n    @override\n    async def start_worker(\n        self,\n        task_queue: str,\n        workflows: list[type] | None = None,\n        activities: list[object] | None = None,\n        build_id: str | None = None,\n        identity: str | None = None,\n        max_concurrent_workflow_tasks: int | None = None,\n        max_concurrent_activities: int | None = None,\n    ) -&gt; WorkerHandle:\n        \"\"\"Start a Temporal worker for the specified task queue.\n\n        Args:\n            task_queue (str): The task queue this worker will poll from.\n            workflows (list[type], optional): List of workflow classes to register.\n                Defaults to None.\n            activities (list[object], optional): List of activity instances to register.\n                Defaults to None.\n            build_id (str, optional): Build identifier for worker versioning.\n                Defaults to None.\n            identity (str, optional): Unique worker identity. If None, auto-generated.\n                Defaults to None.\n            max_concurrent_workflow_tasks (int, optional): Maximum concurrent workflow tasks.\n                Defaults to None (server default).\n            max_concurrent_activities (int, optional): Maximum concurrent activity tasks.\n                Defaults to None (server default).\n\n        Returns:\n            WorkerHandle: Handle to the started worker.\n\n        Raises:\n            WorkerConnectionError: If the worker fails to start.\n        \"\"\"\n        client = await self._get_client()\n        worker_id = str(uuid4())\n        worker_identity = identity or f\"worker-{worker_id[:8]}\"\n\n        try:\n            # Create the Temporal worker\n            worker = Worker(\n                client,\n                task_queue=task_queue,\n                workflows=workflows or [],\n                activities=activities or [],\n                build_id=build_id,\n                identity=worker_identity,\n                max_concurrent_workflow_tasks=max_concurrent_workflow_tasks,\n                max_concurrent_activities=max_concurrent_activities,\n            )\n\n            # Create worker handle\n            worker_handle = WorkerHandle(\n                worker=worker,\n                worker_id=worker_id,\n                task_queue=task_queue,\n                workflows=workflows,\n                activities=activities,\n                build_id=build_id,\n                identity=worker_identity,\n                max_concurrent_workflow_tasks=max_concurrent_workflow_tasks,\n                max_concurrent_activities=max_concurrent_activities,\n            )\n\n            # Start the worker\n            await worker_handle.start()\n\n            # Register the worker\n            self._workers[worker_id] = worker_handle\n\n            self._logger.info(\n                \"Worker created and started\",\n                extra={\n                    \"worker_id\": worker_id,\n                    \"task_queue\": task_queue,\n                    \"identity\": worker_identity,\n                    \"workflow_count\": len(workflows) if workflows else 0,\n                    \"activity_count\": len(activities) if activities else 0,\n                },\n            )\n\n            return worker_handle\n\n        except Exception as error:\n            raise WorkerConnectionError(\n                additional_data={\n                    \"message\": f\"Failed to start worker for task queue '{task_queue}'\",\n                    \"task_queue\": task_queue,\n                    \"worker_id\": worker_id,\n                    \"identity\": worker_identity,\n                    \"error\": str(error),\n                },\n            ) from error\n\n    @override\n    async def stop_worker(self, worker_handle: WorkerHandle) -&gt; None:\n        \"\"\"Stop a running Temporal worker.\n\n        Args:\n            worker_handle (WorkerHandle): Handle to the worker to stop.\n\n        Raises:\n            WorkerShutdownError: If the worker fails to stop gracefully.\n        \"\"\"\n        if worker_handle.worker_id not in self._workers:\n            return  # Worker already stopped or not managed by this manager\n\n        try:\n            await worker_handle.stop()\n            del self._workers[worker_handle.worker_id]\n\n            self._logger.info(\n                \"Worker stopped and removed\",\n                extra={\n                    \"worker_id\": worker_handle.worker_id,\n                    \"task_queue\": worker_handle.task_queue,\n                },\n            )\n\n        except Exception:\n            # Remove from tracking even if shutdown failed\n            if worker_handle.worker_id in self._workers:\n                del self._workers[worker_handle.worker_id]\n            raise\n\n    @override\n    async def shutdown_all_workers(self) -&gt; None:\n        \"\"\"Shutdown all workers managed by this port.\n\n        Performs graceful shutdown of all active workers, waiting for current\n        tasks to complete before terminating.\n\n        Raises:\n            WorkerShutdownError: If any worker fails to shutdown gracefully.\n        \"\"\"\n        if not self._workers:\n            return\n\n        self._logger.info(\n            \"Shutting down all workers\",\n            extra={\n                \"worker_count\": len(self._workers),\n            },\n        )\n\n        shutdown_errors = []\n        workers_to_stop = list(self._workers.values())\n\n        # Stop all workers concurrently\n        for worker_handle in workers_to_stop:\n            try:\n                await self.stop_worker(worker_handle)\n            except Exception as error:\n                shutdown_errors.append(\n                    {\n                        \"worker_id\": worker_handle.worker_id,\n                        \"task_queue\": worker_handle.task_queue,\n                        \"error\": str(error),\n                    },\n                )\n\n        if shutdown_errors:\n            raise WorkerShutdownError(\n                additional_data={\n                    \"message\": f\"Failed to shutdown {len(shutdown_errors)} workers\",\n                    \"worker_count\": len(self._workers),\n                    \"failed_count\": len(shutdown_errors),\n                    \"shutdown_errors\": shutdown_errors,\n                },\n            )\n\n        self._logger.info(\"All workers shut down successfully\")\n\n    def get_worker_stats(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Get statistics for all managed workers.\n\n        Returns:\n            list[dict[str, Any]]: List of worker statistics.\n        \"\"\"\n        return [worker.get_stats() for worker in self._workers.values()]\n\n    def get_worker_by_task_queue(self, task_queue: str) -&gt; WorkerHandle | None:\n        \"\"\"Get a worker handle by task queue.\n\n        Args:\n            task_queue (str): The task queue to search for.\n\n        Returns:\n            WorkerHandle | None: Worker handle if found, None otherwise.\n        \"\"\"\n        for worker in self._workers.values():\n            if worker.task_queue == task_queue:\n                return worker\n        return None\n\n    def list_workers(self) -&gt; list[WorkerHandle]:\n        \"\"\"Get a list of all managed workers.\n\n        Returns:\n            list[WorkerHandle]: List of worker handles.\n        \"\"\"\n        return list(self._workers.values())\n\n    @property\n    def worker_count(self) -&gt; int:\n        \"\"\"Get the number of managed workers.\n\n        Returns:\n            int: Number of managed workers.\n        \"\"\"\n        return len(self._workers)\n\n    async def close(self) -&gt; None:\n        \"\"\"Close the worker manager and all managed workers.\n\n        Performs cleanup of all resources, including stopping all workers\n        and closing the Temporal client connection.\n        \"\"\"\n        await self.shutdown_all_workers()\n        await self._temporal_adapter.close()\n        self._logger.info(\"Worker manager closed\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.worker.TemporalWorkerManager.worker_count","title":"<code>archipy.adapters.temporal.worker.TemporalWorkerManager.worker_count</code>  <code>property</code>","text":"<p>Get the number of managed workers.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of managed workers.</p>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.worker.TemporalWorkerManager.__init__","title":"<code>archipy.adapters.temporal.worker.TemporalWorkerManager.__init__(temporal_config=None)</code>","text":"<p>Initialize the worker manager.</p> <p>Parameters:</p> Name Type Description Default <code>temporal_config</code> <code>TemporalConfig</code> <p>Configuration settings for Temporal. If None, retrieves from global config. Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/temporal/worker.py</code> <pre><code>def __init__(self, temporal_config: TemporalConfig | None = None) -&gt; None:\n    \"\"\"Initialize the worker manager.\n\n    Args:\n        temporal_config (TemporalConfig, optional): Configuration settings for Temporal.\n            If None, retrieves from global config. Defaults to None.\n    \"\"\"\n    # Get temporal config from the global config or use provided one\n    if temporal_config is None:\n        global_config = BaseConfig.global_config()\n        if hasattr(global_config, \"TEMPORAL\"):\n            self.config = global_config.TEMPORAL\n        else:\n            # Create a default config if none exists\n            from archipy.configs.config_template import TemporalConfig\n\n            self.config = TemporalConfig()\n    else:\n        self.config = temporal_config\n    self._temporal_adapter = TemporalAdapter(temporal_config)\n    self._workers: dict[str, WorkerHandle] = {}\n    self._logger = logging.getLogger(__name__)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.worker.TemporalWorkerManager.start_worker","title":"<code>archipy.adapters.temporal.worker.TemporalWorkerManager.start_worker(task_queue, workflows=None, activities=None, build_id=None, identity=None, max_concurrent_workflow_tasks=None, max_concurrent_activities=None)</code>  <code>async</code>","text":"<p>Start a Temporal worker for the specified task queue.</p> <p>Parameters:</p> Name Type Description Default <code>task_queue</code> <code>str</code> <p>The task queue this worker will poll from.</p> required <code>workflows</code> <code>list[type]</code> <p>List of workflow classes to register. Defaults to None.</p> <code>None</code> <code>activities</code> <code>list[object]</code> <p>List of activity instances to register. Defaults to None.</p> <code>None</code> <code>build_id</code> <code>str</code> <p>Build identifier for worker versioning. Defaults to None.</p> <code>None</code> <code>identity</code> <code>str</code> <p>Unique worker identity. If None, auto-generated. Defaults to None.</p> <code>None</code> <code>max_concurrent_workflow_tasks</code> <code>int</code> <p>Maximum concurrent workflow tasks. Defaults to None (server default).</p> <code>None</code> <code>max_concurrent_activities</code> <code>int</code> <p>Maximum concurrent activity tasks. Defaults to None (server default).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>WorkerHandle</code> <code>WorkerHandle</code> <p>Handle to the started worker.</p> <p>Raises:</p> Type Description <code>WorkerConnectionError</code> <p>If the worker fails to start.</p> Source code in <code>archipy/adapters/temporal/worker.py</code> <pre><code>@override\nasync def start_worker(\n    self,\n    task_queue: str,\n    workflows: list[type] | None = None,\n    activities: list[object] | None = None,\n    build_id: str | None = None,\n    identity: str | None = None,\n    max_concurrent_workflow_tasks: int | None = None,\n    max_concurrent_activities: int | None = None,\n) -&gt; WorkerHandle:\n    \"\"\"Start a Temporal worker for the specified task queue.\n\n    Args:\n        task_queue (str): The task queue this worker will poll from.\n        workflows (list[type], optional): List of workflow classes to register.\n            Defaults to None.\n        activities (list[object], optional): List of activity instances to register.\n            Defaults to None.\n        build_id (str, optional): Build identifier for worker versioning.\n            Defaults to None.\n        identity (str, optional): Unique worker identity. If None, auto-generated.\n            Defaults to None.\n        max_concurrent_workflow_tasks (int, optional): Maximum concurrent workflow tasks.\n            Defaults to None (server default).\n        max_concurrent_activities (int, optional): Maximum concurrent activity tasks.\n            Defaults to None (server default).\n\n    Returns:\n        WorkerHandle: Handle to the started worker.\n\n    Raises:\n        WorkerConnectionError: If the worker fails to start.\n    \"\"\"\n    client = await self._get_client()\n    worker_id = str(uuid4())\n    worker_identity = identity or f\"worker-{worker_id[:8]}\"\n\n    try:\n        # Create the Temporal worker\n        worker = Worker(\n            client,\n            task_queue=task_queue,\n            workflows=workflows or [],\n            activities=activities or [],\n            build_id=build_id,\n            identity=worker_identity,\n            max_concurrent_workflow_tasks=max_concurrent_workflow_tasks,\n            max_concurrent_activities=max_concurrent_activities,\n        )\n\n        # Create worker handle\n        worker_handle = WorkerHandle(\n            worker=worker,\n            worker_id=worker_id,\n            task_queue=task_queue,\n            workflows=workflows,\n            activities=activities,\n            build_id=build_id,\n            identity=worker_identity,\n            max_concurrent_workflow_tasks=max_concurrent_workflow_tasks,\n            max_concurrent_activities=max_concurrent_activities,\n        )\n\n        # Start the worker\n        await worker_handle.start()\n\n        # Register the worker\n        self._workers[worker_id] = worker_handle\n\n        self._logger.info(\n            \"Worker created and started\",\n            extra={\n                \"worker_id\": worker_id,\n                \"task_queue\": task_queue,\n                \"identity\": worker_identity,\n                \"workflow_count\": len(workflows) if workflows else 0,\n                \"activity_count\": len(activities) if activities else 0,\n            },\n        )\n\n        return worker_handle\n\n    except Exception as error:\n        raise WorkerConnectionError(\n            additional_data={\n                \"message\": f\"Failed to start worker for task queue '{task_queue}'\",\n                \"task_queue\": task_queue,\n                \"worker_id\": worker_id,\n                \"identity\": worker_identity,\n                \"error\": str(error),\n            },\n        ) from error\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.worker.TemporalWorkerManager.stop_worker","title":"<code>archipy.adapters.temporal.worker.TemporalWorkerManager.stop_worker(worker_handle)</code>  <code>async</code>","text":"<p>Stop a running Temporal worker.</p> <p>Parameters:</p> Name Type Description Default <code>worker_handle</code> <code>WorkerHandle</code> <p>Handle to the worker to stop.</p> required <p>Raises:</p> Type Description <code>WorkerShutdownError</code> <p>If the worker fails to stop gracefully.</p> Source code in <code>archipy/adapters/temporal/worker.py</code> <pre><code>@override\nasync def stop_worker(self, worker_handle: WorkerHandle) -&gt; None:\n    \"\"\"Stop a running Temporal worker.\n\n    Args:\n        worker_handle (WorkerHandle): Handle to the worker to stop.\n\n    Raises:\n        WorkerShutdownError: If the worker fails to stop gracefully.\n    \"\"\"\n    if worker_handle.worker_id not in self._workers:\n        return  # Worker already stopped or not managed by this manager\n\n    try:\n        await worker_handle.stop()\n        del self._workers[worker_handle.worker_id]\n\n        self._logger.info(\n            \"Worker stopped and removed\",\n            extra={\n                \"worker_id\": worker_handle.worker_id,\n                \"task_queue\": worker_handle.task_queue,\n            },\n        )\n\n    except Exception:\n        # Remove from tracking even if shutdown failed\n        if worker_handle.worker_id in self._workers:\n            del self._workers[worker_handle.worker_id]\n        raise\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.worker.TemporalWorkerManager.shutdown_all_workers","title":"<code>archipy.adapters.temporal.worker.TemporalWorkerManager.shutdown_all_workers()</code>  <code>async</code>","text":"<p>Shutdown all workers managed by this port.</p> <p>Performs graceful shutdown of all active workers, waiting for current tasks to complete before terminating.</p> <p>Raises:</p> Type Description <code>WorkerShutdownError</code> <p>If any worker fails to shutdown gracefully.</p> Source code in <code>archipy/adapters/temporal/worker.py</code> <pre><code>@override\nasync def shutdown_all_workers(self) -&gt; None:\n    \"\"\"Shutdown all workers managed by this port.\n\n    Performs graceful shutdown of all active workers, waiting for current\n    tasks to complete before terminating.\n\n    Raises:\n        WorkerShutdownError: If any worker fails to shutdown gracefully.\n    \"\"\"\n    if not self._workers:\n        return\n\n    self._logger.info(\n        \"Shutting down all workers\",\n        extra={\n            \"worker_count\": len(self._workers),\n        },\n    )\n\n    shutdown_errors = []\n    workers_to_stop = list(self._workers.values())\n\n    # Stop all workers concurrently\n    for worker_handle in workers_to_stop:\n        try:\n            await self.stop_worker(worker_handle)\n        except Exception as error:\n            shutdown_errors.append(\n                {\n                    \"worker_id\": worker_handle.worker_id,\n                    \"task_queue\": worker_handle.task_queue,\n                    \"error\": str(error),\n                },\n            )\n\n    if shutdown_errors:\n        raise WorkerShutdownError(\n            additional_data={\n                \"message\": f\"Failed to shutdown {len(shutdown_errors)} workers\",\n                \"worker_count\": len(self._workers),\n                \"failed_count\": len(shutdown_errors),\n                \"shutdown_errors\": shutdown_errors,\n            },\n        )\n\n    self._logger.info(\"All workers shut down successfully\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.worker.TemporalWorkerManager.get_worker_stats","title":"<code>archipy.adapters.temporal.worker.TemporalWorkerManager.get_worker_stats()</code>","text":"<p>Get statistics for all managed workers.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: List of worker statistics.</p> Source code in <code>archipy/adapters/temporal/worker.py</code> <pre><code>def get_worker_stats(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Get statistics for all managed workers.\n\n    Returns:\n        list[dict[str, Any]]: List of worker statistics.\n    \"\"\"\n    return [worker.get_stats() for worker in self._workers.values()]\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.worker.TemporalWorkerManager.get_worker_by_task_queue","title":"<code>archipy.adapters.temporal.worker.TemporalWorkerManager.get_worker_by_task_queue(task_queue)</code>","text":"<p>Get a worker handle by task queue.</p> <p>Parameters:</p> Name Type Description Default <code>task_queue</code> <code>str</code> <p>The task queue to search for.</p> required <p>Returns:</p> Type Description <code>WorkerHandle | None</code> <p>WorkerHandle | None: Worker handle if found, None otherwise.</p> Source code in <code>archipy/adapters/temporal/worker.py</code> <pre><code>def get_worker_by_task_queue(self, task_queue: str) -&gt; WorkerHandle | None:\n    \"\"\"Get a worker handle by task queue.\n\n    Args:\n        task_queue (str): The task queue to search for.\n\n    Returns:\n        WorkerHandle | None: Worker handle if found, None otherwise.\n    \"\"\"\n    for worker in self._workers.values():\n        if worker.task_queue == task_queue:\n            return worker\n    return None\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.worker.TemporalWorkerManager.list_workers","title":"<code>archipy.adapters.temporal.worker.TemporalWorkerManager.list_workers()</code>","text":"<p>Get a list of all managed workers.</p> <p>Returns:</p> Type Description <code>list[WorkerHandle]</code> <p>list[WorkerHandle]: List of worker handles.</p> Source code in <code>archipy/adapters/temporal/worker.py</code> <pre><code>def list_workers(self) -&gt; list[WorkerHandle]:\n    \"\"\"Get a list of all managed workers.\n\n    Returns:\n        list[WorkerHandle]: List of worker handles.\n    \"\"\"\n    return list(self._workers.values())\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.worker.TemporalWorkerManager.close","title":"<code>archipy.adapters.temporal.worker.TemporalWorkerManager.close()</code>  <code>async</code>","text":"<p>Close the worker manager and all managed workers.</p> <p>Performs cleanup of all resources, including stopping all workers and closing the Temporal client connection.</p> Source code in <code>archipy/adapters/temporal/worker.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the worker manager and all managed workers.\n\n    Performs cleanup of all resources, including stopping all workers\n    and closing the Temporal client connection.\n    \"\"\"\n    await self.shutdown_all_workers()\n    await self._temporal_adapter.close()\n    self._logger.info(\"Worker manager closed\")\n</code></pre>"},{"location":"api_reference/adapters/#temporal-base-classes","title":"Temporal Base Classes","text":"<p>Base classes for Temporal workflows and activities.</p> <p>This module provides base classes and utilities for implementing Temporal workflows and activities within the ArchiPy architecture, including integration with existing adapters and standardized patterns.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.base.BaseWorkflow","title":"<code>archipy.adapters.temporal.base.BaseWorkflow</code>","text":"<p>Base class for all Temporal workflows in ArchiPy.</p> <p>Provides common functionality and patterns for workflow implementations, including standardized logging, error handling, and integration with ArchiPy services through activities.</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>T</code> <p>Type of the workflow input parameter.</p> required <code>R</code> <p>Type of the workflow return value.</p> required Source code in <code>archipy/adapters/temporal/base.py</code> <pre><code>class BaseWorkflow[T, R]:\n    \"\"\"Base class for all Temporal workflows in ArchiPy.\n\n    Provides common functionality and patterns for workflow implementations,\n    including standardized logging, error handling, and integration with\n    ArchiPy services through activities.\n\n    Type Parameters:\n        T: Type of the workflow input parameter.\n        R: Type of the workflow return value.\n    \"\"\"\n\n    @workflow.run\n    async def run(self, workflow_input: T) -&gt; R:\n        \"\"\"Main workflow execution method.\n\n        This method must be implemented by concrete workflow classes to define\n        the workflow logic. It should orchestrate activities and child workflows\n        to accomplish the business process.\n\n        Args:\n            workflow_input (T): The input data for the workflow.\n\n        Returns:\n            R: The result of the workflow execution.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError(\"Workflow must implement run method\")\n\n    async def _execute_activity_with_retry(\n        self,\n        activity_func: Any,\n        arg: Any,\n        start_to_close_timeout: timedelta | None = None,\n        heartbeat_timeout: timedelta | None = None,\n        retry_policy: RetryPolicy | None = None,\n        task_queue: str | None = None,\n    ) -&gt; Any:\n        \"\"\"Execute an activity with standardized retry configuration.\n\n        Args:\n            activity_func (Any): The activity function to execute.\n            arg (Any): Argument to pass to the activity.\n            start_to_close_timeout (timedelta): Maximum execution time for the activity.\n                Defaults to 30 seconds.\n            heartbeat_timeout (timedelta, optional): Heartbeat timeout for long-running activities.\n                Defaults to None.\n            retry_policy (RetryPolicy, optional): Custom retry policy.\n                If None, uses default retry policy. Defaults to None.\n            task_queue (str, optional): Task queue for activity execution.\n                If None, uses workflow's task queue. Defaults to None.\n\n        Returns:\n            Any: The result of the activity execution.\n        \"\"\"\n        # Get temporal config for default values\n        from archipy.configs.base_config import BaseConfig\n\n        temporal_config = BaseConfig.global_config().TEMPORAL\n\n        # Use config defaults if not provided\n        if start_to_close_timeout is None:\n            start_to_close_timeout = timedelta(seconds=temporal_config.ACTIVITY_START_TO_CLOSE_TIMEOUT)\n        if heartbeat_timeout is None:\n            heartbeat_timeout = timedelta(seconds=temporal_config.ACTIVITY_HEARTBEAT_TIMEOUT)\n        if retry_policy is None:\n            retry_policy = RetryPolicy(\n                maximum_attempts=temporal_config.RETRY_MAXIMUM_ATTEMPTS,\n                backoff_coefficient=temporal_config.RETRY_BACKOFF_COEFFICIENT,\n                maximum_interval=timedelta(seconds=temporal_config.RETRY_MAXIMUM_INTERVAL),\n            )\n\n        return await workflow.execute_activity(\n            activity_func,\n            arg,\n            start_to_close_timeout=start_to_close_timeout,\n            heartbeat_timeout=heartbeat_timeout,\n            retry_policy=retry_policy,\n            task_queue=task_queue or temporal_config.TASK_QUEUE,\n        )\n\n    async def _execute_child_workflow(\n        self,\n        child_workflow: Any,\n        arg: Any,\n        workflow_id: str | None = None,\n        task_queue: str | None = None,\n        execution_timeout: timedelta | None = None,\n    ) -&gt; Any:\n        \"\"\"Execute a child workflow with standardized configuration.\n\n        Args:\n            child_workflow (Any): The child workflow function to execute.\n            arg (Any): Argument to pass to the child workflow.\n            workflow_id (str, optional): Unique ID for the child workflow.\n                If None, auto-generated. Defaults to None.\n            task_queue (str, optional): Task queue for child workflow execution.\n                If None, uses parent workflow's task queue. Defaults to None.\n            execution_timeout (timedelta, optional): Maximum execution time for the child workflow.\n                If None, uses default timeout. Defaults to None.\n\n        Returns:\n            Any: The result of the child workflow execution.\n        \"\"\"\n        # Get temporal config for default values\n        from archipy.configs.base_config import BaseConfig\n\n        temporal_config = BaseConfig.global_config().TEMPORAL\n\n        # Use config defaults if not provided\n        if execution_timeout is None:\n            execution_timeout = timedelta(seconds=temporal_config.WORKFLOW_EXECUTION_TIMEOUT)\n\n        return await workflow.execute_child_workflow(\n            child_workflow,\n            arg,\n            id=workflow_id,\n            task_queue=task_queue or temporal_config.TASK_QUEUE,\n            execution_timeout=execution_timeout,\n        )\n\n    def _log_workflow_event(self, event: str, details: dict[str, Any] | None = None) -&gt; None:\n        \"\"\"Log workflow events with consistent formatting.\n\n        Args:\n            event (str): The event description.\n            details (dict[str, Any], optional): Additional event details.\n                Defaults to None.\n        \"\"\"\n        log_data = {\n            \"workflow_id\": workflow.info().workflow_id,\n            \"workflow_type\": workflow.info().workflow_type,\n            \"event\": event,\n        }\n\n        if details:\n            log_data.update(details)\n\n        workflow.logger.info(\"Workflow event\", extra=log_data)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.base.BaseWorkflow.run","title":"<code>archipy.adapters.temporal.base.BaseWorkflow.run(workflow_input)</code>  <code>async</code>","text":"<p>Main workflow execution method.</p> <p>This method must be implemented by concrete workflow classes to define the workflow logic. It should orchestrate activities and child workflows to accomplish the business process.</p> <p>Parameters:</p> Name Type Description Default <code>workflow_input</code> <code>T</code> <p>The input data for the workflow.</p> required <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>The result of the workflow execution.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/temporal/base.py</code> <pre><code>@workflow.run\nasync def run(self, workflow_input: T) -&gt; R:\n    \"\"\"Main workflow execution method.\n\n    This method must be implemented by concrete workflow classes to define\n    the workflow logic. It should orchestrate activities and child workflows\n    to accomplish the business process.\n\n    Args:\n        workflow_input (T): The input data for the workflow.\n\n    Returns:\n        R: The result of the workflow execution.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError(\"Workflow must implement run method\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.base.BaseActivity","title":"<code>archipy.adapters.temporal.base.BaseActivity</code>","text":"<p>Base class for all Temporal activities in ArchiPy.</p> <p>Provides common functionality for activity implementations, including integration with your logic layer, standardized error handling, and execution hooks for cross-cutting concerns.</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>T</code> <p>Type of the activity input parameter.</p> required <code>R</code> <p>Type of the activity return value.</p> required Source code in <code>archipy/adapters/temporal/base.py</code> <pre><code>class BaseActivity[T, R]:\n    \"\"\"Base class for all Temporal activities in ArchiPy.\n\n    Provides common functionality for activity implementations, including\n    integration with your logic layer, standardized error handling, and\n    execution hooks for cross-cutting concerns.\n\n    Type Parameters:\n        T: Type of the activity input parameter.\n        R: Type of the activity return value.\n    \"\"\"\n\n    def __init__(self, logic: Any | None = None) -&gt; None:\n        \"\"\"Initialize the activity with a logic instance.\n\n        Args:\n            logic (Any, optional): Your business logic instance (object) that contains\n                a repository with access to adapters. If None, subclass should override _get_logic().\n                Defaults to None.\n        \"\"\"\n        self._logic = logic\n\n    def _get_logic(self) -&gt; Any:\n        \"\"\"Get the logic instance for this activity.\n\n        Override this method in subclasses to provide your specific logic instance,\n        or pass it via constructor using dependency injection. Your logic instance\n        should have a repository that manages adapter access.\n\n        Returns:\n            Any: Your business logic instance.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass and no logic provided.\n        \"\"\"\n        if self._logic is not None:\n            return self._logic\n        raise NotImplementedError(\"Activity must provide a logic instance via constructor or override _get_logic()\")\n\n    @activity.defn\n    async def execute(self, activity_input: T) -&gt; R:\n        \"\"\"Main activity execution method with hooks.\n\n        This method provides a template for activity execution with pre/post hooks\n        for common concerns like caching, validation, and monitoring.\n\n        Args:\n            activity_input (T): The input data for the activity.\n\n        Returns:\n            R: The result of the activity execution.\n\n        Raises:\n            Exception: Any exception that occurs during activity execution.\n        \"\"\"\n        try:\n            # Pre-execution hook\n            await self._before_execute(activity_input)\n\n            # Check cache if enabled\n            if self._is_cacheable():\n                cache_key = self._get_cache_key(activity_input)\n                cached_result = await self._get_from_cache(cache_key)\n                if cached_result is not None:\n                    activity.logger.info(\"Using cached result\", extra={\"cache_key\": cache_key})\n                    return cached_result\n\n            # Main business logic execution\n            result = await self._do_execute(activity_input)\n\n            # Cache result if enabled\n            if self._is_cacheable() and result is not None:\n                cache_key = self._get_cache_key(activity_input)\n                await self._store_in_cache(cache_key, result)\n\n            # Post-execution hook\n            await self._after_execute(activity_input, result)\n\n            return result\n\n        except Exception as error:\n            await self._handle_error(activity_input, error)\n            raise\n\n    @abstractmethod\n    async def _do_execute(self, activity_input: T) -&gt; R:\n        \"\"\"Execute the main activity business logic.\n\n        This method must be implemented by concrete activity classes to define\n        the specific business logic for the activity.\n\n        Args:\n            activity_input (T): The input data for the activity.\n\n        Returns:\n            R: The result of the activity execution.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError(\"Activity must implement _do_execute method\")\n\n    async def _before_execute(self, activity_input: T) -&gt; None:\n        \"\"\"Pre-execution hook for common setup tasks.\n\n        Override this method to perform tasks before the main activity logic,\n        such as validation, setup, or preparation.\n\n        Args:\n            activity_input (T): The input data for the activity.\n        \"\"\"\n        self._log_activity_event(\"execution_started\", {\"input_type\": type(activity_input).__name__})\n\n    async def _after_execute(self, activity_input: T, result: R) -&gt; None:\n        \"\"\"Post-execution hook for cleanup and monitoring.\n\n        Override this method to perform tasks after successful activity execution,\n        such as cleanup, metrics emission, or notifications.\n\n        Args:\n            activity_input (T): The input data that was processed.\n            result (R): The result of the activity execution.\n        \"\"\"\n        self._log_activity_event(\n            \"execution_completed\",\n            {\n                \"input_type\": type(activity_input).__name__,\n                \"result_type\": type(result).__name__,\n            },\n        )\n\n    async def _handle_error(self, activity_input: T, error: Exception) -&gt; None:\n        \"\"\"Handle activity execution errors.\n\n        Override this method to implement custom error handling logic,\n        such as error reporting, cleanup, or compensation actions.\n\n        Args:\n            activity_input (T): The input data that was being processed.\n            error (Exception): The exception that occurred.\n        \"\"\"\n        self._log_activity_event(\n            \"execution_failed\",\n            {\n                \"input_type\": type(activity_input).__name__,\n                \"error_type\": type(error).__name__,\n                \"error_message\": str(error),\n            },\n        )\n\n    def _is_cacheable(self) -&gt; bool:\n        \"\"\"Determine if this activity's results should be cached.\n\n        Override this method to enable caching for specific activities.\n\n        Returns:\n            bool: True if results should be cached, False otherwise.\n        \"\"\"\n        return False\n\n    def _get_cache_key(self, activity_input: T) -&gt; str:\n        \"\"\"Generate a cache key for the given input.\n\n        Override this method to customize cache key generation for activities\n        that support caching.\n\n        Args:\n            activity_input (T): The activity input data.\n\n        Returns:\n            str: The cache key for storing/retrieving results.\n        \"\"\"\n        return f\"{self.__class__.__name__}:{hash(str(activity_input))}\"\n\n    async def _get_from_cache(self, cache_key: str) -&gt; R | None:\n        \"\"\"Retrieve a result from cache using your logic instance.\n\n        Override this method to implement caching using your repository pattern.\n        By default, this returns None (no caching).\n\n        Args:\n            cache_key (str): The cache key to look up.\n\n        Returns:\n            R | None: The cached result if found, None otherwise.\n        \"\"\"\n        # Override this method to use your logic instance's repository\n        return None\n\n    async def _store_in_cache(self, cache_key: str, result: R, ttl: int = 3600) -&gt; None:\n        \"\"\"Store a result in cache using your logic instance.\n\n        Override this method to implement caching using your repository pattern.\n        By default, this does nothing.\n\n        Args:\n            cache_key (str): The cache key for storage.\n            result (R): The result to cache.\n            ttl (int): Time-to-live in seconds. Defaults to 3600 (1 hour).\n        \"\"\"\n        # Override this method to use your logic instance's repository\n        pass\n\n    def _log_activity_event(self, event: str, details: dict[str, Any] | None = None) -&gt; None:\n        \"\"\"Log activity events with consistent formatting.\n\n        Args:\n            event (str): The event description.\n            details (dict[str, Any], optional): Additional event details.\n                Defaults to None.\n        \"\"\"\n        log_data = {\n            \"activity_type\": self.__class__.__name__,\n            \"event\": event,\n        }\n\n        if details:\n            log_data.update(details)\n\n        activity.logger.info(\"Activity event\", extra=log_data)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.base.BaseActivity.__init__","title":"<code>archipy.adapters.temporal.base.BaseActivity.__init__(logic=None)</code>","text":"<p>Initialize the activity with a logic instance.</p> <p>Parameters:</p> Name Type Description Default <code>logic</code> <code>Any</code> <p>Your business logic instance (object) that contains a repository with access to adapters. If None, subclass should override _get_logic(). Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/temporal/base.py</code> <pre><code>def __init__(self, logic: Any | None = None) -&gt; None:\n    \"\"\"Initialize the activity with a logic instance.\n\n    Args:\n        logic (Any, optional): Your business logic instance (object) that contains\n            a repository with access to adapters. If None, subclass should override _get_logic().\n            Defaults to None.\n    \"\"\"\n    self._logic = logic\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.base.BaseActivity.execute","title":"<code>archipy.adapters.temporal.base.BaseActivity.execute(activity_input)</code>  <code>async</code>","text":"<p>Main activity execution method with hooks.</p> <p>This method provides a template for activity execution with pre/post hooks for common concerns like caching, validation, and monitoring.</p> <p>Parameters:</p> Name Type Description Default <code>activity_input</code> <code>T</code> <p>The input data for the activity.</p> required <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>The result of the activity execution.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Any exception that occurs during activity execution.</p> Source code in <code>archipy/adapters/temporal/base.py</code> <pre><code>@activity.defn\nasync def execute(self, activity_input: T) -&gt; R:\n    \"\"\"Main activity execution method with hooks.\n\n    This method provides a template for activity execution with pre/post hooks\n    for common concerns like caching, validation, and monitoring.\n\n    Args:\n        activity_input (T): The input data for the activity.\n\n    Returns:\n        R: The result of the activity execution.\n\n    Raises:\n        Exception: Any exception that occurs during activity execution.\n    \"\"\"\n    try:\n        # Pre-execution hook\n        await self._before_execute(activity_input)\n\n        # Check cache if enabled\n        if self._is_cacheable():\n            cache_key = self._get_cache_key(activity_input)\n            cached_result = await self._get_from_cache(cache_key)\n            if cached_result is not None:\n                activity.logger.info(\"Using cached result\", extra={\"cache_key\": cache_key})\n                return cached_result\n\n        # Main business logic execution\n        result = await self._do_execute(activity_input)\n\n        # Cache result if enabled\n        if self._is_cacheable() and result is not None:\n            cache_key = self._get_cache_key(activity_input)\n            await self._store_in_cache(cache_key, result)\n\n        # Post-execution hook\n        await self._after_execute(activity_input, result)\n\n        return result\n\n    except Exception as error:\n        await self._handle_error(activity_input, error)\n        raise\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.base.LogicIntegratedActivity","title":"<code>archipy.adapters.temporal.base.LogicIntegratedActivity</code>","text":"<p>               Bases: <code>BaseActivity[T, R]</code></p> <p>Activity base class that enforces the logic layer pattern.</p> <p>This class provides helper methods that delegate to your logic instance, ensuring all business operations go through your established architecture with a single repository managing adapter access.</p> Source code in <code>archipy/adapters/temporal/base.py</code> <pre><code>class LogicIntegratedActivity(BaseActivity[T, R]):\n    \"\"\"Activity base class that enforces the logic layer pattern.\n\n    This class provides helper methods that delegate to your logic instance,\n    ensuring all business operations go through your established architecture\n    with a single repository managing adapter access.\n    \"\"\"\n\n    async def _execute_with_logic(self, operation_func: str, *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"Execute an operation using your logic instance.\n\n        This is a convenience method to call methods on your logic instance.\n\n        Args:\n            operation_func (str): The name of the method to call on your logic instance.\n            *args (Any): Arguments to pass to the logic method.\n            **kwargs (Any): Keyword arguments to pass to the logic method.\n\n        Returns:\n            Any: Result of the logic operation.\n\n        Example:\n            # Call logic.get_user_by_id(user_id)\n            user = await self._execute_with_logic(\"get_user_by_id\", user_id)\n        \"\"\"\n        logic = self._get_logic()\n        method = getattr(logic, operation_func)\n        return await method(*args, **kwargs)\n\n    async def _execute_with_atomic(self, operation_func: str, *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"Execute an operation using your logic instance method decorated with @atomic.\n\n        This method assumes your logic methods are decorated with atomic decorators\n        for transaction management.\n\n        Args:\n            operation_func (str): The name of the method to call on your logic instance.\n                This method should be decorated with @atomic for transaction support.\n            *args (Any): Arguments to pass to the logic method.\n            **kwargs (Any): Keyword arguments to pass to the logic method.\n\n        Returns:\n            Any: Result of the atomic operation.\n\n        Example:\n            # Call logic.process_order(order_data) - method decorated with @atomic\n            result = await self._execute_with_atomic(\"process_order\", order_data)\n        \"\"\"\n        logic = self._get_logic()\n        method = getattr(logic, operation_func)\n        # Method should be decorated with @atomic, so transaction is handled automatically\n        return await method(*args, **kwargs)\n\n    async def _call_atomic_method(self, method_name: str, *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"Call an atomic method directly on your logic instance.\n\n        This is an alias for _execute_with_atomic for clearer semantic meaning.\n\n        Args:\n            method_name (str): The name of the atomic method to call.\n            *args (Any): Arguments to pass to the method.\n            **kwargs (Any): Keyword arguments to pass to the method.\n\n        Returns:\n            Any: Result of the atomic method call.\n\n        Example:\n            # Direct call to @atomic decorated method\n            result = await self._call_atomic_method(\"create_order_with_payment\", order_data)\n        \"\"\"\n        return await self._execute_with_atomic(method_name, *args, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.base.AtomicActivity","title":"<code>archipy.adapters.temporal.base.AtomicActivity</code>","text":"<p>               Bases: <code>BaseActivity[T, R]</code></p> <p>Activity base class with built-in atomic transaction support.</p> <p>This class extends BaseActivity to provide direct atomic transaction support within activity execution, ensuring database consistency during activity operations.</p> <p>Parameters:</p> Name Type Description Default <code>logic</code> <code>Any</code> <p>Business logic instance with repository access. Defaults to None.</p> <code>None</code> <code>db_type</code> <code>str</code> <p>Database type for atomic operations. Defaults to \"postgres\".</p> <code>'postgres'</code> Source code in <code>archipy/adapters/temporal/base.py</code> <pre><code>class AtomicActivity(BaseActivity[T, R]):\n    \"\"\"Activity base class with built-in atomic transaction support.\n\n    This class extends BaseActivity to provide direct atomic transaction support\n    within activity execution, ensuring database consistency during activity operations.\n\n    Args:\n        logic (Any, optional): Business logic instance with repository access. Defaults to None.\n        db_type (str, optional): Database type for atomic operations. Defaults to \"postgres\".\n    \"\"\"\n\n    def __init__(self, logic: Any | None = None, db_type: str = \"postgres\") -&gt; None:\n        \"\"\"Initialize the atomic activity.\n\n        Args:\n            logic (Any, optional): Business logic instance. Defaults to None.\n            db_type (str): Database type (\"postgres\", \"sqlite\", \"starrocks\"). Defaults to \"postgres\".\n\n        Raises:\n            ValueError: If an invalid db_type is provided.\n        \"\"\"\n        super().__init__(logic)\n        if db_type not in (\"postgres\", \"sqlite\", \"starrocks\"):\n            raise ValueError(f\"Invalid db_type: {db_type}. Must be one of: postgres, sqlite, starrocks\")\n        self.db_type = db_type\n\n    def _get_atomic_decorator(self) -&gt; Callable[..., Any]:\n        \"\"\"Get the appropriate async atomic decorator for the configured database type.\n\n        Returns:\n            Callable: The async atomic decorator function for the configured database.\n        \"\"\"\n        decorators_map = {\n            \"postgres\": async_postgres_sqlalchemy_atomic_decorator,\n            \"sqlite\": async_sqlite_sqlalchemy_atomic_decorator,\n            \"starrocks\": async_starrocks_sqlalchemy_atomic_decorator,\n        }\n        return decorators_map[self.db_type]\n\n    @activity.defn\n    async def execute_atomic(self, activity_input: T) -&gt; R:\n        \"\"\"Execute the activity within a database transaction.\n\n        This method wraps the entire activity execution (including pre/post hooks)\n        within a database transaction, ensuring atomicity of all database operations.\n\n        Args:\n            activity_input (T): The input data for the activity.\n\n        Returns:\n            R: The result of the activity execution.\n\n        Raises:\n            Exception: Any exception that occurs during activity execution.\n        \"\"\"\n        atomic_decorator = self._get_atomic_decorator()\n\n        @atomic_decorator\n        async def _atomic_execute() -&gt; R:\n            return await super(AtomicActivity, self).execute(activity_input)\n\n        return await _atomic_execute()\n\n    async def _do_execute_atomic(self, activity_input: T) -&gt; R:\n        \"\"\"Execute main business logic within a database transaction.\n\n        This method provides atomic transaction support for the core business logic only,\n        excluding pre/post hooks from the transaction scope.\n\n        Args:\n            activity_input (T): The input data for the activity.\n\n        Returns:\n            R: The result of the business logic execution.\n        \"\"\"\n        atomic_decorator = self._get_atomic_decorator()\n\n        @atomic_decorator\n        async def _atomic_do_execute() -&gt; R:\n            return await self._do_execute(activity_input)\n\n        return await _atomic_do_execute()\n\n    async def execute_custom_atomic_operation(self, operation: Callable[[], Any]) -&gt; Any:\n        \"\"\"Execute a custom operation within a database transaction.\n\n        This utility method allows executing custom logic within the activity's\n        configured atomic transaction context.\n\n        Args:\n            operation (Callable[[], T]): The operation to execute atomically.\n\n        Returns:\n            Any: The result of the operation.\n\n        Example:\n            ```python\n            async def custom_logic():\n                # Custom database operations\n                return await some_database_work()\n\n            result = await self.execute_custom_atomic_operation(custom_logic)\n            ```\n        \"\"\"\n        atomic_decorator = self._get_atomic_decorator()\n\n        @atomic_decorator\n        async def _execute_operation() -&gt; Any:\n            return await operation()\n\n        return await _execute_operation()\n\n    def with_db_type(self, db_type: str) -&gt; \"AtomicActivity[T, R]\":\n        \"\"\"Create a new instance with a different database type.\n\n        Args:\n            db_type (str): The new database type (\"postgres\", \"sqlite\", or \"starrocks\").\n\n        Returns:\n            AtomicActivity[T, R]: New activity instance with the specified database type.\n\n        Raises:\n            ValueError: If an invalid db_type is provided.\n        \"\"\"\n        # Cannot return concrete type due to abstract method\n        raise NotImplementedError(\"AtomicActivity cannot be instantiated directly\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.base.AtomicActivity.__init__","title":"<code>archipy.adapters.temporal.base.AtomicActivity.__init__(logic=None, db_type='postgres')</code>","text":"<p>Initialize the atomic activity.</p> <p>Parameters:</p> Name Type Description Default <code>logic</code> <code>Any</code> <p>Business logic instance. Defaults to None.</p> <code>None</code> <code>db_type</code> <code>str</code> <p>Database type (\"postgres\", \"sqlite\", \"starrocks\"). Defaults to \"postgres\".</p> <code>'postgres'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid db_type is provided.</p> Source code in <code>archipy/adapters/temporal/base.py</code> <pre><code>def __init__(self, logic: Any | None = None, db_type: str = \"postgres\") -&gt; None:\n    \"\"\"Initialize the atomic activity.\n\n    Args:\n        logic (Any, optional): Business logic instance. Defaults to None.\n        db_type (str): Database type (\"postgres\", \"sqlite\", \"starrocks\"). Defaults to \"postgres\".\n\n    Raises:\n        ValueError: If an invalid db_type is provided.\n    \"\"\"\n    super().__init__(logic)\n    if db_type not in (\"postgres\", \"sqlite\", \"starrocks\"):\n        raise ValueError(f\"Invalid db_type: {db_type}. Must be one of: postgres, sqlite, starrocks\")\n    self.db_type = db_type\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.base.AtomicActivity.execute_atomic","title":"<code>archipy.adapters.temporal.base.AtomicActivity.execute_atomic(activity_input)</code>  <code>async</code>","text":"<p>Execute the activity within a database transaction.</p> <p>This method wraps the entire activity execution (including pre/post hooks) within a database transaction, ensuring atomicity of all database operations.</p> <p>Parameters:</p> Name Type Description Default <code>activity_input</code> <code>T</code> <p>The input data for the activity.</p> required <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>The result of the activity execution.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Any exception that occurs during activity execution.</p> Source code in <code>archipy/adapters/temporal/base.py</code> <pre><code>@activity.defn\nasync def execute_atomic(self, activity_input: T) -&gt; R:\n    \"\"\"Execute the activity within a database transaction.\n\n    This method wraps the entire activity execution (including pre/post hooks)\n    within a database transaction, ensuring atomicity of all database operations.\n\n    Args:\n        activity_input (T): The input data for the activity.\n\n    Returns:\n        R: The result of the activity execution.\n\n    Raises:\n        Exception: Any exception that occurs during activity execution.\n    \"\"\"\n    atomic_decorator = self._get_atomic_decorator()\n\n    @atomic_decorator\n    async def _atomic_execute() -&gt; R:\n        return await super(AtomicActivity, self).execute(activity_input)\n\n    return await _atomic_execute()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.base.AtomicActivity.execute_custom_atomic_operation","title":"<code>archipy.adapters.temporal.base.AtomicActivity.execute_custom_atomic_operation(operation)</code>  <code>async</code>","text":"<p>Execute a custom operation within a database transaction.</p> <p>This utility method allows executing custom logic within the activity's configured atomic transaction context.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>Callable[[], T]</code> <p>The operation to execute atomically.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The result of the operation.</p> Example <pre><code>async def custom_logic():\n    # Custom database operations\n    return await some_database_work()\n\nresult = await self.execute_custom_atomic_operation(custom_logic)\n</code></pre> Source code in <code>archipy/adapters/temporal/base.py</code> <pre><code>async def execute_custom_atomic_operation(self, operation: Callable[[], Any]) -&gt; Any:\n    \"\"\"Execute a custom operation within a database transaction.\n\n    This utility method allows executing custom logic within the activity's\n    configured atomic transaction context.\n\n    Args:\n        operation (Callable[[], T]): The operation to execute atomically.\n\n    Returns:\n        Any: The result of the operation.\n\n    Example:\n        ```python\n        async def custom_logic():\n            # Custom database operations\n            return await some_database_work()\n\n        result = await self.execute_custom_atomic_operation(custom_logic)\n        ```\n    \"\"\"\n    atomic_decorator = self._get_atomic_decorator()\n\n    @atomic_decorator\n    async def _execute_operation() -&gt; Any:\n        return await operation()\n\n    return await _execute_operation()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.temporal.base.AtomicActivity.with_db_type","title":"<code>archipy.adapters.temporal.base.AtomicActivity.with_db_type(db_type)</code>","text":"<p>Create a new instance with a different database type.</p> <p>Parameters:</p> Name Type Description Default <code>db_type</code> <code>str</code> <p>The new database type (\"postgres\", \"sqlite\", or \"starrocks\").</p> required <p>Returns:</p> Type Description <code>AtomicActivity[T, R]</code> <p>AtomicActivity[T, R]: New activity instance with the specified database type.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid db_type is provided.</p> Source code in <code>archipy/adapters/temporal/base.py</code> <pre><code>def with_db_type(self, db_type: str) -&gt; \"AtomicActivity[T, R]\":\n    \"\"\"Create a new instance with a different database type.\n\n    Args:\n        db_type (str): The new database type (\"postgres\", \"sqlite\", or \"starrocks\").\n\n    Returns:\n        AtomicActivity[T, R]: New activity instance with the specified database type.\n\n    Raises:\n        ValueError: If an invalid db_type is provided.\n    \"\"\"\n    # Cannot return concrete type due to abstract method\n    raise NotImplementedError(\"AtomicActivity cannot be instantiated directly\")\n</code></pre>"},{"location":"api_reference/configs/","title":"Configs","text":""},{"location":"api_reference/configs/#overview","title":"Overview","text":"<p>The configs module provides tools for standardized configuration management and injection, supporting consistent setup across services like databases, Redis, and email.</p>"},{"location":"api_reference/configs/#quick-start","title":"Quick Start","text":"<pre><code>from archipy.configs.base_config import BaseConfig\n\nclass AppConfig(BaseConfig):\n    APP_NAME: str = \"MyService\"\n    DEBUG: bool = False\n    DB_HOST: str = \"localhost\"\n    DB_PORT: int = 5432\n</code></pre>"},{"location":"api_reference/configs/#api-stability","title":"API Stability","text":"Component Status Notes BaseConfig \ud83d\udfe2 Stable Production-ready Config Templates \ud83d\udfe2 Stable Production-ready Environment Types \ud83d\udfe2 Stable Production-ready"},{"location":"api_reference/configs/#core-classes","title":"Core Classes","text":""},{"location":"api_reference/configs/#base-config","title":"BaseConfig","text":"<p>The main configuration class that provides environment variable support, type validation, and global configuration access.</p> <p>Key Features: - Environment variable support - Type validation - Global configuration access - Nested configuration support</p>"},{"location":"api_reference/configs/#config-templates","title":"SQLAlchemyConfig","text":"<p>Database configuration template with connection settings, pool configuration, and debug options.</p> <p>Key Features: - Database connection settings - Pool configuration - Migration settings - Debug options</p>"},{"location":"api_reference/configs/#examples","title":"Examples","text":"<p>For practical examples, see the Configuration Management Guide.</p>"},{"location":"api_reference/configs/#source-code","title":"Source Code","text":"<p>\ud83d\udcc1 Location: <code>archipy/configs/</code></p> <p>\ud83d\udd17 Browse Source - <code>ENABLE_FROM_LINTING</code>: Whether to enable SQL linting - <code>HIDE_PARAMETERS</code>: Whether to hide SQL parameters in logs - <code>HOST</code>: Database host - <code>ISOLATION_LEVEL</code>: Transaction isolation level - <code>PASSWORD</code>: Database password - <code>POOL_MAX_OVERFLOW</code>: Maximum number of connections in pool overflow - <code>POOL_PRE_PING</code>: Whether to ping connections before use - <code>POOL_RECYCLE_SECONDS</code>: Seconds between connection recycling - <code>POOL_RESET_ON_RETURN</code>: Action when returning connections to pool - <code>POOL_SIZE</code>: Number of connections to keep open - <code>POOL_TIMEOUT</code>: Seconds to wait for a connection - <code>POOL_USE_LIFO</code>: Whether to use LIFO for connection pool - <code>PORT</code>: Database port - <code>QUERY_CACHE_SIZE</code>: Size of the query cache - <code>USERNAME</code>: Database username</p>"},{"location":"api_reference/configs/#sqlitesqlalchemyconfig","title":"SQLiteSQLAlchemyConfig","text":"<p>Class: <code>archipy.configs.config_template.SQLiteSQLAlchemyConfig</code></p> <p>Configures:</p> <ul> <li>SQLite-specific database settings</li> <li>In-memory database options</li> <li>SQLite isolation levels</li> </ul> <p>Attributes:</p> <ul> <li><code>DRIVER_NAME</code>: SQLite driver name</li> <li><code>DATABASE</code>: SQLite database path</li> <li><code>ISOLATION_LEVEL</code>: SQLite isolation level</li> <li><code>PORT</code>: Not used for SQLite</li> </ul>"},{"location":"api_reference/configs/#postgressqlalchemyconfig","title":"PostgresSQLAlchemyConfig","text":"<p>Class: <code>archipy.configs.config_template.PostgresSQLAlchemyConfig</code></p> <p>Configures:</p> <ul> <li>PostgreSQL-specific database settings</li> <li>Connection URL building</li> <li>DSN configuration</li> </ul> <p>Attributes:</p> <ul> <li><code>POSTGRES_DSN</code>: PostgreSQL connection URL</li> </ul>"},{"location":"api_reference/configs/#starrockssqlalchemyconfig","title":"StarrocksSQLAlchemyConfig","text":"<p>Class: <code>archipy.configs.config_template.StarrocksSQLAlchemyConfig</code></p> <p>Configures:</p> <ul> <li>Starrocks-specific database settings</li> <li>Catalog configuration</li> </ul> <p>Attributes:</p> <ul> <li><code>CATALOG</code>: Starrocks catalog name</li> </ul>"},{"location":"api_reference/configs/#redisconfig","title":"RedisConfig","text":"<p>Class: <code>archipy.configs.config_template.RedisConfig</code></p> <p>Configures:</p> <ul> <li>Connection settings</li> <li>Pool configuration</li> <li>SSL options</li> <li>Sentinel support</li> </ul> <p>Attributes:</p> <ul> <li><code>MASTER_HOST</code>: Redis master host</li> <li><code>SLAVE_HOST</code>: Redis slave host</li> <li><code>PORT</code>: Redis server port</li> <li><code>DATABASE</code>: Redis database number</li> <li><code>PASSWORD</code>: Redis password</li> <li><code>DECODE_RESPONSES</code>: Whether to decode responses</li> <li><code>VERSION</code>: Redis protocol version</li> <li><code>HEALTH_CHECK_INTERVAL</code>: Health check interval in seconds</li> </ul>"},{"location":"api_reference/configs/#emailconfig","title":"EmailConfig","text":"<p>Class: <code>archipy.configs.config_template.EmailConfig</code></p> <p>Configures:</p> <ul> <li>SMTP settings</li> <li>Authentication</li> <li>TLS options</li> <li>Default headers</li> </ul> <p>Attributes:</p> <ul> <li><code>SMTP_SERVER</code>: SMTP server host</li> <li><code>SMTP_PORT</code>: SMTP server port</li> <li><code>USERNAME</code>: SMTP username</li> <li><code>PASSWORD</code>: SMTP password</li> <li><code>POOL_SIZE</code>: Connection pool size</li> <li><code>CONNECTION_TIMEOUT</code>: Connection timeout in seconds</li> <li><code>MAX_RETRIES</code>: Maximum retry attempts</li> <li><code>ATTACHMENT_MAX_SIZE</code>: Maximum attachment size in bytes</li> </ul>"},{"location":"api_reference/configs/#fastapiconfig","title":"FastAPIConfig","text":"<p>Class: <code>archipy.configs.config_template.FastAPIConfig</code></p> <p>Configures:</p> <ul> <li>API versioning</li> <li>CORS configuration</li> <li>Rate limiting</li> <li>Documentation</li> </ul> <p>Attributes:</p> <ul> <li><code>PROJECT_NAME</code>: Name of the FastAPI project</li> <li><code>API_PREFIX</code>: URL prefix for API endpoints</li> <li><code>ACCESS_LOG</code>: Whether to enable access logging</li> <li><code>BACKLOG</code>: Maximum number of queued connections</li> <li><code>DATE_HEADER</code>: Whether to include date header in responses</li> <li><code>FORWARDED_ALLOW_IPS</code>: List of allowed forwarded IPs</li> <li><code>LIMIT_CONCURRENCY</code>: Maximum concurrent requests</li> <li><code>LIMIT_MAX_REQUESTS</code>: Maximum number of requests</li> <li><code>CORS_MIDDLEWARE_ALLOW_CREDENTIALS</code>: Whether to allow credentials in CORS</li> <li><code>CORS_MIDDLEWARE_ALLOW_HEADERS</code>: Allowed CORS headers</li> <li><code>CORS_MIDDLEWARE_ALLOW_METHODS</code>: Allowed CORS methods</li> <li><code>CORS_MIDDLEWARE_ALLOW_ORIGINS</code>: Allowed CORS origins</li> <li><code>PROXY_HEADERS</code>: Whether to trust proxy headers</li> <li><code>RELOAD</code>: Whether to enable auto-reload</li> <li><code>SERVER_HEADER</code>: Whether to include server header</li> <li><code>SERVE_HOST</code>: Host to serve the application on</li> <li><code>SERVE_PORT</code>: Port to serve the application on</li> <li><code>TIMEOUT_GRACEFUL_SHUTDOWN</code>: Graceful shutdown timeout</li> <li><code>TIMEOUT_KEEP_ALIVE</code>: Keep-alive timeout</li> <li><code>WORKERS_COUNT</code>: Number of worker processes</li> <li><code>WS_MAX_SIZE</code>: Maximum WebSocket message size</li> <li><code>WS_PER_MESSAGE_DEFLATE</code>: Whether to enable WebSocket compression</li> <li><code>WS_PING_INTERVAL</code>: WebSocket ping interval</li> <li><code>WS_PING_TIMEOUT</code>: WebSocket ping timeout</li> <li><code>OPENAPI_URL</code>: URL for OpenAPI schema</li> <li><code>DOCS_URL</code>: URL for API documentation</li> <li><code>RE_DOCS_URL</code>: URL for ReDoc documentation</li> <li><code>SWAGGER_UI_PARAMS</code>: Swagger UI parameters</li> </ul>"},{"location":"api_reference/configs/#grpcconfig","title":"GrpcConfig","text":"<p>Class: <code>archipy.configs.config_template.GrpcConfig</code></p> <p>Configures:</p> <ul> <li>Server settings</li> <li>Client configuration</li> <li>Interceptors</li> <li>SSL/TLS options</li> </ul> <p>Attributes:</p> <ul> <li><code>SERVE_PORT</code>: Port to serve gRPC on</li> <li><code>SERVE_HOST</code>: Host to serve gRPC on</li> <li><code>THREAD_WORKER_COUNT</code>: Number of worker threads</li> <li><code>THREAD_PER_CPU_CORE</code>: Threads per CPU core</li> <li><code>SERVER_OPTIONS_CONFIG_LIST</code>: Server configuration options</li> <li><code>STUB_OPTIONS_CONFIG_LIST</code>: Client stub configuration options</li> </ul>"},{"location":"api_reference/configs/#sentryconfig","title":"SentryConfig","text":"<p>Class: <code>archipy.configs.config_template.SentryConfig</code></p> <p>Configures:</p> <ul> <li>DSN configuration</li> <li>Environment settings</li> <li>Sample rates</li> <li>Performance monitoring</li> </ul> <p>Attributes:</p> <ul> <li><code>IS_ENABLED</code>: Whether Sentry is enabled</li> <li><code>DSN</code>: Sentry DSN for error reporting</li> <li><code>DEBUG</code>: Whether to enable debug mode</li> <li><code>RELEASE</code>: Application release version</li> <li><code>SAMPLE_RATE</code>: Error sampling rate (0.0 to 1.0)</li> <li><code>TRACES_SAMPLE_RATE</code>: Performance monitoring sampling rate (0.0 to 1.0)</li> </ul>"},{"location":"api_reference/configs/#elasticsearchconfig","title":"ElasticsearchConfig","text":"<p>Class: <code>archipy.configs.config_template.ElasticsearchConfig</code></p> <p>Configures:</p> <ul> <li>Cluster configuration</li> <li>Authentication</li> <li>Index settings</li> <li>Retry policies</li> </ul> <p>Attributes:</p> <ul> <li><code>SEARCH_HOSTS</code>: List of Elasticsearch server hosts</li> <li><code>SEARCH_HTTP_USER_NAME</code>: Username for HTTP authentication</li> <li><code>SEARCH_HTTP_PASSWORD</code>: Password for HTTP authentication</li> <li><code>SEARCH_HTTPS_VERIFY_CERTS</code>: Whether to verify SSL certificates</li> <li><code>SEARCH_KWARG</code>: Additional keyword arguments for Elasticsearch client</li> <li><code>SEARCH_BATCH_INTERVAL_THRESHOLD_IN_SECONDS</code>: Time threshold for batch operations</li> <li><code>SEARCH_BATCH_DOC_COUNT_THRESHOLD</code>: Document count threshold for batch operations</li> </ul>"},{"location":"api_reference/configs/#elasticsearchapmconfig","title":"ElasticsearchAPMConfig","text":"<p>Class: <code>archipy.configs.config_template.ElasticsearchAPMConfig</code></p> <p>Configures:</p> <ul> <li>APM server settings</li> <li>Service name</li> <li>Transaction sampling</li> <li>Instrumentation</li> </ul> <p>Attributes:</p> <ul> <li><code>API_REQUEST_SIZE</code>: Maximum size of API requests</li> <li><code>API_REQUEST_TIME</code>: Maximum time for API requests</li> <li><code>AUTO_LOG_STACKS</code>: Whether to automatically log stack traces</li> <li><code>CAPTURE_BODY</code>: Level of request body capture</li> <li><code>CAPTURE_HEADERS</code>: Whether to capture HTTP headers</li> <li><code>COLLECT_LOCAL_VARIABLES</code>: Level of local variable collection</li> <li><code>IS_ENABLED</code>: Whether APM is enabled</li> <li><code>ENVIRONMENT</code>: APM environment name</li> <li><code>LOG_FILE</code>: Path to APM log file</li> <li><code>LOG_FILE_SIZE</code>: Maximum size of APM log file</li> <li><code>RECORDING</code>: Whether to record transactions</li> <li><code>SECRET_TOKEN</code>: APM secret token</li> <li><code>SERVER_TIMEOUT</code>: Server timeout duration</li> <li><code>SERVER_URL</code>: APM server URL</li> <li><code>SERVICE_NAME</code>: Name of the service being monitored</li> <li><code>SERVICE_VERSION</code>: Version of the service</li> <li><code>TRANSACTION_SAMPLE_RATE</code>: Rate at which to sample transactions</li> <li><code>API_KEY</code>: API key for authentication</li> </ul>"},{"location":"api_reference/configs/#kafkaconfig","title":"KafkaConfig","text":"<p>Class: <code>archipy.configs.config_template.KafkaConfig</code></p> <p>Configures:</p> <ul> <li>Broker configuration</li> <li>Consumer groups</li> <li>Producer settings</li> <li>Security options</li> </ul> <p>Attributes:</p> <ul> <li><code>ACKNOWLEDGE_COUNT</code>: Number of acknowledgments required</li> <li><code>AUTO_OFFSET_RESET</code>: Action to take when there is no initial offset</li> <li><code>BROKERS_LIST</code>: List of Kafka broker addresses</li> <li><code>CERT_PEM</code>: Path to SSL certificate</li> <li><code>ENABLE_AUTO_COMMIT</code>: Whether to enable auto-commit</li> <li><code>MAX_BUFFER_MS</code>: Maximum time to buffer messages</li> <li><code>MAX_BUFFER_SIZE</code>: Maximum number of messages to buffer</li> <li><code>PASSWORD</code>: Password for authentication</li> <li><code>SASL_MECHANISMS</code>: SASL mechanism for authentication</li> <li><code>SECURITY_PROTOCOL</code>: Security protocol to use</li> <li><code>SESSION_TIMEOUT_MS</code>: Session timeout in milliseconds</li> <li><code>REQUEST_ACK_TIMEOUT_MS</code>: Request acknowledgment timeout</li> <li><code>DELIVERY_MESSAGE_TIMEOUT_MS</code>: Message delivery timeout</li> <li><code>USER_NAME</code>: Username for authentication</li> <li><code>LIST_TOPICS_TIMEOUT</code>: Timeout for listing topics</li> </ul>"},{"location":"api_reference/configs/#keycloakconfig","title":"KeycloakConfig","text":"<p>Class: <code>archipy.configs.config_template.KeycloakConfig</code></p> <p>Configures:</p> <ul> <li>Server connection</li> <li>Authentication settings</li> <li>SSL verification</li> <li>Timeout configuration</li> </ul> <p>Attributes:</p> <ul> <li><code>SERVER_URL</code>: URL of the Keycloak server</li> <li><code>CLIENT_ID</code>: Client ID for authentication</li> <li><code>REALM_NAME</code>: Name of the Keycloak realm</li> <li><code>CLIENT_SECRET_KEY</code>: Client secret key</li> <li><code>VERIFY_SSL</code>: Whether to verify SSL certificates</li> <li><code>TIMEOUT</code>: Request timeout in seconds</li> </ul>"},{"location":"api_reference/configs/#minioconfig","title":"MinioConfig","text":"<p>Class: <code>archipy.configs.config_template.MinioConfig</code></p> <p>Configures:</p> <ul> <li>Server connection</li> <li>Authentication</li> <li>Security settings</li> <li>Region configuration</li> </ul> <p>Attributes:</p> <ul> <li><code>ENDPOINT</code>: MinIO server endpoint</li> <li><code>ACCESS_KEY</code>: Access key for authentication</li> <li><code>SECRET_KEY</code>: Secret key for authentication</li> <li><code>SECURE</code>: Whether to use secure (HTTPS) connection</li> <li><code>SESSION_TOKEN</code>: Session token for temporary credentials</li> <li><code>REGION</code>: AWS region for S3 compatibility</li> </ul>"},{"location":"api_reference/configs/#prometheusconfig","title":"PrometheusConfig","text":"<p>Class: <code>archipy.configs.config_template.PrometheusConfig</code></p> <p>Configures:</p> <ul> <li>Metrics collection</li> <li>Server settings</li> <li>Endpoint configuration</li> </ul> <p>Attributes:</p> <ul> <li><code>IS_ENABLED</code>: Whether Prometheus metrics are enabled</li> <li><code>SERVER_PORT</code>: Port for the Prometheus metrics endpoint</li> </ul>"},{"location":"api_reference/configs/#kavenegarconfig","title":"KavenegarConfig","text":"<p>Class: <code>archipy.configs.config_template.KavenegarConfig</code></p> <p>Configures:</p> <ul> <li>API connection</li> <li>Authentication</li> <li>Default sender settings</li> </ul> <p>Attributes:</p> <ul> <li><code>SERVER_URL</code>: Kavenegar API server URL</li> <li><code>API_KEY</code>: Kavenegar API key</li> <li><code>PHONE_NUMBER</code>: Default sender phone number</li> </ul>"},{"location":"api_reference/configs/#authconfig","title":"AuthConfig","text":"<p>Class: <code>archipy.configs.config_template.AuthConfig</code></p> <p>Configures:</p> <ul> <li>JWT settings</li> <li>TOTP configuration</li> <li>Rate limiting</li> <li>Password policies</li> <li>Token security</li> </ul> <p>Attributes:</p> <ul> <li><code>SECRET_KEY</code>: JWT signing key</li> <li><code>ACCESS_TOKEN_EXPIRES_IN</code>: Access token expiration in seconds</li> <li><code>REFRESH_TOKEN_EXPIRES_IN</code>: Refresh token expiration in seconds</li> <li><code>HASH_ALGORITHM</code>: JWT signing algorithm</li> <li><code>JWT_ISSUER</code>: JWT issuer claim</li> <li><code>JWT_AUDIENCE</code>: JWT audience claim</li> <li><code>TOKEN_VERSION</code>: JWT token version</li> <li><code>TOTP_SECRET_KEY</code>: TOTP master key</li> <li><code>TOTP_HASH_ALGORITHM</code>: TOTP hash algorithm</li> <li><code>TOTP_LENGTH</code>: TOTP code length</li> <li><code>TOTP_EXPIRES_IN</code>: TOTP expiration in seconds</li> <li><code>TOTP_TIME_STEP</code>: TOTP time step in seconds</li> <li><code>TOTP_VERIFICATION_WINDOW</code>: TOTP verification window size</li> <li><code>TOTP_MAX_ATTEMPTS</code>: Maximum TOTP verification attempts</li> <li><code>TOTP_LOCKOUT_TIME</code>: TOTP lockout duration in seconds</li> <li><code>LOGIN_RATE_LIMIT</code>: Login attempts per minute</li> <li><code>TOTP_RATE_LIMIT</code>: TOTP requests per minute</li> <li><code>PASSWORD_RESET_RATE_LIMIT</code>: Password reset requests per hour</li> <li><code>HASH_ITERATIONS</code>: Password hash iterations</li> <li><code>MIN_LENGTH</code>: Minimum password length</li> <li><code>REQUIRE_DIGIT</code>: Whether password requires digits</li> <li><code>REQUIRE_LOWERCASE</code>: Whether password requires lowercase</li> <li><code>REQUIRE_SPECIAL</code>: Whether password requires special chars</li> <li><code>REQUIRE_UPPERCASE</code>: Whether password requires uppercase</li> <li><code>SALT_LENGTH</code>: Password salt length</li> <li><code>SPECIAL_CHARACTERS</code>: Allowed special characters</li> <li><code>PASSWORD_HISTORY_SIZE</code>: Number of previous passwords to remember</li> <li><code>ENABLE_JTI_CLAIM</code>: Whether to enable JWT ID claim</li> <li><code>ENABLE_TOKEN_ROTATION</code>: Whether to enable refresh token rotation</li> <li><code>REFRESH_TOKEN_REUSE_INTERVAL</code>: Refresh token reuse grace period</li> </ul>"},{"location":"api_reference/configs/#fileconfig","title":"FileConfig","text":"<p>Class: <code>archipy.configs.config_template.FileConfig</code></p> <p>Configures:</p> <ul> <li>File link security</li> <li>Expiration policies</li> <li>File type restrictions</li> </ul> <p>Attributes:</p> <ul> <li><code>SECRET_KEY</code>: Secret key for generating secure file links</li> <li><code>DEFAULT_EXPIRY_MINUTES</code>: Default link expiration time in minutes</li> <li><code>ALLOWED_EXTENSIONS</code>: List of allowed file extensions</li> </ul>"},{"location":"api_reference/configs/#datetimeconfig","title":"DatetimeConfig","text":"<p>Class: <code>archipy.configs.config_template.DatetimeConfig</code></p> <p>Configures:</p> <ul> <li>API connections</li> <li>Time service settings</li> <li>Caching behavior</li> </ul> <p>Attributes:</p> <ul> <li><code>TIME_IR_API_KEY</code>: API key for time.ir service</li> <li><code>TIME_IR_API_ENDPOINT</code>: Endpoint for time.ir service</li> <li><code>REQUEST_TIMEOUT</code>: Request timeout in seconds</li> <li><code>MAX_RETRIES</code>: Maximum retry attempts</li> <li><code>CACHE_TTL</code>: Cache time-to-live in seconds</li> <li><code>HISTORICAL_CACHE_TTL</code>: Cache time-to-live for historical dates in seconds</li> </ul>"},{"location":"api_reference/configs/#environmenttype","title":"EnvironmentType","text":"<p>Class: <code>archipy.configs.environment_type.EnvironmentType</code></p> <p>Configures:</p> <ul> <li>Environment types (DEV, STAGING, PROD)</li> <li>Environment-specific behaviors</li> <li>Configuration validation rules</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/helpers/","title":"Helpers","text":"<p>The <code>helpers</code> module provides utility functions, decorators, interceptors, and metaclasses to support common development tasks and patterns.</p>"},{"location":"api_reference/helpers/#overview","title":"Overview","text":"<p>The <code>helpers</code> module provides utility functions and classes to simplify common development tasks.</p>"},{"location":"api_reference/helpers/#installation","title":"Installation","text":"<p>This module is included in the base ArchiPy installation:</p> <pre><code># Add ArchiPy to your project\nuv add archipy\n</code></pre> <p>For development features:</p> <pre><code># Add ArchiPy with development extras\nuv add archipy[dev]\n</code></pre>"},{"location":"api_reference/helpers/#source-code","title":"Source Code","text":"<p>\ud83d\udcc1 Location: <code>archipy/helpers/</code></p> <p>\ud83d\udd17 Browse Source</p>"},{"location":"api_reference/helpers/#api-stability","title":"API Stability","text":"Component Status Notes Decorators \ud83d\udfe2 Stable Production-ready Utils \ud83d\udfe2 Stable Production-ready Interceptors \ud83d\udfe1 Beta API may change Metaclasses \ud83d\udfe2 Stable Production-ready"},{"location":"api_reference/helpers/#submodules","title":"Submodules","text":""},{"location":"api_reference/helpers/#utils","title":"Utils","text":"<p>See Utils Documentation for full documentation.</p> <p>General utility functions for common operations:</p> <ul> <li>String manipulation</li> <li>Date and time handling</li> <li>Error utilities</li> <li>File operations</li> <li>Password utilities</li> <li>JWT token handling</li> <li>TOTP generation</li> </ul>"},{"location":"api_reference/helpers/#decorators","title":"Decorators","text":"<p>See Decorators Documentation for full documentation.</p> <p>Function and class decorators for:</p> <ul> <li>Method deprecation</li> <li>Class deprecation</li> <li>Timing operations</li> <li>Retry logic</li> </ul>"},{"location":"api_reference/helpers/#interceptors","title":"Interceptors","text":"<p>See Interceptors Documentation for full documentation.</p> <p>Classes for cross-cutting concerns:</p> <ul> <li>Logging</li> <li>Performance monitoring</li> <li>Request/response tracking</li> </ul>"},{"location":"api_reference/helpers/#overview_1","title":"Overview","text":"<p>The helpers module offers utilities, decorators, and interceptors to enhance productivity and simplify common development tasks, such as retry logic, rate limiting, and tracing.</p> <p>See Examples: Examples Helpers</p>"},{"location":"api_reference/helpers/#decorators_1","title":"Decorators","text":"<p>Tip: See Examples Helpers Decorators for practical examples of decorators.</p>"},{"location":"api_reference/helpers/#retry-decorator","title":"Retry Decorator","text":"<p>The retry decorator provides a mechanism to automatically retry failed operations with configurable backoff strategies.</p> <pre><code>from archipy.helpers.decorators.retry import retry\n\n@retry(max_attempts=3, delay=1, backoff=2)\ndef risky_operation():\n    # Operation that might fail\n    result = some_unreliable_function()\n    return result\n\n# Will retry up to 3 times with exponential backoff\nresult = risky_operation()\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/helpers/#archipy.helpers.decorators.retry.retry_decorator","title":"<code>archipy.helpers.decorators.retry.retry_decorator(max_retries=3, delay=1, retry_on=None, ignore=None, resource_type=None)</code>","text":"<p>A decorator that retries a function when it raises an exception.</p> <p>Parameters:</p> Name Type Description Default <code>max_retries</code> <code>int</code> <p>The maximum number of retry attempts. Defaults to 3.</p> <code>3</code> <code>delay</code> <code>float</code> <p>The delay (in seconds) between retries. Defaults to 1.</p> <code>1</code> <code>retry_on</code> <code>Optional[Tuple[Type[Exception], ...]]</code> <p>A tuple of errors to retry on. If None, retries on all errors. Defaults to None.</p> <code>None</code> <code>ignore</code> <code>Optional[Tuple[Type[Exception], ...]]</code> <p>A tuple of errors to ignore (not retry on). If None, no errors are ignored. Defaults to None.</p> <code>None</code> <code>resource_type</code> <code>Optional[str]</code> <p>The type of resource being exhausted. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable[[F], F]</code> <p>The decorated function with retry logic.</p> Example <p>To use this decorator, apply it to a function:</p> <pre><code>@retry_decorator(max_retries=3, delay=1, retry_on=(ValueError,), ignore=(TypeError,), resource_type=\"API\")\ndef unreliable_function():\n    if random.random() &lt; 0.5:\n        raise ValueError(\"Temporary failure\")\n    return \"Success\"\n\nresult = unreliable_function()\n</code></pre> <p>Output: <pre><code>2023-10-10 12:00:00,000 - WARNING - Attempt 1 failed: Temporary failure\n2023-10-10 12:00:01,000 - INFO - Attempt 2 succeeded.\nSuccess\n</code></pre></p> Source code in <code>archipy/helpers/decorators/retry.py</code> <pre><code>def retry_decorator(\n    max_retries: int = 3,\n    delay: float = 1,\n    retry_on: tuple[type[Exception], ...] | None = None,\n    ignore: tuple[type[Exception], ...] | None = None,\n    resource_type: str | None = None,\n) -&gt; Callable[[F], F]:\n    \"\"\"A decorator that retries a function when it raises an exception.\n\n    Args:\n        max_retries (int): The maximum number of retry attempts. Defaults to 3.\n        delay (float): The delay (in seconds) between retries. Defaults to 1.\n        retry_on (Optional[Tuple[Type[Exception], ...]]): A tuple of errors to retry on.\n            If None, retries on all errors. Defaults to None.\n        ignore (Optional[Tuple[Type[Exception], ...]]): A tuple of errors to ignore (not retry on).\n            If None, no errors are ignored. Defaults to None.\n        resource_type (Optional[str]): The type of resource being exhausted. Defaults to None.\n\n    Returns:\n        Callable: The decorated function with retry logic.\n\n    Example:\n        To use this decorator, apply it to a function:\n\n        ```python\n        @retry_decorator(max_retries=3, delay=1, retry_on=(ValueError,), ignore=(TypeError,), resource_type=\"API\")\n        def unreliable_function():\n            if random.random() &lt; 0.5:\n                raise ValueError(\"Temporary failure\")\n            return \"Success\"\n\n        result = unreliable_function()\n        ```\n\n        Output:\n        ```\n        2023-10-10 12:00:00,000 - WARNING - Attempt 1 failed: Temporary failure\n        2023-10-10 12:00:01,000 - INFO - Attempt 2 succeeded.\n        Success\n        ```\n    \"\"\"\n\n    def decorator(func: F) -&gt; F:\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            retries = 0\n            while retries &lt; max_retries:\n                try:\n                    result = func(*args, **kwargs)\n                    if retries &gt; 0:\n                        logging.info(\"Attempt %d succeeded.\", retries + 1)\n                except Exception as e:\n                    retries += 1\n                    # Check if the exception should be ignored\n                    if ignore and isinstance(e, ignore):\n                        raise\n                    # Check if the exception should be retried\n                    if retry_on and not isinstance(e, retry_on):\n                        raise\n                    logging.warning(\"Attempt %d failed: %s\", retries, e)\n                    if retries &lt; max_retries:\n                        time.sleep(delay)\n                    continue\n                return result\n            raise ResourceExhaustedError(resource_type=resource_type)\n\n        return cast(F, wrapper)\n\n    return decorator\n</code></pre>"},{"location":"api_reference/helpers/#singleton-decorator","title":"Singleton Decorator","text":"<p>The singleton decorator ensures that a class has only one instance throughout the application lifecycle.</p> <pre><code>from archipy.helpers.decorators.singleton import singleton\n\n@singleton\nclass DatabaseConnection:\n    def __init__(self):\n        self.connection = create_connection()\n\n# Both instances will be the same\ndb1 = DatabaseConnection()\ndb2 = DatabaseConnection()\nassert db1 is db2\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/helpers/#archipy.helpers.decorators.singleton.singleton_decorator","title":"<code>archipy.helpers.decorators.singleton.singleton_decorator(*, thread_safe=True)</code>","text":"<p>A decorator to create thread-safe Singleton classes.</p> <p>This decorator ensures that only one instance of a class is created. It supports an optional <code>thread_safe</code> parameter to control whether thread-safety mechanisms (e.g., locks) should be used.</p> <p>Parameters:</p> Name Type Description Default <code>thread_safe</code> <code>bool</code> <p>If True, enables thread-safety for instance creation.                           Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>function</code> <code>Callable[[type[Any]], Callable[..., Any]]</code> <p>A decorator function that can be applied to a class.</p> Example <p>To create a Singleton class, apply the <code>singleton</code> decorator and optionally specify whether thread-safety should be enabled:</p> <pre><code>@singleton(thread_safe=True)\nclass MySingletonClass:\n    def __init__(self, value):\n        self.value = value\n\n# Create instances of MySingletonClass\ninstance1 = MySingletonClass(10)\ninstance2 = MySingletonClass(20)\n\n# Verify that both instances are the same\nprint(instance1.value)  # Output: 10\nprint(instance2.value)  # Output: 10\nprint(instance1 is instance2)  # Output: True\n</code></pre> Source code in <code>archipy/helpers/decorators/singleton.py</code> <pre><code>def singleton_decorator(*, thread_safe: bool = True) -&gt; Callable[[type[Any]], Callable[..., Any]]:\n    \"\"\"A decorator to create thread-safe Singleton classes.\n\n    This decorator ensures that only one instance of a class is created. It supports an optional\n    `thread_safe` parameter to control whether thread-safety mechanisms (e.g., locks) should be used.\n\n    Args:\n        thread_safe (bool, optional): If True, enables thread-safety for instance creation.\n                                      Defaults to True.\n\n    Returns:\n        function: A decorator function that can be applied to a class.\n\n    Example:\n        To create a Singleton class, apply the `singleton` decorator and optionally specify\n        whether thread-safety should be enabled:\n\n        ```python\n        @singleton(thread_safe=True)\n        class MySingletonClass:\n            def __init__(self, value):\n                self.value = value\n\n        # Create instances of MySingletonClass\n        instance1 = MySingletonClass(10)\n        instance2 = MySingletonClass(20)\n\n        # Verify that both instances are the same\n        print(instance1.value)  # Output: 10\n        print(instance2.value)  # Output: 10\n        print(instance1 is instance2)  # Output: True\n        ```\n    \"\"\"\n\n    def decorator(cls: type[Any]) -&gt; Callable[..., Any]:\n        \"\"\"The inner decorator function that implements the Singleton pattern.\n\n        Args:\n            cls: The class to be decorated as a Singleton.\n\n        Returns:\n            function: A function that returns the Singleton instance of the class.\n        \"\"\"\n        instances = {}  # Stores instances of Singleton classes\n        lock: threading.Lock | None = (\n            threading.Lock() if thread_safe else None\n        )  # Lock for thread-safe instance creation\n\n        def get_instance(*args: Any, **kwargs: Any) -&gt; Any:\n            \"\"\"Create or return the Singleton instance of the class.\n\n            If `thread_safe` is True, a lock is used to ensure that only one instance is created\n            even in a multi-threaded environment. If `thread_safe` is False, no locking mechanism\n            is used, which may result in multiple instances being created in a multi-threaded context.\n\n            Args:\n                *args: Positional arguments to pass to the class constructor.\n                **kwargs: Keyword arguments to pass to the class constructor.\n\n            Returns:\n                object: The Singleton instance of the class.\n            \"\"\"\n            if cls not in instances:\n                if thread_safe:\n                    if lock is not None:\n                        with lock:\n                            if cls not in instances:\n                                instances[cls] = cls(*args, **kwargs)\n                else:\n                    instances[cls] = cls(*args, **kwargs)\n            return instances[cls]\n\n        return get_instance\n\n    return decorator\n</code></pre>"},{"location":"api_reference/helpers/#sqlalchemy-atomic-decorator","title":"SQLAlchemy Atomic Decorator","text":"<p>The SQLAlchemy atomic decorator provides transaction management for database operations.</p> <pre><code>from archipy.helpers.decorators.sqlalchemy_atomic import sqlalchemy_atomic\n\n@sqlalchemy_atomic\ndef create_user(username: str, email: str):\n    user = User(username=username, email=email)\n    db.session.add(user)\n    # If any operation fails, the entire transaction is rolled back\n    db.session.commit()\n</code></pre> <p>SQLAlchemy atomic transaction decorators.</p> <p>This module provides decorators for managing SQLAlchemy transactions with automatic commit/rollback and support for different database types (PostgreSQL, SQLite, StarRocks).</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/helpers/#archipy.helpers.decorators.sqlalchemy_atomic.sqlalchemy_atomic_decorator","title":"<code>archipy.helpers.decorators.sqlalchemy_atomic.sqlalchemy_atomic_decorator(db_type, is_async=False, function=None)</code>","text":"<p>Factory for creating SQLAlchemy atomic transaction decorators.</p> <p>This decorator ensures that a function runs within a database transaction for the specified database type. If the function succeeds, the transaction is committed; otherwise, it is rolled back. Supports both synchronous and asynchronous functions.</p> <p>Parameters:</p> Name Type Description Default <code>db_type</code> <code>str</code> <p>The database type (\"postgres\", \"sqlite\", or \"starrocks\").</p> required <code>is_async</code> <code>bool</code> <p>Whether the function is asynchronous. Defaults to False.</p> <code>False</code> <code>function</code> <code>Callable | None</code> <p>The function to wrap. If None, returns a partial function.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[..., Any] | partial[Callable[..., Any]]</code> <p>Callable | partial: The wrapped function or a partial function for later use.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid db_type is provided.</p> <code>DatabaseSerializationError</code> <p>If a serialization failure is detected.</p> <code>DatabaseDeadlockError</code> <p>If an operational error occurs due to a deadlock.</p> <code>DatabaseTransactionError</code> <p>If a transaction-related error occurs.</p> <code>DatabaseQueryError</code> <p>If a query-related error occurs.</p> <code>DatabaseConnectionError</code> <p>If a connection-related error occurs.</p> <code>DatabaseConstraintError</code> <p>If a constraint violation is detected.</p> <code>DatabaseIntegrityError</code> <p>If an integrity violation is detected.</p> <code>DatabaseTimeoutError</code> <p>If a database operation times out.</p> <code>DatabaseConfigurationError</code> <p>If there's an error in the database configuration.</p> Example Source code in <code>archipy/helpers/decorators/sqlalchemy_atomic.py</code> <pre><code>def sqlalchemy_atomic_decorator(\n    db_type: str,\n    is_async: bool = False,\n    function: Callable[..., Any] | None = None,\n) -&gt; Callable[..., Any] | partial[Callable[..., Any]]:\n    \"\"\"Factory for creating SQLAlchemy atomic transaction decorators.\n\n    This decorator ensures that a function runs within a database transaction for the specified\n    database type. If the function succeeds, the transaction is committed; otherwise, it is rolled back.\n    Supports both synchronous and asynchronous functions.\n\n    Args:\n        db_type (str): The database type (\"postgres\", \"sqlite\", or \"starrocks\").\n        is_async (bool): Whether the function is asynchronous. Defaults to False.\n        function (Callable | None): The function to wrap. If None, returns a partial function.\n\n    Returns:\n        Callable | partial: The wrapped function or a partial function for later use.\n\n    Raises:\n        ValueError: If an invalid db_type is provided.\n        DatabaseSerializationError: If a serialization failure is detected.\n        DatabaseDeadlockError: If an operational error occurs due to a deadlock.\n        DatabaseTransactionError: If a transaction-related error occurs.\n        DatabaseQueryError: If a query-related error occurs.\n        DatabaseConnectionError: If a connection-related error occurs.\n        DatabaseConstraintError: If a constraint violation is detected.\n        DatabaseIntegrityError: If an integrity violation is detected.\n        DatabaseTimeoutError: If a database operation times out.\n        DatabaseConfigurationError: If there's an error in the database configuration.\n\n    Example:\n        # Synchronous PostgreSQL example\n        @sqlalchemy_atomic_decorator(db_type=\"postgres\")\n        def update_user(id: int, name: str) -&gt; None:\n            # Database operations\n            pass\n\n        # Asynchronous SQLite example\n        @sqlalchemy_atomic_decorator(db_type=\"sqlite\", is_async=True)\n        async def update_record(id: int, data: str) -&gt; None:\n            # Async database operations\n            pass\n    \"\"\"\n    if db_type not in ATOMIC_BLOCK_CONFIGS:\n        raise ValueError(f\"Invalid db_type: {db_type}. Must be one of {list(ATOMIC_BLOCK_CONFIGS.keys())}\")\n\n    atomic_flag = ATOMIC_BLOCK_CONFIGS[db_type][\"flag\"]\n\n    # Dynamically import the registry class\n    def get_registry() -&gt; type[SessionManagerRegistry]:\n        \"\"\"Get the session manager registry for the specified database type.\n\n        Returns:\n            type[SessionManagerRegistry]: The session manager registry class.\n\n        Raises:\n            DatabaseConfigurationError: If the registry cannot be loaded.\n        \"\"\"\n        try:\n            import importlib\n\n            module_path, class_name = ATOMIC_BLOCK_CONFIGS[db_type][\"registry\"].rsplit(\".\", 1)\n            module = importlib.import_module(module_path)\n            return cast(type[SessionManagerRegistry], getattr(module, class_name))\n        except (ImportError, AttributeError) as e:\n            raise DatabaseConfigurationError(\n                database=db_type,\n                additional_data={\"registry_path\": ATOMIC_BLOCK_CONFIGS[db_type][\"registry\"]},\n            ) from e\n\n    def decorator(func: Callable[..., R]) -&gt; Callable[..., R]:\n        \"\"\"Create a transaction-aware wrapper for the given function.\n\n        Args:\n            func (Callable[..., R]): The function to wrap with transaction management.\n\n        Returns:\n            Callable[..., R]: The wrapped function that manages transactions.\n        \"\"\"\n        if is_async:\n\n            @wraps(func)\n            async def async_wrapper(*args: Any, **kwargs: Any) -&gt; R:\n                \"\"\"Async wrapper for managing database transactions.\n\n                Args:\n                    *args: Positional arguments to pass to the wrapped function.\n                    **kwargs: Keyword arguments to pass to the wrapped function.\n\n                Returns:\n                    R: The result of the wrapped function.\n\n                Raises:\n                    DatabaseSerializationError: If a serialization failure is detected.\n                    DatabaseDeadlockError: If an operational error occurs due to a deadlock.\n                    DatabaseTransactionError: If a transaction-related error occurs.\n                    DatabaseQueryError: If a query-related error occurs.\n                    DatabaseConnectionError: If a connection-related error occurs.\n                    DatabaseConstraintError: If a constraint violation is detected.\n                    DatabaseIntegrityError: If an integrity violation is detected.\n                    DatabaseTimeoutError: If a database operation times out.\n                \"\"\"\n                registry = get_registry()\n                session_manager: AsyncSessionManagerPort = registry.get_async_manager()\n                session = session_manager.get_session()\n                is_nested = session.info.get(atomic_flag, False)\n                if not is_nested:\n                    session.info[atomic_flag] = True\n\n                try:\n                    if session.in_transaction():\n                        result = await func(*args, **kwargs)\n                        if not is_nested:\n                            await session.commit()\n                        return result\n                    else:\n                        async with session.begin():\n                            return await func(*args, **kwargs)\n                except Exception as exception:\n                    await session.rollback()\n                    _handle_db_exception(exception, db_type, func.__name__)\n                finally:\n                    if not session.in_transaction():\n                        await session.close()\n                        await session_manager.remove_session()\n\n            return async_wrapper\n        else:\n\n            @wraps(func)\n            def sync_wrapper(*args: Any, **kwargs: Any) -&gt; R:\n                \"\"\"Synchronous wrapper for managing database transactions.\n\n                Args:\n                    *args: Positional arguments to pass to the wrapped function.\n                    **kwargs: Keyword arguments to pass to the wrapped function.\n\n                Returns:\n                    R: The result of the wrapped function.\n\n                Raises:\n                    DatabaseSerializationError: If a serialization failure is detected.\n                    DatabaseDeadlockError: If an operational error occurs due to a deadlock.\n                    DatabaseTransactionError: If a transaction-related error occurs.\n                    DatabaseQueryError: If a query-related error occurs.\n                    DatabaseConnectionError: If a connection-related error occurs.\n                    DatabaseConstraintError: If a constraint violation is detected.\n                    DatabaseIntegrityError: If an integrity violation is detected.\n                    DatabaseTimeoutError: If a database operation times out.\n                \"\"\"\n                registry = get_registry()\n                session_manager: SessionManagerPort = registry.get_sync_manager()\n                session = session_manager.get_session()\n                is_nested = session.info.get(atomic_flag, False)\n                if not is_nested:\n                    session.info[atomic_flag] = True\n\n                try:\n                    if session.in_transaction():\n                        result = func(*args, **kwargs)\n                        if not is_nested:\n                            session.commit()\n                        return result\n                    else:\n                        with session.begin():\n                            return func(*args, **kwargs)\n                except Exception as exception:\n                    session.rollback()\n                    _handle_db_exception(exception, db_type, func.__name__)\n                finally:\n                    if not session.in_transaction():\n                        session.close()\n                        session_manager.remove_session()\n\n            return sync_wrapper\n\n    return decorator(function) if function else partial(sqlalchemy_atomic_decorator, db_type=db_type, is_async=is_async)\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.decorators.sqlalchemy_atomic.sqlalchemy_atomic_decorator--synchronous-postgresql-example","title":"Synchronous PostgreSQL example","text":"<p>@sqlalchemy_atomic_decorator(db_type=\"postgres\") def update_user(id: int, name: str) -&gt; None:     # Database operations     pass</p>"},{"location":"api_reference/helpers/#archipy.helpers.decorators.sqlalchemy_atomic.sqlalchemy_atomic_decorator--asynchronous-sqlite-example","title":"Asynchronous SQLite example","text":"<p>@sqlalchemy_atomic_decorator(db_type=\"sqlite\", is_async=True) async def update_record(id: int, data: str) -&gt; None:     # Async database operations     pass</p>"},{"location":"api_reference/helpers/#archipy.helpers.decorators.sqlalchemy_atomic.postgres_sqlalchemy_atomic_decorator","title":"<code>archipy.helpers.decorators.sqlalchemy_atomic.postgres_sqlalchemy_atomic_decorator(function=None)</code>","text":"<p>Decorator for PostgreSQL atomic transactions.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable | None</code> <p>The function to wrap. If None, returns a partial function.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[..., Any] | partial</code> <p>Callable | partial: The wrapped function or a partial function for later use.</p> Source code in <code>archipy/helpers/decorators/sqlalchemy_atomic.py</code> <pre><code>def postgres_sqlalchemy_atomic_decorator(function: Callable[..., Any] | None = None) -&gt; Callable[..., Any] | partial:\n    \"\"\"Decorator for PostgreSQL atomic transactions.\n\n    Args:\n        function (Callable | None): The function to wrap. If None, returns a partial function.\n\n    Returns:\n        Callable | partial: The wrapped function or a partial function for later use.\n    \"\"\"\n    return sqlalchemy_atomic_decorator(db_type=\"postgres\", function=function)\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.decorators.sqlalchemy_atomic.async_postgres_sqlalchemy_atomic_decorator","title":"<code>archipy.helpers.decorators.sqlalchemy_atomic.async_postgres_sqlalchemy_atomic_decorator(function=None)</code>","text":"<p>Decorator for asynchronous PostgreSQL atomic transactions.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable | None</code> <p>The function to wrap. If None, returns a partial function.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[..., Any] | partial</code> <p>Callable | partial: The wrapped function or a partial function for later use.</p> Source code in <code>archipy/helpers/decorators/sqlalchemy_atomic.py</code> <pre><code>def async_postgres_sqlalchemy_atomic_decorator(\n    function: Callable[..., Any] | None = None,\n) -&gt; Callable[..., Any] | partial:\n    \"\"\"Decorator for asynchronous PostgreSQL atomic transactions.\n\n    Args:\n        function (Callable | None): The function to wrap. If None, returns a partial function.\n\n    Returns:\n        Callable | partial: The wrapped function or a partial function for later use.\n    \"\"\"\n    return sqlalchemy_atomic_decorator(db_type=\"postgres\", is_async=True, function=function)\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.decorators.sqlalchemy_atomic.sqlite_sqlalchemy_atomic_decorator","title":"<code>archipy.helpers.decorators.sqlalchemy_atomic.sqlite_sqlalchemy_atomic_decorator(function=None)</code>","text":"<p>Decorator for SQLite atomic transactions.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable | None</code> <p>The function to wrap. If None, returns a partial function.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[..., Any] | partial</code> <p>Callable | partial: The wrapped function or a partial function for later use.</p> Source code in <code>archipy/helpers/decorators/sqlalchemy_atomic.py</code> <pre><code>def sqlite_sqlalchemy_atomic_decorator(function: Callable[..., Any] | None = None) -&gt; Callable[..., Any] | partial:\n    \"\"\"Decorator for SQLite atomic transactions.\n\n    Args:\n        function (Callable | None): The function to wrap. If None, returns a partial function.\n\n    Returns:\n        Callable | partial: The wrapped function or a partial function for later use.\n    \"\"\"\n    return sqlalchemy_atomic_decorator(db_type=\"sqlite\", function=function)\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.decorators.sqlalchemy_atomic.async_sqlite_sqlalchemy_atomic_decorator","title":"<code>archipy.helpers.decorators.sqlalchemy_atomic.async_sqlite_sqlalchemy_atomic_decorator(function=None)</code>","text":"<p>Decorator for asynchronous SQLite atomic transactions.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable | None</code> <p>The function to wrap. If None, returns a partial function.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[..., Any] | partial</code> <p>Callable | partial: The wrapped function or a partial function for later use.</p> Source code in <code>archipy/helpers/decorators/sqlalchemy_atomic.py</code> <pre><code>def async_sqlite_sqlalchemy_atomic_decorator(\n    function: Callable[..., Any] | None = None,\n) -&gt; Callable[..., Any] | partial:\n    \"\"\"Decorator for asynchronous SQLite atomic transactions.\n\n    Args:\n        function (Callable | None): The function to wrap. If None, returns a partial function.\n\n    Returns:\n        Callable | partial: The wrapped function or a partial function for later use.\n    \"\"\"\n    return sqlalchemy_atomic_decorator(db_type=\"sqlite\", is_async=True, function=function)\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.decorators.sqlalchemy_atomic.starrocks_sqlalchemy_atomic_decorator","title":"<code>archipy.helpers.decorators.sqlalchemy_atomic.starrocks_sqlalchemy_atomic_decorator(function=None)</code>","text":"<p>Decorator for StarRocks atomic transactions.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable | None</code> <p>The function to wrap. If None, returns a partial function.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[..., Any] | partial</code> <p>Callable | partial: The wrapped function or a partial function for later use.</p> Source code in <code>archipy/helpers/decorators/sqlalchemy_atomic.py</code> <pre><code>def starrocks_sqlalchemy_atomic_decorator(\n    function: Callable[..., Any] | None = None,\n) -&gt; Callable[..., Any] | partial:\n    \"\"\"Decorator for StarRocks atomic transactions.\n\n    Args:\n        function (Callable | None): The function to wrap. If None, returns a partial function.\n\n    Returns:\n        Callable | partial: The wrapped function or a partial function for later use.\n    \"\"\"\n    return sqlalchemy_atomic_decorator(db_type=\"starrocks\", function=function)\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.decorators.sqlalchemy_atomic.async_starrocks_sqlalchemy_atomic_decorator","title":"<code>archipy.helpers.decorators.sqlalchemy_atomic.async_starrocks_sqlalchemy_atomic_decorator(function=None)</code>","text":"<p>Decorator for asynchronous StarRocks atomic transactions.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable | None</code> <p>The function to wrap. If None, returns a partial function.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[..., Any] | partial</code> <p>Callable | partial: The wrapped function or a partial function for later use.</p> Source code in <code>archipy/helpers/decorators/sqlalchemy_atomic.py</code> <pre><code>def async_starrocks_sqlalchemy_atomic_decorator(\n    function: Callable[..., Any] | None = None,\n) -&gt; Callable[..., Any] | partial:\n    \"\"\"Decorator for asynchronous StarRocks atomic transactions.\n\n    Args:\n        function (Callable | None): The function to wrap. If None, returns a partial function.\n\n    Returns:\n        Callable | partial: The wrapped function or a partial function for later use.\n    \"\"\"\n    return sqlalchemy_atomic_decorator(db_type=\"starrocks\", is_async=True, function=function)\n</code></pre>"},{"location":"api_reference/helpers/#interceptors_1","title":"Interceptors","text":""},{"location":"api_reference/helpers/#fastapi-interceptors","title":"FastAPI Interceptors","text":""},{"location":"api_reference/helpers/#fastapi-rest-rate-limit-handler","title":"FastAPI Rest Rate Limit Handler","text":"<p>Provides rate limiting functionality for FastAPI endpoints.</p> <pre><code>from archipy.helpers.interceptors.fastapi.rate_limit import FastAPIRestRateLimitHandler\nfrom fastapi import FastAPI\n\napp = FastAPI()\nrate_limit_handler = FastAPIRestRateLimitHandler(\n    redis_client=redis_client,\n    rate_limit=100,  # requests per minute\n    rate_limit_period=60\n)\n\n@app.get(\"/api/data\")\n@rate_limit_handler\nasync def get_data():\n    return {\"data\": \"protected by rate limit\"}\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.fastapi.rate_limit.fastapi_rest_rate_limit_handler.FastAPIRestRateLimitHandler","title":"<code>archipy.helpers.interceptors.fastapi.rate_limit.fastapi_rest_rate_limit_handler.FastAPIRestRateLimitHandler</code>","text":"<p>A rate-limiting handler for FastAPI REST endpoints using Redis for tracking.</p> <p>This class provides rate-limiting functionality by tracking the number of requests made to a specific endpoint within a defined time window. If the request limit is exceeded, it raises an HTTP 429 Too Many Requests error.</p> <p>Parameters:</p> Name Type Description Default <code>calls_count</code> <code>StrictInt</code> <p>The maximum number of allowed requests within the time window.</p> <code>1</code> <code>milliseconds</code> <code>StrictInt</code> <p>The time window in milliseconds.</p> <code>0</code> <code>seconds</code> <code>StrictInt</code> <p>The time window in seconds.</p> <code>0</code> <code>minutes</code> <code>StrictInt</code> <p>The time window in minutes.</p> <code>0</code> <code>hours</code> <code>StrictInt</code> <p>The time window in hours.</p> <code>0</code> <code>days</code> <code>StrictInt</code> <p>The time window in days.</p> <code>0</code> <code>query_params</code> <code>set(StrictStr</code> <p>request query parameters for rate-limiting based on query params.</p> <code>None</code> Source code in <code>archipy/helpers/interceptors/fastapi/rate_limit/fastapi_rest_rate_limit_handler.py</code> <pre><code>class FastAPIRestRateLimitHandler:\n    \"\"\"A rate-limiting handler for FastAPI REST endpoints using Redis for tracking.\n\n    This class provides rate-limiting functionality by tracking the number of requests\n    made to a specific endpoint within a defined time window. If the request limit is\n    exceeded, it raises an HTTP 429 Too Many Requests error.\n\n    Args:\n        calls_count (StrictInt): The maximum number of allowed requests within the time window.\n        milliseconds (StrictInt): The time window in milliseconds.\n        seconds (StrictInt): The time window in seconds.\n        minutes (StrictInt): The time window in minutes.\n        hours (StrictInt): The time window in hours.\n        days (StrictInt): The time window in days.\n        query_params (set(StrictStr)): request query parameters for rate-limiting based on query params.\n    \"\"\"\n\n    def __init__(\n        self,\n        calls_count: StrictInt = 1,\n        milliseconds: StrictInt = 0,\n        seconds: StrictInt = 0,\n        minutes: StrictInt = 0,\n        hours: StrictInt = 0,\n        days: StrictInt = 0,\n        query_params: set[StrictStr] | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the rate limit handler with specified time window and request limits.\n\n        The time window is calculated by combining all time unit parameters into milliseconds.\n        At least one time unit parameter should be greater than 0 to create a valid window.\n\n        Args:\n            calls_count (StrictInt, optional): Maximum number of allowed requests within the time window.\n                Defaults to 1.\n            milliseconds (StrictInt, optional): Number of milliseconds in the time window.\n                Defaults to 0.\n            seconds (StrictInt, optional): Number of seconds in the time window.\n                Defaults to 0.\n            minutes (StrictInt, optional): Number of minutes in the time window.\n                Defaults to 0.\n            hours (StrictInt, optional): Number of hours in the time window.\n                Defaults to 0.\n            days (StrictInt, optional): Number of days in the time window.\n                Defaults to 0.\n            query_params (set[StrictStr] | None, optional): Set of query parameter names to include\n                in rate limit key generation. If None, no query parameters will be used.\n                Defaults to None.\n\n        Example:\n            &gt;&gt;&gt; # Allow 100 requests per minute\n            &gt;&gt;&gt; handler = FastAPIRestRateLimitHandler(calls_count=100, minutes=1)\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Allow 1000 requests per day with specific query params\n            &gt;&gt;&gt; handler = FastAPIRestRateLimitHandler(\n            ...     calls_count=1000,\n            ...     days=1,\n            ...     query_params={'user_id', 'action'}\n            ... )\n        \"\"\"\n        self.query_params = query_params or set()\n        self.calls_count = calls_count\n        # Calculate total time in milliseconds directly for better readability\n        self.milliseconds = (\n            milliseconds + 1000 * seconds + 60 * 1000 * minutes + 60 * 60 * 1000 * hours + 24 * 60 * 60 * 1000 * days\n        )\n        self.redis_client = AsyncRedisAdapter()\n\n    async def _check(self, key: str) -&gt; RedisResponseType:\n        \"\"\"Checks if the request count for the given key exceeds the allowed limit.\n\n        Args:\n            key (str): The Redis key used to track the request count.\n\n        Returns:\n            int: The remaining time-to-live (TTL) in milliseconds if the limit is exceeded, otherwise 0.\n        \"\"\"\n        # Use await for getting value from Redis as it's asynchronous\n        current_request = await self.redis_client.get(key)\n        if current_request is None:\n            await self.redis_client.set(key, 1, px=self.milliseconds)\n            return 0\n\n        current_request = int(current_request)  # type:ignore[arg-type]\n        if current_request &lt; self.calls_count:\n            await self.redis_client.incrby(key)\n            return 0\n\n        ttl = await self.redis_client.pttl(key)\n        if ttl == -1:\n            await self.redis_client.delete(key)\n        return ttl\n\n    async def __call__(self, request: Request) -&gt; None:\n        \"\"\"Handles the rate-limiting logic for incoming requests.\n\n        Args:\n            request (Request): The incoming FastAPI request.\n\n        Raises:\n            HTTPException: If the rate limit is exceeded, an HTTP 429 Too Many Requests error is raised.\n        \"\"\"\n        rate_key = await self._get_identifier(request)\n        key = f\"RateLimitHandler:{rate_key}:{request.scope['path']}:{request.method}\"\n        pexpire = await self._check(key)  # Awaiting the function since it is an async call\n        if pexpire != 0:\n            await self._create_callback(pexpire)  # type:ignore[arg-type]\n\n    @staticmethod\n    async def _create_callback(pexpire: int) -&gt; None:\n        \"\"\"Raises an HTTP 429 Too Many Requests error with the appropriate headers.\n\n        Args:\n            pexpire (int): The remaining time-to-live (TTL) in milliseconds before the rate limit resets.\n\n        Raises:\n            HTTPException: An HTTP 429 Too Many Requests error with the `Retry-After` header.\n        \"\"\"\n        expire = ceil(pexpire / 1000)\n        raise HTTPException(\n            status_code=HTTP_429_TOO_MANY_REQUESTS,\n            detail=\"Too Many Requests\",\n            headers={\"Retry-After\": str(expire)},\n        )\n\n    async def _get_identifier(self, request: Request) -&gt; str:\n        \"\"\"Extracts a unique identifier from the request, typically an IP address and endpoint.\n\n        Args:\n            request (Request): The FastAPI request object containing headers and client info.\n\n        Returns:\n            str: A Redis key generated using the extracted identifier and request information.\n\n        Note:\n            - Validates IP addresses for proper formatting\n            - Handles forwarded IPs with comma-separated values\n            - Filters out private, loopback, link-local, and multicast IPs in X-Forwarded-For\n            - Falls back to client.host if no valid IP is found\n        \"\"\"\n        base_identifier = await self._extract_client_ip(request)\n        return self._generate_redis_key(request=request, base_identifier=base_identifier)\n\n    async def _extract_client_ip(self, request: Request) -&gt; str:\n        \"\"\"Extracts and validates client IP from request headers.\n\n        Args:\n            request (Request): The FastAPI request object.\n\n        Returns:\n            str: Validated IP address or client host.\n        \"\"\"\n        try:\n            # Check X-Real-IP header first\n            if real_ip := self._validate_ip_from_header(request.headers.get(\"X-Real-IP\")):\n                return real_ip\n\n            # Then check X-Forwarded-For header\n            if forwarded_for := self._validate_forwarded_for_header(request.headers.get(\"X-Forwarded-For\")):\n                return forwarded_for\n            # Fallback to client host\n        except ValueError:\n            return request.client.host  # type:ignore[union-attr]\n        else:\n            return request.client.host  # type:ignore[union-attr]\n\n    def _validate_ip_from_header(self, header_value: str | None) -&gt; str | None:\n        \"\"\"Validates IP address from header value.\n\n        Args:\n            header_value (Optional[str]): IP address from header.\n\n        Returns:\n            Optional[str]: First valid IP address or None.\n        \"\"\"\n        if not header_value:\n            return None\n        try:\n            ip_str = header_value.split(\",\")[0].strip()\n            ip = ip_address(ip_str)  # Validate IP format\n            if not (ip.is_private or ip.is_loopback or ip.is_link_local or ip.is_multicast):\n                return ip_str\n        except ValueError:\n            return None\n        else:\n            return None\n\n    def _validate_forwarded_for_header(self, forwarded_for: str | None) -&gt; str | None:\n        \"\"\"Validates IP from X-Forwarded-For header.\n\n        Args:\n            forwarded_for (Optional[str]): X-Forwarded-For header value.\n\n        Returns:\n            Optional[str]: Valid non-private IP, the header or None.\n        \"\"\"\n        if not forwarded_for:\n            return None\n\n        try:\n            ip_str = forwarded_for.split(\",\")[0].strip()\n            ip = ip_address(ip_str)\n\n            if not (ip.is_private or ip.is_loopback or ip.is_link_local or ip.is_multicast):\n                return ip_str\n\n        except ValueError:\n            pass\n        return forwarded_for\n\n    def _generate_redis_key(self, request: Request, base_identifier: str) -&gt; str:\n        \"\"\"Generates a Redis key for rate limiting based on the request and base identifier.\n\n        Args:\n            request (Request): The FastAPI request object containing path and query parameters.\n            base_identifier (str): The base identifier (typically an IP address) for the request.\n\n        Returns:\n            str: A Redis key string with optional query parameters.\n        \"\"\"\n        path_key = f\"{base_identifier}:{request.scope['path']}\"\n\n        if not self.query_params:\n            return path_key\n\n        return self._append_query_params(path_key, request.query_params)\n\n    def _append_query_params(self, base_key: str, query_params: QueryParams) -&gt; str:\n        \"\"\"Appends sorted query parameters to the Redis key.\n\n        Args:\n            base_key (str): Base Redis key without query parameters.\n            query_params (dict[str, str]): Request query parameters.\n\n        Returns:\n            str: Redis key with appended query parameters.\n        \"\"\"\n        filtered_params = {k: v for k, v in query_params.items() if k in self.query_params and v is not None}\n\n        if not filtered_params:\n            return base_key\n\n        sorted_params = sorted(filtered_params.items())\n        query_string = \"&amp;\".join(f\"{k}={v}\" for k, v in sorted_params)\n        return f\"{base_key}?{query_string}\"\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.fastapi.rate_limit.fastapi_rest_rate_limit_handler.FastAPIRestRateLimitHandler.__init__","title":"<code>archipy.helpers.interceptors.fastapi.rate_limit.fastapi_rest_rate_limit_handler.FastAPIRestRateLimitHandler.__init__(calls_count=1, milliseconds=0, seconds=0, minutes=0, hours=0, days=0, query_params=None)</code>","text":"<p>Initialize the rate limit handler with specified time window and request limits.</p> <p>The time window is calculated by combining all time unit parameters into milliseconds. At least one time unit parameter should be greater than 0 to create a valid window.</p> <p>Parameters:</p> Name Type Description Default <code>calls_count</code> <code>StrictInt</code> <p>Maximum number of allowed requests within the time window. Defaults to 1.</p> <code>1</code> <code>milliseconds</code> <code>StrictInt</code> <p>Number of milliseconds in the time window. Defaults to 0.</p> <code>0</code> <code>seconds</code> <code>StrictInt</code> <p>Number of seconds in the time window. Defaults to 0.</p> <code>0</code> <code>minutes</code> <code>StrictInt</code> <p>Number of minutes in the time window. Defaults to 0.</p> <code>0</code> <code>hours</code> <code>StrictInt</code> <p>Number of hours in the time window. Defaults to 0.</p> <code>0</code> <code>days</code> <code>StrictInt</code> <p>Number of days in the time window. Defaults to 0.</p> <code>0</code> <code>query_params</code> <code>set[StrictStr] | None</code> <p>Set of query parameter names to include in rate limit key generation. If None, no query parameters will be used. Defaults to None.</p> <code>None</code> Example Source code in <code>archipy/helpers/interceptors/fastapi/rate_limit/fastapi_rest_rate_limit_handler.py</code> <pre><code>def __init__(\n    self,\n    calls_count: StrictInt = 1,\n    milliseconds: StrictInt = 0,\n    seconds: StrictInt = 0,\n    minutes: StrictInt = 0,\n    hours: StrictInt = 0,\n    days: StrictInt = 0,\n    query_params: set[StrictStr] | None = None,\n) -&gt; None:\n    \"\"\"Initialize the rate limit handler with specified time window and request limits.\n\n    The time window is calculated by combining all time unit parameters into milliseconds.\n    At least one time unit parameter should be greater than 0 to create a valid window.\n\n    Args:\n        calls_count (StrictInt, optional): Maximum number of allowed requests within the time window.\n            Defaults to 1.\n        milliseconds (StrictInt, optional): Number of milliseconds in the time window.\n            Defaults to 0.\n        seconds (StrictInt, optional): Number of seconds in the time window.\n            Defaults to 0.\n        minutes (StrictInt, optional): Number of minutes in the time window.\n            Defaults to 0.\n        hours (StrictInt, optional): Number of hours in the time window.\n            Defaults to 0.\n        days (StrictInt, optional): Number of days in the time window.\n            Defaults to 0.\n        query_params (set[StrictStr] | None, optional): Set of query parameter names to include\n            in rate limit key generation. If None, no query parameters will be used.\n            Defaults to None.\n\n    Example:\n        &gt;&gt;&gt; # Allow 100 requests per minute\n        &gt;&gt;&gt; handler = FastAPIRestRateLimitHandler(calls_count=100, minutes=1)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Allow 1000 requests per day with specific query params\n        &gt;&gt;&gt; handler = FastAPIRestRateLimitHandler(\n        ...     calls_count=1000,\n        ...     days=1,\n        ...     query_params={'user_id', 'action'}\n        ... )\n    \"\"\"\n    self.query_params = query_params or set()\n    self.calls_count = calls_count\n    # Calculate total time in milliseconds directly for better readability\n    self.milliseconds = (\n        milliseconds + 1000 * seconds + 60 * 1000 * minutes + 60 * 60 * 1000 * hours + 24 * 60 * 60 * 1000 * days\n    )\n    self.redis_client = AsyncRedisAdapter()\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.fastapi.rate_limit.fastapi_rest_rate_limit_handler.FastAPIRestRateLimitHandler.__init__--allow-100-requests-per-minute","title":"Allow 100 requests per minute","text":"<p>handler = FastAPIRestRateLimitHandler(calls_count=100, minutes=1)</p>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.fastapi.rate_limit.fastapi_rest_rate_limit_handler.FastAPIRestRateLimitHandler.__init__--allow-1000-requests-per-day-with-specific-query-params","title":"Allow 1000 requests per day with specific query params","text":"<p>handler = FastAPIRestRateLimitHandler( ...     calls_count=1000, ...     days=1, ...     query_params={'user_id', 'action'} ... )</p>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.fastapi.rate_limit.fastapi_rest_rate_limit_handler.FastAPIRestRateLimitHandler.__call__","title":"<code>archipy.helpers.interceptors.fastapi.rate_limit.fastapi_rest_rate_limit_handler.FastAPIRestRateLimitHandler.__call__(request)</code>  <code>async</code>","text":"<p>Handles the rate-limiting logic for incoming requests.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming FastAPI request.</p> required <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the rate limit is exceeded, an HTTP 429 Too Many Requests error is raised.</p> Source code in <code>archipy/helpers/interceptors/fastapi/rate_limit/fastapi_rest_rate_limit_handler.py</code> <pre><code>async def __call__(self, request: Request) -&gt; None:\n    \"\"\"Handles the rate-limiting logic for incoming requests.\n\n    Args:\n        request (Request): The incoming FastAPI request.\n\n    Raises:\n        HTTPException: If the rate limit is exceeded, an HTTP 429 Too Many Requests error is raised.\n    \"\"\"\n    rate_key = await self._get_identifier(request)\n    key = f\"RateLimitHandler:{rate_key}:{request.scope['path']}:{request.method}\"\n    pexpire = await self._check(key)  # Awaiting the function since it is an async call\n    if pexpire != 0:\n        await self._create_callback(pexpire)  # type:ignore[arg-type]\n</code></pre>"},{"location":"api_reference/helpers/#grpc-interceptors","title":"gRPC Interceptors","text":"<p>gRPC interceptors for tracing and monitoring:</p> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.grpc.trace.client_interceptor.GrpcClientTraceInterceptor","title":"<code>archipy.helpers.interceptors.grpc.trace.client_interceptor.GrpcClientTraceInterceptor</code>","text":"<p>               Bases: <code>BaseGrpcClientInterceptor</code></p> <p>A gRPC client interceptor for tracing requests using Elastic APM and Sentry APM.</p> <p>This interceptor injects the Elastic APM trace parent header into gRPC client requests to enable distributed tracing across services. It also creates Sentry transactions to monitor the performance of gRPC calls.</p> Source code in <code>archipy/helpers/interceptors/grpc/trace/client_interceptor.py</code> <pre><code>class GrpcClientTraceInterceptor(BaseGrpcClientInterceptor):\n    \"\"\"A gRPC client interceptor for tracing requests using Elastic APM and Sentry APM.\n\n    This interceptor injects the Elastic APM trace parent header into gRPC client requests\n    to enable distributed tracing across services. It also creates Sentry transactions\n    to monitor the performance of gRPC calls.\n    \"\"\"\n\n    def intercept(self, method: Callable, request_or_iterator: Any, call_details: grpc.ClientCallDetails) -&gt; Any:\n        \"\"\"Intercepts a gRPC client call to inject the Elastic APM trace parent header and monitor performance with Sentry.\n\n        Args:\n            method (Callable): The gRPC method being intercepted.\n            request_or_iterator (Any): The request or request iterator.\n            call_details (grpc.ClientCallDetails): Details of the gRPC call.\n\n        Returns:\n            Any: The result of the intercepted gRPC method.\n\n        Notes:\n            - If both Elastic APM and Sentry are disabled, the interceptor passes the call through.\n            - Creates Sentry spans for tracing gRPC client calls.\n            - Injects Elastic APM trace parent header when available.\n        \"\"\"\n        config = BaseConfig.global_config()\n\n        # Skip tracing if both APM systems are disabled\n        if not config.ELASTIC_APM.IS_ENABLED and not config.SENTRY.IS_ENABLED:\n            return method(request_or_iterator, call_details)\n\n        # Initialize Sentry span if enabled\n        sentry_span = None\n        if config.SENTRY.IS_ENABLED:\n            try:\n                import sentry_sdk\n\n                sentry_span = sentry_sdk.start_span(\n                    op=\"grpc.client\",\n                    description=f\"gRPC client call to {call_details.method}\",\n                )\n                sentry_span.__enter__()\n            except ImportError:\n                logging.debug(\"sentry_sdk is not installed, skipping Sentry span creation.\")\n            except Exception:\n                logging.exception(\"Failed to create Sentry span for gRPC client call\")\n\n        # Handle Elastic APM trace propagation\n        metadata = list(call_details.metadata or [])\n        if config.ELASTIC_APM.IS_ENABLED and (trace_parent_id := elasticapm.get_trace_parent_header()):\n            metadata.append((TRACEPARENT_HEADER_NAME, f\"{trace_parent_id}\"))\n\n        # Create new call details with updated metadata\n        new_details = ClientCallDetails(\n            method=call_details.method,\n            timeout=call_details.timeout,\n            metadata=metadata,\n            credentials=call_details.credentials,\n            wait_for_ready=call_details.wait_for_ready,\n            compression=call_details.compression,\n        )\n\n        try:\n            # Execute the gRPC method with the updated call details\n            result = method(request_or_iterator, new_details)\n        except Exception as e:\n            # Mark Sentry span as failed and capture exception\n            if sentry_span:\n                sentry_span.set_status(\"internal_error\")\n                sentry_span.set_tag(\"error\", True)\n                sentry_span.set_data(\"exception\", str(e))\n            raise\n        else:\n            # Mark Sentry span as successful\n            if sentry_span:\n                sentry_span.set_status(\"ok\")\n            return result\n        finally:\n            # Clean up Sentry span\n            if sentry_span:\n                try:\n                    sentry_span.__exit__(None, None, None)\n                except Exception:\n                    logging.exception(\"Error closing Sentry span\")\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.grpc.trace.client_interceptor.GrpcClientTraceInterceptor.intercept","title":"<code>archipy.helpers.interceptors.grpc.trace.client_interceptor.GrpcClientTraceInterceptor.intercept(method, request_or_iterator, call_details)</code>","text":"<p>Intercepts a gRPC client call to inject the Elastic APM trace parent header and monitor performance with Sentry.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Callable</code> <p>The gRPC method being intercepted.</p> required <code>request_or_iterator</code> <code>Any</code> <p>The request or request iterator.</p> required <code>call_details</code> <code>ClientCallDetails</code> <p>Details of the gRPC call.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The result of the intercepted gRPC method.</p> Notes <ul> <li>If both Elastic APM and Sentry are disabled, the interceptor passes the call through.</li> <li>Creates Sentry spans for tracing gRPC client calls.</li> <li>Injects Elastic APM trace parent header when available.</li> </ul> Source code in <code>archipy/helpers/interceptors/grpc/trace/client_interceptor.py</code> <pre><code>def intercept(self, method: Callable, request_or_iterator: Any, call_details: grpc.ClientCallDetails) -&gt; Any:\n    \"\"\"Intercepts a gRPC client call to inject the Elastic APM trace parent header and monitor performance with Sentry.\n\n    Args:\n        method (Callable): The gRPC method being intercepted.\n        request_or_iterator (Any): The request or request iterator.\n        call_details (grpc.ClientCallDetails): Details of the gRPC call.\n\n    Returns:\n        Any: The result of the intercepted gRPC method.\n\n    Notes:\n        - If both Elastic APM and Sentry are disabled, the interceptor passes the call through.\n        - Creates Sentry spans for tracing gRPC client calls.\n        - Injects Elastic APM trace parent header when available.\n    \"\"\"\n    config = BaseConfig.global_config()\n\n    # Skip tracing if both APM systems are disabled\n    if not config.ELASTIC_APM.IS_ENABLED and not config.SENTRY.IS_ENABLED:\n        return method(request_or_iterator, call_details)\n\n    # Initialize Sentry span if enabled\n    sentry_span = None\n    if config.SENTRY.IS_ENABLED:\n        try:\n            import sentry_sdk\n\n            sentry_span = sentry_sdk.start_span(\n                op=\"grpc.client\",\n                description=f\"gRPC client call to {call_details.method}\",\n            )\n            sentry_span.__enter__()\n        except ImportError:\n            logging.debug(\"sentry_sdk is not installed, skipping Sentry span creation.\")\n        except Exception:\n            logging.exception(\"Failed to create Sentry span for gRPC client call\")\n\n    # Handle Elastic APM trace propagation\n    metadata = list(call_details.metadata or [])\n    if config.ELASTIC_APM.IS_ENABLED and (trace_parent_id := elasticapm.get_trace_parent_header()):\n        metadata.append((TRACEPARENT_HEADER_NAME, f\"{trace_parent_id}\"))\n\n    # Create new call details with updated metadata\n    new_details = ClientCallDetails(\n        method=call_details.method,\n        timeout=call_details.timeout,\n        metadata=metadata,\n        credentials=call_details.credentials,\n        wait_for_ready=call_details.wait_for_ready,\n        compression=call_details.compression,\n    )\n\n    try:\n        # Execute the gRPC method with the updated call details\n        result = method(request_or_iterator, new_details)\n    except Exception as e:\n        # Mark Sentry span as failed and capture exception\n        if sentry_span:\n            sentry_span.set_status(\"internal_error\")\n            sentry_span.set_tag(\"error\", True)\n            sentry_span.set_data(\"exception\", str(e))\n        raise\n    else:\n        # Mark Sentry span as successful\n        if sentry_span:\n            sentry_span.set_status(\"ok\")\n        return result\n    finally:\n        # Clean up Sentry span\n        if sentry_span:\n            try:\n                sentry_span.__exit__(None, None, None)\n            except Exception:\n                logging.exception(\"Error closing Sentry span\")\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.grpc.trace.client_interceptor.AsyncGrpcClientTraceInterceptor","title":"<code>archipy.helpers.interceptors.grpc.trace.client_interceptor.AsyncGrpcClientTraceInterceptor</code>","text":"<p>               Bases: <code>BaseAsyncGrpcClientInterceptor</code></p> <p>An asynchronous gRPC client interceptor for tracing requests using Elastic APM and Sentry APM.</p> <p>This interceptor injects the Elastic APM trace parent header into asynchronous gRPC client requests to enable distributed tracing across services. It also creates Sentry spans for monitoring performance.</p> Source code in <code>archipy/helpers/interceptors/grpc/trace/client_interceptor.py</code> <pre><code>class AsyncGrpcClientTraceInterceptor(BaseAsyncGrpcClientInterceptor):\n    \"\"\"An asynchronous gRPC client interceptor for tracing requests using Elastic APM and Sentry APM.\n\n    This interceptor injects the Elastic APM trace parent header into asynchronous gRPC client requests\n    to enable distributed tracing across services. It also creates Sentry spans for monitoring performance.\n    \"\"\"\n\n    async def intercept(\n        self,\n        method: Callable,\n        request_or_iterator: Any,\n        call_details: grpc.aio.ClientCallDetails,\n    ) -&gt; Any:\n        \"\"\"Intercepts an asynchronous gRPC client call to inject the Elastic APM trace parent header and monitor with Sentry.\n\n        Args:\n            method (Callable): The asynchronous gRPC method being intercepted.\n            request_or_iterator (Any): The request or request iterator.\n            call_details (grpc.aio.ClientCallDetails): Details of the gRPC call.\n\n        Returns:\n            Any: The result of the intercepted gRPC method.\n\n        Notes:\n            - If both Elastic APM and Sentry are disabled, the interceptor passes the call through.\n            - Creates Sentry spans for tracing async gRPC client calls.\n            - Injects Elastic APM trace parent header when available.\n        \"\"\"\n        config = BaseConfig.global_config()\n\n        # Skip tracing if both APM systems are disabled\n        if not config.ELASTIC_APM.IS_ENABLED and not config.SENTRY.IS_ENABLED:\n            return await method(request_or_iterator, call_details)\n\n        # Initialize Sentry span if enabled\n        sentry_span = None\n        if config.SENTRY.IS_ENABLED:\n            try:\n                import sentry_sdk\n\n                sentry_span = sentry_sdk.start_span(\n                    op=\"grpc.client\",\n                    description=f\"Async gRPC client call to {call_details.method}\",\n                )\n                sentry_span.__enter__()\n            except ImportError:\n                logging.debug(\"sentry_sdk is not installed, skipping Sentry span creation.\")\n            except Exception:\n                logging.exception(\"Failed to create Sentry span for async gRPC client call\")\n\n        # Handle Elastic APM trace propagation\n        metadata = list(call_details.metadata or [])\n        if config.ELASTIC_APM.IS_ENABLED and (trace_parent_id := elasticapm.get_trace_parent_header()):\n            metadata.append((TRACEPARENT_HEADER_NAME, f\"{trace_parent_id}\"))\n\n        # Create new call details with updated metadata\n        new_details = AsyncClientCallDetails(\n            method=call_details.method,\n            timeout=call_details.timeout,\n            metadata=metadata,\n            credentials=call_details.credentials,\n            wait_for_ready=call_details.wait_for_ready,\n        )\n\n        try:\n            # Execute the async gRPC method with the updated call details\n            result = await method(request_or_iterator, new_details)\n        except Exception as e:\n            # Mark Sentry span as failed and capture exception\n            if sentry_span:\n                sentry_span.set_status(\"internal_error\")\n                sentry_span.set_tag(\"error\", True)\n                sentry_span.set_data(\"exception\", str(e))\n            raise\n        else:\n            # Mark Sentry span as successful\n            if sentry_span:\n                sentry_span.set_status(\"ok\")\n            return result\n        finally:\n            # Clean up Sentry span\n            if sentry_span:\n                try:\n                    sentry_span.__exit__(None, None, None)\n                except Exception:\n                    logging.exception(\"Error closing Sentry span\")\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.grpc.trace.client_interceptor.AsyncGrpcClientTraceInterceptor.intercept","title":"<code>archipy.helpers.interceptors.grpc.trace.client_interceptor.AsyncGrpcClientTraceInterceptor.intercept(method, request_or_iterator, call_details)</code>  <code>async</code>","text":"<p>Intercepts an asynchronous gRPC client call to inject the Elastic APM trace parent header and monitor with Sentry.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Callable</code> <p>The asynchronous gRPC method being intercepted.</p> required <code>request_or_iterator</code> <code>Any</code> <p>The request or request iterator.</p> required <code>call_details</code> <code>ClientCallDetails</code> <p>Details of the gRPC call.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The result of the intercepted gRPC method.</p> Notes <ul> <li>If both Elastic APM and Sentry are disabled, the interceptor passes the call through.</li> <li>Creates Sentry spans for tracing async gRPC client calls.</li> <li>Injects Elastic APM trace parent header when available.</li> </ul> Source code in <code>archipy/helpers/interceptors/grpc/trace/client_interceptor.py</code> <pre><code>async def intercept(\n    self,\n    method: Callable,\n    request_or_iterator: Any,\n    call_details: grpc.aio.ClientCallDetails,\n) -&gt; Any:\n    \"\"\"Intercepts an asynchronous gRPC client call to inject the Elastic APM trace parent header and monitor with Sentry.\n\n    Args:\n        method (Callable): The asynchronous gRPC method being intercepted.\n        request_or_iterator (Any): The request or request iterator.\n        call_details (grpc.aio.ClientCallDetails): Details of the gRPC call.\n\n    Returns:\n        Any: The result of the intercepted gRPC method.\n\n    Notes:\n        - If both Elastic APM and Sentry are disabled, the interceptor passes the call through.\n        - Creates Sentry spans for tracing async gRPC client calls.\n        - Injects Elastic APM trace parent header when available.\n    \"\"\"\n    config = BaseConfig.global_config()\n\n    # Skip tracing if both APM systems are disabled\n    if not config.ELASTIC_APM.IS_ENABLED and not config.SENTRY.IS_ENABLED:\n        return await method(request_or_iterator, call_details)\n\n    # Initialize Sentry span if enabled\n    sentry_span = None\n    if config.SENTRY.IS_ENABLED:\n        try:\n            import sentry_sdk\n\n            sentry_span = sentry_sdk.start_span(\n                op=\"grpc.client\",\n                description=f\"Async gRPC client call to {call_details.method}\",\n            )\n            sentry_span.__enter__()\n        except ImportError:\n            logging.debug(\"sentry_sdk is not installed, skipping Sentry span creation.\")\n        except Exception:\n            logging.exception(\"Failed to create Sentry span for async gRPC client call\")\n\n    # Handle Elastic APM trace propagation\n    metadata = list(call_details.metadata or [])\n    if config.ELASTIC_APM.IS_ENABLED and (trace_parent_id := elasticapm.get_trace_parent_header()):\n        metadata.append((TRACEPARENT_HEADER_NAME, f\"{trace_parent_id}\"))\n\n    # Create new call details with updated metadata\n    new_details = AsyncClientCallDetails(\n        method=call_details.method,\n        timeout=call_details.timeout,\n        metadata=metadata,\n        credentials=call_details.credentials,\n        wait_for_ready=call_details.wait_for_ready,\n    )\n\n    try:\n        # Execute the async gRPC method with the updated call details\n        result = await method(request_or_iterator, new_details)\n    except Exception as e:\n        # Mark Sentry span as failed and capture exception\n        if sentry_span:\n            sentry_span.set_status(\"internal_error\")\n            sentry_span.set_tag(\"error\", True)\n            sentry_span.set_data(\"exception\", str(e))\n        raise\n    else:\n        # Mark Sentry span as successful\n        if sentry_span:\n            sentry_span.set_status(\"ok\")\n        return result\n    finally:\n        # Clean up Sentry span\n        if sentry_span:\n            try:\n                sentry_span.__exit__(None, None, None)\n            except Exception:\n                logging.exception(\"Error closing Sentry span\")\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.grpc.trace.server_interceptor.GrpcServerTraceInterceptor","title":"<code>archipy.helpers.interceptors.grpc.trace.server_interceptor.GrpcServerTraceInterceptor</code>","text":"<p>               Bases: <code>BaseGrpcServerInterceptor</code></p> <p>A gRPC server interceptor for tracing requests using Elastic APM and Sentry APM.</p> <p>This interceptor captures and traces gRPC server requests, enabling distributed tracing across services. It integrates with both Elastic APM and Sentry to monitor and log transactions.</p> Source code in <code>archipy/helpers/interceptors/grpc/trace/server_interceptor.py</code> <pre><code>class GrpcServerTraceInterceptor(BaseGrpcServerInterceptor):\n    \"\"\"A gRPC server interceptor for tracing requests using Elastic APM and Sentry APM.\n\n    This interceptor captures and traces gRPC server requests, enabling distributed tracing\n    across services. It integrates with both Elastic APM and Sentry to monitor and log transactions.\n    \"\"\"\n\n    def intercept(\n        self,\n        method: Callable,\n        request: object,\n        context: grpc.ServicerContext,\n        method_name_model: MethodName,\n    ) -&gt; object:\n        \"\"\"Intercepts a gRPC server call to trace the request using Elastic APM and Sentry APM.\n\n        Args:\n            method (Callable): The gRPC method being intercepted.\n            request (object): The request object passed to the method.\n            context (grpc.ServicerContext): The context of the gRPC call.\n            method_name_model (MethodName): The parsed method name containing package, service, and method components.\n\n        Returns:\n            object: The result of the intercepted gRPC method.\n\n        Raises:\n            Exception: If an exception occurs during the method execution, it is captured and logged.\n\n        Notes:\n            - If both Elastic APM and Sentry are disabled, the interceptor passes the call through.\n            - Creates Sentry transactions for tracing gRPC server calls.\n            - Handles Elastic APM distributed tracing with trace parent headers.\n        \"\"\"\n        try:\n            config = BaseConfig.global_config()\n\n            # Skip tracing if both APM systems are disabled\n            if not config.ELASTIC_APM.IS_ENABLED and not config.SENTRY.IS_ENABLED:\n                return method(request, context)\n\n            # Convert metadata to a dictionary for easier access\n            metadata_dict = dict(context.invocation_metadata())\n\n            # Initialize Sentry transaction if enabled\n            sentry_transaction = None\n            if config.SENTRY.IS_ENABLED:\n                try:\n                    import sentry_sdk\n\n                    # Initialize Sentry if not already done\n                    if not sentry_sdk.Hub.current.client:\n                        sentry_sdk.init(\n                            dsn=config.SENTRY.DSN,\n                            debug=config.SENTRY.DEBUG,\n                            release=config.SENTRY.RELEASE,\n                            sample_rate=config.SENTRY.SAMPLE_RATE,\n                            traces_sample_rate=config.SENTRY.TRACES_SAMPLE_RATE,\n                            environment=getattr(config, \"ENVIRONMENT\", None),\n                        )\n\n                    sentry_transaction = sentry_sdk.start_transaction(\n                        name=method_name_model.full_name,\n                        op=\"grpc.server\",\n                        description=f\"gRPC server call {method_name_model.full_name}\",\n                    )\n                    sentry_transaction.__enter__()\n                except ImportError:\n                    logging.debug(\"sentry_sdk is not installed, skipping Sentry transaction creation.\")\n                except Exception:\n                    logging.exception(\"Failed to create Sentry transaction for gRPC server call\")\n\n            # Handle Elastic APM if enabled\n            elastic_client = None\n            if config.ELASTIC_APM.IS_ENABLED:\n                try:\n                    # Get the Elastic APM client\n                    elastic_client = elasticapm.Client(config.ELASTIC_APM.model_dump())\n\n                    # Check if a trace parent header is present in the metadata\n                    if parent := elasticapm.trace_parent_from_headers(metadata_dict):\n                        # Start a transaction linked to the distributed trace\n                        elastic_client.begin_transaction(transaction_type=\"request\", trace_parent=parent)\n                    else:\n                        # Start a new transaction if no trace parent header is present\n                        elastic_client.begin_transaction(transaction_type=\"request\")\n                except Exception:\n                    logging.exception(\"Failed to initialize Elastic APM transaction\")\n\n            try:\n                # Execute the gRPC method\n                result = method(request, context)\n            except Exception:\n                # Mark transactions as failed and capture exception\n                if sentry_transaction:\n                    sentry_transaction.set_status(\"internal_error\")\n                if elastic_client:\n                    elastic_client.end_transaction(name=method_name_model.full_name, result=\"failure\")\n                raise\n            else:\n                # Mark transactions as successful\n                if sentry_transaction:\n                    sentry_transaction.set_status(\"ok\")\n                if elastic_client:\n                    elastic_client.end_transaction(name=method_name_model.full_name, result=\"success\")\n                return result\n            finally:\n                # Clean up Sentry transaction\n                if sentry_transaction:\n                    try:\n                        sentry_transaction.__exit__(None, None, None)\n                    except Exception:\n                        logging.exception(\"Error closing Sentry transaction\")\n\n        except Exception as exception:\n            BaseUtils.capture_exception(exception)\n            raise\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.grpc.trace.server_interceptor.GrpcServerTraceInterceptor.intercept","title":"<code>archipy.helpers.interceptors.grpc.trace.server_interceptor.GrpcServerTraceInterceptor.intercept(method, request, context, method_name_model)</code>","text":"<p>Intercepts a gRPC server call to trace the request using Elastic APM and Sentry APM.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Callable</code> <p>The gRPC method being intercepted.</p> required <code>request</code> <code>object</code> <p>The request object passed to the method.</p> required <code>context</code> <code>ServicerContext</code> <p>The context of the gRPC call.</p> required <code>method_name_model</code> <code>MethodName</code> <p>The parsed method name containing package, service, and method components.</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>The result of the intercepted gRPC method.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an exception occurs during the method execution, it is captured and logged.</p> Notes <ul> <li>If both Elastic APM and Sentry are disabled, the interceptor passes the call through.</li> <li>Creates Sentry transactions for tracing gRPC server calls.</li> <li>Handles Elastic APM distributed tracing with trace parent headers.</li> </ul> Source code in <code>archipy/helpers/interceptors/grpc/trace/server_interceptor.py</code> <pre><code>def intercept(\n    self,\n    method: Callable,\n    request: object,\n    context: grpc.ServicerContext,\n    method_name_model: MethodName,\n) -&gt; object:\n    \"\"\"Intercepts a gRPC server call to trace the request using Elastic APM and Sentry APM.\n\n    Args:\n        method (Callable): The gRPC method being intercepted.\n        request (object): The request object passed to the method.\n        context (grpc.ServicerContext): The context of the gRPC call.\n        method_name_model (MethodName): The parsed method name containing package, service, and method components.\n\n    Returns:\n        object: The result of the intercepted gRPC method.\n\n    Raises:\n        Exception: If an exception occurs during the method execution, it is captured and logged.\n\n    Notes:\n        - If both Elastic APM and Sentry are disabled, the interceptor passes the call through.\n        - Creates Sentry transactions for tracing gRPC server calls.\n        - Handles Elastic APM distributed tracing with trace parent headers.\n    \"\"\"\n    try:\n        config = BaseConfig.global_config()\n\n        # Skip tracing if both APM systems are disabled\n        if not config.ELASTIC_APM.IS_ENABLED and not config.SENTRY.IS_ENABLED:\n            return method(request, context)\n\n        # Convert metadata to a dictionary for easier access\n        metadata_dict = dict(context.invocation_metadata())\n\n        # Initialize Sentry transaction if enabled\n        sentry_transaction = None\n        if config.SENTRY.IS_ENABLED:\n            try:\n                import sentry_sdk\n\n                # Initialize Sentry if not already done\n                if not sentry_sdk.Hub.current.client:\n                    sentry_sdk.init(\n                        dsn=config.SENTRY.DSN,\n                        debug=config.SENTRY.DEBUG,\n                        release=config.SENTRY.RELEASE,\n                        sample_rate=config.SENTRY.SAMPLE_RATE,\n                        traces_sample_rate=config.SENTRY.TRACES_SAMPLE_RATE,\n                        environment=getattr(config, \"ENVIRONMENT\", None),\n                    )\n\n                sentry_transaction = sentry_sdk.start_transaction(\n                    name=method_name_model.full_name,\n                    op=\"grpc.server\",\n                    description=f\"gRPC server call {method_name_model.full_name}\",\n                )\n                sentry_transaction.__enter__()\n            except ImportError:\n                logging.debug(\"sentry_sdk is not installed, skipping Sentry transaction creation.\")\n            except Exception:\n                logging.exception(\"Failed to create Sentry transaction for gRPC server call\")\n\n        # Handle Elastic APM if enabled\n        elastic_client = None\n        if config.ELASTIC_APM.IS_ENABLED:\n            try:\n                # Get the Elastic APM client\n                elastic_client = elasticapm.Client(config.ELASTIC_APM.model_dump())\n\n                # Check if a trace parent header is present in the metadata\n                if parent := elasticapm.trace_parent_from_headers(metadata_dict):\n                    # Start a transaction linked to the distributed trace\n                    elastic_client.begin_transaction(transaction_type=\"request\", trace_parent=parent)\n                else:\n                    # Start a new transaction if no trace parent header is present\n                    elastic_client.begin_transaction(transaction_type=\"request\")\n            except Exception:\n                logging.exception(\"Failed to initialize Elastic APM transaction\")\n\n        try:\n            # Execute the gRPC method\n            result = method(request, context)\n        except Exception:\n            # Mark transactions as failed and capture exception\n            if sentry_transaction:\n                sentry_transaction.set_status(\"internal_error\")\n            if elastic_client:\n                elastic_client.end_transaction(name=method_name_model.full_name, result=\"failure\")\n            raise\n        else:\n            # Mark transactions as successful\n            if sentry_transaction:\n                sentry_transaction.set_status(\"ok\")\n            if elastic_client:\n                elastic_client.end_transaction(name=method_name_model.full_name, result=\"success\")\n            return result\n        finally:\n            # Clean up Sentry transaction\n            if sentry_transaction:\n                try:\n                    sentry_transaction.__exit__(None, None, None)\n                except Exception:\n                    logging.exception(\"Error closing Sentry transaction\")\n\n    except Exception as exception:\n        BaseUtils.capture_exception(exception)\n        raise\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.grpc.trace.server_interceptor.AsyncGrpcServerTraceInterceptor","title":"<code>archipy.helpers.interceptors.grpc.trace.server_interceptor.AsyncGrpcServerTraceInterceptor</code>","text":"<p>               Bases: <code>BaseAsyncGrpcServerInterceptor</code></p> <p>An async gRPC server interceptor for tracing requests using Elastic APM and Sentry APM.</p> <p>This interceptor captures and traces async gRPC server requests, enabling distributed tracing across services. It integrates with both Elastic APM and Sentry to monitor and log transactions.</p> Source code in <code>archipy/helpers/interceptors/grpc/trace/server_interceptor.py</code> <pre><code>class AsyncGrpcServerTraceInterceptor(BaseAsyncGrpcServerInterceptor):\n    \"\"\"An async gRPC server interceptor for tracing requests using Elastic APM and Sentry APM.\n\n    This interceptor captures and traces async gRPC server requests, enabling distributed tracing\n    across services. It integrates with both Elastic APM and Sentry to monitor and log transactions.\n    \"\"\"\n\n    async def intercept(\n        self,\n        method: Callable,\n        request: object,\n        context: grpc.aio.ServicerContext,\n        method_name_model: MethodName,\n    ) -&gt; object:\n        \"\"\"Intercepts an async gRPC server call to trace the request using Elastic APM and Sentry APM.\n\n        Args:\n            method (Callable): The async gRPC method being intercepted.\n            request (object): The request object passed to the method.\n            context (grpc.aio.ServicerContext): The context of the async gRPC call.\n            method_name_model (MethodName): The parsed method name containing package, service, and method components.\n\n        Returns:\n            object: The result of the intercepted gRPC method.\n\n        Raises:\n            Exception: If an exception occurs during the method execution, it is captured and logged.\n\n        Notes:\n            - If both Elastic APM and Sentry are disabled, the interceptor passes the call through.\n            - Creates Sentry transactions for tracing async gRPC server calls.\n            - Handles Elastic APM distributed tracing with trace parent headers.\n        \"\"\"\n        try:\n            config = BaseConfig.global_config()\n\n            # Skip tracing if both APM systems are disabled\n            if not config.ELASTIC_APM.IS_ENABLED and not config.SENTRY.IS_ENABLED:\n                return await method(request, context)\n\n            # Convert metadata to a dictionary for easier access\n            metadata_dict = dict(context.invocation_metadata())\n\n            # Initialize Sentry transaction if enabled\n            sentry_transaction = None\n            if config.SENTRY.IS_ENABLED:\n                try:\n                    import sentry_sdk\n\n                    # Initialize Sentry if not already done\n                    if not sentry_sdk.Hub.current.client:\n                        sentry_sdk.init(\n                            dsn=config.SENTRY.DSN,\n                            debug=config.SENTRY.DEBUG,\n                            release=config.SENTRY.RELEASE,\n                            sample_rate=config.SENTRY.SAMPLE_RATE,\n                            traces_sample_rate=config.SENTRY.TRACES_SAMPLE_RATE,\n                            environment=getattr(config, \"ENVIRONMENT\", None),\n                        )\n\n                    sentry_transaction = sentry_sdk.start_transaction(\n                        name=method_name_model.full_name,\n                        op=\"grpc.server\",\n                        description=f\"Async gRPC server call {method_name_model.full_name}\",\n                    )\n                    sentry_transaction.__enter__()\n                except ImportError:\n                    logging.debug(\"sentry_sdk is not installed, skipping Sentry transaction creation.\")\n                except Exception:\n                    logging.exception(\"Failed to create Sentry transaction for async gRPC server call\")\n\n            # Handle Elastic APM if enabled\n            elastic_client = None\n            if config.ELASTIC_APM.IS_ENABLED:\n                try:\n                    # Get the Elastic APM client\n                    elastic_client = elasticapm.Client(config.ELASTIC_APM.model_dump())\n\n                    # Check if a trace parent header is present in the metadata\n                    if parent := elasticapm.trace_parent_from_headers(metadata_dict):\n                        # Start a transaction linked to the distributed trace\n                        elastic_client.begin_transaction(transaction_type=\"request\", trace_parent=parent)\n                    else:\n                        # Start a new transaction if no trace parent header is present\n                        elastic_client.begin_transaction(transaction_type=\"request\")\n                except Exception:\n                    logging.exception(\"Failed to initialize Elastic APM transaction\")\n\n            try:\n                # Execute the async gRPC method\n                result = await method(request, context)\n            except Exception:\n                # Mark transactions as failed and capture exception\n                if sentry_transaction:\n                    sentry_transaction.set_status(\"internal_error\")\n                if elastic_client:\n                    elastic_client.end_transaction(name=method_name_model.full_name, result=\"failure\")\n                raise\n            else:\n                # Mark transactions as successful\n                if sentry_transaction:\n                    sentry_transaction.set_status(\"ok\")\n                if elastic_client:\n                    elastic_client.end_transaction(name=method_name_model.full_name, result=\"success\")\n                return result\n            finally:\n                # Clean up Sentry transaction\n                if sentry_transaction:\n                    try:\n                        sentry_transaction.__exit__(None, None, None)\n                    except Exception:\n                        logging.exception(\"Error closing Sentry transaction\")\n\n        except Exception as exception:\n            BaseUtils.capture_exception(exception)\n            raise\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.grpc.trace.server_interceptor.AsyncGrpcServerTraceInterceptor.intercept","title":"<code>archipy.helpers.interceptors.grpc.trace.server_interceptor.AsyncGrpcServerTraceInterceptor.intercept(method, request, context, method_name_model)</code>  <code>async</code>","text":"<p>Intercepts an async gRPC server call to trace the request using Elastic APM and Sentry APM.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Callable</code> <p>The async gRPC method being intercepted.</p> required <code>request</code> <code>object</code> <p>The request object passed to the method.</p> required <code>context</code> <code>ServicerContext</code> <p>The context of the async gRPC call.</p> required <code>method_name_model</code> <code>MethodName</code> <p>The parsed method name containing package, service, and method components.</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>The result of the intercepted gRPC method.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an exception occurs during the method execution, it is captured and logged.</p> Notes <ul> <li>If both Elastic APM and Sentry are disabled, the interceptor passes the call through.</li> <li>Creates Sentry transactions for tracing async gRPC server calls.</li> <li>Handles Elastic APM distributed tracing with trace parent headers.</li> </ul> Source code in <code>archipy/helpers/interceptors/grpc/trace/server_interceptor.py</code> <pre><code>async def intercept(\n    self,\n    method: Callable,\n    request: object,\n    context: grpc.aio.ServicerContext,\n    method_name_model: MethodName,\n) -&gt; object:\n    \"\"\"Intercepts an async gRPC server call to trace the request using Elastic APM and Sentry APM.\n\n    Args:\n        method (Callable): The async gRPC method being intercepted.\n        request (object): The request object passed to the method.\n        context (grpc.aio.ServicerContext): The context of the async gRPC call.\n        method_name_model (MethodName): The parsed method name containing package, service, and method components.\n\n    Returns:\n        object: The result of the intercepted gRPC method.\n\n    Raises:\n        Exception: If an exception occurs during the method execution, it is captured and logged.\n\n    Notes:\n        - If both Elastic APM and Sentry are disabled, the interceptor passes the call through.\n        - Creates Sentry transactions for tracing async gRPC server calls.\n        - Handles Elastic APM distributed tracing with trace parent headers.\n    \"\"\"\n    try:\n        config = BaseConfig.global_config()\n\n        # Skip tracing if both APM systems are disabled\n        if not config.ELASTIC_APM.IS_ENABLED and not config.SENTRY.IS_ENABLED:\n            return await method(request, context)\n\n        # Convert metadata to a dictionary for easier access\n        metadata_dict = dict(context.invocation_metadata())\n\n        # Initialize Sentry transaction if enabled\n        sentry_transaction = None\n        if config.SENTRY.IS_ENABLED:\n            try:\n                import sentry_sdk\n\n                # Initialize Sentry if not already done\n                if not sentry_sdk.Hub.current.client:\n                    sentry_sdk.init(\n                        dsn=config.SENTRY.DSN,\n                        debug=config.SENTRY.DEBUG,\n                        release=config.SENTRY.RELEASE,\n                        sample_rate=config.SENTRY.SAMPLE_RATE,\n                        traces_sample_rate=config.SENTRY.TRACES_SAMPLE_RATE,\n                        environment=getattr(config, \"ENVIRONMENT\", None),\n                    )\n\n                sentry_transaction = sentry_sdk.start_transaction(\n                    name=method_name_model.full_name,\n                    op=\"grpc.server\",\n                    description=f\"Async gRPC server call {method_name_model.full_name}\",\n                )\n                sentry_transaction.__enter__()\n            except ImportError:\n                logging.debug(\"sentry_sdk is not installed, skipping Sentry transaction creation.\")\n            except Exception:\n                logging.exception(\"Failed to create Sentry transaction for async gRPC server call\")\n\n        # Handle Elastic APM if enabled\n        elastic_client = None\n        if config.ELASTIC_APM.IS_ENABLED:\n            try:\n                # Get the Elastic APM client\n                elastic_client = elasticapm.Client(config.ELASTIC_APM.model_dump())\n\n                # Check if a trace parent header is present in the metadata\n                if parent := elasticapm.trace_parent_from_headers(metadata_dict):\n                    # Start a transaction linked to the distributed trace\n                    elastic_client.begin_transaction(transaction_type=\"request\", trace_parent=parent)\n                else:\n                    # Start a new transaction if no trace parent header is present\n                    elastic_client.begin_transaction(transaction_type=\"request\")\n            except Exception:\n                logging.exception(\"Failed to initialize Elastic APM transaction\")\n\n        try:\n            # Execute the async gRPC method\n            result = await method(request, context)\n        except Exception:\n            # Mark transactions as failed and capture exception\n            if sentry_transaction:\n                sentry_transaction.set_status(\"internal_error\")\n            if elastic_client:\n                elastic_client.end_transaction(name=method_name_model.full_name, result=\"failure\")\n            raise\n        else:\n            # Mark transactions as successful\n            if sentry_transaction:\n                sentry_transaction.set_status(\"ok\")\n            if elastic_client:\n                elastic_client.end_transaction(name=method_name_model.full_name, result=\"success\")\n            return result\n        finally:\n            # Clean up Sentry transaction\n            if sentry_transaction:\n                try:\n                    sentry_transaction.__exit__(None, None, None)\n                except Exception:\n                    logging.exception(\"Error closing Sentry transaction\")\n\n    except Exception as exception:\n        BaseUtils.capture_exception(exception)\n        raise\n</code></pre>"},{"location":"api_reference/helpers/#metaclasses","title":"Metaclasses","text":""},{"location":"api_reference/helpers/#singleton-metaclass","title":"Singleton Metaclass","text":"<p>A metaclass implementation of the singleton pattern.</p> <pre><code>from archipy.helpers.metaclasses.singleton import Singleton\n\nclass DatabaseConnection(metaclass=Singleton):\n    def __init__(self):\n        self.connection = create_connection()\n\n# Both instances will be the same\ndb1 = DatabaseConnection()\ndb2 = DatabaseConnection()\nassert db1 is db2\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/helpers/#archipy.helpers.metaclasses.singleton.Singleton","title":"<code>archipy.helpers.metaclasses.singleton.Singleton</code>","text":"<p>               Bases: <code>type</code></p> <p>A thread-safe Singleton metaclass that ensures only one instance of a class is created.</p> <p>This metaclass can be used to create Singleton classes. It supports an optional <code>thread_safe</code> parameter to control whether thread-safety mechanisms (e.g., locks) should be used.</p> <p>Attributes:</p> Name Type Description <code>_instances</code> <code>dict</code> <p>A dictionary to store instances of Singleton classes.</p> <code>_lock</code> <code>Lock</code> <p>A lock to ensure thread-safe instance creation.</p> Example <p>To create a Singleton class, use the <code>Singleton</code> metaclass and optionally specify whether thread-safety should be enabled:</p> <pre><code>class MySingletonClass(metaclass=Singleton, thread_safe=True):\n    def __init__(self, value):\n        self.value = value\n\n# Create instances of MySingletonClass\ninstance1 = MySingletonClass(10)\ninstance2 = MySingletonClass(20)\n\n# Verify that both instances are the same\nprint(instance1.value)  # Output: 10\nprint(instance2.value)  # Output: 10\nprint(instance1 is instance2)  # Output: True\n</code></pre> Source code in <code>archipy/helpers/metaclasses/singleton.py</code> <pre><code>class Singleton(type):\n    \"\"\"A thread-safe Singleton metaclass that ensures only one instance of a class is created.\n\n    This metaclass can be used to create Singleton classes. It supports an optional `thread_safe`\n    parameter to control whether thread-safety mechanisms (e.g., locks) should be used.\n\n    Attributes:\n        _instances (dict): A dictionary to store instances of Singleton classes.\n        _lock (threading.Lock): A lock to ensure thread-safe instance creation.\n\n    Example:\n        To create a Singleton class, use the `Singleton` metaclass and optionally specify\n        whether thread-safety should be enabled:\n\n        ```python\n        class MySingletonClass(metaclass=Singleton, thread_safe=True):\n            def __init__(self, value):\n                self.value = value\n\n        # Create instances of MySingletonClass\n        instance1 = MySingletonClass(10)\n        instance2 = MySingletonClass(20)\n\n        # Verify that both instances are the same\n        print(instance1.value)  # Output: 10\n        print(instance2.value)  # Output: 10\n        print(instance1 is instance2)  # Output: True\n        ```\n    \"\"\"\n\n    _instances: ClassVar[dict[type, SingletonInstance]] = {}  # Stores instances of Singleton classes\n    _lock: ClassVar[threading.Lock] = threading.Lock()  # Lock for thread-safe instance creation\n\n    def __new__(\n        cls,\n        name: str,\n        bases: ClassBases,\n        dct: ClassDict,\n        **kwargs: object,\n    ) -&gt; type:\n        \"\"\"Create a new Singleton metaclass instance.\n\n        Args:\n            name (str): The name of the class.\n            bases (tuple): The base classes of the class.\n            dct (dict): The namespace containing the class attributes.\n            **kwargs: Additional keyword arguments, including `thread_safe`.\n\n        Returns:\n            type: A new metaclass instance.\n        \"\"\"\n        # Extract the `thread_safe` parameter from kwargs\n        thread_safe = kwargs.pop(\"thread_safe\", True)\n        # Create the new class\n        new_class = super().__new__(cls, name, bases, dct, **kwargs)\n        # Store thread_safe as an attribute using setattr to avoid linting errors\n        setattr(new_class, \"__thread_safe\", thread_safe)\n        return new_class\n\n    def __call__(cls, *args: object, **kwargs: object) -&gt; SingletonInstance:\n        \"\"\"Create or return the Singleton instance of the class.\n\n        If `thread_safe` is True, a lock is used to ensure that only one instance is created\n        even in a multi-threaded environment. If `thread_safe` is False, no locking mechanism\n        is used, which may result in multiple instances being created in a multi-threaded context.\n\n        Args:\n            *args: Positional arguments to pass to the class constructor.\n            **kwargs: Keyword arguments to pass to the class constructor.\n\n        Returns:\n            object: The Singleton instance of the class.\n        \"\"\"\n        if cls not in cls._instances:\n            if getattr(cls, \"__thread_safe\", True):\n                with cls._lock:\n                    if cls not in cls._instances:\n                        cls._instances[cls] = super().__call__(*args, **kwargs)\n            else:\n                cls._instances[cls] = super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.metaclasses.singleton.Singleton.__new__","title":"<code>archipy.helpers.metaclasses.singleton.Singleton.__new__(name, bases, dct, **kwargs)</code>","text":"<p>Create a new Singleton metaclass instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the class.</p> required <code>bases</code> <code>tuple</code> <p>The base classes of the class.</p> required <code>dct</code> <code>dict</code> <p>The namespace containing the class attributes.</p> required <code>**kwargs</code> <code>object</code> <p>Additional keyword arguments, including <code>thread_safe</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>type</code> <code>type</code> <p>A new metaclass instance.</p> Source code in <code>archipy/helpers/metaclasses/singleton.py</code> <pre><code>def __new__(\n    cls,\n    name: str,\n    bases: ClassBases,\n    dct: ClassDict,\n    **kwargs: object,\n) -&gt; type:\n    \"\"\"Create a new Singleton metaclass instance.\n\n    Args:\n        name (str): The name of the class.\n        bases (tuple): The base classes of the class.\n        dct (dict): The namespace containing the class attributes.\n        **kwargs: Additional keyword arguments, including `thread_safe`.\n\n    Returns:\n        type: A new metaclass instance.\n    \"\"\"\n    # Extract the `thread_safe` parameter from kwargs\n    thread_safe = kwargs.pop(\"thread_safe\", True)\n    # Create the new class\n    new_class = super().__new__(cls, name, bases, dct, **kwargs)\n    # Store thread_safe as an attribute using setattr to avoid linting errors\n    setattr(new_class, \"__thread_safe\", thread_safe)\n    return new_class\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.metaclasses.singleton.Singleton.__call__","title":"<code>archipy.helpers.metaclasses.singleton.Singleton.__call__(*args, **kwargs)</code>","text":"<p>Create or return the Singleton instance of the class.</p> <p>If <code>thread_safe</code> is True, a lock is used to ensure that only one instance is created even in a multi-threaded environment. If <code>thread_safe</code> is False, no locking mechanism is used, which may result in multiple instances being created in a multi-threaded context.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>object</code> <p>Positional arguments to pass to the class constructor.</p> <code>()</code> <code>**kwargs</code> <code>object</code> <p>Keyword arguments to pass to the class constructor.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>object</code> <code>SingletonInstance</code> <p>The Singleton instance of the class.</p> Source code in <code>archipy/helpers/metaclasses/singleton.py</code> <pre><code>def __call__(cls, *args: object, **kwargs: object) -&gt; SingletonInstance:\n    \"\"\"Create or return the Singleton instance of the class.\n\n    If `thread_safe` is True, a lock is used to ensure that only one instance is created\n    even in a multi-threaded environment. If `thread_safe` is False, no locking mechanism\n    is used, which may result in multiple instances being created in a multi-threaded context.\n\n    Args:\n        *args: Positional arguments to pass to the class constructor.\n        **kwargs: Keyword arguments to pass to the class constructor.\n\n    Returns:\n        object: The Singleton instance of the class.\n    \"\"\"\n    if cls not in cls._instances:\n        if getattr(cls, \"__thread_safe\", True):\n            with cls._lock:\n                if cls not in cls._instances:\n                    cls._instances[cls] = super().__call__(*args, **kwargs)\n        else:\n            cls._instances[cls] = super().__call__(*args, **kwargs)\n    return cls._instances[cls]\n</code></pre>"},{"location":"api_reference/helpers/#key-classes","title":"Key Classes","text":""},{"location":"api_reference/helpers/#retry-decorator_1","title":"Retry Decorator","text":"<p>Function: <code>archipy.helpers.decorators.retry.retry</code></p> <p>A decorator that retries a function call when it fails, with configurable:</p> <ul> <li>Maximum number of attempts</li> <li>Delay between attempts</li> <li>Backoff strategy</li> <li>Exception types to catch</li> </ul>"},{"location":"api_reference/helpers/#singleton","title":"Singleton","text":"<p>Class: <code>archipy.helpers.metaclasses.singleton.Singleton</code></p> <p>A metaclass that ensures a class has only one instance. Features:</p> <ul> <li>Thread-safe implementation</li> <li>Lazy initialization</li> <li>Support for inheritance</li> <li>Clear instance access</li> </ul>"},{"location":"api_reference/helpers/#fastapirestratelimithandler","title":"FastAPIRestRateLimitHandler","text":"<p>Class: <code>archipy.helpers.interceptors.fastapi.rate_limit.fastapi_rest_rate_limit_handler.FastAPIRestRateLimitHandler</code></p> <p>A rate limiting handler for FastAPI applications that:</p> <ul> <li>Supports Redis-based rate limiting</li> <li>Configurable rate limits and periods</li> <li>Customizable response handling</li> <li>Support for multiple rate limit rules</li> </ul>"},{"location":"api_reference/models/","title":"Models","text":"<p>The <code>models</code> module provides core data structures and types used throughout the application, following clean architecture principles.</p>"},{"location":"api_reference/models/#quick-start","title":"Quick Start","text":"<pre><code>from archipy.models.dtos.base_dtos import BaseDTO\nfrom archipy.models.entities.sqlalchemy.base_entities import BaseEntity\n\n# Create a DTO\nclass UserDTO(BaseDTO):\n    id: str\n    username: str\n    email: str\n\n# Create an entity\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n    username: str\n    email: str\n</code></pre>"},{"location":"api_reference/models/#core-components","title":"Core Components","text":""},{"location":"api_reference/models/#dtos-data-transfer-objects","title":"DTOs (Data Transfer Objects)","text":"<p>Base DTOs - Base classes for all DTOs with common functionality Protobuf DTOs - DTOs that can be converted to/from Google Protocol Buffer messages Email DTOs - DTOs for email-related operations Error DTOs - Standardized error response format Pagination DTO - Handles pagination parameters for queries Range DTOs - Handles range-based queries (integer, date, datetime) Search Input DTO - Standardized search input format Sort DTO - Handles sorting parameters</p>"},{"location":"api_reference/models/#entities","title":"Entities","text":"<p>Base Entities - Base classes for SQLAlchemy entities with common functionality Update Tracking - Entities with automatic update timestamp tracking Soft Deletion - Entities with soft deletion support Admin Tracking - Entities with admin user tracking Manager Tracking - Entities with manager user tracking</p>"},{"location":"api_reference/models/#errors","title":"Errors","text":"<p>Base Error - Base class for all custom exceptions Auth Errors - Authentication and authorization errors Business Errors - Business logic violation errors Database Errors - Database operation errors Network Errors - Network communication errors Resource Errors - Resource not found or access errors System Errors - System-level errors Validation Errors - Data validation errors</p>"},{"location":"api_reference/models/#types","title":"Types","text":"<p>Base Types - Common type definitions Email Types - Email-related type definitions Error Message Types - Error message type definitions Language Type - Language enumeration Sort Order Type - Sort order enumeration Time Interval Unit Type - Time interval unit enumeration</p>"},{"location":"api_reference/models/#examples","title":"Examples","text":"<p>For detailed examples, see: - Protobuf DTOs - Error Handling     page_size=10,     total_items=100 ) <pre><code>::: archipy.models.dtos.pagination_dto\noptions:\nshow_root_heading: true\nshow_source: true\n\n### Range DTOs\n\nHandles range-based queries and filters.\n\n```python\nfrom archipy.models.dtos.range_dtos import (\n    RangeDTO,\n    IntegerRangeDTO,\n    DateRangeDTO,\n    DatetimeRangeDTO\n)\n\n# Integer range\nint_range = IntegerRangeDTO(start=1, end=100)\n\n# Date range\ndate_range = DateRangeDTO(\n    start=date(2023, 1, 1),\n    end=date(2023, 12, 31)\n)\n\n# Datetime range\ndt_range = DatetimeRangeDTO(\n    start=datetime(2023, 1, 1),\n    end=datetime(2023, 12, 31)\n)\n</code></pre></p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.dtos.range_dtos.Comparable","title":"<code>archipy.models.dtos.range_dtos.Comparable</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for types that support comparison operators.</p> Source code in <code>archipy/models/dtos/range_dtos.py</code> <pre><code>class Comparable(Protocol):\n    \"\"\"Protocol for types that support comparison operators.\"\"\"\n\n    def __gt__(self, other: Self) -&gt; bool:\n        \"\"\"Greater than comparison operator.\"\"\"\n        ...\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.range_dtos.Comparable.__gt__","title":"<code>archipy.models.dtos.range_dtos.Comparable.__gt__(other)</code>","text":"<p>Greater than comparison operator.</p> Source code in <code>archipy/models/dtos/range_dtos.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Greater than comparison operator.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.range_dtos.BaseRangeDTO","title":"<code>archipy.models.dtos.range_dtos.BaseRangeDTO</code>","text":"<p>               Bases: <code>BaseDTO</code></p> <p>Base Data Transfer Object for range queries.</p> <p>Encapsulates a range of values with from_ and to fields. Provides validation to ensure range integrity.</p> Source code in <code>archipy/models/dtos/range_dtos.py</code> <pre><code>class BaseRangeDTO[R](BaseDTO):\n    \"\"\"Base Data Transfer Object for range queries.\n\n    Encapsulates a range of values with from_ and to fields.\n    Provides validation to ensure range integrity.\n    \"\"\"\n\n    from_: R | None = None\n    to: R | None = None\n\n    @model_validator(mode=\"after\")\n    def validate_range(self) -&gt; Self:\n        \"\"\"Validate that from_ is less than or equal to to when both are provided.\n\n        Returns:\n            Self: The validated model instance.\n\n        Raises:\n            OutOfRangeError: If from_ is greater than to.\n        \"\"\"\n        if self.from_ is not None and self.to is not None and self.from_ &gt; self.to:\n            raise OutOfRangeError(field_name=\"from_\")\n        return self\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.range_dtos.BaseRangeDTO.validate_range","title":"<code>archipy.models.dtos.range_dtos.BaseRangeDTO.validate_range()</code>","text":"<p>Validate that from_ is less than or equal to to when both are provided.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The validated model instance.</p> <p>Raises:</p> Type Description <code>OutOfRangeError</code> <p>If from_ is greater than to.</p> Source code in <code>archipy/models/dtos/range_dtos.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_range(self) -&gt; Self:\n    \"\"\"Validate that from_ is less than or equal to to when both are provided.\n\n    Returns:\n        Self: The validated model instance.\n\n    Raises:\n        OutOfRangeError: If from_ is greater than to.\n    \"\"\"\n    if self.from_ is not None and self.to is not None and self.from_ &gt; self.to:\n        raise OutOfRangeError(field_name=\"from_\")\n    return self\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.range_dtos.DecimalRangeDTO","title":"<code>archipy.models.dtos.range_dtos.DecimalRangeDTO</code>","text":"<p>               Bases: <code>BaseRangeDTO[Decimal]</code></p> <p>Data Transfer Object for decimal range queries.</p> Source code in <code>archipy/models/dtos/range_dtos.py</code> <pre><code>class DecimalRangeDTO(BaseRangeDTO[Decimal]):\n    \"\"\"Data Transfer Object for decimal range queries.\"\"\"\n\n    from_: Decimal | None = None\n    to: Decimal | None = None\n\n    @field_validator(\"from_\", \"to\", mode=\"before\")\n    @classmethod\n    def convert_to_decimal(cls, value: Decimal | str | None) -&gt; Decimal | None:\n        \"\"\"Convert input values to Decimal type.\n\n        Args:\n            value: The value to convert (None, string, or Decimal).\n\n        Returns:\n            Decimal | None: The converted Decimal value or None.\n\n        Raises:\n            InvalidArgumentError: If the value cannot be converted to Decimal.\n        \"\"\"\n        if value is None:\n            return None\n        try:\n            return Decimal(value)\n        except (TypeError, ValueError) as e:\n            raise InvalidArgumentError(argument_name=\"value\") from e\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.range_dtos.DecimalRangeDTO.convert_to_decimal","title":"<code>archipy.models.dtos.range_dtos.DecimalRangeDTO.convert_to_decimal(value)</code>  <code>classmethod</code>","text":"<p>Convert input values to Decimal type.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Decimal | str | None</code> <p>The value to convert (None, string, or Decimal).</p> required <p>Returns:</p> Type Description <code>Decimal | None</code> <p>Decimal | None: The converted Decimal value or None.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the value cannot be converted to Decimal.</p> Source code in <code>archipy/models/dtos/range_dtos.py</code> <pre><code>@field_validator(\"from_\", \"to\", mode=\"before\")\n@classmethod\ndef convert_to_decimal(cls, value: Decimal | str | None) -&gt; Decimal | None:\n    \"\"\"Convert input values to Decimal type.\n\n    Args:\n        value: The value to convert (None, string, or Decimal).\n\n    Returns:\n        Decimal | None: The converted Decimal value or None.\n\n    Raises:\n        InvalidArgumentError: If the value cannot be converted to Decimal.\n    \"\"\"\n    if value is None:\n        return None\n    try:\n        return Decimal(value)\n    except (TypeError, ValueError) as e:\n        raise InvalidArgumentError(argument_name=\"value\") from e\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.range_dtos.IntegerRangeDTO","title":"<code>archipy.models.dtos.range_dtos.IntegerRangeDTO</code>","text":"<p>               Bases: <code>BaseRangeDTO[int]</code></p> <p>Data Transfer Object for integer range queries.</p> Source code in <code>archipy/models/dtos/range_dtos.py</code> <pre><code>class IntegerRangeDTO(BaseRangeDTO[int]):\n    \"\"\"Data Transfer Object for integer range queries.\"\"\"\n\n    from_: int | None = None\n    to: int | None = None\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.range_dtos.DateRangeDTO","title":"<code>archipy.models.dtos.range_dtos.DateRangeDTO</code>","text":"<p>               Bases: <code>BaseRangeDTO[date]</code></p> <p>Data Transfer Object for date range queries.</p> Source code in <code>archipy/models/dtos/range_dtos.py</code> <pre><code>class DateRangeDTO(BaseRangeDTO[date]):\n    \"\"\"Data Transfer Object for date range queries.\"\"\"\n\n    from_: date | None = None\n    to: date | None = None\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.range_dtos.DatetimeRangeDTO","title":"<code>archipy.models.dtos.range_dtos.DatetimeRangeDTO</code>","text":"<p>               Bases: <code>BaseRangeDTO[datetime]</code></p> <p>Data Transfer Object for datetime range queries.</p> Source code in <code>archipy/models/dtos/range_dtos.py</code> <pre><code>class DatetimeRangeDTO(BaseRangeDTO[datetime]):\n    \"\"\"Data Transfer Object for datetime range queries.\"\"\"\n\n    from_: datetime | None = None\n    to: datetime | None = None\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.range_dtos.DatetimeIntervalRangeDTO","title":"<code>archipy.models.dtos.range_dtos.DatetimeIntervalRangeDTO</code>","text":"<p>               Bases: <code>BaseRangeDTO[datetime]</code></p> <p>Data Transfer Object for datetime range queries with interval.</p> <p>Rejects requests if the number of intervals exceeds MAX_ITEMS or if interval-specific range size or 'to' age constraints are violated.</p> Source code in <code>archipy/models/dtos/range_dtos.py</code> <pre><code>class DatetimeIntervalRangeDTO(BaseRangeDTO[datetime]):\n    \"\"\"Data Transfer Object for datetime range queries with interval.\n\n    Rejects requests if the number of intervals exceeds MAX_ITEMS or if interval-specific\n    range size or 'to' age constraints are violated.\n    \"\"\"\n\n    from_: datetime\n    to: datetime\n    interval: TimeIntervalUnitType\n\n    # Maximum number of intervals allowed\n    MAX_ITEMS: ClassVar[int] = 100\n\n    # Range size limits for each interval\n    RANGE_SIZE_LIMITS: ClassVar[dict[TimeIntervalUnitType, timedelta]] = {\n        TimeIntervalUnitType.SECONDS: timedelta(days=2),\n        TimeIntervalUnitType.MINUTES: timedelta(days=7),\n        TimeIntervalUnitType.HOURS: timedelta(days=30),\n        TimeIntervalUnitType.DAYS: timedelta(days=365),\n        TimeIntervalUnitType.WEEKS: timedelta(days=365 * 2),\n        TimeIntervalUnitType.MONTHS: timedelta(days=365 * 5),  # No limit for MONTHS, set high\n        TimeIntervalUnitType.YEAR: timedelta(days=365 * 10),  # No limit for YEAR, set high\n    }\n\n    # 'to' age limits for each interval\n    TO_AGE_LIMITS: ClassVar[dict[TimeIntervalUnitType, timedelta]] = {\n        TimeIntervalUnitType.SECONDS: timedelta(days=2),\n        TimeIntervalUnitType.MINUTES: timedelta(days=7),\n        TimeIntervalUnitType.HOURS: timedelta(days=30),\n        TimeIntervalUnitType.DAYS: timedelta(days=365 * 5),\n        TimeIntervalUnitType.WEEKS: timedelta(days=365 * 10),\n        TimeIntervalUnitType.MONTHS: timedelta(days=365 * 20),  # No limit for MONTHS, set high\n        TimeIntervalUnitType.YEAR: timedelta(days=365 * 50),  # No limit for YEAR, set high\n    }\n\n    # Mapping of intervals to timedelta for step size\n    INTERVAL_TO_TIMEDELTA: ClassVar[dict[TimeIntervalUnitType, timedelta]] = {\n        TimeIntervalUnitType.SECONDS: timedelta(seconds=1),\n        TimeIntervalUnitType.MINUTES: timedelta(minutes=1),\n        TimeIntervalUnitType.HOURS: timedelta(hours=1),\n        TimeIntervalUnitType.DAYS: timedelta(days=1),\n        TimeIntervalUnitType.WEEKS: timedelta(weeks=1),\n        TimeIntervalUnitType.MONTHS: timedelta(days=30),  # Approximate\n        TimeIntervalUnitType.YEAR: timedelta(days=365),  # Approximate\n    }\n\n    @model_validator(mode=\"after\")\n    def validate_interval_constraints(self) -&gt; Self:\n        \"\"\"Validate interval based on range size, 'to' field age, and max intervals.\n\n        - Each interval has specific range size and 'to' age limits.\n        - Rejects if the number of intervals exceeds MAX_ITEMS.\n\n        Returns:\n            Self: The validated model instance.\n\n        Raises:\n            OutOfRangeError: If interval constraints are violated or number of intervals &gt; MAX_ITEMS.\n        \"\"\"\n        if self.from_ is not None and self.to is not None:\n            # Validate range size limit for the selected interval\n            range_size = self.to - self.from_\n            max_range_size = self.RANGE_SIZE_LIMITS.get(self.interval)\n            if max_range_size and range_size &gt; max_range_size:\n                raise OutOfRangeError(field_name=\"range_size\")\n\n            # Validate 'to' age limit\n            current_time = datetime.now()\n            max_to_age = self.TO_AGE_LIMITS.get(self.interval)\n            if max_to_age:\n                age_threshold = current_time - max_to_age\n                if self.to &lt; age_threshold:\n                    raise OutOfRangeError(field_name=\"to\")\n\n            # Calculate number of intervals\n            step = self.INTERVAL_TO_TIMEDELTA[self.interval]\n            range_duration = self.to - self.from_\n            num_intervals = int(range_duration.total_seconds() / step.total_seconds()) + 1\n\n            # Reject if number of intervals exceeds MAX_ITEMS\n            if num_intervals &gt; self.MAX_ITEMS:\n                raise OutOfRangeError(field_name=\"interval_count\")\n\n        return self\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.range_dtos.DatetimeIntervalRangeDTO.validate_interval_constraints","title":"<code>archipy.models.dtos.range_dtos.DatetimeIntervalRangeDTO.validate_interval_constraints()</code>","text":"<p>Validate interval based on range size, 'to' field age, and max intervals.</p> <ul> <li>Each interval has specific range size and 'to' age limits.</li> <li>Rejects if the number of intervals exceeds MAX_ITEMS.</li> </ul> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The validated model instance.</p> <p>Raises:</p> Type Description <code>OutOfRangeError</code> <p>If interval constraints are violated or number of intervals &gt; MAX_ITEMS.</p> Source code in <code>archipy/models/dtos/range_dtos.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_interval_constraints(self) -&gt; Self:\n    \"\"\"Validate interval based on range size, 'to' field age, and max intervals.\n\n    - Each interval has specific range size and 'to' age limits.\n    - Rejects if the number of intervals exceeds MAX_ITEMS.\n\n    Returns:\n        Self: The validated model instance.\n\n    Raises:\n        OutOfRangeError: If interval constraints are violated or number of intervals &gt; MAX_ITEMS.\n    \"\"\"\n    if self.from_ is not None and self.to is not None:\n        # Validate range size limit for the selected interval\n        range_size = self.to - self.from_\n        max_range_size = self.RANGE_SIZE_LIMITS.get(self.interval)\n        if max_range_size and range_size &gt; max_range_size:\n            raise OutOfRangeError(field_name=\"range_size\")\n\n        # Validate 'to' age limit\n        current_time = datetime.now()\n        max_to_age = self.TO_AGE_LIMITS.get(self.interval)\n        if max_to_age:\n            age_threshold = current_time - max_to_age\n            if self.to &lt; age_threshold:\n                raise OutOfRangeError(field_name=\"to\")\n\n        # Calculate number of intervals\n        step = self.INTERVAL_TO_TIMEDELTA[self.interval]\n        range_duration = self.to - self.from_\n        num_intervals = int(range_duration.total_seconds() / step.total_seconds()) + 1\n\n        # Reject if number of intervals exceeds MAX_ITEMS\n        if num_intervals &gt; self.MAX_ITEMS:\n            raise OutOfRangeError(field_name=\"interval_count\")\n\n    return self\n</code></pre>"},{"location":"api_reference/models/#search-input-dto","title":"Search Input DTO","text":"<p>Standardized search parameters.</p> <pre><code>from archipy.models.dtos.search_input_dto import SearchInputDTO\n\nsearch = SearchInputDTO[str](\n    query=\"john\",\n    filters={\"active\": True},\n    pagination=pagination\n)\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.dtos.search_input_dto.SearchInputDTO","title":"<code>archipy.models.dtos.search_input_dto.SearchInputDTO</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data Transfer Object for search inputs with pagination and sorting.</p> <p>This DTO encapsulates search parameters for database queries and API responses, providing a standard way to handle pagination and sorting.</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>T</code> <p>The type for sort column (usually an Enum with column names).</p> required Source code in <code>archipy/models/dtos/search_input_dto.py</code> <pre><code>class SearchInputDTO[T](BaseModel):\n    \"\"\"Data Transfer Object for search inputs with pagination and sorting.\n\n    This DTO encapsulates search parameters for database queries and API responses,\n    providing a standard way to handle pagination and sorting.\n\n    Type Parameters:\n        T: The type for sort column (usually an Enum with column names).\n    \"\"\"\n\n    pagination: PaginationDTO | None = None\n    sort_info: SortDTO[T] | None = None\n</code></pre>"},{"location":"api_reference/models/#sort-dto","title":"Sort DTO","text":"<p>Handles sorting parameters for queries.</p> <pre><code>from archipy.models.dtos.sort_dto import SortDTO\n\nsort = SortDTO[str](\n    field=\"created_at\",\n    order=\"desc\"\n)\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.dtos.sort_dto.SortDTO","title":"<code>archipy.models.dtos.sort_dto.SortDTO</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data Transfer Object for sorting parameters.</p> <p>This DTO encapsulates sorting information for database queries and API responses, providing a standard way to specify how results should be ordered.</p> <p>Attributes:</p> Name Type Description <code>column</code> <code>T | str</code> <p>The name or enum value of the column to sort by</p> <code>order</code> <code>str</code> <p>The sort direction - \"ASC\" for ascending, \"DESC\" for descending</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from archipy.models.dtos.sort_dto import SortDTO\n&gt;&gt;&gt; from archipy.models.types.sort_order_type import SortOrderType\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Sort by name in ascending order\n&gt;&gt;&gt; sort = SortDTO(column=\"name\", order=SortOrderType.ASCENDING)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Sort by creation date in descending order (newest first)\n&gt;&gt;&gt; sort = SortDTO(column=\"created_at\", order=\"DESCENDING\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Using with a database query\n&gt;&gt;&gt; def get_sorted_users(sort: SortDTO = SortDTO.default()):\n...     query = select(User)\n...     if sort.order == SortOrderType.ASCENDING:\n...         query = query.order_by(getattr(User, sort.column).asc())\n...     else:\n...         query = query.order_by(getattr(User, sort.column).desc())\n...     return db.execute(query).scalars().all()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Using with enum column types\n&gt;&gt;&gt; from enum import Enum\n&gt;&gt;&gt; class UserColumns(Enum):\n...     ID = \"id\"\n...     NAME = \"name\"\n...     EMAIL = \"email\"\n...     CREATED_AT = \"created_at\"\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create a sort configuration with enum\n&gt;&gt;&gt; sort = SortDTO[UserColumns](column=UserColumns.NAME, order=SortOrderType.ASCENDING)\n</code></pre> Source code in <code>archipy/models/dtos/sort_dto.py</code> <pre><code>class SortDTO[T](BaseModel):\n    \"\"\"Data Transfer Object for sorting parameters.\n\n    This DTO encapsulates sorting information for database queries and API responses,\n    providing a standard way to specify how results should be ordered.\n\n    Attributes:\n        column (T | str): The name or enum value of the column to sort by\n        order (str): The sort direction - \"ASC\" for ascending, \"DESC\" for descending\n\n    Examples:\n        &gt;&gt;&gt; from archipy.models.dtos.sort_dto import SortDTO\n        &gt;&gt;&gt; from archipy.models.types.sort_order_type import SortOrderType\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Sort by name in ascending order\n        &gt;&gt;&gt; sort = SortDTO(column=\"name\", order=SortOrderType.ASCENDING)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Sort by creation date in descending order (newest first)\n        &gt;&gt;&gt; sort = SortDTO(column=\"created_at\", order=\"DESCENDING\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Using with a database query\n        &gt;&gt;&gt; def get_sorted_users(sort: SortDTO = SortDTO.default()):\n        ...     query = select(User)\n        ...     if sort.order == SortOrderType.ASCENDING:\n        ...         query = query.order_by(getattr(User, sort.column).asc())\n        ...     else:\n        ...         query = query.order_by(getattr(User, sort.column).desc())\n        ...     return db.execute(query).scalars().all()\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Using with enum column types\n        &gt;&gt;&gt; from enum import Enum\n        &gt;&gt;&gt; class UserColumns(Enum):\n        ...     ID = \"id\"\n        ...     NAME = \"name\"\n        ...     EMAIL = \"email\"\n        ...     CREATED_AT = \"created_at\"\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create a sort configuration with enum\n        &gt;&gt;&gt; sort = SortDTO[UserColumns](column=UserColumns.NAME, order=SortOrderType.ASCENDING)\n    \"\"\"\n\n    column: T | str = Field(default=\"created_at\", description=\"Column name or enum to sort by\")\n    order: SortOrderType = Field(default=SortOrderType.DESCENDING, description=\"Sort order (ASCENDING or DESCENDING)\")\n\n    @classmethod\n    def default(cls) -&gt; \"SortDTO\":\n        \"\"\"Create a default sort configuration.\n\n        Returns a sort configuration that orders by created_at in descending order\n        (newest first), which is a common default sorting behavior.\n\n        Returns:\n            SortDTO: A default sort configuration\n\n        Examples:\n            &gt;&gt;&gt; default_sort = SortDTO.default()\n            &gt;&gt;&gt; print(f\"Sort by {default_sort.column} {default_sort.order}\")\n            Sort by created_at DESCENDING\n        \"\"\"\n        return cls(column=\"created_at\", order=SortOrderType.DESCENDING)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.sort_dto.SortDTO.default","title":"<code>archipy.models.dtos.sort_dto.SortDTO.default()</code>  <code>classmethod</code>","text":"<p>Create a default sort configuration.</p> <p>Returns a sort configuration that orders by created_at in descending order (newest first), which is a common default sorting behavior.</p> <p>Returns:</p> Name Type Description <code>SortDTO</code> <code>SortDTO</code> <p>A default sort configuration</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; default_sort = SortDTO.default()\n&gt;&gt;&gt; print(f\"Sort by {default_sort.column} {default_sort.order}\")\nSort by created_at DESCENDING\n</code></pre> Source code in <code>archipy/models/dtos/sort_dto.py</code> <pre><code>@classmethod\ndef default(cls) -&gt; \"SortDTO\":\n    \"\"\"Create a default sort configuration.\n\n    Returns a sort configuration that orders by created_at in descending order\n    (newest first), which is a common default sorting behavior.\n\n    Returns:\n        SortDTO: A default sort configuration\n\n    Examples:\n        &gt;&gt;&gt; default_sort = SortDTO.default()\n        &gt;&gt;&gt; print(f\"Sort by {default_sort.column} {default_sort.order}\")\n        Sort by created_at DESCENDING\n    \"\"\"\n    return cls(column=\"created_at\", order=SortOrderType.DESCENDING)\n</code></pre>"},{"location":"api_reference/models/#entities_1","title":"Entities","text":""},{"location":"api_reference/models/#sqlalchemy-base-entities","title":"SQLAlchemy Base Entities","text":"<p>Base classes for SQLAlchemy entities with various mixins for different capabilities.</p> <pre><code>from archipy.models.entities.sqlalchemy.base_entities import (\n    BaseEntity,\n    UpdatableEntity,\n    DeletableEntity,\n    AdminEntity,\n    ManagerEntity,\n    UpdatableDeletableEntity,\n    ArchivableEntity,\n    UpdatableAdminEntity,\n    UpdatableManagerEntity,\n    ArchivableDeletableEntity,\n    UpdatableDeletableAdminEntity,\n    UpdatableDeletableManagerEntity,\n    ArchivableAdminEntity,\n    ArchivableManagerEntity,\n    UpdatableManagerAdminEntity,\n    ArchivableManagerAdminEntity,\n    ArchivableDeletableAdminEntity,\n    ArchivableDeletableManagerEntity,\n    UpdatableDeletableManagerAdminEntity,\n    ArchivableDeletableManagerAdminEntity\n)\nfrom sqlalchemy import Column, String\n\n# Basic entity\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n    username = Column(String(100), unique=True)\n    email = Column(String(255), unique=True)\n\n# Entity with update tracking\nclass Post(UpdatableEntity):\n    __tablename__ = \"posts\"\n    title = Column(String(200))\n    content = Column(String)\n\n# Entity with soft deletion\nclass Comment(DeletableEntity):\n    __tablename__ = \"comments\"\n    text = Column(String)\n\n# Entity with admin tracking\nclass AdminLog(AdminEntity):\n    __tablename__ = \"admin_logs\"\n    action = Column(String)\n\n# Entity with manager tracking\nclass ManagerLog(ManagerEntity):\n    __tablename__ = \"manager_logs\"\n    action = Column(String)\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.BaseEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.BaseEntity</code>","text":"<p>               Bases: <code>DeclarativeBase</code></p> <p>Base class for all SQLAlchemy models with automatic timestamps.</p> <p>This class serves as the base for all entities in the application. It provides common functionality such as automatic timestamping for <code>created_at</code> and validation for the primary key column.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class BaseEntity(DeclarativeBase):\n    \"\"\"Base class for all SQLAlchemy models with automatic timestamps.\n\n    This class serves as the base for all entities in the application. It provides\n    common functionality such as automatic timestamping for `created_at` and\n    validation for the primary key column.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n    \"\"\"\n\n    __abstract__ = True\n    created_at: Mapped[datetime] = mapped_column(DateTime(), server_default=func.now(), nullable=False)\n\n    @classmethod\n    def _is_abstract(cls) -&gt; bool:\n        \"\"\"Check if the class is abstract.\n\n        Returns:\n            bool: True if the class is abstract, False otherwise.\n        \"\"\"\n        return (not hasattr(cls, \"__tablename__\")) and cls.__abstract__\n\n    def __init_subclass__(cls, **kw: object) -&gt; None:\n        \"\"\"Validate the subclass during initialization.\n\n        Args:\n            **kw: Additional keyword arguments passed to the subclass.\n\n        Raises:\n            AttributeError: If the subclass does not have the required primary key column.\n        \"\"\"\n        if cls._is_abstract():\n            return\n        cls._validate_pk_column()\n        super().__init_subclass__(**kw)\n\n    @classmethod\n    def _validate_pk_column(cls) -&gt; None:\n        \"\"\"Validate that the subclass has the required primary key column.\n\n        Raises:\n            AttributeError: If the primary key column is missing or invalid.\n        \"\"\"\n        if not hasattr(cls, PK_COLUMN_NAME):\n            error_message = f\"Child class {cls.__name__} must have {PK_COLUMN_NAME}\"\n            raise AttributeError(error_message)\n        pk_column = getattr(cls, PK_COLUMN_NAME)\n        if not isinstance(pk_column, Synonym):\n            error_message = f\"{PK_COLUMN_NAME} must be a sqlalchemy.orm.Synonym type\"\n            raise TypeError(error_message)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.BaseEntity.__init_subclass__","title":"<code>archipy.models.entities.sqlalchemy.base_entities.BaseEntity.__init_subclass__(**kw)</code>","text":"<p>Validate the subclass during initialization.</p> <p>Parameters:</p> Name Type Description Default <code>**kw</code> <code>object</code> <p>Additional keyword arguments passed to the subclass.</p> <code>{}</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the subclass does not have the required primary key column.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>def __init_subclass__(cls, **kw: object) -&gt; None:\n    \"\"\"Validate the subclass during initialization.\n\n    Args:\n        **kw: Additional keyword arguments passed to the subclass.\n\n    Raises:\n        AttributeError: If the subclass does not have the required primary key column.\n    \"\"\"\n    if cls._is_abstract():\n        return\n    cls._validate_pk_column()\n    super().__init_subclass__(**kw)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.EntityAttributeChecker","title":"<code>archipy.models.entities.sqlalchemy.base_entities.EntityAttributeChecker</code>","text":"<p>Utility class for validating model attributes.</p> <p>This class provides functionality to ensure that at least one of the specified attributes is present in a model.</p> <p>Attributes:</p> Name Type Description <code>required_any</code> <code>list[list[str]]</code> <p>A list of lists, where each inner list contains attribute names. At least one attribute from each inner list must be present.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class EntityAttributeChecker:\n    \"\"\"Utility class for validating model attributes.\n\n    This class provides functionality to ensure that at least one of the specified\n    attributes is present in a model.\n\n    Attributes:\n        required_any: A list of lists, where each inner list contains\n            attribute names. At least one attribute from each inner list must be present.\n    \"\"\"\n\n    required_any: ClassVar[list[list[str]]] = []\n\n    @classmethod\n    def validate(cls, base_class: type) -&gt; None:\n        \"\"\"Validate that at least one of the required attributes is present.\n\n        Args:\n            base_class: The class to validate.\n\n        Raises:\n            AttributeError: If none of the required attributes are present.\n        \"\"\"\n        for attrs in cls.required_any:\n            if not any(hasattr(base_class, attr) for attr in attrs):\n                error_message = f\"One of {attrs} must be defined in {base_class.__name__}\"\n                raise AttributeError(error_message)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.EntityAttributeChecker.validate","title":"<code>archipy.models.entities.sqlalchemy.base_entities.EntityAttributeChecker.validate(base_class)</code>  <code>classmethod</code>","text":"<p>Validate that at least one of the required attributes is present.</p> <p>Parameters:</p> Name Type Description Default <code>base_class</code> <code>type</code> <p>The class to validate.</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If none of the required attributes are present.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>@classmethod\ndef validate(cls, base_class: type) -&gt; None:\n    \"\"\"Validate that at least one of the required attributes is present.\n\n    Args:\n        base_class: The class to validate.\n\n    Raises:\n        AttributeError: If none of the required attributes are present.\n    \"\"\"\n    for attrs in cls.required_any:\n        if not any(hasattr(base_class, attr) for attr in attrs):\n            error_message = f\"One of {attrs} must be defined in {base_class.__name__}\"\n            raise AttributeError(error_message)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.DeletableMixin","title":"<code>archipy.models.entities.sqlalchemy.base_entities.DeletableMixin</code>","text":"<p>Mixin to add a deletable flag to models.</p> <p>This mixin adds an <code>is_deleted</code> column to indicate whether the entity has been soft-deleted, allowing for logical deletion without physically removing records.</p> <p>Attributes:</p> Name Type Description <code>is_deleted</code> <p>Flag indicating if the entity is deleted.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class DeletableMixin:\n    \"\"\"Mixin to add a deletable flag to models.\n\n    This mixin adds an `is_deleted` column to indicate whether the entity has been\n    soft-deleted, allowing for logical deletion without physically removing records.\n\n    Attributes:\n        is_deleted: Flag indicating if the entity is deleted.\n    \"\"\"\n\n    __abstract__ = True\n    is_deleted = Column(Boolean, default=False, nullable=False)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableMixin","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableMixin</code>","text":"<p>Mixin to add updatable timestamp functionality.</p> <p>This mixin adds an <code>updated_at</code> column to track the last update time of the entity, automatically maintaining a timestamp of the most recent modification.</p> <p>Attributes:</p> Name Type Description <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class UpdatableMixin:\n    \"\"\"Mixin to add updatable timestamp functionality.\n\n    This mixin adds an `updated_at` column to track the last update time of the entity,\n    automatically maintaining a timestamp of the most recent modification.\n\n    Attributes:\n        updated_at: Timestamp indicating when the entity was last updated.\n    \"\"\"\n\n    __abstract__ = True\n\n    updated_at = Column(\n        DateTime(),\n        server_default=func.now(),\n        nullable=False,\n        onupdate=func.now(),\n    )\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ArchivableMixin","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ArchivableMixin</code>","text":"<p>Mixin to add Archivable functionality.</p> <p>This mixin adds an <code>is_archived</code> column to indicate whether the entity has been archived, and an <code>origin_uuid</code> column to reference the original entity.</p> <p>Attributes:</p> Name Type Description <code>is_archived</code> <p>Flag indicating if the entity is archived.</p> <code>origin_uuid</code> <p>Reference to the original entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class ArchivableMixin:\n    \"\"\"Mixin to add Archivable functionality.\n\n    This mixin adds an `is_archived` column to indicate whether the entity has been\n    archived, and an `origin_uuid` column to reference the original entity.\n\n    Attributes:\n        is_archived: Flag indicating if the entity is archived.\n        origin_uuid: Reference to the original entity.\n    \"\"\"\n\n    __abstract__ = True\n    is_archived = Column(Boolean, default=False, nullable=False)\n    # Using Column without Mapped is acceptable since Column works with BaseEntity.__table__\n    origin_uuid = Column(ForeignKey(\"self.pk_uuid\"), nullable=True)  # type: ignore[var-annotated]\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.AdminMixin","title":"<code>archipy.models.entities.sqlalchemy.base_entities.AdminMixin</code>","text":"<p>               Bases: <code>EntityAttributeChecker</code></p> <p>Mixin for models with admin-related attributes.</p> <p>This mixin ensures that at least one of the admin-related attributes is present, providing tracking of which administrator created the entity.</p> <p>Attributes:</p> Name Type Description <code>required_any</code> <code>list[list[str]]</code> <p>Specifies the required admin-related attributes.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class AdminMixin(EntityAttributeChecker):\n    \"\"\"Mixin for models with admin-related attributes.\n\n    This mixin ensures that at least one of the admin-related attributes is present,\n    providing tracking of which administrator created the entity.\n\n    Attributes:\n        required_any: Specifies the required admin-related attributes.\n    \"\"\"\n\n    __abstract__ = True\n    required_any: ClassVar[list[list[str]]] = [[\"created_by_admin\", \"created_by_admin_uuid\"]]\n\n    def __init_subclass__(cls, **kw: object) -&gt; None:\n        \"\"\"Validate the subclass during initialization.\n\n        Args:\n            **kw: Additional keyword arguments passed to the subclass.\n        \"\"\"\n        cls.validate(cls)\n        super().__init_subclass__(**kw)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.AdminMixin.__init_subclass__","title":"<code>archipy.models.entities.sqlalchemy.base_entities.AdminMixin.__init_subclass__(**kw)</code>","text":"<p>Validate the subclass during initialization.</p> <p>Parameters:</p> Name Type Description Default <code>**kw</code> <code>object</code> <p>Additional keyword arguments passed to the subclass.</p> <code>{}</code> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>def __init_subclass__(cls, **kw: object) -&gt; None:\n    \"\"\"Validate the subclass during initialization.\n\n    Args:\n        **kw: Additional keyword arguments passed to the subclass.\n    \"\"\"\n    cls.validate(cls)\n    super().__init_subclass__(**kw)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ManagerMixin","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ManagerMixin</code>","text":"<p>               Bases: <code>EntityAttributeChecker</code></p> <p>Mixin for models with manager-related attributes.</p> <p>This mixin ensures that at least one of the manager-related attributes is present, providing tracking of which manager created the entity.</p> <p>Attributes:</p> Name Type Description <code>required_any</code> <code>list[list[str]]</code> <p>Specifies the required manager-related attributes.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class ManagerMixin(EntityAttributeChecker):\n    \"\"\"Mixin for models with manager-related attributes.\n\n    This mixin ensures that at least one of the manager-related attributes is present,\n    providing tracking of which manager created the entity.\n\n    Attributes:\n        required_any: Specifies the required manager-related attributes.\n    \"\"\"\n\n    __abstract__ = True\n    required_any: ClassVar[list[list[str]]] = [[\"created_by\", \"created_by_uuid\"]]\n\n    def __init_subclass__(cls, **kw: object) -&gt; None:\n        \"\"\"Validate the subclass during initialization.\n\n        Args:\n            **kw: Additional keyword arguments passed to the subclass.\n        \"\"\"\n        cls.validate(cls)\n        super().__init_subclass__(**kw)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ManagerMixin.__init_subclass__","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ManagerMixin.__init_subclass__(**kw)</code>","text":"<p>Validate the subclass during initialization.</p> <p>Parameters:</p> Name Type Description Default <code>**kw</code> <code>object</code> <p>Additional keyword arguments passed to the subclass.</p> <code>{}</code> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>def __init_subclass__(cls, **kw: object) -&gt; None:\n    \"\"\"Validate the subclass during initialization.\n\n    Args:\n        **kw: Additional keyword arguments passed to the subclass.\n    \"\"\"\n    cls.validate(cls)\n    super().__init_subclass__(**kw)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableAdminMixin","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableAdminMixin</code>","text":"<p>               Bases: <code>EntityAttributeChecker</code></p> <p>Mixin for models updatable by admin.</p> <p>This mixin ensures that at least one of the admin-related update attributes is present, providing tracking of which administrator last updated the entity.</p> <p>Attributes:</p> Name Type Description <code>required_any</code> <code>list[list[str]]</code> <p>Specifies the required admin-related update attributes.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class UpdatableAdminMixin(EntityAttributeChecker):\n    \"\"\"Mixin for models updatable by admin.\n\n    This mixin ensures that at least one of the admin-related update attributes is present,\n    providing tracking of which administrator last updated the entity.\n\n    Attributes:\n        required_any: Specifies the required admin-related update attributes.\n    \"\"\"\n\n    __abstract__ = True\n    required_any: ClassVar[list[list[str]]] = [[\"updated_by_admin\", \"updated_by_admin_uuid\"]]\n\n    def __init_subclass__(cls, **kw: object) -&gt; None:\n        \"\"\"Validate the subclass during initialization.\n\n        Args:\n            **kw: Additional keyword arguments passed to the subclass.\n        \"\"\"\n        cls.validate(cls)\n        super().__init_subclass__(**kw)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableAdminMixin.__init_subclass__","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableAdminMixin.__init_subclass__(**kw)</code>","text":"<p>Validate the subclass during initialization.</p> <p>Parameters:</p> Name Type Description Default <code>**kw</code> <code>object</code> <p>Additional keyword arguments passed to the subclass.</p> <code>{}</code> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>def __init_subclass__(cls, **kw: object) -&gt; None:\n    \"\"\"Validate the subclass during initialization.\n\n    Args:\n        **kw: Additional keyword arguments passed to the subclass.\n    \"\"\"\n    cls.validate(cls)\n    super().__init_subclass__(**kw)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableManagerMixin","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableManagerMixin</code>","text":"<p>               Bases: <code>EntityAttributeChecker</code></p> <p>Mixin for models updatable by managers.</p> <p>This mixin ensures that at least one of the manager-related update attributes is present, providing tracking of which manager last updated the entity.</p> <p>Attributes:</p> Name Type Description <code>required_any</code> <code>list[list[str]]</code> <p>Specifies the required manager-related update attributes.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class UpdatableManagerMixin(EntityAttributeChecker):\n    \"\"\"Mixin for models updatable by managers.\n\n    This mixin ensures that at least one of the manager-related update attributes is present,\n    providing tracking of which manager last updated the entity.\n\n    Attributes:\n        required_any: Specifies the required manager-related update attributes.\n    \"\"\"\n\n    __abstract__ = True\n    required_any: ClassVar[list[list[str]]] = [[\"updated_by\", \"updated_by_uuid\"]]\n\n    def __init_subclass__(cls, **kw: object) -&gt; None:\n        \"\"\"Validate the subclass during initialization.\n\n        Args:\n            **kw: Additional keyword arguments passed to the subclass.\n        \"\"\"\n        cls.validate(cls)\n        super().__init_subclass__(**kw)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableManagerMixin.__init_subclass__","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableManagerMixin.__init_subclass__(**kw)</code>","text":"<p>Validate the subclass during initialization.</p> <p>Parameters:</p> Name Type Description Default <code>**kw</code> <code>object</code> <p>Additional keyword arguments passed to the subclass.</p> <code>{}</code> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>def __init_subclass__(cls, **kw: object) -&gt; None:\n    \"\"\"Validate the subclass during initialization.\n\n    Args:\n        **kw: Additional keyword arguments passed to the subclass.\n    \"\"\"\n    cls.validate(cls)\n    super().__init_subclass__(**kw)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableEntity</code>","text":"<p>               Bases: <code>BaseEntity</code>, <code>UpdatableMixin</code></p> <p>Base class for entities that support updating timestamps.</p> <p>This class extends BaseEntity with update tracking functionality, allowing applications to track when records were last modified.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class UpdatableEntity(BaseEntity, UpdatableMixin):\n    \"\"\"Base class for entities that support updating timestamps.\n\n    This class extends BaseEntity with update tracking functionality, allowing\n    applications to track when records were last modified.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.DeletableEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.DeletableEntity</code>","text":"<p>               Bases: <code>BaseEntity</code>, <code>DeletableMixin</code></p> <p>Base class for entities that support soft deletion.</p> <p>This class extends BaseEntity with soft deletion capability, allowing applications to mark records as deleted without physically removing them.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>is_deleted</code> <p>Flag indicating if the entity is deleted.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class DeletableEntity(BaseEntity, DeletableMixin):\n    \"\"\"Base class for entities that support soft deletion.\n\n    This class extends BaseEntity with soft deletion capability, allowing\n    applications to mark records as deleted without physically removing them.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        is_deleted: Flag indicating if the entity is deleted.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.AdminEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.AdminEntity</code>","text":"<p>               Bases: <code>BaseEntity</code>, <code>AdminMixin</code></p> <p>Base class for entities with admin-related attributes.</p> <p>This class extends BaseEntity with tracking of which administrator created the entity, supporting audit and accountability requirements.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>created_by_admin/created_by_admin_uuid</code> <code>Mapped[datetime]</code> <p>Reference to the admin who created the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class AdminEntity(BaseEntity, AdminMixin):\n    \"\"\"Base class for entities with admin-related attributes.\n\n    This class extends BaseEntity with tracking of which administrator created\n    the entity, supporting audit and accountability requirements.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        created_by_admin/created_by_admin_uuid: Reference to the admin who created the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ManagerEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ManagerEntity</code>","text":"<p>               Bases: <code>BaseEntity</code>, <code>ManagerMixin</code></p> <p>Base class for entities with manager-related attributes.</p> <p>This class extends BaseEntity with tracking of which manager created the entity, supporting audit and accountability requirements.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>created_by/created_by_uuid</code> <code>Mapped[datetime]</code> <p>Reference to the manager who created the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class ManagerEntity(BaseEntity, ManagerMixin):\n    \"\"\"Base class for entities with manager-related attributes.\n\n    This class extends BaseEntity with tracking of which manager created\n    the entity, supporting audit and accountability requirements.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        created_by/created_by_uuid: Reference to the manager who created the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableDeletableEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableDeletableEntity</code>","text":"<p>               Bases: <code>BaseEntity</code>, <code>UpdatableMixin</code>, <code>DeletableMixin</code></p> <p>Base class for entities that support updating timestamps and soft deletion.</p> <p>This class combines update tracking and soft deletion capabilities, providing a complete history of when records were created, updated, and deleted.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_deleted</code> <p>Flag indicating if the entity is deleted.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class UpdatableDeletableEntity(BaseEntity, UpdatableMixin, DeletableMixin):\n    \"\"\"Base class for entities that support updating timestamps and soft deletion.\n\n    This class combines update tracking and soft deletion capabilities, providing\n    a complete history of when records were created, updated, and deleted.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_deleted: Flag indicating if the entity is deleted.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ArchivableEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ArchivableEntity</code>","text":"<p>               Bases: <code>UpdatableEntity</code>, <code>ArchivableMixin</code></p> <p>Base class for entities that support archiving.</p> <p>This class extends UpdatableEntity with archiving capability, allowing applications to mark records as archived and track the original entity.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_archived</code> <p>Flag indicating if the entity is archived.</p> <code>origin_uuid</code> <p>Reference to the original entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class ArchivableEntity(UpdatableEntity, ArchivableMixin):\n    \"\"\"Base class for entities that support archiving.\n\n    This class extends UpdatableEntity with archiving capability, allowing\n    applications to mark records as archived and track the original entity.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_archived: Flag indicating if the entity is archived.\n        origin_uuid: Reference to the original entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableAdminEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableAdminEntity</code>","text":"<p>               Bases: <code>BaseEntity</code>, <code>UpdatableMixin</code>, <code>AdminMixin</code>, <code>UpdatableAdminMixin</code></p> <p>Base class for entities updatable by admin with timestamps.</p> <p>This class combines creation and update tracking for administrator actions, providing a comprehensive audit trail of administrative modifications.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>created_by_admin/created_by_admin_uuid</code> <p>Reference to the admin who created the entity.</p> <code>updated_by_admin/updated_by_admin_uuid</code> <p>Reference to the admin who last updated the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class UpdatableAdminEntity(BaseEntity, UpdatableMixin, AdminMixin, UpdatableAdminMixin):\n    \"\"\"Base class for entities updatable by admin with timestamps.\n\n    This class combines creation and update tracking for administrator actions,\n    providing a comprehensive audit trail of administrative modifications.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        created_by_admin/created_by_admin_uuid: Reference to the admin who created the entity.\n        updated_by_admin/updated_by_admin_uuid: Reference to the admin who last updated the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableManagerEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableManagerEntity</code>","text":"<p>               Bases: <code>BaseEntity</code>, <code>UpdatableMixin</code>, <code>ManagerMixin</code>, <code>UpdatableManagerMixin</code></p> <p>Base class for entities updatable by managers with timestamps.</p> <p>This class combines creation and update tracking for manager actions, providing a comprehensive audit trail of management modifications.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>created_by/created_by_uuid</code> <p>Reference to the manager who created the entity.</p> <code>updated_by/updated_by_uuid</code> <p>Reference to the manager who last updated the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class UpdatableManagerEntity(BaseEntity, UpdatableMixin, ManagerMixin, UpdatableManagerMixin):\n    \"\"\"Base class for entities updatable by managers with timestamps.\n\n    This class combines creation and update tracking for manager actions,\n    providing a comprehensive audit trail of management modifications.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        created_by/created_by_uuid: Reference to the manager who created the entity.\n        updated_by/updated_by_uuid: Reference to the manager who last updated the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ArchivableDeletableEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ArchivableDeletableEntity</code>","text":"<p>               Bases: <code>UpdatableDeletableEntity</code>, <code>ArchivableMixin</code></p> <p>Base class for entities that support both archiving and soft deletion.</p> <p>This class combines archiving and soft deletion capabilities, providing a complete history of when records were created, updated, archived, and deleted.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_deleted</code> <p>Flag indicating if the entity is deleted.</p> <code>is_archived</code> <p>Flag indicating if the entity is archived.</p> <code>origin_uuid</code> <p>Reference to the original entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class ArchivableDeletableEntity(UpdatableDeletableEntity, ArchivableMixin):\n    \"\"\"Base class for entities that support both archiving and soft deletion.\n\n    This class combines archiving and soft deletion capabilities, providing\n    a complete history of when records were created, updated, archived, and deleted.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_deleted: Flag indicating if the entity is deleted.\n        is_archived: Flag indicating if the entity is archived.\n        origin_uuid: Reference to the original entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableDeletableAdminEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableDeletableAdminEntity</code>","text":"<p>               Bases: <code>BaseEntity</code>, <code>UpdatableMixin</code>, <code>AdminMixin</code>, <code>UpdatableAdminMixin</code>, <code>DeletableMixin</code></p> <p>Base class for entities updatable by admin with timestamps and soft deletion.</p> <p>This class combines administrator creation and update tracking with soft deletion, providing a complete audit trail throughout the entity's lifecycle.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_deleted</code> <p>Flag indicating if the entity is deleted.</p> <code>created_by_admin/created_by_admin_uuid</code> <p>Reference to the admin who created the entity.</p> <code>updated_by_admin/updated_by_admin_uuid</code> <p>Reference to the admin who last updated the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class UpdatableDeletableAdminEntity(BaseEntity, UpdatableMixin, AdminMixin, UpdatableAdminMixin, DeletableMixin):\n    \"\"\"Base class for entities updatable by admin with timestamps and soft deletion.\n\n    This class combines administrator creation and update tracking with soft deletion,\n    providing a complete audit trail throughout the entity's lifecycle.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_deleted: Flag indicating if the entity is deleted.\n        created_by_admin/created_by_admin_uuid: Reference to the admin who created the entity.\n        updated_by_admin/updated_by_admin_uuid: Reference to the admin who last updated the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableDeletableManagerEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableDeletableManagerEntity</code>","text":"<p>               Bases: <code>BaseEntity</code>, <code>UpdatableMixin</code>, <code>ManagerMixin</code>, <code>UpdatableManagerMixin</code>, <code>DeletableMixin</code></p> <p>Base class for entities updatable by managers with timestamps and soft deletion.</p> <p>This class combines manager creation and update tracking with soft deletion, providing a complete audit trail throughout the entity's lifecycle.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_deleted</code> <p>Flag indicating if the entity is deleted.</p> <code>created_by/created_by_uuid</code> <p>Reference to the manager who created the entity.</p> <code>updated_by/updated_by_uuid</code> <p>Reference to the manager who last updated the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class UpdatableDeletableManagerEntity(BaseEntity, UpdatableMixin, ManagerMixin, UpdatableManagerMixin, DeletableMixin):\n    \"\"\"Base class for entities updatable by managers with timestamps and soft deletion.\n\n    This class combines manager creation and update tracking with soft deletion,\n    providing a complete audit trail throughout the entity's lifecycle.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_deleted: Flag indicating if the entity is deleted.\n        created_by/created_by_uuid: Reference to the manager who created the entity.\n        updated_by/updated_by_uuid: Reference to the manager who last updated the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ArchivableAdminEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ArchivableAdminEntity</code>","text":"<p>               Bases: <code>ArchivableEntity</code>, <code>AdminMixin</code></p> <p>Base class for entities Archivable by admin.</p> <p>This class extends ArchivableEntity with tracking of which administrator created the entity, supporting audit and accountability requirements.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_archived</code> <p>Flag indicating if the entity is archived.</p> <code>origin_uuid</code> <p>Reference to the original entity.</p> <code>created_by_admin/created_by_admin_uuid</code> <p>Reference to the admin who created the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class ArchivableAdminEntity(ArchivableEntity, AdminMixin):\n    \"\"\"Base class for entities Archivable by admin.\n\n    This class extends ArchivableEntity with tracking of which administrator created\n    the entity, supporting audit and accountability requirements.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_archived: Flag indicating if the entity is archived.\n        origin_uuid: Reference to the original entity.\n        created_by_admin/created_by_admin_uuid: Reference to the admin who created the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ArchivableManagerEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ArchivableManagerEntity</code>","text":"<p>               Bases: <code>ArchivableEntity</code>, <code>ManagerMixin</code></p> <p>Base class for entities Archivable by managers.</p> <p>This class extends ArchivableEntity with tracking of which manager created the entity, supporting audit and accountability requirements.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_archived</code> <p>Flag indicating if the entity is archived.</p> <code>origin_uuid</code> <p>Reference to the original entity.</p> <code>created_by/created_by_uuid</code> <p>Reference to the manager who created the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class ArchivableManagerEntity(ArchivableEntity, ManagerMixin):\n    \"\"\"Base class for entities Archivable by managers.\n\n    This class extends ArchivableEntity with tracking of which manager created\n    the entity, supporting audit and accountability requirements.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_archived: Flag indicating if the entity is archived.\n        origin_uuid: Reference to the original entity.\n        created_by/created_by_uuid: Reference to the manager who created the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableManagerAdminEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableManagerAdminEntity</code>","text":"<p>               Bases: <code>BaseEntity</code>, <code>UpdatableMixin</code>, <code>ManagerMixin</code>, <code>AdminMixin</code>, <code>UpdatableManagerMixin</code>, <code>UpdatableAdminMixin</code></p> <p>Base class for entities updatable by both managers and admins with timestamps.</p> <p>This class provides comprehensive tracking of entity creation and updates by both administrators and managers, supporting complex workflows where different user roles interact with the same data.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>created_by_admin/created_by_admin_uuid</code> <p>Reference to the admin who created the entity.</p> <code>created_by/created_by_uuid</code> <p>Reference to the manager who created the entity.</p> <code>updated_by_admin/updated_by_admin_uuid</code> <p>Reference to the admin who last updated the entity.</p> <code>updated_by/updated_by_uuid</code> <p>Reference to the manager who last updated the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class UpdatableManagerAdminEntity(\n    BaseEntity,\n    UpdatableMixin,\n    ManagerMixin,\n    AdminMixin,\n    UpdatableManagerMixin,\n    UpdatableAdminMixin,\n):\n    \"\"\"Base class for entities updatable by both managers and admins with timestamps.\n\n    This class provides comprehensive tracking of entity creation and updates\n    by both administrators and managers, supporting complex workflows where\n    different user roles interact with the same data.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        created_by_admin/created_by_admin_uuid: Reference to the admin who created the entity.\n        created_by/created_by_uuid: Reference to the manager who created the entity.\n        updated_by_admin/updated_by_admin_uuid: Reference to the admin who last updated the entity.\n        updated_by/updated_by_uuid: Reference to the manager who last updated the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ArchivableManagerAdminEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ArchivableManagerAdminEntity</code>","text":"<p>               Bases: <code>ArchivableEntity</code>, <code>ManagerMixin</code>, <code>AdminMixin</code></p> <p>Base class for entities Archivable by both managers and admins.</p> <p>This class provides comprehensive tracking of entity creation by both administrators and managers, supporting complex workflows where different user roles interact with the same data.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_archived</code> <p>Flag indicating if the entity is archived.</p> <code>origin_uuid</code> <p>Reference to the original entity.</p> <code>created_by_admin/created_by_admin_uuid</code> <p>Reference to the admin who created the entity.</p> <code>created_by/created_by_uuid</code> <p>Reference to the manager who created the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class ArchivableManagerAdminEntity(\n    ArchivableEntity,\n    ManagerMixin,\n    AdminMixin,\n):\n    \"\"\"Base class for entities Archivable by both managers and admins.\n\n    This class provides comprehensive tracking of entity creation\n    by both administrators and managers, supporting complex workflows where\n    different user roles interact with the same data.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_archived: Flag indicating if the entity is archived.\n        origin_uuid: Reference to the original entity.\n        created_by_admin/created_by_admin_uuid: Reference to the admin who created the entity.\n        created_by/created_by_uuid: Reference to the manager who created the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ArchivableDeletableAdminEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ArchivableDeletableAdminEntity</code>","text":"<p>               Bases: <code>ArchivableDeletableEntity</code>, <code>AdminMixin</code></p> <p>Base class for entities Archivable and deletable by admin.</p> <p>This class combines administrator creation tracking with soft deletion and archiving, providing a complete audit trail throughout the entity's lifecycle.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_deleted</code> <p>Flag indicating if the entity is deleted.</p> <code>is_archived</code> <p>Flag indicating if the entity is archived.</p> <code>origin_uuid</code> <p>Reference to the original entity.</p> <code>created_by_admin/created_by_admin_uuid</code> <p>Reference to the admin who created the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class ArchivableDeletableAdminEntity(ArchivableDeletableEntity, AdminMixin):\n    \"\"\"Base class for entities Archivable and deletable by admin.\n\n    This class combines administrator creation tracking with soft deletion and archiving,\n    providing a complete audit trail throughout the entity's lifecycle.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_deleted: Flag indicating if the entity is deleted.\n        is_archived: Flag indicating if the entity is archived.\n        origin_uuid: Reference to the original entity.\n        created_by_admin/created_by_admin_uuid: Reference to the admin who created the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ArchivableDeletableManagerEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ArchivableDeletableManagerEntity</code>","text":"<p>               Bases: <code>ArchivableDeletableEntity</code>, <code>ManagerMixin</code></p> <p>Base class for entities Archivable and deletable by managers.</p> <p>This class combines manager creation tracking with soft deletion and archiving, providing a complete audit trail throughout the entity's lifecycle.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_deleted</code> <p>Flag indicating if the entity is deleted.</p> <code>is_archived</code> <p>Flag indicating if the entity is archived.</p> <code>origin_uuid</code> <p>Reference to the original entity.</p> <code>created_by/created_by_uuid</code> <p>Reference to the manager who created the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class ArchivableDeletableManagerEntity(ArchivableDeletableEntity, ManagerMixin):\n    \"\"\"Base class for entities Archivable and deletable by managers.\n\n    This class combines manager creation tracking with soft deletion and archiving,\n    providing a complete audit trail throughout the entity's lifecycle.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_deleted: Flag indicating if the entity is deleted.\n        is_archived: Flag indicating if the entity is archived.\n        origin_uuid: Reference to the original entity.\n        created_by/created_by_uuid: Reference to the manager who created the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableDeletableManagerAdminEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableDeletableManagerAdminEntity</code>","text":"<p>               Bases: <code>BaseEntity</code>, <code>UpdatableMixin</code>, <code>ManagerMixin</code>, <code>AdminMixin</code>, <code>UpdatableManagerMixin</code>, <code>UpdatableAdminMixin</code>, <code>DeletableMixin</code></p> <p>Base class for entities updatable by both managers and admins with timestamps and soft deletion.</p> <p>This is the most comprehensive entity class, supporting tracking of creation and updates by both administrators and managers, along with soft deletion capability. It provides complete accountability for all operations throughout the entity's lifecycle.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_deleted</code> <p>Flag indicating if the entity is deleted.</p> <code>created_by_admin/created_by_admin_uuid</code> <p>Reference to the admin who created the entity.</p> <code>created_by/created_by_uuid</code> <p>Reference to the manager who created the entity.</p> <code>updated_by_admin/updated_by_admin_uuid</code> <p>Reference to the admin who last updated the entity.</p> <code>updated_by/updated_by_uuid</code> <p>Reference to the manager who last updated the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class UpdatableDeletableManagerAdminEntity(\n    BaseEntity,\n    UpdatableMixin,\n    ManagerMixin,\n    AdminMixin,\n    UpdatableManagerMixin,\n    UpdatableAdminMixin,\n    DeletableMixin,\n):\n    \"\"\"Base class for entities updatable by both managers and admins with timestamps and soft deletion.\n\n    This is the most comprehensive entity class, supporting tracking of creation and\n    updates by both administrators and managers, along with soft deletion capability.\n    It provides complete accountability for all operations throughout the entity's lifecycle.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_deleted: Flag indicating if the entity is deleted.\n        created_by_admin/created_by_admin_uuid: Reference to the admin who created the entity.\n        created_by/created_by_uuid: Reference to the manager who created the entity.\n        updated_by_admin/updated_by_admin_uuid: Reference to the admin who last updated the entity.\n        updated_by/updated_by_uuid: Reference to the manager who last updated the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ArchivableDeletableManagerAdminEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ArchivableDeletableManagerAdminEntity</code>","text":"<p>               Bases: <code>ArchivableDeletableEntity</code>, <code>ManagerMixin</code>, <code>AdminMixin</code></p> <p>Base class for entities Archivable and deletable by both managers and admins.</p> <p>This is a comprehensive entity class, supporting tracking of creation by both administrators and managers, along with soft deletion and archiving capability. It provides complete accountability for all operations throughout the entity's lifecycle.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_deleted</code> <p>Flag indicating if the entity is deleted.</p> <code>is_archived</code> <p>Flag indicating if the entity is archived.</p> <code>origin_uuid</code> <p>Reference to the original entity.</p> <code>created_by_admin/created_by_admin_uuid</code> <p>Reference to the admin who created the entity.</p> <code>created_by/created_by_uuid</code> <p>Reference to the manager who created the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class ArchivableDeletableManagerAdminEntity(\n    ArchivableDeletableEntity,\n    ManagerMixin,\n    AdminMixin,\n):\n    \"\"\"Base class for entities Archivable and deletable by both managers and admins.\n\n    This is a comprehensive entity class, supporting tracking of creation\n    by both administrators and managers, along with soft deletion and archiving capability.\n    It provides complete accountability for all operations throughout the entity's lifecycle.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_deleted: Flag indicating if the entity is deleted.\n        is_archived: Flag indicating if the entity is archived.\n        origin_uuid: Reference to the original entity.\n        created_by_admin/created_by_admin_uuid: Reference to the admin who created the entity.\n        created_by/created_by_uuid: Reference to the manager who created the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#errors_1","title":"Errors","text":"<p>The error handling system is organized into several categories, each handling specific types of errors:</p>"},{"location":"api_reference/models/#authentication-errors","title":"Authentication Errors","text":"<p>Handles authentication and authorization related errors.</p> <pre><code>from archipy.models.errors import (\n    UnauthenticatedError,\n    InvalidCredentialsError,\n    TokenExpiredError,\n    InvalidTokenError,\n    SessionExpiredError,\n    PermissionDeniedError,\n    AccountLockedError,\n    AccountDisabledError,\n    InvalidVerificationCodeError\n)\n\n# Example: Handle invalid credentials\ntry:\n    authenticate_user(username, password)\nexcept InvalidCredentialsError as e:\n    logger.warning(f\"Failed login attempt: {e}\")\n</code></pre>"},{"location":"api_reference/models/#validation-errors","title":"Validation Errors","text":"<p>Handles input validation and format errors.</p> <pre><code>from archipy.models.errors import (\n    InvalidArgumentError,\n    InvalidFormatError,\n    InvalidEmailError,\n    InvalidPhoneNumberError,\n    InvalidLandlineNumberError,\n    InvalidNationalCodeError,\n    InvalidPasswordError,\n    InvalidDateError,\n    InvalidUrlError,\n    InvalidIpError,\n    InvalidJsonError,\n    InvalidTimestampError,\n    OutOfRangeError\n)\n\n# Example: Validate user input\ntry:\n    validate_user_input(email, phone)\nexcept InvalidEmailError as e:\n    return {\"error\": e.to_dict()}\n</code></pre>"},{"location":"api_reference/models/#resource-errors","title":"Resource Errors","text":"<p>Handles resource and data management errors.</p> <pre><code>from archipy.models.errors import (\n    NotFoundError,\n    AlreadyExistsError,\n    ConflictError,\n    ResourceLockedError,\n    ResourceBusyError,\n    DataLossError,\n    InvalidEntityTypeError,\n    FileTooLargeError,\n    InvalidFileTypeError,\n    QuotaExceededError\n)\n\n# Example: Handle resource not found\ntry:\n    user = get_user(user_id)\nexcept NotFoundError as e:\n    return {\"error\": e.to_dict()}\n</code></pre>"},{"location":"api_reference/models/#network-errors","title":"Network Errors","text":"<p>Handles network and communication errors.</p> <pre><code>from archipy.models.errors import (\n    NetworkError,\n    ConnectionTimeoutError,\n    ServiceUnavailableError,\n    GatewayTimeoutError,\n    BadGatewayError,\n    RateLimitExceededError\n)\n\n# Example: Handle network issues\ntry:\n    response = make_api_request()\nexcept ConnectionTimeoutError as e:\n    logger.error(f\"Connection timeout: {e}\")\n</code></pre>"},{"location":"api_reference/models/#business-errors","title":"Business Errors","text":"<p>Handles business logic and operation errors.</p> <pre><code>from archipy.models.errors import (\n    InvalidStateError,\n    BusinessRuleViolationError,\n    InvalidOperationError,\n    InsufficientFundsError,\n    InsufficientBalanceError,\n    MaintenanceModeError,\n    FailedPreconditionError\n)\n\n# Example: Handle business rule violation\ntry:\n    process_transaction(amount)\nexcept InsufficientFundsError as e:\n    return {\"error\": e.to_dict()}\n</code></pre>"},{"location":"api_reference/models/#database-errors","title":"Database Errors","text":"<p>Handles database and storage related errors.</p> <pre><code>from archipy.models.errors import (\n    DatabaseConnectionError,\n    DatabaseQueryError,\n    DatabaseTransactionError,\n    StorageError,\n    CacheError,\n    CacheMissError\n)\n\n# Example: Handle database errors\ntry:\n    save_to_database(data)\nexcept DatabaseConnectionError as e:\n    logger.error(f\"Database connection failed: {e}\")\n</code></pre>"},{"location":"api_reference/models/#system-errors","title":"System Errors","text":"<p>Handles system and internal errors.</p> <pre><code>from archipy.models.errors import (\n    InternalError,\n    ConfigurationError,\n    ResourceExhaustedError,\n    UnavailableError,\n    UnknownError,\n    AbortedError,\n    DeadlockDetectedError\n)\n\n# Example: Handle system errors\ntry:\n    process_request()\nexcept DeadlockDetectedError as e:\n    logger.error(f\"Deadlock detected: {e}\")\n    # Implement retry logic\n</code></pre> <p>Error handling module for the application.</p> <p>This module provides a comprehensive set of custom exceptions for handling various error scenarios in the application, organized by category.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.errors.AccountDisabledError","title":"<code>archipy.models.errors.AccountDisabledError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when an account is disabled.</p> Source code in <code>archipy/models/errors/auth_errors.py</code> <pre><code>class AccountDisabledError(BaseError):\n    \"\"\"Exception raised when an account is disabled.\"\"\"\n\n    def __init__(\n        self,\n        username: str | None = None,\n        reason: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.ACCOUNT_DISABLED.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if username:\n            data[\"username\"] = username\n        if reason:\n            data[\"reason\"] = reason\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.AccountLockedError","title":"<code>archipy.models.errors.AccountLockedError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when an account is locked.</p> Source code in <code>archipy/models/errors/auth_errors.py</code> <pre><code>class AccountLockedError(BaseError):\n    \"\"\"Exception raised when an account is locked.\"\"\"\n\n    def __init__(\n        self,\n        username: str | None = None,\n        lockout_duration: int | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.ACCOUNT_LOCKED.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if username:\n            data[\"username\"] = username\n        if lockout_duration:\n            data[\"lockout_duration\"] = lockout_duration\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidCredentialsError","title":"<code>archipy.models.errors.InvalidCredentialsError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid credentials.</p> Source code in <code>archipy/models/errors/auth_errors.py</code> <pre><code>class InvalidCredentialsError(BaseError):\n    \"\"\"Exception raised for invalid credentials.\"\"\"\n\n    def __init__(\n        self,\n        username: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_CREDENTIALS.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"username\": username} if username else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidTokenError","title":"<code>archipy.models.errors.InvalidTokenError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a token is invalid.</p> Source code in <code>archipy/models/errors/auth_errors.py</code> <pre><code>class InvalidTokenError(BaseError):\n    \"\"\"Exception raised when a token is invalid.\"\"\"\n\n    def __init__(\n        self,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_TOKEN.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(error, lang, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidVerificationCodeError","title":"<code>archipy.models.errors.InvalidVerificationCodeError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a verification code is invalid.</p> Source code in <code>archipy/models/errors/auth_errors.py</code> <pre><code>class InvalidVerificationCodeError(BaseError):\n    \"\"\"Exception raised when a verification code is invalid.\"\"\"\n\n    def __init__(\n        self,\n        code: str | None = None,\n        remaining_attempts: int | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_VERIFICATION_CODE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if code:\n            data[\"code\"] = code\n        if remaining_attempts is not None:\n            data[\"remaining_attempts\"] = remaining_attempts\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.PermissionDeniedError","title":"<code>archipy.models.errors.PermissionDeniedError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when permission is denied.</p> Source code in <code>archipy/models/errors/auth_errors.py</code> <pre><code>class PermissionDeniedError(BaseError):\n    \"\"\"Exception raised when permission is denied.\"\"\"\n\n    def __init__(\n        self,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.PERMISSION_DENIED.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(error, lang, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.SessionExpiredError","title":"<code>archipy.models.errors.SessionExpiredError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a session has expired.</p> Source code in <code>archipy/models/errors/auth_errors.py</code> <pre><code>class SessionExpiredError(BaseError):\n    \"\"\"Exception raised when a session has expired.\"\"\"\n\n    def __init__(\n        self,\n        session_id: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.SESSION_EXPIRED.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"session_id\": session_id} if session_id else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.TokenExpiredError","title":"<code>archipy.models.errors.TokenExpiredError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a token has expired.</p> Source code in <code>archipy/models/errors/auth_errors.py</code> <pre><code>class TokenExpiredError(BaseError):\n    \"\"\"Exception raised when a token has expired.\"\"\"\n\n    def __init__(\n        self,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.TOKEN_EXPIRED.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(error, lang, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.UnauthenticatedError","title":"<code>archipy.models.errors.UnauthenticatedError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a user is unauthenticated.</p> Source code in <code>archipy/models/errors/auth_errors.py</code> <pre><code>class UnauthenticatedError(BaseError):\n    \"\"\"Exception raised when a user is unauthenticated.\"\"\"\n\n    def __init__(\n        self,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.UNAUTHENTICATED.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(error, lang, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.BaseError","title":"<code>archipy.models.errors.BaseError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception class for all custom errors.</p> <p>This class provides a standardized way to handle errors with support for: - Localization of error messages - Additional context data - Integration with HTTP and gRPC status codes</p> <p>Attributes:</p> Name Type Description <code>http_status_code</code> <code>ClassVar[int]</code> <p>HTTP status code for the error.</p> <code>grpc_status_code</code> <code>ClassVar[int | StatusCode]</code> <p>gRPC status code for the error.</p> Source code in <code>archipy/models/errors/base_error.py</code> <pre><code>class BaseError(Exception):\n    \"\"\"Base exception class for all custom errors.\n\n    This class provides a standardized way to handle errors with support for:\n    - Localization of error messages\n    - Additional context data\n    - Integration with HTTP and gRPC status codes\n\n    Attributes:\n        http_status_code (ClassVar[int]): HTTP status code for the error.\n        grpc_status_code (ClassVar[int | \"grpc.StatusCode\"]): gRPC status code for the error.\n    \"\"\"\n\n    http_status_code: ClassVar[int] = 500\n    grpc_status_code: ClassVar[int] = grpc.StatusCode.INTERNAL if grpc else 13\n\n    def __init__(\n        self,\n        error: ErrorDetailDTO | ErrorMessageType | None = None,\n        lang: LanguageType | None = None,\n        additional_data: dict[str, Any] | None = None,\n        *args: object,\n    ) -&gt; None:\n        \"\"\"Initialize the error with message and optional context.\n\n        Args:\n            error: The error detail or message. Can be:\n                - ErrorDetail: Direct error detail object\n                - ExceptionMessageType: Enum member containing error detail\n                - None: Will use UNKNOWN_ERROR\n            lang: Language code for the error message (defaults to Persian).\n            additional_data: Additional context data for the error.\n            *args: Additional arguments for the base Exception class.\n        \"\"\"\n        if isinstance(error, ErrorMessageType):\n            self.error_detail = error.value\n        elif isinstance(error, ErrorDetailDTO):\n            self.error_detail = error\n        else:\n            self.error_detail = ErrorMessageType.UNKNOWN_ERROR.value\n\n        if lang is None:\n            try:\n                from archipy.configs.base_config import BaseConfig\n\n                self.lang = BaseConfig.global_config().LANGUAGE\n            except (ImportError, AssertionError):\n                from archipy.models.types.language_type import LanguageType\n\n                self.lang = LanguageType.FA\n        else:\n            self.lang = lang\n\n        self.additional_data = additional_data or {}\n\n        # Initialize base Exception with the message\n        super().__init__(self.get_message(), *args)\n\n    def get_message(self) -&gt; str:\n        \"\"\"Gets the localized error message based on the language setting.\n\n        Returns:\n            str: The error message in the current language.\n        \"\"\"\n        return self.error_detail.message_fa if self.lang == LanguageType.FA else self.error_detail.message_en\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Converts the exception to a dictionary format for API responses.\n\n        Returns:\n            dict: A dictionary containing error details and additional data.\n        \"\"\"\n        response = {\n            \"error\": self.error_detail.code,\n            \"detail\": self.error_detail.model_dump(mode=\"json\", exclude_none=True),\n        }\n\n        # Add additional data if present\n        detail = response[\"detail\"]\n        if isinstance(detail, dict) and self.additional_data:\n            detail.update(self.additional_data)\n\n        return response\n\n    @property\n    def http_status_code_value(self) -&gt; int | None:\n        \"\"\"Gets the HTTP status code if HTTP support is available.\n\n        Returns:\n            Optional[int]: The HTTP status code or None if HTTP is not available.\n        \"\"\"\n        return self.error_detail.http_status if HTTP_AVAILABLE else None\n\n    @property\n    def grpc_status_code_value(self) -&gt; int | None:\n        \"\"\"Gets the gRPC status code if gRPC support is available.\n\n        Returns:\n            Optional[int]: The gRPC status code or None if gRPC is not available.\n        \"\"\"\n        return self.error_detail.grpc_status if GRPC_AVAILABLE else None\n\n    def __str__(self) -&gt; str:\n        \"\"\"String representation of the exception.\n\n        Returns:\n            str: A formatted string containing the error code and message.\n        \"\"\"\n        return f\"[{self.error_detail.code}] {self.get_message()}\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Detailed string representation of the exception.\n\n        Returns:\n            str: A detailed string representation including all error details.\n        \"\"\"\n        return (\n            f\"{self.__class__.__name__}(\"\n            f\"code='{self.error_detail.code}', \"\n            f\"message='{self.get_message()}', \"\n            f\"http_status={self.http_status_code_value}, \"\n            f\"grpc_status={self.grpc_status_code_value}, \"\n            f\"additional_data={self.additional_data}\"\n            f\")\"\n        )\n\n    @property\n    def code(self) -&gt; str:\n        \"\"\"Gets the error code.\n\n        Returns:\n            str: The error code.\n        \"\"\"\n        return self.error_detail.code\n\n    @property\n    def message(self) -&gt; str:\n        \"\"\"Gets the current language message.\n\n        Returns:\n            str: The error message in the current language.\n        \"\"\"\n        return self.get_message()\n\n    @property\n    def message_en(self) -&gt; str:\n        \"\"\"Gets the English message.\n\n        Returns:\n            str: The English error message.\n        \"\"\"\n        return self.error_detail.message_en\n\n    @property\n    def message_fa(self) -&gt; str:\n        \"\"\"Gets the Persian message.\n\n        Returns:\n            str: The Persian error message.\n        \"\"\"\n        return self.error_detail.message_fa\n\n    @staticmethod\n    def _convert_int_to_grpc_status(status_int: int) -&gt; \"grpc.StatusCode\":\n        \"\"\"Convert integer status code to gRPC StatusCode enum.\n\n        Args:\n            status_int: Integer status code\n\n        Returns:\n            grpc.StatusCode: Corresponding StatusCode enum member\n        \"\"\"\n        status_map = {\n            0: grpc.StatusCode.OK,\n            1: grpc.StatusCode.CANCELLED,\n            2: grpc.StatusCode.UNKNOWN,\n            3: grpc.StatusCode.INVALID_ARGUMENT,\n            4: grpc.StatusCode.DEADLINE_EXCEEDED,\n            5: grpc.StatusCode.NOT_FOUND,\n            6: grpc.StatusCode.ALREADY_EXISTS,\n            7: grpc.StatusCode.PERMISSION_DENIED,\n            8: grpc.StatusCode.RESOURCE_EXHAUSTED,\n            9: grpc.StatusCode.FAILED_PRECONDITION,\n            10: grpc.StatusCode.ABORTED,\n            11: grpc.StatusCode.OUT_OF_RANGE,\n            12: grpc.StatusCode.UNIMPLEMENTED,\n            13: grpc.StatusCode.INTERNAL,\n            14: grpc.StatusCode.UNAVAILABLE,\n            15: grpc.StatusCode.DATA_LOSS,\n            16: grpc.StatusCode.UNAUTHENTICATED,\n        }\n\n        return status_map.get(status_int, grpc.StatusCode.INTERNAL)\n\n    def _get_grpc_status_code(self) -&gt; \"grpc.StatusCode\":\n        \"\"\"Gets the proper gRPC status code for this error.\n\n        Returns:\n            grpc.StatusCode: The gRPC status code enum.\n        \"\"\"\n        if self.grpc_status_code_value is not None:\n            return self._convert_int_to_grpc_status(self.grpc_status_code_value)\n\n        if hasattr(self.__class__, \"grpc_status_code\"):\n            status_code = self.__class__.grpc_status_code\n\n            if isinstance(status_code, grpc.StatusCode):\n                return status_code\n\n            if isinstance(status_code, int):\n                return self._convert_int_to_grpc_status(status_code)\n\n        return grpc.StatusCode.INTERNAL\n\n    async def abort_grpc_async(self, context: AsyncServicerContext) -&gt; None:\n        \"\"\"Aborts an async gRPC call with the appropriate status code and message.\n\n        Args:\n            context: The gRPC ServicerContext to abort.\n\n        Raises:\n            ValueError: If context is None or doesn't have abort method.\n        \"\"\"\n        if context is None:\n            raise ValueError(\"gRPC context cannot be None\")\n\n        if not GRPC_AVAILABLE or not hasattr(context, \"abort\"):\n            raise ValueError(\"Invalid gRPC context: missing abort method\")\n\n        status_code = self._get_grpc_status_code()\n        message = self.get_message()\n\n        if self.additional_data:\n            context.set_trailing_metadata([(\"additional_data\", json.dumps(self.additional_data))])\n\n        await context.abort(status_code, message)\n\n    def abort_grpc_sync(self, context: ServicerContext) -&gt; None:\n        \"\"\"Aborts a sync gRPC call with the appropriate status code and message.\n\n        Args:\n            context: The gRPC ServicerContext to abort.\n\n        Raises:\n            ValueError: If context is None or doesn't have abort method.\n        \"\"\"\n        if context is None:\n            raise ValueError(\"gRPC context cannot be None\")\n\n        if not GRPC_AVAILABLE or not hasattr(context, \"abort\"):\n            raise ValueError(\"Invalid gRPC context: missing abort method\")\n\n        status_code = self._get_grpc_status_code()\n        if status_code is None:\n            raise ValueError(\"gRPC is not available\")\n\n        message = self.get_message()\n\n        if self.additional_data:\n            context.set_trailing_metadata([(\"additional_data\", json.dumps(self.additional_data))])\n\n        context.abort(status_code, message)\n\n    @classmethod\n    async def abort_with_error_async(\n        cls,\n        context: AsyncServicerContext,\n        error: ErrorDetailDTO | ErrorMessageType | None = None,\n        lang: LanguageType | None = None,\n        additional_data: dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"Creates an error instance and immediately aborts the async gRPC context.\n\n        Args:\n            context: The async gRPC ServicerContext to abort.\n            error: The error detail or message type.\n            lang: Language code for the error message.\n            additional_data: Additional context data for the error.\n\n        Raises:\n            ValueError: If context is None or invalid.\n        \"\"\"\n        instance = cls(error=error, lang=lang, additional_data=additional_data)\n        await instance.abort_grpc_async(context)\n\n    @classmethod\n    def abort_with_error_sync(\n        cls,\n        context: ServicerContext,\n        error: ErrorDetailDTO | ErrorMessageType | None = None,\n        lang: LanguageType | None = None,\n        additional_data: dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"Creates an error instance and immediately aborts the sync gRPC context.\n\n        Args:\n            context: The sync gRPC ServicerContext to abort.\n            error: The error detail or message type.\n            lang: Language code for the error message.\n            additional_data: Additional context data for the error.\n\n        Raises:\n            ValueError: If context is None or invalid.\n        \"\"\"\n        instance = cls(error=error, lang=lang, additional_data=additional_data)\n        instance.abort_grpc_sync(context)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.http_status_code_value","title":"<code>archipy.models.errors.BaseError.http_status_code_value</code>  <code>property</code>","text":"<p>Gets the HTTP status code if HTTP support is available.</p> <p>Returns:</p> Type Description <code>int | None</code> <p>Optional[int]: The HTTP status code or None if HTTP is not available.</p>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.grpc_status_code_value","title":"<code>archipy.models.errors.BaseError.grpc_status_code_value</code>  <code>property</code>","text":"<p>Gets the gRPC status code if gRPC support is available.</p> <p>Returns:</p> Type Description <code>int | None</code> <p>Optional[int]: The gRPC status code or None if gRPC is not available.</p>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.code","title":"<code>archipy.models.errors.BaseError.code</code>  <code>property</code>","text":"<p>Gets the error code.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The error code.</p>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.message","title":"<code>archipy.models.errors.BaseError.message</code>  <code>property</code>","text":"<p>Gets the current language message.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The error message in the current language.</p>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.message_en","title":"<code>archipy.models.errors.BaseError.message_en</code>  <code>property</code>","text":"<p>Gets the English message.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The English error message.</p>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.message_fa","title":"<code>archipy.models.errors.BaseError.message_fa</code>  <code>property</code>","text":"<p>Gets the Persian message.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The Persian error message.</p>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.__init__","title":"<code>archipy.models.errors.BaseError.__init__(error=None, lang=None, additional_data=None, *args)</code>","text":"<p>Initialize the error with message and optional context.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>ErrorDetailDTO | ErrorMessageType | None</code> <p>The error detail or message. Can be: - ErrorDetail: Direct error detail object - ExceptionMessageType: Enum member containing error detail - None: Will use UNKNOWN_ERROR</p> <code>None</code> <code>lang</code> <code>LanguageType | None</code> <p>Language code for the error message (defaults to Persian).</p> <code>None</code> <code>additional_data</code> <code>dict[str, Any] | None</code> <p>Additional context data for the error.</p> <code>None</code> <code>*args</code> <code>object</code> <p>Additional arguments for the base Exception class.</p> <code>()</code> Source code in <code>archipy/models/errors/base_error.py</code> <pre><code>def __init__(\n    self,\n    error: ErrorDetailDTO | ErrorMessageType | None = None,\n    lang: LanguageType | None = None,\n    additional_data: dict[str, Any] | None = None,\n    *args: object,\n) -&gt; None:\n    \"\"\"Initialize the error with message and optional context.\n\n    Args:\n        error: The error detail or message. Can be:\n            - ErrorDetail: Direct error detail object\n            - ExceptionMessageType: Enum member containing error detail\n            - None: Will use UNKNOWN_ERROR\n        lang: Language code for the error message (defaults to Persian).\n        additional_data: Additional context data for the error.\n        *args: Additional arguments for the base Exception class.\n    \"\"\"\n    if isinstance(error, ErrorMessageType):\n        self.error_detail = error.value\n    elif isinstance(error, ErrorDetailDTO):\n        self.error_detail = error\n    else:\n        self.error_detail = ErrorMessageType.UNKNOWN_ERROR.value\n\n    if lang is None:\n        try:\n            from archipy.configs.base_config import BaseConfig\n\n            self.lang = BaseConfig.global_config().LANGUAGE\n        except (ImportError, AssertionError):\n            from archipy.models.types.language_type import LanguageType\n\n            self.lang = LanguageType.FA\n    else:\n        self.lang = lang\n\n    self.additional_data = additional_data or {}\n\n    # Initialize base Exception with the message\n    super().__init__(self.get_message(), *args)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.get_message","title":"<code>archipy.models.errors.BaseError.get_message()</code>","text":"<p>Gets the localized error message based on the language setting.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The error message in the current language.</p> Source code in <code>archipy/models/errors/base_error.py</code> <pre><code>def get_message(self) -&gt; str:\n    \"\"\"Gets the localized error message based on the language setting.\n\n    Returns:\n        str: The error message in the current language.\n    \"\"\"\n    return self.error_detail.message_fa if self.lang == LanguageType.FA else self.error_detail.message_en\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.to_dict","title":"<code>archipy.models.errors.BaseError.to_dict()</code>","text":"<p>Converts the exception to a dictionary format for API responses.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing error details and additional data.</p> Source code in <code>archipy/models/errors/base_error.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Converts the exception to a dictionary format for API responses.\n\n    Returns:\n        dict: A dictionary containing error details and additional data.\n    \"\"\"\n    response = {\n        \"error\": self.error_detail.code,\n        \"detail\": self.error_detail.model_dump(mode=\"json\", exclude_none=True),\n    }\n\n    # Add additional data if present\n    detail = response[\"detail\"]\n    if isinstance(detail, dict) and self.additional_data:\n        detail.update(self.additional_data)\n\n    return response\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.__str__","title":"<code>archipy.models.errors.BaseError.__str__()</code>","text":"<p>String representation of the exception.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A formatted string containing the error code and message.</p> Source code in <code>archipy/models/errors/base_error.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"String representation of the exception.\n\n    Returns:\n        str: A formatted string containing the error code and message.\n    \"\"\"\n    return f\"[{self.error_detail.code}] {self.get_message()}\"\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.__repr__","title":"<code>archipy.models.errors.BaseError.__repr__()</code>","text":"<p>Detailed string representation of the exception.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A detailed string representation including all error details.</p> Source code in <code>archipy/models/errors/base_error.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Detailed string representation of the exception.\n\n    Returns:\n        str: A detailed string representation including all error details.\n    \"\"\"\n    return (\n        f\"{self.__class__.__name__}(\"\n        f\"code='{self.error_detail.code}', \"\n        f\"message='{self.get_message()}', \"\n        f\"http_status={self.http_status_code_value}, \"\n        f\"grpc_status={self.grpc_status_code_value}, \"\n        f\"additional_data={self.additional_data}\"\n        f\")\"\n    )\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.abort_grpc_async","title":"<code>archipy.models.errors.BaseError.abort_grpc_async(context)</code>  <code>async</code>","text":"<p>Aborts an async gRPC call with the appropriate status code and message.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>ServicerContext</code> <p>The gRPC ServicerContext to abort.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If context is None or doesn't have abort method.</p> Source code in <code>archipy/models/errors/base_error.py</code> <pre><code>async def abort_grpc_async(self, context: AsyncServicerContext) -&gt; None:\n    \"\"\"Aborts an async gRPC call with the appropriate status code and message.\n\n    Args:\n        context: The gRPC ServicerContext to abort.\n\n    Raises:\n        ValueError: If context is None or doesn't have abort method.\n    \"\"\"\n    if context is None:\n        raise ValueError(\"gRPC context cannot be None\")\n\n    if not GRPC_AVAILABLE or not hasattr(context, \"abort\"):\n        raise ValueError(\"Invalid gRPC context: missing abort method\")\n\n    status_code = self._get_grpc_status_code()\n    message = self.get_message()\n\n    if self.additional_data:\n        context.set_trailing_metadata([(\"additional_data\", json.dumps(self.additional_data))])\n\n    await context.abort(status_code, message)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.abort_grpc_sync","title":"<code>archipy.models.errors.BaseError.abort_grpc_sync(context)</code>","text":"<p>Aborts a sync gRPC call with the appropriate status code and message.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>ServicerContext</code> <p>The gRPC ServicerContext to abort.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If context is None or doesn't have abort method.</p> Source code in <code>archipy/models/errors/base_error.py</code> <pre><code>def abort_grpc_sync(self, context: ServicerContext) -&gt; None:\n    \"\"\"Aborts a sync gRPC call with the appropriate status code and message.\n\n    Args:\n        context: The gRPC ServicerContext to abort.\n\n    Raises:\n        ValueError: If context is None or doesn't have abort method.\n    \"\"\"\n    if context is None:\n        raise ValueError(\"gRPC context cannot be None\")\n\n    if not GRPC_AVAILABLE or not hasattr(context, \"abort\"):\n        raise ValueError(\"Invalid gRPC context: missing abort method\")\n\n    status_code = self._get_grpc_status_code()\n    if status_code is None:\n        raise ValueError(\"gRPC is not available\")\n\n    message = self.get_message()\n\n    if self.additional_data:\n        context.set_trailing_metadata([(\"additional_data\", json.dumps(self.additional_data))])\n\n    context.abort(status_code, message)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.abort_with_error_async","title":"<code>archipy.models.errors.BaseError.abort_with_error_async(context, error=None, lang=None, additional_data=None)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Creates an error instance and immediately aborts the async gRPC context.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>ServicerContext</code> <p>The async gRPC ServicerContext to abort.</p> required <code>error</code> <code>ErrorDetailDTO | ErrorMessageType | None</code> <p>The error detail or message type.</p> <code>None</code> <code>lang</code> <code>LanguageType | None</code> <p>Language code for the error message.</p> <code>None</code> <code>additional_data</code> <code>dict[str, Any] | None</code> <p>Additional context data for the error.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If context is None or invalid.</p> Source code in <code>archipy/models/errors/base_error.py</code> <pre><code>@classmethod\nasync def abort_with_error_async(\n    cls,\n    context: AsyncServicerContext,\n    error: ErrorDetailDTO | ErrorMessageType | None = None,\n    lang: LanguageType | None = None,\n    additional_data: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"Creates an error instance and immediately aborts the async gRPC context.\n\n    Args:\n        context: The async gRPC ServicerContext to abort.\n        error: The error detail or message type.\n        lang: Language code for the error message.\n        additional_data: Additional context data for the error.\n\n    Raises:\n        ValueError: If context is None or invalid.\n    \"\"\"\n    instance = cls(error=error, lang=lang, additional_data=additional_data)\n    await instance.abort_grpc_async(context)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.abort_with_error_sync","title":"<code>archipy.models.errors.BaseError.abort_with_error_sync(context, error=None, lang=None, additional_data=None)</code>  <code>classmethod</code>","text":"<p>Creates an error instance and immediately aborts the sync gRPC context.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>ServicerContext</code> <p>The sync gRPC ServicerContext to abort.</p> required <code>error</code> <code>ErrorDetailDTO | ErrorMessageType | None</code> <p>The error detail or message type.</p> <code>None</code> <code>lang</code> <code>LanguageType | None</code> <p>Language code for the error message.</p> <code>None</code> <code>additional_data</code> <code>dict[str, Any] | None</code> <p>Additional context data for the error.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If context is None or invalid.</p> Source code in <code>archipy/models/errors/base_error.py</code> <pre><code>@classmethod\ndef abort_with_error_sync(\n    cls,\n    context: ServicerContext,\n    error: ErrorDetailDTO | ErrorMessageType | None = None,\n    lang: LanguageType | None = None,\n    additional_data: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"Creates an error instance and immediately aborts the sync gRPC context.\n\n    Args:\n        context: The sync gRPC ServicerContext to abort.\n        error: The error detail or message type.\n        lang: Language code for the error message.\n        additional_data: Additional context data for the error.\n\n    Raises:\n        ValueError: If context is None or invalid.\n    \"\"\"\n    instance = cls(error=error, lang=lang, additional_data=additional_data)\n    instance.abort_grpc_sync(context)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.BusinessRuleViolationError","title":"<code>archipy.models.errors.BusinessRuleViolationError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a business rule is violated.</p> Source code in <code>archipy/models/errors/business_errors.py</code> <pre><code>class BusinessRuleViolationError(BaseError):\n    \"\"\"Exception raised when a business rule is violated.\"\"\"\n\n    def __init__(\n        self,\n        rule: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.BUSINESS_RULE_VIOLATION.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if rule:\n            data[\"rule\"] = rule\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.FailedPreconditionError","title":"<code>archipy.models.errors.FailedPreconditionError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a precondition for an operation is not met.</p> Source code in <code>archipy/models/errors/business_errors.py</code> <pre><code>class FailedPreconditionError(BaseError):\n    \"\"\"Exception raised when a precondition for an operation is not met.\"\"\"\n\n    def __init__(\n        self,\n        precondition: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.FAILED_PRECONDITION.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if precondition:\n            data[\"precondition\"] = precondition\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InsufficientBalanceError","title":"<code>archipy.models.errors.InsufficientBalanceError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when an operation fails due to insufficient account balance.</p> Source code in <code>archipy/models/errors/business_errors.py</code> <pre><code>class InsufficientBalanceError(BaseError):\n    \"\"\"Exception raised when an operation fails due to insufficient account balance.\"\"\"\n\n    def __init__(\n        self,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.INSUFFICIENT_BALANCE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(error, lang, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InsufficientFundsError","title":"<code>archipy.models.errors.InsufficientFundsError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when there are insufficient funds for an operation.</p> Source code in <code>archipy/models/errors/business_errors.py</code> <pre><code>class InsufficientFundsError(BaseError):\n    \"\"\"Exception raised when there are insufficient funds for an operation.\"\"\"\n\n    def __init__(\n        self,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.INSUFFICIENT_FUNDS.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(error, lang, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidOperationError","title":"<code>archipy.models.errors.InvalidOperationError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when an operation is not allowed in the current context.</p> Source code in <code>archipy/models/errors/business_errors.py</code> <pre><code>class InvalidOperationError(BaseError):\n    \"\"\"Exception raised when an operation is not allowed in the current context.\"\"\"\n\n    def __init__(\n        self,\n        operation: str | None = None,\n        context: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_OPERATION.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if operation:\n            data[\"operation\"] = operation\n        if context:\n            data[\"context\"] = context\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidStateError","title":"<code>archipy.models.errors.InvalidStateError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when an operation is attempted in an invalid state.</p> Source code in <code>archipy/models/errors/business_errors.py</code> <pre><code>class InvalidStateError(BaseError):\n    \"\"\"Exception raised when an operation is attempted in an invalid state.\"\"\"\n\n    def __init__(\n        self,\n        current_state: str | None = None,\n        expected_state: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_STATE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if current_state:\n            data[\"current_state\"] = current_state\n        if expected_state:\n            data[\"expected_state\"] = expected_state\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.MaintenanceModeError","title":"<code>archipy.models.errors.MaintenanceModeError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when the system is in maintenance mode.</p> Source code in <code>archipy/models/errors/business_errors.py</code> <pre><code>class MaintenanceModeError(BaseError):\n    \"\"\"Exception raised when the system is in maintenance mode.\"\"\"\n\n    def __init__(\n        self,\n        estimated_duration: int | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.MAINTENANCE_MODE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"estimated_duration\": estimated_duration} if estimated_duration else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.CacheError","title":"<code>archipy.models.errors.CacheError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for cache access errors.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class CacheError(BaseError):\n    \"\"\"Exception raised for cache access errors.\"\"\"\n\n    def __init__(\n        self,\n        cache_type: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.CACHE_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if cache_type:\n            data[\"cache_type\"] = cache_type\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.CacheMissError","title":"<code>archipy.models.errors.CacheMissError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when requested data is not found in cache.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class CacheMissError(BaseError):\n    \"\"\"Exception raised when requested data is not found in cache.\"\"\"\n\n    def __init__(\n        self,\n        cache_key: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.CACHE_MISS.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"cache_key\": cache_key} if cache_key else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DatabaseConfigurationError","title":"<code>archipy.models.errors.DatabaseConfigurationError</code>","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Exception raised for database configuration errors.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class DatabaseConfigurationError(DatabaseError):\n    \"\"\"Exception raised for database configuration errors.\"\"\"\n\n    def __init__(\n        self,\n        database: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.DATABASE_CONFIGURATION_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(database, lang, error, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DatabaseConnectionError","title":"<code>archipy.models.errors.DatabaseConnectionError</code>","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Exception raised for database connection errors.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class DatabaseConnectionError(DatabaseError):\n    \"\"\"Exception raised for database connection errors.\"\"\"\n\n    def __init__(\n        self,\n        database: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.DATABASE_CONNECTION_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(database, lang, error, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DatabaseConstraintError","title":"<code>archipy.models.errors.DatabaseConstraintError</code>","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Exception raised for database constraint violations.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class DatabaseConstraintError(DatabaseError):\n    \"\"\"Exception raised for database constraint violations.\"\"\"\n\n    def __init__(\n        self,\n        database: str | None = None,\n        constraint: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.DATABASE_CONSTRAINT_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if constraint:\n            data[\"constraint\"] = constraint\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(database, lang, error, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DatabaseDeadlockError","title":"<code>archipy.models.errors.DatabaseDeadlockError</code>","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Exception raised for database deadlock errors.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class DatabaseDeadlockError(DatabaseError):\n    \"\"\"Exception raised for database deadlock errors.\"\"\"\n\n    def __init__(\n        self,\n        database: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.DATABASE_DEADLOCK_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(database, lang, error, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DatabaseError","title":"<code>archipy.models.errors.DatabaseError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Base class for all database-related errors.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class DatabaseError(BaseError):\n    \"\"\"Base class for all database-related errors.\"\"\"\n\n    def __init__(\n        self,\n        database: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.DATABASE_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if database:\n            data[\"database\"] = database\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DatabaseIntegrityError","title":"<code>archipy.models.errors.DatabaseIntegrityError</code>","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Exception raised for database integrity violations.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class DatabaseIntegrityError(DatabaseError):\n    \"\"\"Exception raised for database integrity violations.\"\"\"\n\n    def __init__(\n        self,\n        database: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.DATABASE_INTEGRITY_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(database, lang, error, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DatabaseQueryError","title":"<code>archipy.models.errors.DatabaseQueryError</code>","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Exception raised for database query errors.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class DatabaseQueryError(DatabaseError):\n    \"\"\"Exception raised for database query errors.\"\"\"\n\n    def __init__(\n        self,\n        database: str | None = None,\n        query: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.DATABASE_QUERY_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if query:\n            data[\"query\"] = query\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(database, lang, error, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DatabaseSerializationError","title":"<code>archipy.models.errors.DatabaseSerializationError</code>","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Exception raised for database serialization errors.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class DatabaseSerializationError(DatabaseError):\n    \"\"\"Exception raised for database serialization errors.\"\"\"\n\n    def __init__(\n        self,\n        database: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.DATABASE_SERIALIZATION_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(database, lang, error, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DatabaseTimeoutError","title":"<code>archipy.models.errors.DatabaseTimeoutError</code>","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Exception raised for database timeout errors.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class DatabaseTimeoutError(DatabaseError):\n    \"\"\"Exception raised for database timeout errors.\"\"\"\n\n    def __init__(\n        self,\n        database: str | None = None,\n        timeout: int | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.DATABASE_TIMEOUT_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if timeout:\n            data[\"timeout\"] = timeout\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(database, lang, error, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DatabaseTransactionError","title":"<code>archipy.models.errors.DatabaseTransactionError</code>","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Exception raised for database transaction errors.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class DatabaseTransactionError(DatabaseError):\n    \"\"\"Exception raised for database transaction errors.\"\"\"\n\n    def __init__(\n        self,\n        database: str | None = None,\n        transaction_id: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.DATABASE_TRANSACTION_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if transaction_id:\n            data[\"transaction_id\"] = transaction_id\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(database, lang, error, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.ClientAlreadyExistsError","title":"<code>archipy.models.errors.ClientAlreadyExistsError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when trying to create a client that already exists.</p> Source code in <code>archipy/models/errors/keycloak_errors.py</code> <pre><code>class ClientAlreadyExistsError(BaseError):\n    \"\"\"Exception raised when trying to create a client that already exists.\"\"\"\n\n    http_status_code: ClassVar[int] = 409\n    grpc_status_code: ClassVar[int] = 6  # ALREADY_EXISTS\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InsufficientPermissionsError","title":"<code>archipy.models.errors.InsufficientPermissionsError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when user lacks required permissions.</p> Source code in <code>archipy/models/errors/keycloak_errors.py</code> <pre><code>class InsufficientPermissionsError(BaseError):\n    \"\"\"Exception raised when user lacks required permissions.\"\"\"\n\n    http_status_code: ClassVar[int] = 403\n    grpc_status_code: ClassVar[int] = 7  # PERMISSION_DENIED\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.KeycloakInvalidCredentialsError","title":"<code>archipy.models.errors.KeycloakInvalidCredentialsError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid authentication credentials.</p> Source code in <code>archipy/models/errors/keycloak_errors.py</code> <pre><code>class InvalidCredentialsError(BaseError):\n    \"\"\"Exception raised for invalid authentication credentials.\"\"\"\n\n    http_status_code: ClassVar[int] = 401\n    grpc_status_code: ClassVar[int] = 16  # UNAUTHENTICATED\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.KeycloakConnectionTimeoutError","title":"<code>archipy.models.errors.KeycloakConnectionTimeoutError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when Keycloak connection times out.</p> Source code in <code>archipy/models/errors/keycloak_errors.py</code> <pre><code>class KeycloakConnectionTimeoutError(BaseError):\n    \"\"\"Exception raised when Keycloak connection times out.\"\"\"\n\n    http_status_code: ClassVar[int] = 504\n    grpc_status_code: ClassVar[int] = 4  # DEADLINE_EXCEEDED\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.KeycloakServiceUnavailableError","title":"<code>archipy.models.errors.KeycloakServiceUnavailableError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when Keycloak service is unavailable.</p> Source code in <code>archipy/models/errors/keycloak_errors.py</code> <pre><code>class KeycloakServiceUnavailableError(BaseError):\n    \"\"\"Exception raised when Keycloak service is unavailable.\"\"\"\n\n    http_status_code: ClassVar[int] = 503\n    grpc_status_code: ClassVar[int] = 14  # UNAVAILABLE\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.PasswordPolicyError","title":"<code>archipy.models.errors.PasswordPolicyError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when password doesn't meet policy requirements.</p> Source code in <code>archipy/models/errors/keycloak_errors.py</code> <pre><code>class PasswordPolicyError(BaseError):\n    \"\"\"Exception raised when password doesn't meet policy requirements.\"\"\"\n\n    http_status_code: ClassVar[int] = 400\n    grpc_status_code: ClassVar[int] = 3  # INVALID_ARGUMENT\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.RealmAlreadyExistsError","title":"<code>archipy.models.errors.RealmAlreadyExistsError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when trying to create a realm that already exists.</p> Source code in <code>archipy/models/errors/keycloak_errors.py</code> <pre><code>class RealmAlreadyExistsError(BaseError):\n    \"\"\"Exception raised when trying to create a realm that already exists.\"\"\"\n\n    http_status_code: ClassVar[int] = 409\n    grpc_status_code: ClassVar[int] = 6  # ALREADY_EXISTS\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.ResourceNotFoundError","title":"<code>archipy.models.errors.ResourceNotFoundError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a resource is not found.</p> Source code in <code>archipy/models/errors/keycloak_errors.py</code> <pre><code>class ResourceNotFoundError(BaseError):\n    \"\"\"Exception raised when a resource is not found.\"\"\"\n\n    http_status_code: ClassVar[int] = 404\n    grpc_status_code: ClassVar[int] = 5  # NOT_FOUND\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.RoleAlreadyExistsError","title":"<code>archipy.models.errors.RoleAlreadyExistsError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when trying to create a role that already exists.</p> Source code in <code>archipy/models/errors/keycloak_errors.py</code> <pre><code>class RoleAlreadyExistsError(BaseError):\n    \"\"\"Exception raised when trying to create a role that already exists.\"\"\"\n\n    http_status_code: ClassVar[int] = 409\n    grpc_status_code: ClassVar[int] = 6  # ALREADY_EXISTS\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.UserAlreadyExistsError","title":"<code>archipy.models.errors.UserAlreadyExistsError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when trying to create a user that already exists.</p> Source code in <code>archipy/models/errors/keycloak_errors.py</code> <pre><code>class UserAlreadyExistsError(BaseError):\n    \"\"\"Exception raised when trying to create a user that already exists.\"\"\"\n\n    http_status_code: ClassVar[int] = 409\n    grpc_status_code: ClassVar[int] = 6  # ALREADY_EXISTS\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.ValidationError","title":"<code>archipy.models.errors.ValidationError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for validation errors.</p> Source code in <code>archipy/models/errors/keycloak_errors.py</code> <pre><code>class ValidationError(BaseError):\n    \"\"\"Exception raised for validation errors.\"\"\"\n\n    http_status_code: ClassVar[int] = 400\n    grpc_status_code: ClassVar[int] = 3  # INVALID_ARGUMENT\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.BadGatewayError","title":"<code>archipy.models.errors.BadGatewayError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a gateway returns an invalid response.</p> Source code in <code>archipy/models/errors/network_errors.py</code> <pre><code>class BadGatewayError(BaseError):\n    \"\"\"Exception raised when a gateway returns an invalid response.\"\"\"\n\n    def __init__(\n        self,\n        gateway: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.BAD_GATEWAY.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if gateway:\n            data[\"gateway\"] = gateway\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.ConnectionTimeoutError","title":"<code>archipy.models.errors.ConnectionTimeoutError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a connection times out.</p> Source code in <code>archipy/models/errors/network_errors.py</code> <pre><code>class ConnectionTimeoutError(BaseError):\n    \"\"\"Exception raised when a connection times out.\"\"\"\n\n    def __init__(\n        self,\n        service: str | None = None,\n        timeout: int | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.CONNECTION_TIMEOUT.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if service:\n            data[\"service\"] = service\n        if timeout:\n            data[\"timeout\"] = timeout\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.GatewayTimeoutError","title":"<code>archipy.models.errors.GatewayTimeoutError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a gateway times out.</p> Source code in <code>archipy/models/errors/network_errors.py</code> <pre><code>class GatewayTimeoutError(BaseError):\n    \"\"\"Exception raised when a gateway times out.\"\"\"\n\n    def __init__(\n        self,\n        gateway: str | None = None,\n        timeout: int | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.GATEWAY_TIMEOUT.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if gateway:\n            data[\"gateway\"] = gateway\n        if timeout:\n            data[\"timeout\"] = timeout\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.NetworkError","title":"<code>archipy.models.errors.NetworkError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for network-related errors.</p> Source code in <code>archipy/models/errors/network_errors.py</code> <pre><code>class NetworkError(BaseError):\n    \"\"\"Exception raised for network-related errors.\"\"\"\n\n    def __init__(\n        self,\n        service: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.NETWORK_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if service:\n            data[\"service\"] = service\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.RateLimitExceededError","title":"<code>archipy.models.errors.RateLimitExceededError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a rate limit is exceeded.</p> Source code in <code>archipy/models/errors/network_errors.py</code> <pre><code>class RateLimitExceededError(BaseError):\n    \"\"\"Exception raised when a rate limit is exceeded.\"\"\"\n\n    def __init__(\n        self,\n        rate_limit_type: str | None = None,\n        retry_after: int | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.RATE_LIMIT_EXCEEDED.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if rate_limit_type:\n            data[\"rate_limit_type\"] = rate_limit_type\n        if retry_after:\n            data[\"retry_after\"] = retry_after\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.ServiceUnavailableError","title":"<code>archipy.models.errors.ServiceUnavailableError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a service is unavailable.</p> Source code in <code>archipy/models/errors/network_errors.py</code> <pre><code>class ServiceUnavailableError(BaseError):\n    \"\"\"Exception raised when a service is unavailable.\"\"\"\n\n    def __init__(\n        self,\n        service: str | None = None,\n        retry_after: int | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.SERVICE_UNAVAILABLE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if service:\n            data[\"service\"] = service\n        if retry_after:\n            data[\"retry_after\"] = retry_after\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.AlreadyExistsError","title":"<code>archipy.models.errors.AlreadyExistsError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a resource already exists.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class AlreadyExistsError(BaseError):\n    \"\"\"Exception raised when a resource already exists.\"\"\"\n\n    def __init__(\n        self,\n        resource_type: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.ALREADY_EXISTS.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"resource_type\": resource_type} if resource_type else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.ConflictError","title":"<code>archipy.models.errors.ConflictError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when there is a resource conflict.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class ConflictError(BaseError):\n    \"\"\"Exception raised when there is a resource conflict.\"\"\"\n\n    def __init__(\n        self,\n        resource_type: str | None = None,\n        resource_id: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.CONFLICT.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if resource_type:\n            data[\"resource_type\"] = resource_type\n        if resource_id:\n            data[\"resource_id\"] = resource_id\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DataLossError","title":"<code>archipy.models.errors.DataLossError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when data is lost.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class DataLossError(BaseError):\n    \"\"\"Exception raised when data is lost.\"\"\"\n\n    def __init__(\n        self,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.DATA_LOSS.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(error, lang, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.FileTooLargeError","title":"<code>archipy.models.errors.FileTooLargeError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a file is too large.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class FileTooLargeError(BaseError):\n    \"\"\"Exception raised when a file is too large.\"\"\"\n\n    def __init__(\n        self,\n        file_name: str | None = None,\n        file_size: int | None = None,\n        max_size: int | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.FILE_TOO_LARGE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if file_name:\n            data[\"file_name\"] = file_name\n        if file_size:\n            data[\"file_size\"] = file_size\n        if max_size:\n            data[\"max_size\"] = max_size\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidEntityTypeError","title":"<code>archipy.models.errors.InvalidEntityTypeError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid entity types.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class InvalidEntityTypeError(BaseError):\n    \"\"\"Exception raised for invalid entity types.\"\"\"\n\n    def __init__(\n        self,\n        message: str | None = None,\n        expected_type: str | None = None,\n        actual_type: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_ENTITY_TYPE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if message:\n            data[\"message\"] = message\n        if expected_type:\n            data[\"expected_type\"] = expected_type\n        if actual_type:\n            data[\"actual_type\"] = actual_type\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidFileTypeError","title":"<code>archipy.models.errors.InvalidFileTypeError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid file types.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class InvalidFileTypeError(BaseError):\n    \"\"\"Exception raised for invalid file types.\"\"\"\n\n    def __init__(\n        self,\n        file_name: str | None = None,\n        file_type: str | None = None,\n        allowed_types: list[str] | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_FILE_TYPE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if file_name:\n            data[\"file_name\"] = file_name\n        if file_type:\n            data[\"file_type\"] = file_type\n        if allowed_types:\n            data[\"allowed_types\"] = allowed_types\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.NotFoundError","title":"<code>archipy.models.errors.NotFoundError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a resource is not found.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class NotFoundError(BaseError):\n    \"\"\"Exception raised when a resource is not found.\"\"\"\n\n    def __init__(\n        self,\n        resource_type: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.NOT_FOUND.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"resource_type\": resource_type} if resource_type else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.QuotaExceededError","title":"<code>archipy.models.errors.QuotaExceededError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a quota is exceeded.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class QuotaExceededError(BaseError):\n    \"\"\"Exception raised when a quota is exceeded.\"\"\"\n\n    def __init__(\n        self,\n        quota_type: str | None = None,\n        current_usage: int | None = None,\n        quota_limit: int | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.QUOTA_EXCEEDED.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if quota_type:\n            data[\"quota_type\"] = quota_type\n        if current_usage:\n            data[\"current_usage\"] = current_usage\n        if quota_limit:\n            data[\"quota_limit\"] = quota_limit\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.ResourceBusyError","title":"<code>archipy.models.errors.ResourceBusyError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a resource is busy.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class ResourceBusyError(BaseError):\n    \"\"\"Exception raised when a resource is busy.\"\"\"\n\n    def __init__(\n        self,\n        resource_id: str | None = None,\n        busy_reason: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.RESOURCE_BUSY.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if resource_id:\n            data[\"resource_id\"] = resource_id\n        if busy_reason:\n            data[\"busy_reason\"] = busy_reason\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.ResourceExhaustedError","title":"<code>archipy.models.errors.ResourceExhaustedError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a resource is exhausted.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class ResourceExhaustedError(BaseError):\n    \"\"\"Exception raised when a resource is exhausted.\"\"\"\n\n    def __init__(\n        self,\n        resource_type: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.RESOURCE_EXHAUSTED.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"resource_type\": resource_type} if resource_type else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.ResourceLockedError","title":"<code>archipy.models.errors.ResourceLockedError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a resource is locked.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class ResourceLockedError(BaseError):\n    \"\"\"Exception raised when a resource is locked.\"\"\"\n\n    def __init__(\n        self,\n        resource_id: str | None = None,\n        lock_owner: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.RESOURCE_LOCKED.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if resource_id:\n            data[\"resource_id\"] = resource_id\n        if lock_owner:\n            data[\"lock_owner\"] = lock_owner\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.StorageError","title":"<code>archipy.models.errors.StorageError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for storage-related errors.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class StorageError(BaseError):\n    \"\"\"Exception raised for storage-related errors.\"\"\"\n\n    def __init__(\n        self,\n        storage_type: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.STORAGE_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"storage_type\": storage_type} if storage_type else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.AbortedError","title":"<code>archipy.models.errors.AbortedError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Represents an aborted operation error.</p> <p>This error is used when an operation is aborted, typically due to a concurrency issue or user cancellation.</p> Source code in <code>archipy/models/errors/system_errors.py</code> <pre><code>class AbortedError(BaseError):\n    \"\"\"Represents an aborted operation error.\n\n    This error is used when an operation is aborted, typically due to\n    a concurrency issue or user cancellation.\n    \"\"\"\n\n    def __init__(\n        self,\n        service: str | None = None,\n        reason: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.UNAVAILABLE.value,\n        additional_data: dict[str, Any] | None = None,\n    ) -&gt; None:\n        data = {}\n        if service:\n            data[\"service\"] = service\n        if reason:\n            data[\"reason\"] = reason\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.ConfigurationError","title":"<code>archipy.models.errors.ConfigurationError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Represents a configuration error.</p> <p>This error is used when there is a problem with the application's configuration that prevents it from operating correctly.</p> Source code in <code>archipy/models/errors/system_errors.py</code> <pre><code>class ConfigurationError(BaseError):\n    \"\"\"Represents a configuration error.\n\n    This error is used when there is a problem with the application's\n    configuration that prevents it from operating correctly.\n    \"\"\"\n\n    def __init__(\n        self,\n        operation: str | None = None,\n        reason: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.CONFIGURATION_ERROR.value,\n        additional_data: dict[str, Any] | None = None,\n    ) -&gt; None:\n        data = {}\n        if operation:\n            data[\"operation\"] = operation\n        if reason:\n            data[\"reason\"] = reason\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DeadlineExceededError","title":"<code>archipy.models.errors.DeadlineExceededError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Raised when an operation exceeds its deadline/timeout.</p> <p>This error is typically used in decorators or functions that have time limits or deadlines for completion.</p> Source code in <code>archipy/models/errors/system_errors.py</code> <pre><code>class DeadlineExceededError(BaseError):\n    \"\"\"Raised when an operation exceeds its deadline/timeout.\n\n    This error is typically used in decorators or functions that have\n    time limits or deadlines for completion.\n    \"\"\"\n\n    http_status_code: ClassVar[int] = 408  # Request Timeout\n    grpc_status_code: ClassVar[int] = 4  # DEADLINE_EXCEEDED\n\n    def __init__(\n        self,\n        timeout: int | None = None,\n        operation: str | None = None,\n        lang: LanguageType | None = None,\n        additional_data: dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize DeadlineExceededError.\n\n        Args:\n            timeout: The timeout value that was exceeded (in seconds).\n            operation: The operation that exceeded the deadline.\n            lang: The language for error messages.\n            additional_data: Additional context data.\n        \"\"\"\n        error = ErrorDetailDTO(\n            code=\"DEADLINE_EXCEEDED\",\n            message_en=\"Operation exceeded its deadline\",\n            message_fa=\"\u0639\u0645\u0644\u06cc\u0627\u062a \u0627\u0632 \u0645\u0647\u0644\u062a \u0632\u0645\u0627\u0646\u06cc \u0645\u062c\u0627\u0632 \u062a\u062c\u0627\u0648\u0632 \u06a9\u0631\u062f\",\n            http_status=self.http_status_code,\n            grpc_status=self.grpc_status_code,\n        )\n\n        data = {}\n        if timeout is not None:\n            data[\"timeout\"] = timeout\n        if operation:\n            data[\"operation\"] = operation\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DeadlineExceededError.__init__","title":"<code>archipy.models.errors.DeadlineExceededError.__init__(timeout=None, operation=None, lang=None, additional_data=None)</code>","text":"<p>Initialize DeadlineExceededError.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int | None</code> <p>The timeout value that was exceeded (in seconds).</p> <code>None</code> <code>operation</code> <code>str | None</code> <p>The operation that exceeded the deadline.</p> <code>None</code> <code>lang</code> <code>LanguageType | None</code> <p>The language for error messages.</p> <code>None</code> <code>additional_data</code> <code>dict[str, Any] | None</code> <p>Additional context data.</p> <code>None</code> Source code in <code>archipy/models/errors/system_errors.py</code> <pre><code>def __init__(\n    self,\n    timeout: int | None = None,\n    operation: str | None = None,\n    lang: LanguageType | None = None,\n    additional_data: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"Initialize DeadlineExceededError.\n\n    Args:\n        timeout: The timeout value that was exceeded (in seconds).\n        operation: The operation that exceeded the deadline.\n        lang: The language for error messages.\n        additional_data: Additional context data.\n    \"\"\"\n    error = ErrorDetailDTO(\n        code=\"DEADLINE_EXCEEDED\",\n        message_en=\"Operation exceeded its deadline\",\n        message_fa=\"\u0639\u0645\u0644\u06cc\u0627\u062a \u0627\u0632 \u0645\u0647\u0644\u062a \u0632\u0645\u0627\u0646\u06cc \u0645\u062c\u0627\u0632 \u062a\u062c\u0627\u0648\u0632 \u06a9\u0631\u062f\",\n        http_status=self.http_status_code,\n        grpc_status=self.grpc_status_code,\n    )\n\n    data = {}\n    if timeout is not None:\n        data[\"timeout\"] = timeout\n    if operation:\n        data[\"operation\"] = operation\n    if additional_data:\n        data.update(additional_data)\n    super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DeadlockDetectedError","title":"<code>archipy.models.errors.DeadlockDetectedError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Represents a deadlock detection error.</p> <p>This error is used when a deadlock is detected in a system operation, typically in database transactions or resource locking scenarios.</p> Source code in <code>archipy/models/errors/system_errors.py</code> <pre><code>class DeadlockDetectedError(BaseError):\n    \"\"\"Represents a deadlock detection error.\n\n    This error is used when a deadlock is detected in a system operation,\n    typically in database transactions or resource locking scenarios.\n    \"\"\"\n\n    def __init__(\n        self,\n        service: str | None = None,\n        reason: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.UNAVAILABLE.value,\n        additional_data: dict[str, Any] | None = None,\n    ) -&gt; None:\n        data = {}\n        if service:\n            data[\"service\"] = service\n        if reason:\n            data[\"reason\"] = reason\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DeprecationError","title":"<code>archipy.models.errors.DeprecationError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Raised when deprecated functionality is used.</p> <p>This error is used to signal that a feature, method, or API is deprecated and should no longer be used.</p> Source code in <code>archipy/models/errors/system_errors.py</code> <pre><code>class DeprecationError(BaseError):\n    \"\"\"Raised when deprecated functionality is used.\n\n    This error is used to signal that a feature, method, or API\n    is deprecated and should no longer be used.\n    \"\"\"\n\n    http_status_code: ClassVar[int] = 410  # Gone\n    grpc_status_code: ClassVar[int] = 12  # UNIMPLEMENTED\n\n    def __init__(\n        self,\n        deprecated_feature: str | None = None,\n        replacement: str | None = None,\n        removal_version: str | None = None,\n        lang: LanguageType | None = None,\n        additional_data: dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize DeprecationError.\n\n        Args:\n            deprecated_feature: The name of the deprecated feature.\n            replacement: The recommended replacement feature.\n            removal_version: The version when the feature will be removed.\n            lang: The language for error messages.\n            additional_data: Additional context data.\n        \"\"\"\n        error = ErrorDetailDTO(\n            code=\"DEPRECATED_FEATURE\",\n            message_en=\"This feature is deprecated and should no longer be used\",\n            message_fa=\"\u0627\u06cc\u0646 \u0648\u06cc\u0698\u06af\u06cc \u0645\u0646\u0633\u0648\u062e \u0634\u062f\u0647 \u0648 \u062f\u06cc\u06af\u0631 \u0646\u0628\u0627\u06cc\u062f \u0627\u0633\u062a\u0641\u0627\u062f\u0647 \u0634\u0648\u062f\",\n            http_status=self.http_status_code,\n            grpc_status=self.grpc_status_code,\n        )\n\n        data = {}\n        if deprecated_feature:\n            data[\"deprecated_feature\"] = deprecated_feature\n        if replacement:\n            data[\"replacement\"] = replacement\n        if removal_version:\n            data[\"removal_version\"] = removal_version\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DeprecationError.__init__","title":"<code>archipy.models.errors.DeprecationError.__init__(deprecated_feature=None, replacement=None, removal_version=None, lang=None, additional_data=None)</code>","text":"<p>Initialize DeprecationError.</p> <p>Parameters:</p> Name Type Description Default <code>deprecated_feature</code> <code>str | None</code> <p>The name of the deprecated feature.</p> <code>None</code> <code>replacement</code> <code>str | None</code> <p>The recommended replacement feature.</p> <code>None</code> <code>removal_version</code> <code>str | None</code> <p>The version when the feature will be removed.</p> <code>None</code> <code>lang</code> <code>LanguageType | None</code> <p>The language for error messages.</p> <code>None</code> <code>additional_data</code> <code>dict[str, Any] | None</code> <p>Additional context data.</p> <code>None</code> Source code in <code>archipy/models/errors/system_errors.py</code> <pre><code>def __init__(\n    self,\n    deprecated_feature: str | None = None,\n    replacement: str | None = None,\n    removal_version: str | None = None,\n    lang: LanguageType | None = None,\n    additional_data: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"Initialize DeprecationError.\n\n    Args:\n        deprecated_feature: The name of the deprecated feature.\n        replacement: The recommended replacement feature.\n        removal_version: The version when the feature will be removed.\n        lang: The language for error messages.\n        additional_data: Additional context data.\n    \"\"\"\n    error = ErrorDetailDTO(\n        code=\"DEPRECATED_FEATURE\",\n        message_en=\"This feature is deprecated and should no longer be used\",\n        message_fa=\"\u0627\u06cc\u0646 \u0648\u06cc\u0698\u06af\u06cc \u0645\u0646\u0633\u0648\u062e \u0634\u062f\u0647 \u0648 \u062f\u06cc\u06af\u0631 \u0646\u0628\u0627\u06cc\u062f \u0627\u0633\u062a\u0641\u0627\u062f\u0647 \u0634\u0648\u062f\",\n        http_status=self.http_status_code,\n        grpc_status=self.grpc_status_code,\n    )\n\n    data = {}\n    if deprecated_feature:\n        data[\"deprecated_feature\"] = deprecated_feature\n    if replacement:\n        data[\"replacement\"] = replacement\n    if removal_version:\n        data[\"removal_version\"] = removal_version\n    if additional_data:\n        data.update(additional_data)\n    super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InternalError","title":"<code>archipy.models.errors.InternalError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Represents an internal server error.</p> <p>This error is typically used when an unexpected condition is encountered that prevents the server from fulfilling the request.</p> Source code in <code>archipy/models/errors/system_errors.py</code> <pre><code>class InternalError(BaseError):\n    \"\"\"Represents an internal server error.\n\n    This error is typically used when an unexpected condition is encountered\n    that prevents the server from fulfilling the request.\n    \"\"\"\n\n    def __init__(\n        self,\n        error_code: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.INTERNAL_ERROR.value,\n        additional_data: dict[str, Any] | None = None,\n    ) -&gt; None:\n        data = {}\n        if error_code:\n            data[\"error_code\"] = error_code\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.UnavailableError","title":"<code>archipy.models.errors.UnavailableError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Represents a resource unavailability error.</p> <p>This error is used when a required resource is temporarily unavailable but may become available again in the future.</p> Source code in <code>archipy/models/errors/system_errors.py</code> <pre><code>class UnavailableError(BaseError):\n    \"\"\"Represents a resource unavailability error.\n\n    This error is used when a required resource is temporarily unavailable\n    but may become available again in the future.\n    \"\"\"\n\n    def __init__(\n        self,\n        resource_type: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.UNAVAILABLE.value,\n        additional_data: dict[str, Any] | None = None,\n    ) -&gt; None:\n        data = {}\n        if resource_type:\n            data[\"resource_type\"] = resource_type\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.UnknownError","title":"<code>archipy.models.errors.UnknownError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Represents an unknown error.</p> <p>This is a catch-all error type for unexpected conditions that don't fit into other error categories.</p> Source code in <code>archipy/models/errors/system_errors.py</code> <pre><code>class UnknownError(BaseError):\n    \"\"\"Represents an unknown error.\n\n    This is a catch-all error type for unexpected conditions that\n    don't fit into other error categories.\n    \"\"\"\n\n    def __init__(\n        self,\n        config_key: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.UNKNOWN_ERROR.value,\n        additional_data: dict[str, Any] | None = None,\n    ) -&gt; None:\n        data = {}\n        if config_key:\n            data[\"config_key\"] = config_key\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidArgumentError","title":"<code>archipy.models.errors.InvalidArgumentError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid arguments.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidArgumentError(BaseError):\n    \"\"\"Exception raised for invalid arguments.\"\"\"\n\n    def __init__(\n        self,\n        argument_name: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_ARGUMENT.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"argument\": argument_name} if argument_name else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidDateError","title":"<code>archipy.models.errors.InvalidDateError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid date formats.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidDateError(BaseError):\n    \"\"\"Exception raised for invalid date formats.\"\"\"\n\n    def __init__(\n        self,\n        date: str | None = None,\n        expected_format: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_DATE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if date:\n            data[\"date\"] = date\n        if expected_format:\n            data[\"expected_format\"] = expected_format\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidEmailError","title":"<code>archipy.models.errors.InvalidEmailError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid email formats.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidEmailError(BaseError):\n    \"\"\"Exception raised for invalid email formats.\"\"\"\n\n    def __init__(\n        self,\n        email: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_EMAIL.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"email\": email} if email else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidFormatError","title":"<code>archipy.models.errors.InvalidFormatError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid data formats.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidFormatError(BaseError):\n    \"\"\"Exception raised for invalid data formats.\"\"\"\n\n    def __init__(\n        self,\n        format_type: str | None = None,\n        expected_format: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_FORMAT.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if format_type:\n            data[\"format_type\"] = format_type\n        if expected_format:\n            data[\"expected_format\"] = expected_format\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidIpError","title":"<code>archipy.models.errors.InvalidIpError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid IP address formats.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidIpError(BaseError):\n    \"\"\"Exception raised for invalid IP address formats.\"\"\"\n\n    def __init__(\n        self,\n        ip: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_IP.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"ip\": ip} if ip else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidJsonError","title":"<code>archipy.models.errors.InvalidJsonError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid JSON formats.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidJsonError(BaseError):\n    \"\"\"Exception raised for invalid JSON formats.\"\"\"\n\n    def __init__(\n        self,\n        json_data: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_JSON.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if json_data:\n            data[\"json_data\"] = json_data\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidLandlineNumberError","title":"<code>archipy.models.errors.InvalidLandlineNumberError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid landline numbers.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidLandlineNumberError(BaseError):\n    \"\"\"Exception raised for invalid landline numbers.\"\"\"\n\n    def __init__(\n        self,\n        landline_number: str,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_LANDLINE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"landline_number\": landline_number}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidNationalCodeError","title":"<code>archipy.models.errors.InvalidNationalCodeError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid national codes.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidNationalCodeError(BaseError):\n    \"\"\"Exception raised for invalid national codes.\"\"\"\n\n    def __init__(\n        self,\n        national_code: str,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_NATIONAL_CODE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"national_code\": national_code}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidPasswordError","title":"<code>archipy.models.errors.InvalidPasswordError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a password does not meet the security requirements.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidPasswordError(BaseError):\n    \"\"\"Exception raised when a password does not meet the security requirements.\"\"\"\n\n    def __init__(\n        self,\n        requirements: list[str] | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_PASSWORD.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"requirements\": requirements} if requirements else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidPhoneNumberError","title":"<code>archipy.models.errors.InvalidPhoneNumberError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid phone numbers.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidPhoneNumberError(BaseError):\n    \"\"\"Exception raised for invalid phone numbers.\"\"\"\n\n    def __init__(\n        self,\n        phone_number: str,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_PHONE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"phone_number\": phone_number}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidTimestampError","title":"<code>archipy.models.errors.InvalidTimestampError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a timestamp format is invalid.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidTimestampError(BaseError):\n    \"\"\"Exception raised when a timestamp format is invalid.\"\"\"\n\n    def __init__(\n        self,\n        timestamp: str | None = None,\n        expected_format: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_TIMESTAMP.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if timestamp:\n            data[\"timestamp\"] = timestamp\n        if expected_format:\n            data[\"expected_format\"] = expected_format\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidUrlError","title":"<code>archipy.models.errors.InvalidUrlError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid URL formats.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidUrlError(BaseError):\n    \"\"\"Exception raised for invalid URL formats.\"\"\"\n\n    def __init__(\n        self,\n        url: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_URL.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"url\": url} if url else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.OutOfRangeError","title":"<code>archipy.models.errors.OutOfRangeError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a value is out of range.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class OutOfRangeError(BaseError):\n    \"\"\"Exception raised when a value is out of range.\"\"\"\n\n    def __init__(\n        self,\n        field_name: str | None = None,\n        lang: LanguageType | None = None,\n        error: ErrorDetailDTO = ErrorMessageType.OUT_OF_RANGE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"field\": field_name} if field_name else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#types_1","title":"Types","text":""},{"location":"api_reference/models/#base-types","title":"Base Types","text":"<p>Basic type definitions used throughout the application.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.types.base_types.BaseType","title":"<code>archipy.models.types.base_types.BaseType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Base class for creating enumerated types with custom values.</p> <p>This class extends the <code>Enum</code> class to allow custom values for enum members.</p> Source code in <code>archipy/models/types/base_types.py</code> <pre><code>class BaseType(Enum):\n    \"\"\"Base class for creating enumerated types with custom values.\n\n    This class extends the `Enum` class to allow custom values for enum members.\n    \"\"\"\n\n    def __new__(cls: type[\"BaseType\"], *args: object, **_: object) -&gt; \"BaseType\":\n        \"\"\"Create a new instance of the enum member.\n\n        Args:\n            cls: The enum class.\n            *args: Arguments passed to the enum member.\n            **_: Unused keyword arguments.\n\n        Returns:\n            BaseType: A new instance of the enum member with the custom value.\n        \"\"\"\n        obj = object.__new__(cls)\n        obj._value_ = args[0]\n        return obj\n</code></pre>"},{"location":"api_reference/models/#archipy.models.types.base_types.BaseType.__new__","title":"<code>archipy.models.types.base_types.BaseType.__new__(*args, **_)</code>","text":"<p>Create a new instance of the enum member.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[BaseType]</code> <p>The enum class.</p> required <code>*args</code> <code>object</code> <p>Arguments passed to the enum member.</p> <code>()</code> <code>**_</code> <code>object</code> <p>Unused keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>BaseType</code> <code>BaseType</code> <p>A new instance of the enum member with the custom value.</p> Source code in <code>archipy/models/types/base_types.py</code> <pre><code>def __new__(cls: type[\"BaseType\"], *args: object, **_: object) -&gt; \"BaseType\":\n    \"\"\"Create a new instance of the enum member.\n\n    Args:\n        cls: The enum class.\n        *args: Arguments passed to the enum member.\n        **_: Unused keyword arguments.\n\n    Returns:\n        BaseType: A new instance of the enum member with the custom value.\n    \"\"\"\n    obj = object.__new__(cls)\n    obj._value_ = args[0]\n    return obj\n</code></pre>"},{"location":"api_reference/models/#archipy.models.types.base_types.FilterOperationType","title":"<code>archipy.models.types.base_types.FilterOperationType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of filter operations for querying or filtering data.</p> <p>This enum defines the types of operations that can be used in filtering, such as equality checks, comparisons, and string matching.</p> <p>Attributes:</p> Name Type Description <code>EQUAL</code> <code>str</code> <p>Represents an equality check.</p> <code>NOT_EQUAL</code> <code>str</code> <p>Represents a non-equality check.</p> <code>LESS_THAN</code> <code>str</code> <p>Represents a less-than comparison.</p> <code>LESS_THAN_OR_EQUAL</code> <code>str</code> <p>Represents a less-than-or-equal comparison.</p> <code>GREATER_THAN</code> <code>str</code> <p>Represents a greater-than comparison.</p> <code>GREATER_THAN_OR_EQUAL</code> <code>str</code> <p>Represents a greater-than-or-equal comparison.</p> <code>IN_LIST</code> <code>str</code> <p>Represents a check for membership in a list.</p> <code>NOT_IN_LIST</code> <code>str</code> <p>Represents a check for non-membership in a list.</p> <code>LIKE</code> <code>str</code> <p>Represents a case-sensitive string pattern match.</p> <code>ILIKE</code> <code>str</code> <p>Represents a case-insensitive string pattern match.</p> <code>STARTS_WITH</code> <code>str</code> <p>Represents a check if a string starts with a given prefix.</p> <code>ENDS_WITH</code> <code>str</code> <p>Represents a check if a string ends with a given suffix.</p> <code>CONTAINS</code> <code>str</code> <p>Represents a check if a string contains a given substring.</p> <code>IS_NULL</code> <code>str</code> <p>Represents a check if a value is null.</p> <code>IS_NOT_NULL</code> <code>str</code> <p>Represents a check if a value is not null.</p> Source code in <code>archipy/models/types/base_types.py</code> <pre><code>class FilterOperationType(Enum):\n    \"\"\"Enumeration of filter operations for querying or filtering data.\n\n    This enum defines the types of operations that can be used in filtering,\n    such as equality checks, comparisons, and string matching.\n\n    Attributes:\n        EQUAL (str): Represents an equality check.\n        NOT_EQUAL (str): Represents a non-equality check.\n        LESS_THAN (str): Represents a less-than comparison.\n        LESS_THAN_OR_EQUAL (str): Represents a less-than-or-equal comparison.\n        GREATER_THAN (str): Represents a greater-than comparison.\n        GREATER_THAN_OR_EQUAL (str): Represents a greater-than-or-equal comparison.\n        IN_LIST (str): Represents a check for membership in a list.\n        NOT_IN_LIST (str): Represents a check for non-membership in a list.\n        LIKE (str): Represents a case-sensitive string pattern match.\n        ILIKE (str): Represents a case-insensitive string pattern match.\n        STARTS_WITH (str): Represents a check if a string starts with a given prefix.\n        ENDS_WITH (str): Represents a check if a string ends with a given suffix.\n        CONTAINS (str): Represents a check if a string contains a given substring.\n        IS_NULL (str): Represents a check if a value is null.\n        IS_NOT_NULL (str): Represents a check if a value is not null.\n    \"\"\"\n\n    EQUAL = \"equal\"\n    NOT_EQUAL = \"not_equal\"\n    LESS_THAN = \"less_than\"\n    LESS_THAN_OR_EQUAL = \"less_than_or_equal\"\n    GREATER_THAN = \"greater_than\"\n    GREATER_THAN_OR_EQUAL = \"greater_than_or_equal\"\n    IN_LIST = \"in_list\"\n    NOT_IN_LIST = \"not_in_list\"\n    LIKE = \"like\"\n    ILIKE = \"ilike\"\n    STARTS_WITH = \"starts_with\"\n    ENDS_WITH = \"ends_with\"\n    CONTAINS = \"contains\"\n    IS_NULL = \"is_null\"\n    IS_NOT_NULL = \"is_not_null\"\n</code></pre>"},{"location":"api_reference/models/#email-types","title":"Email Types","text":"<p>Type definitions for email-related operations.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.types.email_types.EmailAttachmentType","title":"<code>archipy.models.types.email_types.EmailAttachmentType</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum representing different types of email attachments.</p> <p>This enum defines the types of attachments that can be included in an email, such as files, base64-encoded data, URLs, or binary data.</p> <p>Attributes:</p> Name Type Description <code>FILE</code> <code>str</code> <p>Represents a file attachment.</p> <code>BASE64</code> <code>str</code> <p>Represents a base64-encoded attachment.</p> <code>URL</code> <code>str</code> <p>Represents an attachment referenced by a URL.</p> <code>BINARY</code> <code>str</code> <p>Represents raw binary data as an attachment.</p> Source code in <code>archipy/models/types/email_types.py</code> <pre><code>class EmailAttachmentType(StrEnum):\n    \"\"\"Enum representing different types of email attachments.\n\n    This enum defines the types of attachments that can be included in an email,\n    such as files, base64-encoded data, URLs, or binary data.\n\n    Attributes:\n        FILE (str): Represents a file attachment.\n        BASE64 (str): Represents a base64-encoded attachment.\n        URL (str): Represents an attachment referenced by a URL.\n        BINARY (str): Represents raw binary data as an attachment.\n    \"\"\"\n\n    FILE = \"file\"\n    BASE64 = \"base64\"\n    URL = \"url\"\n    BINARY = \"binary\"\n</code></pre>"},{"location":"api_reference/models/#archipy.models.types.email_types.EmailAttachmentDispositionType","title":"<code>archipy.models.types.email_types.EmailAttachmentDispositionType</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum representing attachment disposition types.</p> <p>This enum defines how an email attachment should be displayed or handled, such as being treated as a downloadable attachment or displayed inline.</p> <p>Attributes:</p> Name Type Description <code>ATTACHMENT</code> <code>str</code> <p>Represents an attachment that should be downloaded.</p> <code>INLINE</code> <code>str</code> <p>Represents an attachment that should be displayed inline.</p> Source code in <code>archipy/models/types/email_types.py</code> <pre><code>class EmailAttachmentDispositionType(StrEnum):\n    \"\"\"Enum representing attachment disposition types.\n\n    This enum defines how an email attachment should be displayed or handled,\n    such as being treated as a downloadable attachment or displayed inline.\n\n    Attributes:\n        ATTACHMENT (str): Represents an attachment that should be downloaded.\n        INLINE (str): Represents an attachment that should be displayed inline.\n    \"\"\"\n\n    ATTACHMENT = \"attachment\"\n    INLINE = \"inline\"\n</code></pre>"},{"location":"api_reference/models/#error-message-types","title":"Error Message Types","text":"<p>Standardized error message types for consistent error handling.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.types.error_message_types.ErrorMessageType","title":"<code>archipy.models.types.error_message_types.ErrorMessageType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of exception types with associated error details.</p> <p>This class defines a set of standard exception types, each with an associated error code, English and Farsi messages, and corresponding HTTP and gRPC status codes.</p> <p>Attributes:</p> Name Type Description <code>UNAUTHENTICATED</code> <p>Indicates that the user is not authenticated.</p> <code>INVALID_PHONE</code> <p>Indicates an invalid Iranian phone number.</p> <code>INVALID_LANDLINE</code> <p>Indicates an invalid Iranian landline number.</p> <code>INVALID_NATIONAL_CODE</code> <p>Indicates an invalid national code format.</p> <code>TOKEN_EXPIRED</code> <p>Indicates that the authentication token has expired.</p> <code>INVALID_TOKEN</code> <p>Indicates an invalid authentication token.</p> <code>PERMISSION_DENIED</code> <p>Indicates that the user does not have permission for the operation.</p> <code>NOT_FOUND</code> <p>Indicates that the requested resource was not found.</p> <code>ALREADY_EXISTS</code> <p>Indicates that the resource already exists.</p> <code>INVALID_ARGUMENT</code> <p>Indicates an invalid argument was provided.</p> <code>OUT_OF_RANGE</code> <p>Indicates that a value is out of the acceptable range.</p> <code>DEADLINE_EXCEEDED</code> <p>Indicates that the operation deadline was exceeded.</p> <code>FAILED_PRECONDITION</code> <p>Indicates that the operation preconditions were not met.</p> <code>RESOURCE_EXHAUSTED</code> <p>Indicates that the resource limit has been reached.</p> <code>ABORTED</code> <p>Indicates that the operation was aborted.</p> <code>CANCELLED</code> <p>Indicates that the operation was cancelled.</p> <code>INVALID_ENTITY_TYPE</code> <p>Indicates an invalid entity type.</p> <code>INTERNAL_ERROR</code> <p>Indicates an internal system error.</p> <code>DATA_LOSS</code> <p>Indicates critical data loss.</p> <code>UNIMPLEMENTED</code> <p>Indicates that the operation is not implemented.</p> <code>DEPRECATION</code> <p>Indicates that the operation is deprecated.</p> <code>UNAVAILABLE</code> <p>Indicates that the service is unavailable.</p> <code>UNKNOWN_ERROR</code> <p>Indicates an unknown error occurred.</p> <code>DEADLOCK</code> <p>Indicates a deadlock condition was detected.</p> Source code in <code>archipy/models/types/error_message_types.py</code> <pre><code>class ErrorMessageType(Enum):\n    \"\"\"Enumeration of exception types with associated error details.\n\n    This class defines a set of standard exception types, each with an associated error code,\n    English and Farsi messages, and corresponding HTTP and gRPC status codes.\n\n    Attributes:\n        UNAUTHENTICATED: Indicates that the user is not authenticated.\n        INVALID_PHONE: Indicates an invalid Iranian phone number.\n        INVALID_LANDLINE: Indicates an invalid Iranian landline number.\n        INVALID_NATIONAL_CODE: Indicates an invalid national code format.\n        TOKEN_EXPIRED: Indicates that the authentication token has expired.\n        INVALID_TOKEN: Indicates an invalid authentication token.\n        PERMISSION_DENIED: Indicates that the user does not have permission for the operation.\n        NOT_FOUND: Indicates that the requested resource was not found.\n        ALREADY_EXISTS: Indicates that the resource already exists.\n        INVALID_ARGUMENT: Indicates an invalid argument was provided.\n        OUT_OF_RANGE: Indicates that a value is out of the acceptable range.\n        DEADLINE_EXCEEDED: Indicates that the operation deadline was exceeded.\n        FAILED_PRECONDITION: Indicates that the operation preconditions were not met.\n        RESOURCE_EXHAUSTED: Indicates that the resource limit has been reached.\n        ABORTED: Indicates that the operation was aborted.\n        CANCELLED: Indicates that the operation was cancelled.\n        INVALID_ENTITY_TYPE: Indicates an invalid entity type.\n        INTERNAL_ERROR: Indicates an internal system error.\n        DATA_LOSS: Indicates critical data loss.\n        UNIMPLEMENTED: Indicates that the operation is not implemented.\n        DEPRECATION: Indicates that the operation is deprecated.\n        UNAVAILABLE: Indicates that the service is unavailable.\n        UNKNOWN_ERROR: Indicates an unknown error occurred.\n        DEADLOCK: Indicates a deadlock condition was detected.\n    \"\"\"\n\n    # Authentication Errors (400, 401, 403)\n    UNAUTHENTICATED = ErrorDetailDTO.create_error_detail(\n        code=\"UNAUTHENTICATED\",\n        message_en=\"You are not authorized to perform this action.\",\n        message_fa=\"\u0634\u0645\u0627 \u0645\u062c\u0648\u0632 \u0627\u0646\u062c\u0627\u0645 \u0627\u06cc\u0646 \u0639\u0645\u0644 \u0631\u0627 \u0646\u062f\u0627\u0631\u06cc\u062f.\",\n        http_status=HTTPStatus.UNAUTHORIZED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAUTHENTICATED if GRPC_AVAILABLE else None,\n    )\n    INVALID_PHONE = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_PHONE\",\n        message_en=\"Invalid Iranian phone number\",\n        message_fa=\"\u0634\u0645\u0627\u0631\u0647 \u062a\u0644\u0641\u0646 \u0647\u0645\u0631\u0627\u0647 \u0627\u06cc\u0631\u0627\u0646 \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_LANDLINE = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_LANDLINE\",\n        message_en=\"Invalid Iranian landline number\",\n        message_fa=\"\u0634\u0645\u0627\u0631\u0647 \u062a\u0644\u0641\u0646 \u062b\u0627\u0628\u062a \u0627\u06cc\u0631\u0627\u0646 \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_NATIONAL_CODE = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_NATIONAL_CODE\",\n        message_en=\"Invalid national code format\",\n        message_fa=\"\u0641\u0631\u0645\u062a \u06a9\u062f \u0645\u0644\u06cc \u0648\u0627\u0631\u062f \u0634\u062f\u0647 \u0627\u0634\u062a\u0628\u0627\u0647 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    TOKEN_EXPIRED = ErrorDetailDTO.create_error_detail(\n        code=\"TOKEN_EXPIRED\",\n        message_en=\"Authentication token has expired\",\n        message_fa=\"\u062a\u0648\u06a9\u0646 \u0627\u062d\u0631\u0627\u0632 \u0647\u0648\u06cc\u062a \u0645\u0646\u0642\u0636\u06cc \u0634\u062f\u0647 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.UNAUTHORIZED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAUTHENTICATED if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_TOKEN = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_TOKEN\",\n        message_en=\"Invalid authentication token\",\n        message_fa=\"\u062a\u0648\u06a9\u0646 \u0627\u062d\u0631\u0627\u0632 \u0647\u0648\u06cc\u062a \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.UNAUTHORIZED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAUTHENTICATED if GRPC_AVAILABLE else None,\n    )\n\n    PERMISSION_DENIED = ErrorDetailDTO.create_error_detail(\n        code=\"PERMISSION_DENIED\",\n        message_en=\"Permission denied for this operation\",\n        message_fa=\"\u062f\u0633\u062a\u0631\u0633\u06cc \u0628\u0631\u0627\u06cc \u0627\u0646\u062c\u0627\u0645 \u0627\u06cc\u0646 \u0639\u0645\u0644\u06cc\u0627\u062a \u0648\u062c\u0648\u062f \u0646\u062f\u0627\u0631\u062f.\",\n        http_status=HTTPStatus.FORBIDDEN if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.PERMISSION_DENIED if GRPC_AVAILABLE else None,\n    )\n\n    # Resource Errors (404, 409)\n    NOT_FOUND = ErrorDetailDTO.create_error_detail(\n        code=\"NOT_FOUND\",\n        message_en=\"Requested resource not found\",\n        message_fa=\"\u0645\u0646\u0628\u0639 \u062f\u0631\u062e\u0648\u0627\u0633\u062a\u06cc \u06cc\u0627\u0641\u062a \u0646\u0634\u062f.\",\n        http_status=HTTPStatus.NOT_FOUND if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.NOT_FOUND if GRPC_AVAILABLE else None,\n    )\n\n    ALREADY_EXISTS = ErrorDetailDTO.create_error_detail(\n        code=\"ALREADY_EXISTS\",\n        message_en=\"Resource already exists\",\n        message_fa=\"\u0645\u0646\u0628\u0639 \u0627\u0632 \u0642\u0628\u0644 \u0645\u0648\u062c\u0648\u062f \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.ALREADY_EXISTS if GRPC_AVAILABLE else None,\n    )\n\n    # Validation Errors (400)\n    INVALID_ARGUMENT = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_ARGUMENT\",\n        message_en=\"Invalid argument provided\",\n        message_fa=\"\u067e\u0627\u0631\u0627\u0645\u062a\u0631 \u0648\u0631\u0648\u062f\u06cc \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_PASSWORD = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_PASSWORD\",\n        message_en=\"Password does not meet the security requirements\",\n        message_fa=\"\u0631\u0645\u0632 \u0639\u0628\u0648\u0631 \u0627\u0644\u0632\u0627\u0645\u0627\u062a \u0627\u0645\u0646\u06cc\u062a\u06cc \u0631\u0627 \u0628\u0631\u0622\u0648\u0631\u062f\u0647 \u0646\u0645\u06cc\u200c\u06a9\u0646\u062f.\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    OUT_OF_RANGE = ErrorDetailDTO.create_error_detail(\n        code=\"OUT_OF_RANGE\",\n        message_en=\"Value is out of acceptable range\",\n        message_fa=\"\u0645\u0642\u062f\u0627\u0631 \u062e\u0627\u0631\u062c \u0627\u0632 \u0645\u062d\u062f\u0648\u062f\u0647 \u0645\u062c\u0627\u0632 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.OUT_OF_RANGE if GRPC_AVAILABLE else None,\n    )\n\n    # Operation Errors (408, 409, 412, 429)\n    DEADLINE_EXCEEDED = ErrorDetailDTO.create_error_detail(\n        code=\"DEADLINE_EXCEEDED\",\n        message_en=\"Operation deadline exceeded\",\n        message_fa=\"\u0645\u0647\u0644\u062a \u0627\u0646\u062c\u0627\u0645 \u0639\u0645\u0644\u06cc\u0627\u062a \u0628\u0647 \u067e\u0627\u06cc\u0627\u0646 \u0631\u0633\u06cc\u062f\u0647 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.REQUEST_TIMEOUT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.DEADLINE_EXCEEDED if GRPC_AVAILABLE else None,\n    )\n\n    FAILED_PRECONDITION = ErrorDetailDTO.create_error_detail(\n        code=\"FAILED_PRECONDITION\",\n        message_en=\"Operation preconditions not met\",\n        message_fa=\"\u067e\u06cc\u0634\u200c\u0646\u06cc\u0627\u0632\u0647\u0627\u06cc \u0639\u0645\u0644\u06cc\u0627\u062a \u0628\u0631\u0622\u0648\u0631\u062f\u0647 \u0646\u0634\u062f\u0647 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.PRECONDITION_FAILED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.FAILED_PRECONDITION if GRPC_AVAILABLE else None,\n    )\n\n    RESOURCE_EXHAUSTED = ErrorDetailDTO.create_error_detail(\n        code=\"RESOURCE_EXHAUSTED\",\n        message_en=\"Resource limit has been reached\",\n        message_fa=\"\u0645\u062d\u062f\u0648\u062f\u06cc\u062a \u0645\u0646\u0627\u0628\u0639 \u0628\u0647 \u067e\u0627\u06cc\u0627\u0646 \u0631\u0633\u06cc\u062f\u0647 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.TOO_MANY_REQUESTS if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.RESOURCE_EXHAUSTED if GRPC_AVAILABLE else None,\n    )\n\n    ABORTED = ErrorDetailDTO.create_error_detail(\n        code=\"ABORTED\",\n        message_en=\"Operation was aborted\",\n        message_fa=\"\u0639\u0645\u0644\u06cc\u0627\u062a \u0645\u062a\u0648\u0642\u0641 \u0634\u062f.\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.ABORTED if GRPC_AVAILABLE else None,\n    )\n\n    CANCELLED = ErrorDetailDTO.create_error_detail(\n        code=\"CANCELLED\",\n        message_en=\"Operation was cancelled\",\n        message_fa=\"\u0639\u0645\u0644\u06cc\u0627\u062a \u0644\u063a\u0648 \u0634\u062f.\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.CANCELLED if GRPC_AVAILABLE else None,\n    )\n\n    INSUFFICIENT_BALANCE = ErrorDetailDTO.create_error_detail(\n        code=\"INSUFFICIENT_BALANCE\",\n        message_en=\"Insufficient balance for operation\",\n        message_fa=\"\u0639\u062f\u0645 \u0645\u0648\u062c\u0648\u062f\u06cc \u06a9\u0627\u0641\u06cc \u0628\u0631\u0627\u06cc \u0639\u0645\u0644\u06cc\u0627\u062a.\",\n        http_status=HTTPStatus.PAYMENT_REQUIRED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.FAILED_PRECONDITION if GRPC_AVAILABLE else None,\n    )\n\n    # System Errors (500, 501, 503)\n    INVALID_ENTITY_TYPE = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_ENTITY\",\n        message_en=\"Invalid entity type\",\n        message_fa=\"\u0646\u0648\u0639 \u0645\u0648\u062c\u0648\u062f\u06cc\u062a \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n    INTERNAL_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"INTERNAL_ERROR\",\n        message_en=\"Internal system error occurred\",\n        message_fa=\"\u062e\u0637\u0627\u06cc \u062f\u0627\u062e\u0644\u06cc \u0633\u06cc\u0633\u062a\u0645 \u0631\u062e \u062f\u0627\u062f\u0647 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    DATA_LOSS = ErrorDetailDTO.create_error_detail(\n        code=\"DATA_LOSS\",\n        message_en=\"Critical data loss detected\",\n        message_fa=\"\u0627\u0632 \u062f\u0633\u062a \u062f\u0627\u062f\u0646 \u0627\u0637\u0644\u0627\u0639\u0627\u062a \u062d\u06cc\u0627\u062a\u06cc \u062a\u0634\u062e\u06cc\u0635 \u062f\u0627\u062f\u0647 \u0634\u062f.\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.DATA_LOSS if GRPC_AVAILABLE else None,\n    )\n\n    UNIMPLEMENTED = ErrorDetailDTO.create_error_detail(\n        code=\"UNIMPLEMENTED\",\n        message_en=\"Requested operation is not implemented\",\n        message_fa=\"\u0639\u0645\u0644\u06cc\u0627\u062a \u062f\u0631\u062e\u0648\u0627\u0633\u062a\u06cc \u067e\u06cc\u0627\u062f\u0647\u200c\u0633\u0627\u0632\u06cc \u0646\u0634\u062f\u0647 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.NOT_IMPLEMENTED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNIMPLEMENTED if GRPC_AVAILABLE else None,\n    )\n\n    DEPRECATION = ErrorDetailDTO.create_error_detail(\n        code=\"DEPRECATION\",\n        message_en=\"This operation is deprecated and will be removed in a future version.\",\n        message_fa=\"\u0627\u06cc\u0646 \u0639\u0645\u0644\u06cc\u0627\u062a \u0645\u0646\u0633\u0648\u062e \u0634\u062f\u0647 \u0648 \u062f\u0631 \u0646\u0633\u062e\u0647\u200c\u0647\u0627\u06cc \u0622\u06cc\u0646\u062f\u0647 \u062d\u0630\u0641 \u062e\u0648\u0627\u0647\u062f \u0634\u062f.\",\n        http_status=HTTPStatus.GONE if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAVAILABLE if GRPC_AVAILABLE else None,\n    )\n\n    UNAVAILABLE = ErrorDetailDTO.create_error_detail(\n        code=\"UNAVAILABLE\",\n        message_en=\"Service is currently unavailable\",\n        message_fa=\"\u0633\u0631\u0648\u06cc\u0633 \u062f\u0631 \u062d\u0627\u0644 \u062d\u0627\u0636\u0631 \u062f\u0631 \u062f\u0633\u062a\u0631\u0633 \u0646\u06cc\u0633\u062a.\",\n        http_status=HTTPStatus.SERVICE_UNAVAILABLE if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAVAILABLE if GRPC_AVAILABLE else None,\n    )\n\n    UNKNOWN_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"UNKNOWN_ERROR\",\n        message_en=\"An unknown error occurred\",\n        message_fa=\"\u062e\u0637\u0627\u06cc \u0646\u0627\u0634\u0646\u0627\u062e\u062a\u0647\u200c\u0627\u06cc \u0631\u062e \u062f\u0627\u062f\u0647 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNKNOWN if GRPC_AVAILABLE else None,\n    )\n\n    DEADLOCK = ErrorDetailDTO.create_error_detail(\n        code=\"DEADLOCK\",\n        message_en=\"Deadlock detected\",\n        message_fa=\"\u062e\u0637\u0627\u06cc \u0642\u0641\u0644\u200c\u0634\u062f\u06af\u06cc (Deadlock) \u062a\u0634\u062e\u06cc\u0635 \u062f\u0627\u062f\u0647 \u0634\u062f.\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    # Authentication &amp; Authorization\n    INVALID_CREDENTIALS = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_CREDENTIALS\",\n        message_en=\"Invalid username or password\",\n        message_fa=\"\u0646\u0627\u0645 \u06a9\u0627\u0631\u0628\u0631\u06cc \u06cc\u0627 \u0631\u0645\u0632 \u0639\u0628\u0648\u0631 \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.UNAUTHORIZED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAUTHENTICATED if GRPC_AVAILABLE else None,\n    )\n\n    ACCOUNT_LOCKED = ErrorDetailDTO.create_error_detail(\n        code=\"ACCOUNT_LOCKED\",\n        message_en=\"Account has been locked due to too many failed attempts\",\n        message_fa=\"\u062d\u0633\u0627\u0628 \u06a9\u0627\u0631\u0628\u0631\u06cc \u0628\u0647 \u062f\u0644\u06cc\u0644 \u062a\u0644\u0627\u0634\u200c\u0647\u0627\u06cc \u0646\u0627\u0645\u0648\u0641\u0642 \u0645\u062a\u0639\u062f\u062f \u0642\u0641\u0644 \u0634\u062f\u0647 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.FORBIDDEN if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.PERMISSION_DENIED if GRPC_AVAILABLE else None,\n    )\n\n    ACCOUNT_DISABLED = ErrorDetailDTO.create_error_detail(\n        code=\"ACCOUNT_DISABLED\",\n        message_en=\"Account has been disabled\",\n        message_fa=\"\u062d\u0633\u0627\u0628 \u06a9\u0627\u0631\u0628\u0631\u06cc \u063a\u06cc\u0631\u0641\u0639\u0627\u0644 \u0634\u062f\u0647 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.FORBIDDEN if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.PERMISSION_DENIED if GRPC_AVAILABLE else None,\n    )\n\n    SESSION_EXPIRED = ErrorDetailDTO.create_error_detail(\n        code=\"SESSION_EXPIRED\",\n        message_en=\"Session has expired\",\n        message_fa=\"\u0646\u0634\u0633\u062a \u06a9\u0627\u0631\u0628\u0631\u06cc \u0645\u0646\u0642\u0636\u06cc \u0634\u062f\u0647 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.UNAUTHORIZED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAUTHENTICATED if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_REFRESH_TOKEN = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_REFRESH_TOKEN\",\n        message_en=\"Invalid refresh token\",\n        message_fa=\"\u062a\u0648\u06a9\u0646 \u062a\u0627\u0632\u0647\u200c\u0633\u0627\u0632\u06cc \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.UNAUTHORIZED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAUTHENTICATED if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_VERIFICATION_CODE = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_VERIFICATION_CODE\",\n        message_en=\"Invalid verification code\",\n        message_fa=\"\u06a9\u062f \u062a\u0627\u06cc\u06cc\u062f \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    # Resource &amp; Data\n    CONFLICT = ErrorDetailDTO.create_error_detail(\n        code=\"CONFLICT\",\n        message_en=\"Resource conflict detected\",\n        message_fa=\"\u062a\u0639\u0627\u0631\u0636 \u062f\u0631 \u0645\u0646\u0627\u0628\u0639 \u062a\u0634\u062e\u06cc\u0635 \u062f\u0627\u062f\u0647 \u0634\u062f\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.ABORTED if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_FORMAT = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_FORMAT\",\n        message_en=\"Invalid data format\",\n        message_fa=\"\u0641\u0631\u0645\u062a \u062f\u0627\u062f\u0647 \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    FILE_TOO_LARGE = ErrorDetailDTO.create_error_detail(\n        code=\"FILE_TOO_LARGE\",\n        message_en=\"File size exceeds the maximum allowed limit\",\n        message_fa=\"\u062d\u062c\u0645 \u0641\u0627\u06cc\u0644 \u0627\u0632 \u062d\u062f \u0645\u062c\u0627\u0632 \u0628\u06cc\u0634\u062a\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_FILE_TYPE = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_FILE_TYPE\",\n        message_en=\"File type is not supported\",\n        message_fa=\"\u0646\u0648\u0639 \u0641\u0627\u06cc\u0644 \u067e\u0634\u062a\u06cc\u0628\u0627\u0646\u06cc \u0646\u0645\u06cc\u200c\u0634\u0648\u062f\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    QUOTA_EXCEEDED = ErrorDetailDTO.create_error_detail(\n        code=\"QUOTA_EXCEEDED\",\n        message_en=\"Storage quota has been exceeded\",\n        message_fa=\"\u0633\u0647\u0645\u06cc\u0647 \u0630\u062e\u06cc\u0631\u0647\u200c\u0633\u0627\u0632\u06cc \u0628\u0647 \u067e\u0627\u06cc\u0627\u0646 \u0631\u0633\u06cc\u062f\u0647 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.FORBIDDEN if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.RESOURCE_EXHAUSTED if GRPC_AVAILABLE else None,\n    )\n\n    RATE_LIMIT_EXCEEDED = ErrorDetailDTO.create_error_detail(\n        code=\"RATE_LIMIT_EXCEEDED\",\n        message_en=\"Rate limit has been exceeded\",\n        message_fa=\"\u0645\u062d\u062f\u0648\u062f\u06cc\u062a \u0646\u0631\u062e \u062f\u0631\u062e\u0648\u0627\u0633\u062a \u0628\u0647 \u067e\u0627\u06cc\u0627\u0646 \u0631\u0633\u06cc\u062f\u0647 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.TOO_MANY_REQUESTS if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.RESOURCE_EXHAUSTED if GRPC_AVAILABLE else None,\n    )\n\n    # Network &amp; Communication\n    CONNECTION_TIMEOUT = ErrorDetailDTO.create_error_detail(\n        code=\"CONNECTION_TIMEOUT\",\n        message_en=\"Connection timed out\",\n        message_fa=\"\u0627\u062a\u0635\u0627\u0644 \u0628\u0627 \u062a\u0627\u06cc\u0645\u200c\u0627\u0648\u062a \u0645\u0648\u0627\u062c\u0647 \u0634\u062f\",\n        http_status=HTTPStatus.REQUEST_TIMEOUT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.DEADLINE_EXCEEDED if GRPC_AVAILABLE else None,\n    )\n\n    NETWORK_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"NETWORK_ERROR\",\n        message_en=\"Network error occurred\",\n        message_fa=\"\u062e\u0637\u0627\u06cc \u0634\u0628\u06a9\u0647 \u0631\u062e \u062f\u0627\u062f\u0647 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.BAD_GATEWAY if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAVAILABLE if GRPC_AVAILABLE else None,\n    )\n\n    SERVICE_UNAVAILABLE = ErrorDetailDTO.create_error_detail(\n        code=\"SERVICE_UNAVAILABLE\",\n        message_en=\"Service is currently unavailable\",\n        message_fa=\"\u0633\u0631\u0648\u06cc\u0633 \u062f\u0631 \u062d\u0627\u0644 \u062d\u0627\u0636\u0631 \u062f\u0631 \u062f\u0633\u062a\u0631\u0633 \u0646\u06cc\u0633\u062a\",\n        http_status=HTTPStatus.SERVICE_UNAVAILABLE if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAVAILABLE if GRPC_AVAILABLE else None,\n    )\n\n    GATEWAY_TIMEOUT = ErrorDetailDTO.create_error_detail(\n        code=\"GATEWAY_TIMEOUT\",\n        message_en=\"Gateway timeout\",\n        message_fa=\"\u062a\u0627\u06cc\u0645\u200c\u0627\u0648\u062a \u062f\u0631\u0648\u0627\u0632\u0647\",\n        http_status=HTTPStatus.GATEWAY_TIMEOUT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.DEADLINE_EXCEEDED if GRPC_AVAILABLE else None,\n    )\n\n    BAD_GATEWAY = ErrorDetailDTO.create_error_detail(\n        code=\"BAD_GATEWAY\",\n        message_en=\"Bad gateway\",\n        message_fa=\"\u062f\u0631\u0648\u0627\u0632\u0647 \u0646\u0627\u0645\u0639\u062a\u0628\u0631\",\n        http_status=HTTPStatus.BAD_GATEWAY if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAVAILABLE if GRPC_AVAILABLE else None,\n    )\n\n    # Business Logic\n    INVALID_STATE = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_STATE\",\n        message_en=\"Invalid state for the requested operation\",\n        message_fa=\"\u0648\u0636\u0639\u06cc\u062a \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0628\u0631\u0627\u06cc \u0639\u0645\u0644\u06cc\u0627\u062a \u062f\u0631\u062e\u0648\u0627\u0633\u062a\u06cc\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.FAILED_PRECONDITION if GRPC_AVAILABLE else None,\n    )\n\n    BUSINESS_RULE_VIOLATION = ErrorDetailDTO.create_error_detail(\n        code=\"BUSINESS_RULE_VIOLATION\",\n        message_en=\"Business rule violation\",\n        message_fa=\"\u0646\u0642\u0636 \u0642\u0648\u0627\u0646\u06cc\u0646 \u06a9\u0633\u0628 \u0648 \u06a9\u0627\u0631\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.FAILED_PRECONDITION if GRPC_AVAILABLE else None,\n    )\n\n    INSUFFICIENT_FUNDS = ErrorDetailDTO.create_error_detail(\n        code=\"INSUFFICIENT_FUNDS\",\n        message_en=\"Insufficient funds for the operation\",\n        message_fa=\"\u0645\u0648\u062c\u0648\u062f\u06cc \u0646\u0627\u06a9\u0627\u0641\u06cc \u0628\u0631\u0627\u06cc \u0639\u0645\u0644\u06cc\u0627\u062a\",\n        http_status=HTTPStatus.PAYMENT_REQUIRED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.FAILED_PRECONDITION if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_OPERATION = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_OPERATION\",\n        message_en=\"Operation is not allowed in the current context\",\n        message_fa=\"\u0639\u0645\u0644\u06cc\u0627\u062a \u062f\u0631 \u0648\u0636\u0639\u06cc\u062a \u0641\u0639\u0644\u06cc \u0645\u062c\u0627\u0632 \u0646\u06cc\u0633\u062a\",\n        http_status=HTTPStatus.FORBIDDEN if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.PERMISSION_DENIED if GRPC_AVAILABLE else None,\n    )\n\n    MAINTENANCE_MODE = ErrorDetailDTO.create_error_detail(\n        code=\"MAINTENANCE_MODE\",\n        message_en=\"System is currently in maintenance mode\",\n        message_fa=\"\u0633\u06cc\u0633\u062a\u0645 \u062f\u0631 \u062d\u0627\u0644 \u062d\u0627\u0636\u0631 \u062f\u0631 \u062d\u0627\u0644\u062a \u062a\u0639\u0645\u06cc\u0631 \u0648 \u0646\u06af\u0647\u062f\u0627\u0631\u06cc \u0627\u0633\u062a\",\n        http_status=HTTPStatus.SERVICE_UNAVAILABLE if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAVAILABLE if GRPC_AVAILABLE else None,\n    )\n\n    # Validation\n    INVALID_EMAIL = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_EMAIL\",\n        message_en=\"Invalid email format\",\n        message_fa=\"\u0641\u0631\u0645\u062a \u0627\u06cc\u0645\u06cc\u0644 \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_DATE = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_DATE\",\n        message_en=\"Invalid date format\",\n        message_fa=\"\u0641\u0631\u0645\u062a \u062a\u0627\u0631\u06cc\u062e \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_URL = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_URL\",\n        message_en=\"Invalid URL format\",\n        message_fa=\"\u0641\u0631\u0645\u062a URL \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_IP = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_IP\",\n        message_en=\"Invalid IP address format\",\n        message_fa=\"\u0641\u0631\u0645\u062a \u0622\u062f\u0631\u0633 IP \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_JSON = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_JSON\",\n        message_en=\"Invalid JSON format\",\n        message_fa=\"\u0641\u0631\u0645\u062a JSON \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    # Database &amp; Storage Errors\n    DATABASE_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"DATABASE_ERROR\",\n        message_en=\"Database error occurred\",\n        message_fa=\"\u062e\u0637\u0627\u06cc \u067e\u0627\u06cc\u06af\u0627\u0647 \u062f\u0627\u062f\u0647 \u0631\u062e \u062f\u0627\u062f\u0647 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    DATABASE_CONNECTION_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"DATABASE_CONNECTION_ERROR\",\n        message_en=\"Failed to connect to the database\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u0627\u062a\u0635\u0627\u0644 \u0628\u0647 \u067e\u0627\u06cc\u06af\u0627\u0647 \u062f\u0627\u062f\u0647\",\n        http_status=HTTPStatus.SERVICE_UNAVAILABLE if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAVAILABLE if GRPC_AVAILABLE else None,\n    )\n\n    DATABASE_QUERY_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"DATABASE_QUERY_ERROR\",\n        message_en=\"Error executing database query\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u0627\u062c\u0631\u0627\u06cc \u067e\u0631\u0633 \u0648 \u062c\u0648\u06cc \u067e\u0627\u06cc\u06af\u0627\u0647 \u062f\u0627\u062f\u0647\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    DATABASE_TRANSACTION_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"DATABASE_TRANSACTION_ERROR\",\n        message_en=\"Error in database transaction\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u062a\u0631\u0627\u06a9\u0646\u0634 \u067e\u0627\u06cc\u06af\u0627\u0647 \u062f\u0627\u062f\u0647\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    DATABASE_TIMEOUT_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"DATABASE_TIMEOUT_ERROR\",\n        message_en=\"Database operation timed out\",\n        message_fa=\"\u0639\u0645\u0644\u06cc\u0627\u062a \u067e\u0627\u06cc\u06af\u0627\u0647 \u062f\u0627\u062f\u0647 \u0628\u0627 \u062a\u0627\u06cc\u0645\u200c\u0627\u0648\u062a \u0645\u0648\u0627\u062c\u0647 \u0634\u062f\",\n        http_status=HTTPStatus.REQUEST_TIMEOUT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.DEADLINE_EXCEEDED if GRPC_AVAILABLE else None,\n    )\n\n    DATABASE_CONSTRAINT_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"DATABASE_CONSTRAINT_ERROR\",\n        message_en=\"Database constraint violation\",\n        message_fa=\"\u0646\u0642\u0636 \u0645\u062d\u062f\u0648\u062f\u06cc\u062a \u067e\u0627\u06cc\u06af\u0627\u0647 \u062f\u0627\u062f\u0647\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.FAILED_PRECONDITION if GRPC_AVAILABLE else None,\n    )\n\n    DATABASE_INTEGRITY_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"DATABASE_INTEGRITY_ERROR\",\n        message_en=\"Database integrity violation\",\n        message_fa=\"\u0646\u0642\u0636 \u06cc\u06a9\u067e\u0627\u0631\u0686\u06af\u06cc \u067e\u0627\u06cc\u06af\u0627\u0647 \u062f\u0627\u062f\u0647\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.FAILED_PRECONDITION if GRPC_AVAILABLE else None,\n    )\n\n    DATABASE_DEADLOCK_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"DATABASE_DEADLOCK_ERROR\",\n        message_en=\"Database deadlock detected\",\n        message_fa=\"\u0642\u0641\u0644\u200c\u0634\u062f\u06af\u06cc \u067e\u0627\u06cc\u06af\u0627\u0647 \u062f\u0627\u062f\u0647 \u062a\u0634\u062e\u06cc\u0635 \u062f\u0627\u062f\u0647 \u0634\u062f\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.ABORTED if GRPC_AVAILABLE else None,\n    )\n\n    DATABASE_SERIALIZATION_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"DATABASE_SERIALIZATION_ERROR\",\n        message_en=\"Database serialization failure\",\n        message_fa=\"\u062e\u0637\u0627\u06cc \u0633\u0631\u06cc\u0627\u0644\u200c\u0633\u0627\u0632\u06cc \u067e\u0627\u06cc\u06af\u0627\u0647 \u062f\u0627\u062f\u0647\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.ABORTED if GRPC_AVAILABLE else None,\n    )\n\n    DATABASE_CONFIGURATION_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"DATABASE_CONFIGURATION_ERROR\",\n        message_en=\"Database configuration error\",\n        message_fa=\"\u062e\u0637\u0627\u06cc \u067e\u06cc\u06a9\u0631\u0628\u0646\u062f\u06cc \u067e\u0627\u06cc\u06af\u0627\u0647 \u062f\u0627\u062f\u0647\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    STORAGE_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"STORAGE_ERROR\",\n        message_en=\"Storage access error occurred\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u062f\u0633\u062a\u0631\u0633\u06cc \u0628\u0647 \u0641\u0636\u0627\u06cc \u0630\u062e\u06cc\u0631\u0647\u200c\u0633\u0627\u0632\u06cc\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    # Cache Errors\n    CACHE_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"CACHE_ERROR\",\n        message_en=\"Error accessing cache\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u062f\u0633\u062a\u0631\u0633\u06cc \u0628\u0647 \u062d\u0627\u0641\u0638\u0647 \u0646\u0647\u0627\u0646\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    CACHE_MISS = ErrorDetailDTO.create_error_detail(\n        code=\"CACHE_MISS\",\n        message_en=\"Requested data not found in cache\",\n        message_fa=\"\u062f\u0627\u062f\u0647 \u062f\u0631\u062e\u0648\u0627\u0633\u062a\u06cc \u062f\u0631 \u062d\u0627\u0641\u0638\u0647 \u0646\u0647\u0627\u0646 \u06cc\u0627\u0641\u062a \u0646\u0634\u062f\",\n        http_status=HTTPStatus.NOT_FOUND if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.NOT_FOUND if GRPC_AVAILABLE else None,\n    )\n\n    # Message Queue Errors\n    QUEUE_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"QUEUE_ERROR\",\n        message_en=\"Error in message queue operation\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u0639\u0645\u0644\u06cc\u0627\u062a \u0635\u0641 \u067e\u06cc\u0627\u0645\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    QUEUE_FULL = ErrorDetailDTO.create_error_detail(\n        code=\"QUEUE_FULL\",\n        message_en=\"Message queue is full\",\n        message_fa=\"\u0635\u0641 \u067e\u06cc\u0627\u0645 \u067e\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.SERVICE_UNAVAILABLE if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.RESOURCE_EXHAUSTED if GRPC_AVAILABLE else None,\n    )\n\n    # Search Engine Errors\n    SEARCH_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"SEARCH_ERROR\",\n        message_en=\"Error performing search operation\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u0627\u0646\u062c\u0627\u0645 \u0639\u0645\u0644\u06cc\u0627\u062a \u062c\u0633\u062a\u062c\u0648\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    SEARCH_TIMEOUT = ErrorDetailDTO.create_error_detail(\n        code=\"SEARCH_TIMEOUT\",\n        message_en=\"Search operation timed out\",\n        message_fa=\"\u0639\u0645\u0644\u06cc\u0627\u062a \u062c\u0633\u062a\u062c\u0648 \u0628\u0627 \u062a\u0627\u06cc\u0645\u200c\u0627\u0648\u062a \u0645\u0648\u0627\u062c\u0647 \u0634\u062f\",\n        http_status=HTTPStatus.REQUEST_TIMEOUT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.DEADLINE_EXCEEDED if GRPC_AVAILABLE else None,\n    )\n\n    # External Service Errors\n    EXTERNAL_SERVICE_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"EXTERNAL_SERVICE_ERROR\",\n        message_en=\"Error in external service\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u0633\u0631\u0648\u06cc\u0633 \u062e\u0627\u0631\u062c\u06cc\",\n        http_status=HTTPStatus.BAD_GATEWAY if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAVAILABLE if GRPC_AVAILABLE else None,\n    )\n\n    EXTERNAL_SERVICE_TIMEOUT = ErrorDetailDTO.create_error_detail(\n        code=\"EXTERNAL_SERVICE_TIMEOUT\",\n        message_en=\"External service request timed out\",\n        message_fa=\"\u062f\u0631\u062e\u0648\u0627\u0633\u062a \u0628\u0647 \u0633\u0631\u0648\u06cc\u0633 \u062e\u0627\u0631\u062c\u06cc \u0628\u0627 \u062a\u0627\u06cc\u0645\u200c\u0627\u0648\u062a \u0645\u0648\u0627\u062c\u0647 \u0634\u062f\",\n        http_status=HTTPStatus.GATEWAY_TIMEOUT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.DEADLINE_EXCEEDED if GRPC_AVAILABLE else None,\n    )\n\n    # Security Errors\n    SECURITY_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"SECURITY_ERROR\",\n        message_en=\"Security violation detected\",\n        message_fa=\"\u0646\u0642\u0636 \u0627\u0645\u0646\u06cc\u062a\u06cc \u062a\u0634\u062e\u06cc\u0635 \u062f\u0627\u062f\u0647 \u0634\u062f\",\n        http_status=HTTPStatus.FORBIDDEN if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.PERMISSION_DENIED if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_SIGNATURE = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_SIGNATURE\",\n        message_en=\"Invalid digital signature\",\n        message_fa=\"\u0627\u0645\u0636\u0627\u06cc \u062f\u06cc\u062c\u06cc\u062a\u0627\u0644 \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.UNAUTHORIZED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAUTHENTICATED if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_CERTIFICATE = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_CERTIFICATE\",\n        message_en=\"Invalid security certificate\",\n        message_fa=\"\u06af\u0648\u0627\u0647\u06cc \u0627\u0645\u0646\u06cc\u062a\u06cc \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.UNAUTHORIZED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAUTHENTICATED if GRPC_AVAILABLE else None,\n    )\n\n    # Configuration Errors\n    CONFIGURATION_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"CONFIGURATION_ERROR\",\n        message_en=\"Error in system configuration\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u067e\u06cc\u06a9\u0631\u0628\u0646\u062f\u06cc \u0633\u06cc\u0633\u062a\u0645\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    MISSING_CONFIGURATION = ErrorDetailDTO.create_error_detail(\n        code=\"MISSING_CONFIGURATION\",\n        message_en=\"Required configuration is missing\",\n        message_fa=\"\u067e\u06cc\u06a9\u0631\u0628\u0646\u062f\u06cc \u0645\u0648\u0631\u062f \u0646\u06cc\u0627\u0632 \u0648\u062c\u0648\u062f \u0646\u062f\u0627\u0631\u062f\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.FAILED_PRECONDITION if GRPC_AVAILABLE else None,\n    )\n\n    # Integration Errors\n    INTEGRATION_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"INTEGRATION_ERROR\",\n        message_en=\"Error in system integration\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u06cc\u06a9\u067e\u0627\u0631\u0686\u0647\u200c\u0633\u0627\u0632\u06cc \u0633\u06cc\u0633\u062a\u0645\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    INCOMPATIBLE_VERSION = ErrorDetailDTO.create_error_detail(\n        code=\"INCOMPATIBLE_VERSION\",\n        message_en=\"Incompatible system version\",\n        message_fa=\"\u0646\u0633\u062e\u0647 \u0633\u06cc\u0633\u062a\u0645 \u0646\u0627\u0633\u0627\u0632\u06af\u0627\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.FAILED_PRECONDITION if GRPC_AVAILABLE else None,\n    )\n\n    # Monitoring &amp; Logging Errors\n    MONITORING_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"MONITORING_ERROR\",\n        message_en=\"Error in monitoring system\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u0633\u06cc\u0633\u062a\u0645 \u0646\u0638\u0627\u0631\u062a\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    LOGGING_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"LOGGING_ERROR\",\n        message_en=\"Error in logging system\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u0633\u06cc\u0633\u062a\u0645 \u062b\u0628\u062a \u0631\u0648\u06cc\u062f\u0627\u062f\u0647\u0627\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    # Backup &amp; Recovery Errors\n    BACKUP_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"BACKUP_ERROR\",\n        message_en=\"Error in backup operation\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u0639\u0645\u0644\u06cc\u0627\u062a \u067e\u0634\u062a\u06cc\u0628\u0627\u0646\u200c\u06af\u06cc\u0631\u06cc\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    RECOVERY_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"RECOVERY_ERROR\",\n        message_en=\"Error in recovery operation\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u0639\u0645\u0644\u06cc\u0627\u062a \u0628\u0627\u0632\u06cc\u0627\u0628\u06cc\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    # Resource Management Errors\n    RESOURCE_LOCKED = ErrorDetailDTO.create_error_detail(\n        code=\"RESOURCE_LOCKED\",\n        message_en=\"Resource is currently locked\",\n        message_fa=\"\u0645\u0646\u0628\u0639 \u062f\u0631 \u062d\u0627\u0644 \u062d\u0627\u0636\u0631 \u0642\u0641\u0644 \u0634\u062f\u0647 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.ABORTED if GRPC_AVAILABLE else None,\n    )\n\n    RESOURCE_BUSY = ErrorDetailDTO.create_error_detail(\n        code=\"RESOURCE_BUSY\",\n        message_en=\"Resource is currently busy\",\n        message_fa=\"\u0645\u0646\u0628\u0639 \u062f\u0631 \u062d\u0627\u0644 \u062d\u0627\u0636\u0631 \u0645\u0634\u063a\u0648\u0644 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.ABORTED if GRPC_AVAILABLE else None,\n    )\n\n    # Time-related Errors\n    INVALID_TIMESTAMP = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_TIMESTAMP\",\n        message_en=\"Invalid timestamp format\",\n        message_fa=\"\u0641\u0631\u0645\u062a \u0632\u0645\u0627\u0646 \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    TIMEZONE_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"TIMEZONE_ERROR\",\n        message_en=\"Error in timezone conversion\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u062a\u0628\u062f\u06cc\u0644 \u0645\u0646\u0637\u0642\u0647 \u0632\u0645\u0627\u0646\u06cc\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n</code></pre>"},{"location":"api_reference/models/#language-type","title":"Language Type","text":"<p>Language code type definition.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.types.language_type.LanguageType","title":"<code>archipy.models.types.language_type.LanguageType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum representing supported languages for error messages.</p> <p>This enum defines the languages that are supported for generating or displaying error messages. Each language is represented by its ISO 639-1 code.</p> <p>Attributes:</p> Name Type Description <code>FA</code> <code>str</code> <p>Represents the Persian language (ISO 639-1 code: 'fa').</p> <code>EN</code> <code>str</code> <p>Represents the English language (ISO 639-1 code: 'en').</p> Source code in <code>archipy/models/types/language_type.py</code> <pre><code>class LanguageType(str, Enum):\n    \"\"\"Enum representing supported languages for error messages.\n\n    This enum defines the languages that are supported for generating or displaying\n    error messages. Each language is represented by its ISO 639-1 code.\n\n    Attributes:\n        FA (str): Represents the Persian language (ISO 639-1 code: 'fa').\n        EN (str): Represents the English language (ISO 639-1 code: 'en').\n    \"\"\"\n\n    FA = \"FA\"  # Persian\n    EN = \"EN\"  # English\n</code></pre>"},{"location":"api_reference/models/#sort-order-type","title":"Sort Order Type","text":"<p>Sort order type definition for queries.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.types.sort_order_type.SortOrderType","title":"<code>archipy.models.types.sort_order_type.SortOrderType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of sorting order types.</p> <p>This enum defines the types of sorting orders that can be applied to data, such as ascending or descending.</p> <p>Attributes:</p> Name Type Description <code>ASCENDING</code> <code>str</code> <p>Represents sorting in ascending order.</p> <code>DESCENDING</code> <code>str</code> <p>Represents sorting in descending order.</p> Source code in <code>archipy/models/types/sort_order_type.py</code> <pre><code>class SortOrderType(Enum):\n    \"\"\"Enumeration of sorting order types.\n\n    This enum defines the types of sorting orders that can be applied to data,\n    such as ascending or descending.\n\n    Attributes:\n        ASCENDING (str): Represents sorting in ascending order.\n        DESCENDING (str): Represents sorting in descending order.\n    \"\"\"\n\n    ASCENDING = \"ascending\"\n    DESCENDING = \"descending\"\n</code></pre>"},{"location":"api_reference/models/#key-classes","title":"Key Classes","text":""},{"location":"api_reference/models/#basedto","title":"BaseDTO","text":"<p>Class: <code>archipy.models.dtos.base_dtos.BaseDTO</code></p> <p>Base class for all DTOs with features:</p> <ul> <li>Pydantic model inheritance</li> <li>JSON serialization</li> <li>Validation</li> <li>Type hints</li> <li>Common utility methods</li> </ul>"},{"location":"api_reference/models/#baseentity","title":"BaseEntity","text":"<p>Class: <code>archipy.models.entities.sqlalchemy.base_entities.BaseEntity</code></p> <p>Base class for SQLAlchemy entities with features:</p> <ul> <li>UUID primary key</li> <li>Timestamp fields (created_at, updated_at)</li> <li>Common query methods</li> <li>Relationship support</li> <li>Type-safe column definitions</li> <li>Mixin support for:<ul> <li>Update tracking</li> <li>Soft deletion</li> <li>Admin tracking</li> <li>Manager tracking</li> <li>Archiving</li> <li>Combined capabilities</li> </ul> </li> </ul>"},{"location":"api_reference/models/#baseerror","title":"BaseError","text":"<p>Class: <code>archipy.models.errors.BaseError</code></p> <p>Base class for custom errors with features:</p> <ul> <li>Standardized error format</li> <li>Error code system</li> <li>Detailed error messages</li> <li>Stack trace support</li> <li>Error context</li> <li>Additional data support</li> <li>Language localization</li> <li>HTTP and gRPC status code mapping</li> </ul>"},{"location":"api_reference/utils/","title":"Utils","text":"<p>The <code>utils</code> module provides helper classes with static methods for common operations across the application.</p>"},{"location":"api_reference/utils/#datetime_utils","title":"datetime_utils","text":"<p>Utilities for date and time operations.</p> <pre><code>from archipy.helpers.utils.datetime_utils import DateTimeUtils\n\n# Get current UTC time\nnow = DateTimeUtils.get_utc_now()\n\n# Format datetime\nformatted = DateTimeUtils.format_datetime(now, format=\"%Y-%m-%d %H:%M:%S\")\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils</code>","text":"<p>A utility class for handling date and time operations, including conversions, caching, and API integrations.</p> <p>This class provides methods for working with both Gregorian and Jalali (Persian) calendars, as well as utility functions for timezone-aware datetime objects, date ranges, and string formatting.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>class DatetimeUtils:\n    \"\"\"A utility class for handling date and time operations, including conversions, caching, and API integrations.\n\n    This class provides methods for working with both Gregorian and Jalali (Persian) calendars, as well as\n    utility functions for timezone-aware datetime objects, date ranges, and string formatting.\n    \"\"\"\n\n    \"\"\"A class-level cache for storing holiday statuses to avoid redundant API calls.\"\"\"\n    _holiday_cache: ClassVar[dict[str, tuple[bool, datetime]]] = {}\n\n    @staticmethod\n    def convert_to_jalali(target_date: date) -&gt; jdatetime.date:\n        \"\"\"Converts a Gregorian date to a Jalali (Persian) date.\n\n        Args:\n            target_date (date): The Gregorian date to convert.\n\n        Returns:\n            jdatetime.date: The corresponding Jalali date.\n        \"\"\"\n        return jdatetime.date.fromgregorian(date=target_date)\n\n    @classmethod\n    def is_holiday_in_iran(cls, target_date: date) -&gt; bool:\n        \"\"\"Determines if the target date is a holiday in Iran.\n\n        This method leverages caching and an external API to check if the given date is a holiday.\n\n        Args:\n            target_date (date): The date to check for holiday status.\n\n        Returns:\n            bool: True if the date is a holiday, False otherwise.\n        \"\"\"\n        # Convert to Jalali date first\n        jalali_date = cls.convert_to_jalali(target_date)\n        date_str = target_date.strftime(\"%Y-%m-%d\")\n        current_time = cls.get_datetime_utc_now()\n\n        # Check cache first\n        is_cached, is_holiday = cls._check_cache(date_str, current_time)\n        if is_cached:\n            return is_holiday\n\n        # Fetch holiday status and cache it\n        return cls._fetch_and_cache_holiday_status(jalali_date, date_str, current_time)\n\n    @classmethod\n    def _check_cache(cls, date_str: str, current_time: datetime) -&gt; tuple[bool, bool]:\n        \"\"\"Checks the cache for holiday status to avoid redundant API calls.\n\n        Args:\n            date_str (str): The date string to check in the cache.\n            current_time (datetime): The current time to compare against cache expiration.\n\n        Returns:\n            tuple[bool, bool]: A tuple where the first element indicates if the cache was hit,\n                               and the second element is the cached holiday status.\n        \"\"\"\n        cached_data = cls._holiday_cache.get(date_str)\n        if cached_data:\n            is_holiday, expiry_time = cached_data\n            if current_time &lt; expiry_time:\n                return True, is_holiday\n\n            # Remove expired cache entry\n            del cls._holiday_cache[date_str]\n\n        return False, False\n\n    @classmethod\n    def _fetch_and_cache_holiday_status(\n        cls,\n        jalali_date: jdatetime.date,\n        date_str: str,\n        current_time: datetime,\n    ) -&gt; bool:\n        \"\"\"Fetches holiday status from the API and caches the result.\n\n        This method calls an external API to determine if the given Jalali date is a holiday.\n        If the API call is successful, the result is cached with an expiration time to avoid\n        redundant API calls. If the API call fails, an `UnknownError` is raised.\n\n        Args:\n            jalali_date (jdatetime.date): The Jalali date to check for holiday status.\n            date_str (str): The date string to use as a cache key.\n            current_time (datetime): The current time to set cache expiration.\n\n        Returns:\n            bool: True if the date is a holiday, False otherwise.\n\n        Raises:\n            UnknownError: If the API request fails due to a network issue or other request-related errors.\n        \"\"\"\n        try:\n            config: Any = BaseConfig.global_config()\n            response = cls._call_holiday_api(jalali_date)\n            is_holiday = cls._parse_holiday_response(response, jalali_date)\n\n            # Determine cache TTL based on whether the date is historical\n            target_date = datetime.strptime(date_str, \"%Y-%m-%d\").replace(tzinfo=UTC).date()\n            is_historical = target_date &lt;= current_time.date()\n            cache_ttl = config.DATETIME.HISTORICAL_CACHE_TTL if is_historical else config.DATETIME.CACHE_TTL\n\n            # Cache the result with appropriate expiration\n            expiry_time = current_time + timedelta(seconds=cache_ttl)\n            cls._holiday_cache[date_str] = (is_holiday, expiry_time)\n        except requests.RequestException as exception:\n            raise UnknownError from exception\n\n        return is_holiday\n\n    @staticmethod\n    def _call_holiday_api(jalali_date: jdatetime.date) -&gt; dict[str, Any]:\n        \"\"\"Calls the Time.ir API to fetch holiday data for the given Jalali date.\n\n        Args:\n            jalali_date (jdatetime.date): The Jalali date to fetch data for.\n\n        Returns:\n            Dict[str, Any]: The JSON response from the API.\n\n        Raises:\n            requests.RequestException: If the API request fails.\n        \"\"\"\n        config: Any = BaseConfig.global_config()\n        retry_strategy = Retry(\n            total=config.DATETIME.MAX_RETRIES,\n            status_forcelist=[429, 500, 502, 503, 504],\n            allowed_methods=[\"HEAD\", \"GET\", \"OPTIONS\"],\n        )\n        adapter = HTTPAdapter(max_retries=retry_strategy)\n        session = requests.Session()\n        session.mount(\"https://\", adapter)\n\n        url = DatetimeUtils._build_api_url(jalali_date)\n        headers = {\"x-api-key\": config.DATETIME.TIME_IR_API_KEY}\n        response = session.get(url, headers=headers, timeout=config.DATETIME.REQUEST_TIMEOUT)\n        response.raise_for_status()\n        result: dict[str, Any] = response.json()\n        return result\n\n    @staticmethod\n    def _build_api_url(jalali_date: jdatetime.date) -&gt; str:\n        \"\"\"Builds the API URL with Jalali date parameters.\n\n        Args:\n            jalali_date (jdatetime.date): The Jalali date to include in the URL.\n\n        Returns:\n            str: The constructed API URL.\n        \"\"\"\n        config: Any = BaseConfig.global_config()\n        base_url = config.DATETIME.TIME_IR_API_ENDPOINT\n        return f\"{base_url}?year={jalali_date.year}&amp;month={jalali_date.month}&amp;day={jalali_date.day}\"\n\n    @staticmethod\n    def _parse_holiday_response(response_data: dict[str, Any], jalali_date: jdatetime.date) -&gt; bool:\n        \"\"\"Parses the API response to extract and return the holiday status.\n\n        Args:\n            response_data (Dict[str, Any]): The JSON response from the API.\n            jalali_date (jdatetime.date): The Jalali date to check.\n\n        Returns:\n            bool: True if the date is a holiday, False otherwise.\n        \"\"\"\n        event_list = response_data.get(\"data\", {}).get(\"event_list\", [])\n        for event_info in event_list:\n            if (\n                event_info.get(\"jalali_year\") == jalali_date.year\n                and event_info.get(\"jalali_month\") == jalali_date.month\n                and event_info.get(\"jalali_day\") == jalali_date.day\n            ):\n                is_holiday = event_info.get(\"is_holiday\", False)\n                return bool(is_holiday)\n        return False\n\n    @classmethod\n    def ensure_timezone_aware(cls, dt: datetime) -&gt; datetime:\n        \"\"\"Ensures a datetime object is timezone-aware, converting it to UTC if necessary.\n\n        Args:\n            dt (datetime): The datetime object to make timezone-aware.\n\n        Returns:\n            datetime: The timezone-aware datetime object.\n        \"\"\"\n        if dt.tzinfo is None:\n            return dt.replace(tzinfo=UTC)\n        return dt\n\n    @classmethod\n    def daterange(cls, start_date: datetime, end_date: datetime) -&gt; Generator[date]:\n        \"\"\"Generates a range of dates from start_date to end_date, exclusive of end_date.\n\n        Args:\n            start_date (datetime): The start date of the range.\n            end_date (datetime): The end date of the range.\n\n        Yields:\n            date: Each date in the range.\n        \"\"\"\n        for n in range((end_date - start_date).days):\n            yield (start_date + timedelta(n)).date()\n\n    @classmethod\n    def get_string_datetime_from_datetime(cls, dt: datetime, format_: str | None = None) -&gt; str:\n        \"\"\"Converts a datetime object to a formatted string. Default format is ISO 8601.\n\n        Args:\n            dt (datetime): The datetime object to format.\n            format_ (str | None): The format string. If None, uses ISO 8601.\n\n        Returns:\n            str: The formatted datetime string.\n        \"\"\"\n        format_ = format_ or \"%Y-%m-%dT%H:%M:%S.%f\"\n        return dt.strftime(format_)\n\n    @classmethod\n    def standardize_string_datetime(cls, date_string: str) -&gt; str:\n        \"\"\"Standardizes a datetime string to the default format.\n\n        Args:\n            date_string (str): The datetime string to standardize.\n\n        Returns:\n            str: The standardized datetime string.\n        \"\"\"\n        datetime_ = cls.get_datetime_from_string_datetime(date_string)\n        return cls.get_string_datetime_from_datetime(datetime_)\n\n    @classmethod\n    def get_datetime_from_string_datetime(cls, date_string: str, format_: str | None = None) -&gt; datetime:\n        \"\"\"Parses a string to a datetime object using the given format, or ISO 8601 by default.\n\n        Args:\n            date_string (str): The datetime string to parse.\n            format_ (str | None): The format string. If None, uses ISO 8601.\n\n        Returns:\n            datetime: The parsed datetime object with UTC timezone.\n        \"\"\"\n        # Parse using a single expression and immediately make timezone-aware for both cases\n        dt = (\n            datetime.fromisoformat(date_string)\n            if format_ is None\n            else datetime.strptime(date_string, format_).replace(tzinfo=UTC)\n        )\n\n        # Handle the fromisoformat case which might already have timezone info\n        if dt.tzinfo is None:\n            dt = dt.replace(tzinfo=UTC)\n\n        return dt\n\n    @classmethod\n    def get_string_datetime_now(cls) -&gt; str:\n        \"\"\"Gets the current datetime as a formatted string. Default format is ISO 8601.\n\n        Returns:\n            str: The formatted datetime string.\n        \"\"\"\n        return cls.get_string_datetime_from_datetime(cls.get_datetime_now())\n\n    @classmethod\n    def get_datetime_now(cls) -&gt; datetime:\n        \"\"\"Gets the current local datetime.\n\n        Returns:\n            datetime: The current local datetime.\n        \"\"\"\n        return datetime.now()\n\n    @classmethod\n    def get_datetime_utc_now(cls) -&gt; datetime:\n        \"\"\"Gets the current UTC datetime.\n\n        Returns:\n            datetime: The current UTC datetime.\n        \"\"\"\n        return datetime.now(UTC)\n\n    @classmethod\n    def get_epoch_time_now(cls) -&gt; int:\n        \"\"\"Gets the current time in seconds since the epoch.\n\n        Returns:\n            int: The current epoch time.\n        \"\"\"\n        return int(time.time())\n\n    @classmethod\n    def get_datetime_before_given_datetime_or_now(\n        cls,\n        weeks: int = 0,\n        days: int = 0,\n        hours: int = 0,\n        minutes: int = 0,\n        seconds: int = 0,\n        datetime_given: datetime | None = None,\n    ) -&gt; datetime:\n        \"\"\"Subtracts time from a given datetime or the current datetime if not specified.\n\n        Args:\n            weeks (int): The number of weeks to subtract.\n            days (int): The number of days to subtract.\n            hours (int): The number of hours to subtract.\n            minutes (int): The number of minutes to subtract.\n            seconds (int): The number of seconds to subtract.\n            datetime_given (datetime | None): The datetime to subtract from. If None, uses the current datetime.\n\n        Returns:\n            datetime: The resulting datetime after subtraction.\n        \"\"\"\n        datetime_given = datetime_given or cls.get_datetime_now()\n        return datetime_given - timedelta(weeks=weeks, days=days, hours=hours, minutes=minutes, seconds=seconds)\n\n    @classmethod\n    def get_datetime_after_given_datetime_or_now(\n        cls,\n        weeks: int = 0,\n        days: int = 0,\n        hours: int = 0,\n        minutes: int = 0,\n        seconds: int = 0,\n        datetime_given: datetime | None = None,\n    ) -&gt; datetime:\n        \"\"\"Adds time to a given datetime or the current datetime if not specified.\n\n        Args:\n            weeks (int): The number of weeks to add.\n            days (int): The number of days to add.\n            hours (int): The number of hours to add.\n            minutes (int): The number of minutes to add.\n            seconds (int): The number of seconds to add.\n            datetime_given (datetime | None): The datetime to add to. If None, uses the current datetime.\n\n        Returns:\n            datetime: The resulting datetime after addition.\n        \"\"\"\n        datetime_given = datetime_given or cls.get_datetime_now()\n        return datetime_given + timedelta(weeks=weeks, days=days, hours=hours, minutes=minutes, seconds=seconds)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.convert_to_jalali","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.convert_to_jalali(target_date)</code>  <code>staticmethod</code>","text":"<p>Converts a Gregorian date to a Jalali (Persian) date.</p> <p>Parameters:</p> Name Type Description Default <code>target_date</code> <code>date</code> <p>The Gregorian date to convert.</p> required <p>Returns:</p> Type Description <code>date</code> <p>jdatetime.date: The corresponding Jalali date.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@staticmethod\ndef convert_to_jalali(target_date: date) -&gt; jdatetime.date:\n    \"\"\"Converts a Gregorian date to a Jalali (Persian) date.\n\n    Args:\n        target_date (date): The Gregorian date to convert.\n\n    Returns:\n        jdatetime.date: The corresponding Jalali date.\n    \"\"\"\n    return jdatetime.date.fromgregorian(date=target_date)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.is_holiday_in_iran","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.is_holiday_in_iran(target_date)</code>  <code>classmethod</code>","text":"<p>Determines if the target date is a holiday in Iran.</p> <p>This method leverages caching and an external API to check if the given date is a holiday.</p> <p>Parameters:</p> Name Type Description Default <code>target_date</code> <code>date</code> <p>The date to check for holiday status.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the date is a holiday, False otherwise.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef is_holiday_in_iran(cls, target_date: date) -&gt; bool:\n    \"\"\"Determines if the target date is a holiday in Iran.\n\n    This method leverages caching and an external API to check if the given date is a holiday.\n\n    Args:\n        target_date (date): The date to check for holiday status.\n\n    Returns:\n        bool: True if the date is a holiday, False otherwise.\n    \"\"\"\n    # Convert to Jalali date first\n    jalali_date = cls.convert_to_jalali(target_date)\n    date_str = target_date.strftime(\"%Y-%m-%d\")\n    current_time = cls.get_datetime_utc_now()\n\n    # Check cache first\n    is_cached, is_holiday = cls._check_cache(date_str, current_time)\n    if is_cached:\n        return is_holiday\n\n    # Fetch holiday status and cache it\n    return cls._fetch_and_cache_holiday_status(jalali_date, date_str, current_time)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.ensure_timezone_aware","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.ensure_timezone_aware(dt)</code>  <code>classmethod</code>","text":"<p>Ensures a datetime object is timezone-aware, converting it to UTC if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime</code> <p>The datetime object to make timezone-aware.</p> required <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>The timezone-aware datetime object.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef ensure_timezone_aware(cls, dt: datetime) -&gt; datetime:\n    \"\"\"Ensures a datetime object is timezone-aware, converting it to UTC if necessary.\n\n    Args:\n        dt (datetime): The datetime object to make timezone-aware.\n\n    Returns:\n        datetime: The timezone-aware datetime object.\n    \"\"\"\n    if dt.tzinfo is None:\n        return dt.replace(tzinfo=UTC)\n    return dt\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.daterange","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.daterange(start_date, end_date)</code>  <code>classmethod</code>","text":"<p>Generates a range of dates from start_date to end_date, exclusive of end_date.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>datetime</code> <p>The start date of the range.</p> required <code>end_date</code> <code>datetime</code> <p>The end date of the range.</p> required <p>Yields:</p> Name Type Description <code>date</code> <code>Generator[date]</code> <p>Each date in the range.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef daterange(cls, start_date: datetime, end_date: datetime) -&gt; Generator[date]:\n    \"\"\"Generates a range of dates from start_date to end_date, exclusive of end_date.\n\n    Args:\n        start_date (datetime): The start date of the range.\n        end_date (datetime): The end date of the range.\n\n    Yields:\n        date: Each date in the range.\n    \"\"\"\n    for n in range((end_date - start_date).days):\n        yield (start_date + timedelta(n)).date()\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.get_string_datetime_from_datetime","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.get_string_datetime_from_datetime(dt, format_=None)</code>  <code>classmethod</code>","text":"<p>Converts a datetime object to a formatted string. Default format is ISO 8601.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime</code> <p>The datetime object to format.</p> required <code>format_</code> <code>str | None</code> <p>The format string. If None, uses ISO 8601.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The formatted datetime string.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef get_string_datetime_from_datetime(cls, dt: datetime, format_: str | None = None) -&gt; str:\n    \"\"\"Converts a datetime object to a formatted string. Default format is ISO 8601.\n\n    Args:\n        dt (datetime): The datetime object to format.\n        format_ (str | None): The format string. If None, uses ISO 8601.\n\n    Returns:\n        str: The formatted datetime string.\n    \"\"\"\n    format_ = format_ or \"%Y-%m-%dT%H:%M:%S.%f\"\n    return dt.strftime(format_)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.standardize_string_datetime","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.standardize_string_datetime(date_string)</code>  <code>classmethod</code>","text":"<p>Standardizes a datetime string to the default format.</p> <p>Parameters:</p> Name Type Description Default <code>date_string</code> <code>str</code> <p>The datetime string to standardize.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The standardized datetime string.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef standardize_string_datetime(cls, date_string: str) -&gt; str:\n    \"\"\"Standardizes a datetime string to the default format.\n\n    Args:\n        date_string (str): The datetime string to standardize.\n\n    Returns:\n        str: The standardized datetime string.\n    \"\"\"\n    datetime_ = cls.get_datetime_from_string_datetime(date_string)\n    return cls.get_string_datetime_from_datetime(datetime_)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.get_datetime_from_string_datetime","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.get_datetime_from_string_datetime(date_string, format_=None)</code>  <code>classmethod</code>","text":"<p>Parses a string to a datetime object using the given format, or ISO 8601 by default.</p> <p>Parameters:</p> Name Type Description Default <code>date_string</code> <code>str</code> <p>The datetime string to parse.</p> required <code>format_</code> <code>str | None</code> <p>The format string. If None, uses ISO 8601.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>The parsed datetime object with UTC timezone.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef get_datetime_from_string_datetime(cls, date_string: str, format_: str | None = None) -&gt; datetime:\n    \"\"\"Parses a string to a datetime object using the given format, or ISO 8601 by default.\n\n    Args:\n        date_string (str): The datetime string to parse.\n        format_ (str | None): The format string. If None, uses ISO 8601.\n\n    Returns:\n        datetime: The parsed datetime object with UTC timezone.\n    \"\"\"\n    # Parse using a single expression and immediately make timezone-aware for both cases\n    dt = (\n        datetime.fromisoformat(date_string)\n        if format_ is None\n        else datetime.strptime(date_string, format_).replace(tzinfo=UTC)\n    )\n\n    # Handle the fromisoformat case which might already have timezone info\n    if dt.tzinfo is None:\n        dt = dt.replace(tzinfo=UTC)\n\n    return dt\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.get_string_datetime_now","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.get_string_datetime_now()</code>  <code>classmethod</code>","text":"<p>Gets the current datetime as a formatted string. Default format is ISO 8601.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The formatted datetime string.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef get_string_datetime_now(cls) -&gt; str:\n    \"\"\"Gets the current datetime as a formatted string. Default format is ISO 8601.\n\n    Returns:\n        str: The formatted datetime string.\n    \"\"\"\n    return cls.get_string_datetime_from_datetime(cls.get_datetime_now())\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.get_datetime_now","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.get_datetime_now()</code>  <code>classmethod</code>","text":"<p>Gets the current local datetime.</p> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>The current local datetime.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef get_datetime_now(cls) -&gt; datetime:\n    \"\"\"Gets the current local datetime.\n\n    Returns:\n        datetime: The current local datetime.\n    \"\"\"\n    return datetime.now()\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.get_datetime_utc_now","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.get_datetime_utc_now()</code>  <code>classmethod</code>","text":"<p>Gets the current UTC datetime.</p> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>The current UTC datetime.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef get_datetime_utc_now(cls) -&gt; datetime:\n    \"\"\"Gets the current UTC datetime.\n\n    Returns:\n        datetime: The current UTC datetime.\n    \"\"\"\n    return datetime.now(UTC)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.get_epoch_time_now","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.get_epoch_time_now()</code>  <code>classmethod</code>","text":"<p>Gets the current time in seconds since the epoch.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The current epoch time.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef get_epoch_time_now(cls) -&gt; int:\n    \"\"\"Gets the current time in seconds since the epoch.\n\n    Returns:\n        int: The current epoch time.\n    \"\"\"\n    return int(time.time())\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.get_datetime_before_given_datetime_or_now","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.get_datetime_before_given_datetime_or_now(weeks=0, days=0, hours=0, minutes=0, seconds=0, datetime_given=None)</code>  <code>classmethod</code>","text":"<p>Subtracts time from a given datetime or the current datetime if not specified.</p> <p>Parameters:</p> Name Type Description Default <code>weeks</code> <code>int</code> <p>The number of weeks to subtract.</p> <code>0</code> <code>days</code> <code>int</code> <p>The number of days to subtract.</p> <code>0</code> <code>hours</code> <code>int</code> <p>The number of hours to subtract.</p> <code>0</code> <code>minutes</code> <code>int</code> <p>The number of minutes to subtract.</p> <code>0</code> <code>seconds</code> <code>int</code> <p>The number of seconds to subtract.</p> <code>0</code> <code>datetime_given</code> <code>datetime | None</code> <p>The datetime to subtract from. If None, uses the current datetime.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>The resulting datetime after subtraction.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef get_datetime_before_given_datetime_or_now(\n    cls,\n    weeks: int = 0,\n    days: int = 0,\n    hours: int = 0,\n    minutes: int = 0,\n    seconds: int = 0,\n    datetime_given: datetime | None = None,\n) -&gt; datetime:\n    \"\"\"Subtracts time from a given datetime or the current datetime if not specified.\n\n    Args:\n        weeks (int): The number of weeks to subtract.\n        days (int): The number of days to subtract.\n        hours (int): The number of hours to subtract.\n        minutes (int): The number of minutes to subtract.\n        seconds (int): The number of seconds to subtract.\n        datetime_given (datetime | None): The datetime to subtract from. If None, uses the current datetime.\n\n    Returns:\n        datetime: The resulting datetime after subtraction.\n    \"\"\"\n    datetime_given = datetime_given or cls.get_datetime_now()\n    return datetime_given - timedelta(weeks=weeks, days=days, hours=hours, minutes=minutes, seconds=seconds)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.get_datetime_after_given_datetime_or_now","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.get_datetime_after_given_datetime_or_now(weeks=0, days=0, hours=0, minutes=0, seconds=0, datetime_given=None)</code>  <code>classmethod</code>","text":"<p>Adds time to a given datetime or the current datetime if not specified.</p> <p>Parameters:</p> Name Type Description Default <code>weeks</code> <code>int</code> <p>The number of weeks to add.</p> <code>0</code> <code>days</code> <code>int</code> <p>The number of days to add.</p> <code>0</code> <code>hours</code> <code>int</code> <p>The number of hours to add.</p> <code>0</code> <code>minutes</code> <code>int</code> <p>The number of minutes to add.</p> <code>0</code> <code>seconds</code> <code>int</code> <p>The number of seconds to add.</p> <code>0</code> <code>datetime_given</code> <code>datetime | None</code> <p>The datetime to add to. If None, uses the current datetime.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>The resulting datetime after addition.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef get_datetime_after_given_datetime_or_now(\n    cls,\n    weeks: int = 0,\n    days: int = 0,\n    hours: int = 0,\n    minutes: int = 0,\n    seconds: int = 0,\n    datetime_given: datetime | None = None,\n) -&gt; datetime:\n    \"\"\"Adds time to a given datetime or the current datetime if not specified.\n\n    Args:\n        weeks (int): The number of weeks to add.\n        days (int): The number of days to add.\n        hours (int): The number of hours to add.\n        minutes (int): The number of minutes to add.\n        seconds (int): The number of seconds to add.\n        datetime_given (datetime | None): The datetime to add to. If None, uses the current datetime.\n\n    Returns:\n        datetime: The resulting datetime after addition.\n    \"\"\"\n    datetime_given = datetime_given or cls.get_datetime_now()\n    return datetime_given + timedelta(weeks=weeks, days=days, hours=hours, minutes=minutes, seconds=seconds)\n</code></pre>"},{"location":"api_reference/utils/#file_utils","title":"file_utils","text":"<p>Utilities for file operations.</p> <pre><code>from archipy.helpers.utils.file_utils import FileUtils\n\n# Read file content\ncontent = FileUtils.read_file(\"path/to/file.txt\")\n\n# Write to file\nFileUtils.write_file(\"path/to/output.txt\", \"content\")\n\n# Get file hash\nfile_hash = FileUtils.get_file_hash(\"path/to/file.txt\")\n\n# Validate file type\nis_valid = FileUtils.validate_file_type(\"path/to/file.pdf\", allowed_types=[\"pdf\", \"doc\"])\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/utils/#archipy.helpers.utils.file_utils.FileUtils","title":"<code>archipy.helpers.utils.file_utils.FileUtils</code>","text":"<p>A utility class for handling file-related operations, such as creating secure links and validating file names.</p> Source code in <code>archipy/helpers/utils/file_utils.py</code> <pre><code>class FileUtils:\n    \"\"\"A utility class for handling file-related operations, such as creating secure links and validating file names.\"\"\"\n\n    @staticmethod\n    def _create_secure_link_hash(path: str, expires_at: float, file_config: FileConfig | None = None) -&gt; str:\n        \"\"\"Generates a secure hash for a file link based on the file path, expiration timestamp, and secret key.\n\n        Args:\n            path (str): The file path to generate the hash for.\n            expires_at (float): The expiration timestamp for the link.\n            file_config (FileConfig | None): Optional file configuration object. If not provided, uses the global config.\n\n        Returns:\n            str: A base64-encoded secure hash for the file link.\n\n        Raises:\n            InvalidArgumentError: If the `SECRET_KEY` in the configuration is `None`.\n        \"\"\"\n        configs: FileConfig = file_config or BaseConfig.global_config().FILE\n        secret: str | None = configs.SECRET_KEY\n        if secret is None:\n            raise InvalidArgumentError(argument_name=\"SECRET_KEY\")\n        _input = f\"{expires_at}{path} {secret}\"\n        hash_object = hashlib.md5(_input.encode(\"utf8\"))\n        return base64.urlsafe_b64encode(hash_object.digest()).decode(\"utf-8\").rstrip(\"=\")\n\n    @classmethod\n    def create_secure_link(\n        cls,\n        path: str,\n        minutes: int | None = None,\n        file_config: FileConfig | None = None,\n    ) -&gt; str:\n        \"\"\"Creates a secure link with expiration for file access.\n\n        Args:\n            path (str): The file path to create a secure link for.\n            minutes (int | None): Number of minutes until link expiration. Defaults to the config's `DEFAULT_EXPIRY_MINUTES`.\n            file_config (FileConfig | None): Optional file configuration object. If not provided, uses the global config.\n\n        Returns:\n            str: A secure link with a hash and expiration timestamp.\n\n        Raises:\n            InvalidArgumentError: If the `path` is empty.\n            OutOfRangeError: If `minutes` is less than 1.\n        \"\"\"\n        if not path:\n            raise InvalidArgumentError(argument_name=\"path\")\n\n        configs: FileConfig = file_config or BaseConfig.global_config().FILE\n        expiry_minutes: int = minutes if minutes is not None else configs.DEFAULT_EXPIRY_MINUTES\n\n        if expiry_minutes &lt; 1:\n            raise OutOfRangeError(field_name=\"minutes\")\n\n        expires_at = int(DatetimeUtils.get_datetime_after_given_datetime_or_now(minutes=expiry_minutes).timestamp())\n        secure_link_hash = cls._create_secure_link_hash(path, expires_at, file_config)\n\n        return f\"{path}?md5={secure_link_hash}&amp;expires_at={expires_at}\"\n\n    @classmethod\n    def validate_file_name(\n        cls,\n        file_name: str,\n        file_config: FileConfig | None = None,\n    ) -&gt; bool:\n        \"\"\"Validates a file name based on allowed extensions.\n\n        Args:\n            file_name (str): The file name to validate.\n            file_config (FileConfig | None): Optional file configuration object. If not provided, uses the global config.\n\n        Returns:\n            bool: `True` if the file name has an allowed extension, `False` otherwise.\n\n        Raises:\n            InvalidArgumentError: If `file_name` is not a string or `allowed_extensions` is not a list.\n        \"\"\"\n        configs: FileConfig = file_config or BaseConfig.global_config().FILE\n        allowed_extensions: list[str] = configs.ALLOWED_EXTENSIONS\n\n        if not isinstance(file_name, str):\n            raise InvalidArgumentError(argument_name=\"file_name\")\n\n        if not allowed_extensions:\n            raise InvalidArgumentError(argument_name=\"allowed_extensions\")\n\n        file_path = Path(file_name)\n        ext = file_path.suffix[1:].lower()\n        return ext in allowed_extensions and bool(ext)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.file_utils.FileUtils.create_secure_link","title":"<code>archipy.helpers.utils.file_utils.FileUtils.create_secure_link(path, minutes=None, file_config=None)</code>  <code>classmethod</code>","text":"<p>Creates a secure link with expiration for file access.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The file path to create a secure link for.</p> required <code>minutes</code> <code>int | None</code> <p>Number of minutes until link expiration. Defaults to the config's <code>DEFAULT_EXPIRY_MINUTES</code>.</p> <code>None</code> <code>file_config</code> <code>FileConfig | None</code> <p>Optional file configuration object. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A secure link with a hash and expiration timestamp.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the <code>path</code> is empty.</p> <code>OutOfRangeError</code> <p>If <code>minutes</code> is less than 1.</p> Source code in <code>archipy/helpers/utils/file_utils.py</code> <pre><code>@classmethod\ndef create_secure_link(\n    cls,\n    path: str,\n    minutes: int | None = None,\n    file_config: FileConfig | None = None,\n) -&gt; str:\n    \"\"\"Creates a secure link with expiration for file access.\n\n    Args:\n        path (str): The file path to create a secure link for.\n        minutes (int | None): Number of minutes until link expiration. Defaults to the config's `DEFAULT_EXPIRY_MINUTES`.\n        file_config (FileConfig | None): Optional file configuration object. If not provided, uses the global config.\n\n    Returns:\n        str: A secure link with a hash and expiration timestamp.\n\n    Raises:\n        InvalidArgumentError: If the `path` is empty.\n        OutOfRangeError: If `minutes` is less than 1.\n    \"\"\"\n    if not path:\n        raise InvalidArgumentError(argument_name=\"path\")\n\n    configs: FileConfig = file_config or BaseConfig.global_config().FILE\n    expiry_minutes: int = minutes if minutes is not None else configs.DEFAULT_EXPIRY_MINUTES\n\n    if expiry_minutes &lt; 1:\n        raise OutOfRangeError(field_name=\"minutes\")\n\n    expires_at = int(DatetimeUtils.get_datetime_after_given_datetime_or_now(minutes=expiry_minutes).timestamp())\n    secure_link_hash = cls._create_secure_link_hash(path, expires_at, file_config)\n\n    return f\"{path}?md5={secure_link_hash}&amp;expires_at={expires_at}\"\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.file_utils.FileUtils.validate_file_name","title":"<code>archipy.helpers.utils.file_utils.FileUtils.validate_file_name(file_name, file_config=None)</code>  <code>classmethod</code>","text":"<p>Validates a file name based on allowed extensions.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>The file name to validate.</p> required <code>file_config</code> <code>FileConfig | None</code> <p>Optional file configuration object. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the file name has an allowed extension, <code>False</code> otherwise.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If <code>file_name</code> is not a string or <code>allowed_extensions</code> is not a list.</p> Source code in <code>archipy/helpers/utils/file_utils.py</code> <pre><code>@classmethod\ndef validate_file_name(\n    cls,\n    file_name: str,\n    file_config: FileConfig | None = None,\n) -&gt; bool:\n    \"\"\"Validates a file name based on allowed extensions.\n\n    Args:\n        file_name (str): The file name to validate.\n        file_config (FileConfig | None): Optional file configuration object. If not provided, uses the global config.\n\n    Returns:\n        bool: `True` if the file name has an allowed extension, `False` otherwise.\n\n    Raises:\n        InvalidArgumentError: If `file_name` is not a string or `allowed_extensions` is not a list.\n    \"\"\"\n    configs: FileConfig = file_config or BaseConfig.global_config().FILE\n    allowed_extensions: list[str] = configs.ALLOWED_EXTENSIONS\n\n    if not isinstance(file_name, str):\n        raise InvalidArgumentError(argument_name=\"file_name\")\n\n    if not allowed_extensions:\n        raise InvalidArgumentError(argument_name=\"allowed_extensions\")\n\n    file_path = Path(file_name)\n    ext = file_path.suffix[1:].lower()\n    return ext in allowed_extensions and bool(ext)\n</code></pre>"},{"location":"api_reference/utils/#jwt_utils","title":"jwt_utils","text":"<p>Utilities for JWT (JSON Web Token) operations.</p> <pre><code>from archipy.helpers.utils.jwt_utils import JWTUtils\n\n# Generate JWT\ntoken = JWTUtils.generate_jwt(\n    payload={\"user_id\": \"123\"},\n    secret=\"your-secret\",\n    expires_in=3600\n)\n\n# Verify JWT\nis_valid = JWTUtils.verify_jwt(token, secret=\"your-secret\")\n\n# Decode JWT\npayload = JWTUtils.decode_jwt(token)\n</code></pre> <p>Utility module for JWT token operations with enhanced security and datetime handling.</p> <p>This module provides a robust JWT handling implementation with support for access and refresh tokens, cryptographic security, token validation, and comprehensive error handling.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/utils/#archipy.helpers.utils.jwt_utils.JWTUtils","title":"<code>archipy.helpers.utils.jwt_utils.JWTUtils</code>","text":"<p>Utility class for JWT token operations with enhanced security and datetime handling.</p> Source code in <code>archipy/helpers/utils/jwt_utils.py</code> <pre><code>class JWTUtils:\n    \"\"\"Utility class for JWT token operations with enhanced security and datetime handling.\"\"\"\n\n    @classmethod\n    def create_token(\n        cls,\n        data: dict[str, Any],\n        expires_in: int,\n        additional_claims: dict[str, Any] | None = None,\n        auth_config: AuthConfig | None = None,\n    ) -&gt; str:\n        \"\"\"Creates a JWT token with enhanced security features.\n\n        Args:\n            data (dict[str, Any]): Base claims data to include in the token.\n            expires_in (int): Token expiration time in seconds.\n            additional_claims (dict[str, Any] | None): Optional additional claims to include in the token.\n            auth_config (AuthConfig | None): Optional auth configuration override.\n                If not provided, uses the global config.\n\n        Returns:\n            str: The encoded JWT token.\n\n        Raises:\n            ValueError: If data is empty or expiration is invalid\n        \"\"\"\n        import jwt\n\n        configs = auth_config or BaseConfig.global_config().AUTH\n        current_time = DatetimeUtils.get_datetime_utc_now()\n\n        # Define argument names\n        arg_data = \"data\"\n        arg_expires_in = \"expires_in\"\n\n        if not data:\n            raise InvalidArgumentError(arg_data)\n        if expires_in &lt;= 0:\n            raise InvalidArgumentError(arg_expires_in)\n\n        to_encode = data.copy()\n        expire = DatetimeUtils.get_datetime_after_given_datetime_or_now(seconds=expires_in, datetime_given=current_time)\n\n        # Add standard claims\n        to_encode.update(\n            {\n                # Registered claims (RFC 7519)\n                \"iss\": configs.JWT_ISSUER,\n                \"aud\": configs.JWT_AUDIENCE,\n                \"exp\": expire,\n                \"iat\": current_time,\n                \"nbf\": current_time,\n            },\n        )\n\n        # Add JWT ID if enabled\n        if configs.ENABLE_JTI_CLAIM:\n            to_encode[\"jti\"] = str(uuid4())\n\n        # Add additional claims\n        if additional_claims:\n            to_encode.update(additional_claims)\n\n        # Validate SECRET_KEY\n        secret_key = configs.SECRET_KEY\n        if secret_key is None:\n            raise InvalidArgumentError(\"SECRET_KEY\")\n        return jwt.encode(to_encode, secret_key.get_secret_value(), algorithm=configs.HASH_ALGORITHM)\n\n    @classmethod\n    def create_access_token(\n        cls,\n        user_uuid: UUID,\n        additional_claims: dict[str, Any] | None = None,\n        auth_config: AuthConfig | None = None,\n    ) -&gt; str:\n        \"\"\"Creates an access token for a user.\n\n        Args:\n            user_uuid (UUID): The user's UUID to include in the token.\n            additional_claims (dict[str, Any] | None): Optional additional claims to include in the token.\n            auth_config (AuthConfig | None): Optional auth configuration override.\n                If not provided, uses the global config.\n\n        Returns:\n            str: The encoded access token.\n        \"\"\"\n        configs = auth_config or BaseConfig.global_config().AUTH\n\n        return cls.create_token(\n            data={\n                \"sub\": str(user_uuid),\n                \"type\": \"access\",\n                \"token_version\": configs.TOKEN_VERSION,\n            },\n            expires_in=configs.ACCESS_TOKEN_EXPIRES_IN,\n            additional_claims=additional_claims,\n            auth_config=configs,\n        )\n\n    @classmethod\n    def create_refresh_token(\n        cls,\n        user_uuid: UUID,\n        additional_claims: dict[str, Any] | None = None,\n        auth_config: AuthConfig | None = None,\n    ) -&gt; str:\n        \"\"\"Creates a refresh token for a user.\n\n        Args:\n            user_uuid (UUID): The user's UUID to include in the token.\n            additional_claims (dict[str, Any] | None): Optional additional claims to include in the token.\n            auth_config (AuthConfig | None): Optional auth configuration override.\n                If not provided, uses the global config.\n\n        Returns:\n            str: The encoded refresh token.\n        \"\"\"\n        configs = auth_config or BaseConfig.global_config().AUTH\n\n        return cls.create_token(\n            data={\n                \"sub\": str(user_uuid),\n                \"type\": \"refresh\",\n                \"token_version\": configs.TOKEN_VERSION,\n            },\n            expires_in=configs.REFRESH_TOKEN_EXPIRES_IN,\n            additional_claims=additional_claims,\n            auth_config=configs,\n        )\n\n    @classmethod\n    def decode_token(\n        cls,\n        token: str,\n        verify_type: str | None = None,\n        auth_config: AuthConfig | None = None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Decodes and verifies a JWT token with enhanced security checks.\n\n        Args:\n            token (str): The JWT token to decode.\n            verify_type (str | None): Optional token type to verify (e.g., \"access\" or \"refresh\").\n            auth_config (AuthConfig | None): Optional auth configuration override.\n                If not provided, uses the global config.\n\n        Returns:\n            dict[str, Any]: The decoded token payload.\n\n        Raises:\n            TokenExpiredError: If the token has expired.\n            InvalidTokenError: If the token is invalid (e.g., invalid signature, audience, issuer, or type).\n        \"\"\"\n        import jwt\n        from jwt.exceptions import (\n            ExpiredSignatureError,\n            InvalidAudienceError,\n            InvalidIssuerError,\n            InvalidSignatureError,\n            InvalidTokenError as JWTInvalidTokenError,\n        )\n\n        configs = auth_config or BaseConfig.global_config().AUTH\n        required_claims = [\"exp\", \"iat\", \"nbf\", \"aud\", \"iss\", \"sub\", \"type\", \"token_version\"]\n        if configs.ENABLE_JTI_CLAIM:\n            required_claims.append(\"jti\")\n\n        try:\n            # Validate SECRET_KEY\n            secret_key = configs.SECRET_KEY\n            if secret_key is None:\n                raise InvalidArgumentError(\"SECRET_KEY\")\n\n            payload = jwt.decode(\n                token,\n                secret_key.get_secret_value(),\n                algorithms=[configs.HASH_ALGORITHM],\n                options={\n                    \"verify_signature\": True,\n                    \"verify_exp\": True,\n                    \"verify_nbf\": True,\n                    \"verify_iat\": True,\n                    \"verify_aud\": True,\n                    \"verify_iss\": True,\n                    \"require\": required_claims,\n                },\n                audience=configs.JWT_AUDIENCE,\n                issuer=configs.JWT_ISSUER,\n            )\n\n            # Verify token type\n            if verify_type and payload.get(\"type\") != verify_type:\n                raise InvalidTokenError\n\n            # Verify token version\n            if payload.get(\"token_version\") != configs.TOKEN_VERSION:\n                raise InvalidTokenError\n\n            # Ensure the return type is dict[str, Any] as declared\n            return dict(payload)\n\n        except ExpiredSignatureError as exception:\n            raise TokenExpiredError from exception\n        except InvalidSignatureError as exception:\n            raise InvalidTokenError from exception\n        except InvalidAudienceError as exception:\n            raise InvalidTokenError from exception\n        except InvalidIssuerError as exception:\n            raise InvalidTokenError from exception\n        except JWTInvalidTokenError as exception:\n            raise InvalidTokenError from exception\n\n    @classmethod\n    def verify_access_token(cls, token: str, auth_config: AuthConfig | None = None) -&gt; dict[str, Any]:\n        \"\"\"Verifies an access token.\n\n        Args:\n            token (str): The access token to verify.\n            auth_config (AuthConfig | None): Optional auth configuration override.\n                If not provided, uses the global config.\n\n        Returns:\n            dict[str, Any]: The decoded access token payload.\n\n        Raises:\n            InvalidTokenException: If the token is invalid or not an access token.\n            TokenExpiredException: If the token has expired.\n        \"\"\"\n        configs = auth_config or BaseConfig.global_config().AUTH\n        return cls.decode_token(token, verify_type=\"access\", auth_config=configs)\n\n    @classmethod\n    def verify_refresh_token(cls, token: str, auth_config: AuthConfig | None = None) -&gt; dict[str, Any]:\n        \"\"\"Verifies a refresh token.\n\n        Args:\n            token (str): The refresh token to verify.\n            auth_config (AuthConfig | None): Optional auth configuration override.\n                If not provided, uses the global config.\n\n        Returns:\n            dict[str, Any]: The decoded refresh token payload.\n\n        Raises:\n            InvalidTokenException: If the token is invalid or not a refresh token.\n            TokenExpiredException: If the token has expired.\n        \"\"\"\n        configs = auth_config or BaseConfig.global_config().AUTH\n        return cls.decode_token(token, verify_type=\"refresh\", auth_config=configs)\n\n    @staticmethod\n    def extract_user_uuid(payload: dict[str, Any]) -&gt; UUID:\n        \"\"\"Extracts the user UUID from the token payload.\n\n        Args:\n            payload (dict[str, Any]): The decoded token payload.\n\n        Returns:\n            UUID: The user's UUID.\n\n        Raises:\n            InvalidTokenException: If the user identifier is invalid or missing.\n        \"\"\"\n        try:\n            return UUID(payload[\"sub\"])\n        except (KeyError, ValueError) as exception:\n            raise InvalidTokenError from exception\n\n    @classmethod\n    def get_token_expiry(cls, token: str, auth_config: AuthConfig | None = None) -&gt; int:\n        \"\"\"Gets the token expiry timestamp.\n\n        Args:\n            token (str): The JWT token.\n            auth_config (AuthConfig | None): Optional auth configuration override.\n                If not provided, uses the global config.\n\n        Returns:\n            int: The token expiry timestamp in seconds.\n\n        Raises:\n            InvalidTokenException: If the token is invalid.\n        \"\"\"\n        payload = cls.decode_token(token, auth_config=auth_config)\n        return int(payload[\"exp\"])\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.jwt_utils.JWTUtils.create_token","title":"<code>archipy.helpers.utils.jwt_utils.JWTUtils.create_token(data, expires_in, additional_claims=None, auth_config=None)</code>  <code>classmethod</code>","text":"<p>Creates a JWT token with enhanced security features.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Base claims data to include in the token.</p> required <code>expires_in</code> <code>int</code> <p>Token expiration time in seconds.</p> required <code>additional_claims</code> <code>dict[str, Any] | None</code> <p>Optional additional claims to include in the token.</p> <code>None</code> <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The encoded JWT token.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data is empty or expiration is invalid</p> Source code in <code>archipy/helpers/utils/jwt_utils.py</code> <pre><code>@classmethod\ndef create_token(\n    cls,\n    data: dict[str, Any],\n    expires_in: int,\n    additional_claims: dict[str, Any] | None = None,\n    auth_config: AuthConfig | None = None,\n) -&gt; str:\n    \"\"\"Creates a JWT token with enhanced security features.\n\n    Args:\n        data (dict[str, Any]): Base claims data to include in the token.\n        expires_in (int): Token expiration time in seconds.\n        additional_claims (dict[str, Any] | None): Optional additional claims to include in the token.\n        auth_config (AuthConfig | None): Optional auth configuration override.\n            If not provided, uses the global config.\n\n    Returns:\n        str: The encoded JWT token.\n\n    Raises:\n        ValueError: If data is empty or expiration is invalid\n    \"\"\"\n    import jwt\n\n    configs = auth_config or BaseConfig.global_config().AUTH\n    current_time = DatetimeUtils.get_datetime_utc_now()\n\n    # Define argument names\n    arg_data = \"data\"\n    arg_expires_in = \"expires_in\"\n\n    if not data:\n        raise InvalidArgumentError(arg_data)\n    if expires_in &lt;= 0:\n        raise InvalidArgumentError(arg_expires_in)\n\n    to_encode = data.copy()\n    expire = DatetimeUtils.get_datetime_after_given_datetime_or_now(seconds=expires_in, datetime_given=current_time)\n\n    # Add standard claims\n    to_encode.update(\n        {\n            # Registered claims (RFC 7519)\n            \"iss\": configs.JWT_ISSUER,\n            \"aud\": configs.JWT_AUDIENCE,\n            \"exp\": expire,\n            \"iat\": current_time,\n            \"nbf\": current_time,\n        },\n    )\n\n    # Add JWT ID if enabled\n    if configs.ENABLE_JTI_CLAIM:\n        to_encode[\"jti\"] = str(uuid4())\n\n    # Add additional claims\n    if additional_claims:\n        to_encode.update(additional_claims)\n\n    # Validate SECRET_KEY\n    secret_key = configs.SECRET_KEY\n    if secret_key is None:\n        raise InvalidArgumentError(\"SECRET_KEY\")\n    return jwt.encode(to_encode, secret_key.get_secret_value(), algorithm=configs.HASH_ALGORITHM)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.jwt_utils.JWTUtils.create_access_token","title":"<code>archipy.helpers.utils.jwt_utils.JWTUtils.create_access_token(user_uuid, additional_claims=None, auth_config=None)</code>  <code>classmethod</code>","text":"<p>Creates an access token for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_uuid</code> <code>UUID</code> <p>The user's UUID to include in the token.</p> required <code>additional_claims</code> <code>dict[str, Any] | None</code> <p>Optional additional claims to include in the token.</p> <code>None</code> <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The encoded access token.</p> Source code in <code>archipy/helpers/utils/jwt_utils.py</code> <pre><code>@classmethod\ndef create_access_token(\n    cls,\n    user_uuid: UUID,\n    additional_claims: dict[str, Any] | None = None,\n    auth_config: AuthConfig | None = None,\n) -&gt; str:\n    \"\"\"Creates an access token for a user.\n\n    Args:\n        user_uuid (UUID): The user's UUID to include in the token.\n        additional_claims (dict[str, Any] | None): Optional additional claims to include in the token.\n        auth_config (AuthConfig | None): Optional auth configuration override.\n            If not provided, uses the global config.\n\n    Returns:\n        str: The encoded access token.\n    \"\"\"\n    configs = auth_config or BaseConfig.global_config().AUTH\n\n    return cls.create_token(\n        data={\n            \"sub\": str(user_uuid),\n            \"type\": \"access\",\n            \"token_version\": configs.TOKEN_VERSION,\n        },\n        expires_in=configs.ACCESS_TOKEN_EXPIRES_IN,\n        additional_claims=additional_claims,\n        auth_config=configs,\n    )\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.jwt_utils.JWTUtils.create_refresh_token","title":"<code>archipy.helpers.utils.jwt_utils.JWTUtils.create_refresh_token(user_uuid, additional_claims=None, auth_config=None)</code>  <code>classmethod</code>","text":"<p>Creates a refresh token for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_uuid</code> <code>UUID</code> <p>The user's UUID to include in the token.</p> required <code>additional_claims</code> <code>dict[str, Any] | None</code> <p>Optional additional claims to include in the token.</p> <code>None</code> <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The encoded refresh token.</p> Source code in <code>archipy/helpers/utils/jwt_utils.py</code> <pre><code>@classmethod\ndef create_refresh_token(\n    cls,\n    user_uuid: UUID,\n    additional_claims: dict[str, Any] | None = None,\n    auth_config: AuthConfig | None = None,\n) -&gt; str:\n    \"\"\"Creates a refresh token for a user.\n\n    Args:\n        user_uuid (UUID): The user's UUID to include in the token.\n        additional_claims (dict[str, Any] | None): Optional additional claims to include in the token.\n        auth_config (AuthConfig | None): Optional auth configuration override.\n            If not provided, uses the global config.\n\n    Returns:\n        str: The encoded refresh token.\n    \"\"\"\n    configs = auth_config or BaseConfig.global_config().AUTH\n\n    return cls.create_token(\n        data={\n            \"sub\": str(user_uuid),\n            \"type\": \"refresh\",\n            \"token_version\": configs.TOKEN_VERSION,\n        },\n        expires_in=configs.REFRESH_TOKEN_EXPIRES_IN,\n        additional_claims=additional_claims,\n        auth_config=configs,\n    )\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.jwt_utils.JWTUtils.decode_token","title":"<code>archipy.helpers.utils.jwt_utils.JWTUtils.decode_token(token, verify_type=None, auth_config=None)</code>  <code>classmethod</code>","text":"<p>Decodes and verifies a JWT token with enhanced security checks.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The JWT token to decode.</p> required <code>verify_type</code> <code>str | None</code> <p>Optional token type to verify (e.g., \"access\" or \"refresh\").</p> <code>None</code> <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: The decoded token payload.</p> <p>Raises:</p> Type Description <code>TokenExpiredError</code> <p>If the token has expired.</p> <code>InvalidTokenError</code> <p>If the token is invalid (e.g., invalid signature, audience, issuer, or type).</p> Source code in <code>archipy/helpers/utils/jwt_utils.py</code> <pre><code>@classmethod\ndef decode_token(\n    cls,\n    token: str,\n    verify_type: str | None = None,\n    auth_config: AuthConfig | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Decodes and verifies a JWT token with enhanced security checks.\n\n    Args:\n        token (str): The JWT token to decode.\n        verify_type (str | None): Optional token type to verify (e.g., \"access\" or \"refresh\").\n        auth_config (AuthConfig | None): Optional auth configuration override.\n            If not provided, uses the global config.\n\n    Returns:\n        dict[str, Any]: The decoded token payload.\n\n    Raises:\n        TokenExpiredError: If the token has expired.\n        InvalidTokenError: If the token is invalid (e.g., invalid signature, audience, issuer, or type).\n    \"\"\"\n    import jwt\n    from jwt.exceptions import (\n        ExpiredSignatureError,\n        InvalidAudienceError,\n        InvalidIssuerError,\n        InvalidSignatureError,\n        InvalidTokenError as JWTInvalidTokenError,\n    )\n\n    configs = auth_config or BaseConfig.global_config().AUTH\n    required_claims = [\"exp\", \"iat\", \"nbf\", \"aud\", \"iss\", \"sub\", \"type\", \"token_version\"]\n    if configs.ENABLE_JTI_CLAIM:\n        required_claims.append(\"jti\")\n\n    try:\n        # Validate SECRET_KEY\n        secret_key = configs.SECRET_KEY\n        if secret_key is None:\n            raise InvalidArgumentError(\"SECRET_KEY\")\n\n        payload = jwt.decode(\n            token,\n            secret_key.get_secret_value(),\n            algorithms=[configs.HASH_ALGORITHM],\n            options={\n                \"verify_signature\": True,\n                \"verify_exp\": True,\n                \"verify_nbf\": True,\n                \"verify_iat\": True,\n                \"verify_aud\": True,\n                \"verify_iss\": True,\n                \"require\": required_claims,\n            },\n            audience=configs.JWT_AUDIENCE,\n            issuer=configs.JWT_ISSUER,\n        )\n\n        # Verify token type\n        if verify_type and payload.get(\"type\") != verify_type:\n            raise InvalidTokenError\n\n        # Verify token version\n        if payload.get(\"token_version\") != configs.TOKEN_VERSION:\n            raise InvalidTokenError\n\n        # Ensure the return type is dict[str, Any] as declared\n        return dict(payload)\n\n    except ExpiredSignatureError as exception:\n        raise TokenExpiredError from exception\n    except InvalidSignatureError as exception:\n        raise InvalidTokenError from exception\n    except InvalidAudienceError as exception:\n        raise InvalidTokenError from exception\n    except InvalidIssuerError as exception:\n        raise InvalidTokenError from exception\n    except JWTInvalidTokenError as exception:\n        raise InvalidTokenError from exception\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.jwt_utils.JWTUtils.verify_access_token","title":"<code>archipy.helpers.utils.jwt_utils.JWTUtils.verify_access_token(token, auth_config=None)</code>  <code>classmethod</code>","text":"<p>Verifies an access token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The access token to verify.</p> required <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: The decoded access token payload.</p> <p>Raises:</p> Type Description <code>InvalidTokenException</code> <p>If the token is invalid or not an access token.</p> <code>TokenExpiredException</code> <p>If the token has expired.</p> Source code in <code>archipy/helpers/utils/jwt_utils.py</code> <pre><code>@classmethod\ndef verify_access_token(cls, token: str, auth_config: AuthConfig | None = None) -&gt; dict[str, Any]:\n    \"\"\"Verifies an access token.\n\n    Args:\n        token (str): The access token to verify.\n        auth_config (AuthConfig | None): Optional auth configuration override.\n            If not provided, uses the global config.\n\n    Returns:\n        dict[str, Any]: The decoded access token payload.\n\n    Raises:\n        InvalidTokenException: If the token is invalid or not an access token.\n        TokenExpiredException: If the token has expired.\n    \"\"\"\n    configs = auth_config or BaseConfig.global_config().AUTH\n    return cls.decode_token(token, verify_type=\"access\", auth_config=configs)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.jwt_utils.JWTUtils.verify_refresh_token","title":"<code>archipy.helpers.utils.jwt_utils.JWTUtils.verify_refresh_token(token, auth_config=None)</code>  <code>classmethod</code>","text":"<p>Verifies a refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The refresh token to verify.</p> required <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: The decoded refresh token payload.</p> <p>Raises:</p> Type Description <code>InvalidTokenException</code> <p>If the token is invalid or not a refresh token.</p> <code>TokenExpiredException</code> <p>If the token has expired.</p> Source code in <code>archipy/helpers/utils/jwt_utils.py</code> <pre><code>@classmethod\ndef verify_refresh_token(cls, token: str, auth_config: AuthConfig | None = None) -&gt; dict[str, Any]:\n    \"\"\"Verifies a refresh token.\n\n    Args:\n        token (str): The refresh token to verify.\n        auth_config (AuthConfig | None): Optional auth configuration override.\n            If not provided, uses the global config.\n\n    Returns:\n        dict[str, Any]: The decoded refresh token payload.\n\n    Raises:\n        InvalidTokenException: If the token is invalid or not a refresh token.\n        TokenExpiredException: If the token has expired.\n    \"\"\"\n    configs = auth_config or BaseConfig.global_config().AUTH\n    return cls.decode_token(token, verify_type=\"refresh\", auth_config=configs)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.jwt_utils.JWTUtils.extract_user_uuid","title":"<code>archipy.helpers.utils.jwt_utils.JWTUtils.extract_user_uuid(payload)</code>  <code>staticmethod</code>","text":"<p>Extracts the user UUID from the token payload.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict[str, Any]</code> <p>The decoded token payload.</p> required <p>Returns:</p> Name Type Description <code>UUID</code> <code>UUID</code> <p>The user's UUID.</p> <p>Raises:</p> Type Description <code>InvalidTokenException</code> <p>If the user identifier is invalid or missing.</p> Source code in <code>archipy/helpers/utils/jwt_utils.py</code> <pre><code>@staticmethod\ndef extract_user_uuid(payload: dict[str, Any]) -&gt; UUID:\n    \"\"\"Extracts the user UUID from the token payload.\n\n    Args:\n        payload (dict[str, Any]): The decoded token payload.\n\n    Returns:\n        UUID: The user's UUID.\n\n    Raises:\n        InvalidTokenException: If the user identifier is invalid or missing.\n    \"\"\"\n    try:\n        return UUID(payload[\"sub\"])\n    except (KeyError, ValueError) as exception:\n        raise InvalidTokenError from exception\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.jwt_utils.JWTUtils.get_token_expiry","title":"<code>archipy.helpers.utils.jwt_utils.JWTUtils.get_token_expiry(token, auth_config=None)</code>  <code>classmethod</code>","text":"<p>Gets the token expiry timestamp.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The JWT token.</p> required <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The token expiry timestamp in seconds.</p> <p>Raises:</p> Type Description <code>InvalidTokenException</code> <p>If the token is invalid.</p> Source code in <code>archipy/helpers/utils/jwt_utils.py</code> <pre><code>@classmethod\ndef get_token_expiry(cls, token: str, auth_config: AuthConfig | None = None) -&gt; int:\n    \"\"\"Gets the token expiry timestamp.\n\n    Args:\n        token (str): The JWT token.\n        auth_config (AuthConfig | None): Optional auth configuration override.\n            If not provided, uses the global config.\n\n    Returns:\n        int: The token expiry timestamp in seconds.\n\n    Raises:\n        InvalidTokenException: If the token is invalid.\n    \"\"\"\n    payload = cls.decode_token(token, auth_config=auth_config)\n    return int(payload[\"exp\"])\n</code></pre>"},{"location":"api_reference/utils/#password_utils","title":"password_utils","text":"<p>Utilities for password operations.</p> <pre><code>from archipy.helpers.utils.password_utils import PasswordUtils\n\n# Hash password\nhashed = PasswordUtils.hash_password(\"my-password\")\n\n# Verify password\nis_valid = PasswordUtils.verify_password(\"my-password\", hashed)\n\n# Generate secure password\npassword = PasswordUtils.generate_password(length=12)\n\n# Validate password strength\nis_strong = PasswordUtils.validate_password_strength(\"my-password\")\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/utils/#archipy.helpers.utils.password_utils.PasswordUtils","title":"<code>archipy.helpers.utils.password_utils.PasswordUtils</code>","text":"<p>A utility class for handling password-related operations, such as hashing, verification, and validation.</p> Source code in <code>archipy/helpers/utils/password_utils.py</code> <pre><code>class PasswordUtils:\n    \"\"\"A utility class for handling password-related operations, such as hashing, verification, and validation.\"\"\"\n\n    @staticmethod\n    def hash_password(password: str, auth_config: AuthConfig | None = None) -&gt; str:\n        \"\"\"Hashes a password using PBKDF2 with SHA256.\n\n        Args:\n            password (str): The password to hash.\n            auth_config (AuthConfig | None): Optional auth configuration override. If not provided, uses the global config.\n\n        Returns:\n            str: A base64-encoded string containing the salt and hash in the format \"salt:hash\".\n        \"\"\"\n        configs = auth_config or BaseConfig.global_config().AUTH\n        salt = os.urandom(configs.SALT_LENGTH)\n        pw_hash = hashlib.pbkdf2_hmac(\"sha256\", password.encode(), salt, configs.HASH_ITERATIONS)\n\n        # Combine salt and hash, encode in base64\n        return b64encode(salt + pw_hash).decode(\"utf-8\")\n\n    @staticmethod\n    def verify_password(password: str, stored_password: str, auth_config: AuthConfig | None = None) -&gt; bool:\n        \"\"\"Verifies a password against a stored hash.\n\n        Args:\n            password (str): The password to verify.\n            stored_password (str): The stored password hash to compare against.\n            auth_config (AuthConfig | None): Optional auth configuration override. If not provided, uses the global config.\n\n        Returns:\n            bool: True if the password matches the stored hash, False otherwise.\n        \"\"\"\n        try:\n            configs = auth_config or BaseConfig.global_config().AUTH\n\n            # Decode the stored password\n            decoded = b64decode(stored_password.encode(\"utf-8\"))\n            salt = decoded[: configs.SALT_LENGTH]\n            stored_hash = decoded[configs.SALT_LENGTH :]\n\n            # Hash the provided password with the same salt\n            pw_hash = hashlib.pbkdf2_hmac(\"sha256\", password.encode(), salt, configs.HASH_ITERATIONS)\n\n            # Compare in constant time to prevent timing attacks\n            return hmac.compare_digest(pw_hash, stored_hash)\n        except (ValueError, TypeError, IndexError):\n            # Catch specific exceptions that could occur during decoding or comparison\n            return False\n\n    @staticmethod\n    def validate_password(\n        password: str,\n        auth_config: AuthConfig | None = None,\n    ) -&gt; None:\n        \"\"\"Validates a password against the password policy.\n\n        Args:\n            password (str): The password to validate.\n            auth_config (AuthConfig | None): Optional auth configuration override. If not provided, uses the global config.\n\n        Raises:\n            InvalidPasswordError: If the password does not meet the policy requirements.\n        \"\"\"\n        configs = auth_config or BaseConfig.global_config().AUTH\n        errors = []\n\n        if len(password) &lt; configs.MIN_LENGTH:\n            errors.append(f\"Password must be at least {configs.MIN_LENGTH} characters long.\")\n\n        if configs.REQUIRE_DIGIT and not any(char.isdigit() for char in password):\n            errors.append(\"Password must contain at least one digit.\")\n\n        if configs.REQUIRE_LOWERCASE and not any(char.islower() for char in password):\n            errors.append(\"Password must contain at least one lowercase letter.\")\n\n        if configs.REQUIRE_UPPERCASE and not any(char.isupper() for char in password):\n            errors.append(\"Password must contain at least one uppercase letter.\")\n\n        if configs.REQUIRE_SPECIAL and not any(char in configs.SPECIAL_CHARACTERS for char in password):\n            errors.append(f\"Password must contain at least one special character: {configs.SPECIAL_CHARACTERS}\")\n\n        if errors:\n            raise InvalidPasswordError(requirements=errors)\n\n    @staticmethod\n    def generate_password(auth_config: AuthConfig | None = None) -&gt; str:\n        \"\"\"Generates a random password that meets the policy requirements.\n\n        Args:\n            auth_config (AuthConfig | None): Optional auth configuration override. If not provided, uses the global config.\n\n        Returns:\n            str: A randomly generated password that meets the policy requirements.\n        \"\"\"\n        configs = auth_config or BaseConfig.global_config().AUTH\n\n        lowercase_chars = string.ascii_lowercase\n        uppercase_chars = string.ascii_uppercase\n        digit_chars = string.digits\n        special_chars = \"\".join(configs.SPECIAL_CHARACTERS)\n\n        # Initialize with required characters\n        password_chars = []\n        if configs.REQUIRE_LOWERCASE:\n            password_chars.append(secrets.choice(lowercase_chars))\n        if configs.REQUIRE_UPPERCASE:\n            password_chars.append(secrets.choice(uppercase_chars))\n        if configs.REQUIRE_DIGIT:\n            password_chars.append(secrets.choice(digit_chars))\n        if configs.REQUIRE_SPECIAL:\n            password_chars.append(secrets.choice(special_chars))\n\n        # Calculate remaining length\n        remaining_length = max(0, configs.MIN_LENGTH - len(password_chars))\n\n        # Add random characters to meet minimum length\n        all_chars = lowercase_chars + uppercase_chars + digit_chars + special_chars\n        password_chars.extend(secrets.choice(all_chars) for _ in range(remaining_length))\n\n        # Shuffle the password characters\n        shuffled = list(password_chars)\n        secrets.SystemRandom().shuffle(shuffled)\n\n        return \"\".join(shuffled)\n\n    @classmethod\n    def validate_password_history(\n        cls,\n        new_password: str,\n        password_history: list[str],\n        auth_config: AuthConfig | None = None,\n        lang: LanguageType | None = None,\n    ) -&gt; None:\n        \"\"\"Validates a new password against the password history.\n\n        Args:\n            new_password (str): The new password to validate.\n            password_history (list[str]): A list of previous password hashes.\n            auth_config (AuthConfig | None): Optional auth configuration override. If not provided, uses the global config.\n            lang (LanguageType): The language to use for error messages. Defaults to Persian.\n\n        Raises:\n            InvalidPasswordError: If the new password has been used recently or does not meet the policy requirements.\n        \"\"\"\n        configs = auth_config or BaseConfig.global_config().AUTH\n\n        # First validate against password policy\n        cls.validate_password(new_password, configs)\n\n        # Check password history\n        if any(\n            cls.verify_password(new_password, old_password, configs)\n            for old_password in password_history[-configs.PASSWORD_HISTORY_SIZE :]\n        ):\n            raise InvalidPasswordError(requirements=[\"Password has been used recently\"], lang=lang)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.password_utils.PasswordUtils.hash_password","title":"<code>archipy.helpers.utils.password_utils.PasswordUtils.hash_password(password, auth_config=None)</code>  <code>staticmethod</code>","text":"<p>Hashes a password using PBKDF2 with SHA256.</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>str</code> <p>The password to hash.</p> required <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A base64-encoded string containing the salt and hash in the format \"salt:hash\".</p> Source code in <code>archipy/helpers/utils/password_utils.py</code> <pre><code>@staticmethod\ndef hash_password(password: str, auth_config: AuthConfig | None = None) -&gt; str:\n    \"\"\"Hashes a password using PBKDF2 with SHA256.\n\n    Args:\n        password (str): The password to hash.\n        auth_config (AuthConfig | None): Optional auth configuration override. If not provided, uses the global config.\n\n    Returns:\n        str: A base64-encoded string containing the salt and hash in the format \"salt:hash\".\n    \"\"\"\n    configs = auth_config or BaseConfig.global_config().AUTH\n    salt = os.urandom(configs.SALT_LENGTH)\n    pw_hash = hashlib.pbkdf2_hmac(\"sha256\", password.encode(), salt, configs.HASH_ITERATIONS)\n\n    # Combine salt and hash, encode in base64\n    return b64encode(salt + pw_hash).decode(\"utf-8\")\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.password_utils.PasswordUtils.verify_password","title":"<code>archipy.helpers.utils.password_utils.PasswordUtils.verify_password(password, stored_password, auth_config=None)</code>  <code>staticmethod</code>","text":"<p>Verifies a password against a stored hash.</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>str</code> <p>The password to verify.</p> required <code>stored_password</code> <code>str</code> <p>The stored password hash to compare against.</p> required <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the password matches the stored hash, False otherwise.</p> Source code in <code>archipy/helpers/utils/password_utils.py</code> <pre><code>@staticmethod\ndef verify_password(password: str, stored_password: str, auth_config: AuthConfig | None = None) -&gt; bool:\n    \"\"\"Verifies a password against a stored hash.\n\n    Args:\n        password (str): The password to verify.\n        stored_password (str): The stored password hash to compare against.\n        auth_config (AuthConfig | None): Optional auth configuration override. If not provided, uses the global config.\n\n    Returns:\n        bool: True if the password matches the stored hash, False otherwise.\n    \"\"\"\n    try:\n        configs = auth_config or BaseConfig.global_config().AUTH\n\n        # Decode the stored password\n        decoded = b64decode(stored_password.encode(\"utf-8\"))\n        salt = decoded[: configs.SALT_LENGTH]\n        stored_hash = decoded[configs.SALT_LENGTH :]\n\n        # Hash the provided password with the same salt\n        pw_hash = hashlib.pbkdf2_hmac(\"sha256\", password.encode(), salt, configs.HASH_ITERATIONS)\n\n        # Compare in constant time to prevent timing attacks\n        return hmac.compare_digest(pw_hash, stored_hash)\n    except (ValueError, TypeError, IndexError):\n        # Catch specific exceptions that could occur during decoding or comparison\n        return False\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.password_utils.PasswordUtils.validate_password","title":"<code>archipy.helpers.utils.password_utils.PasswordUtils.validate_password(password, auth_config=None)</code>  <code>staticmethod</code>","text":"<p>Validates a password against the password policy.</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>str</code> <p>The password to validate.</p> required <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Raises:</p> Type Description <code>InvalidPasswordError</code> <p>If the password does not meet the policy requirements.</p> Source code in <code>archipy/helpers/utils/password_utils.py</code> <pre><code>@staticmethod\ndef validate_password(\n    password: str,\n    auth_config: AuthConfig | None = None,\n) -&gt; None:\n    \"\"\"Validates a password against the password policy.\n\n    Args:\n        password (str): The password to validate.\n        auth_config (AuthConfig | None): Optional auth configuration override. If not provided, uses the global config.\n\n    Raises:\n        InvalidPasswordError: If the password does not meet the policy requirements.\n    \"\"\"\n    configs = auth_config or BaseConfig.global_config().AUTH\n    errors = []\n\n    if len(password) &lt; configs.MIN_LENGTH:\n        errors.append(f\"Password must be at least {configs.MIN_LENGTH} characters long.\")\n\n    if configs.REQUIRE_DIGIT and not any(char.isdigit() for char in password):\n        errors.append(\"Password must contain at least one digit.\")\n\n    if configs.REQUIRE_LOWERCASE and not any(char.islower() for char in password):\n        errors.append(\"Password must contain at least one lowercase letter.\")\n\n    if configs.REQUIRE_UPPERCASE and not any(char.isupper() for char in password):\n        errors.append(\"Password must contain at least one uppercase letter.\")\n\n    if configs.REQUIRE_SPECIAL and not any(char in configs.SPECIAL_CHARACTERS for char in password):\n        errors.append(f\"Password must contain at least one special character: {configs.SPECIAL_CHARACTERS}\")\n\n    if errors:\n        raise InvalidPasswordError(requirements=errors)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.password_utils.PasswordUtils.generate_password","title":"<code>archipy.helpers.utils.password_utils.PasswordUtils.generate_password(auth_config=None)</code>  <code>staticmethod</code>","text":"<p>Generates a random password that meets the policy requirements.</p> <p>Parameters:</p> Name Type Description Default <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A randomly generated password that meets the policy requirements.</p> Source code in <code>archipy/helpers/utils/password_utils.py</code> <pre><code>@staticmethod\ndef generate_password(auth_config: AuthConfig | None = None) -&gt; str:\n    \"\"\"Generates a random password that meets the policy requirements.\n\n    Args:\n        auth_config (AuthConfig | None): Optional auth configuration override. If not provided, uses the global config.\n\n    Returns:\n        str: A randomly generated password that meets the policy requirements.\n    \"\"\"\n    configs = auth_config or BaseConfig.global_config().AUTH\n\n    lowercase_chars = string.ascii_lowercase\n    uppercase_chars = string.ascii_uppercase\n    digit_chars = string.digits\n    special_chars = \"\".join(configs.SPECIAL_CHARACTERS)\n\n    # Initialize with required characters\n    password_chars = []\n    if configs.REQUIRE_LOWERCASE:\n        password_chars.append(secrets.choice(lowercase_chars))\n    if configs.REQUIRE_UPPERCASE:\n        password_chars.append(secrets.choice(uppercase_chars))\n    if configs.REQUIRE_DIGIT:\n        password_chars.append(secrets.choice(digit_chars))\n    if configs.REQUIRE_SPECIAL:\n        password_chars.append(secrets.choice(special_chars))\n\n    # Calculate remaining length\n    remaining_length = max(0, configs.MIN_LENGTH - len(password_chars))\n\n    # Add random characters to meet minimum length\n    all_chars = lowercase_chars + uppercase_chars + digit_chars + special_chars\n    password_chars.extend(secrets.choice(all_chars) for _ in range(remaining_length))\n\n    # Shuffle the password characters\n    shuffled = list(password_chars)\n    secrets.SystemRandom().shuffle(shuffled)\n\n    return \"\".join(shuffled)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.password_utils.PasswordUtils.validate_password_history","title":"<code>archipy.helpers.utils.password_utils.PasswordUtils.validate_password_history(new_password, password_history, auth_config=None, lang=None)</code>  <code>classmethod</code>","text":"<p>Validates a new password against the password history.</p> <p>Parameters:</p> Name Type Description Default <code>new_password</code> <code>str</code> <p>The new password to validate.</p> required <code>password_history</code> <code>list[str]</code> <p>A list of previous password hashes.</p> required <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <code>lang</code> <code>LanguageType</code> <p>The language to use for error messages. Defaults to Persian.</p> <code>None</code> <p>Raises:</p> Type Description <code>InvalidPasswordError</code> <p>If the new password has been used recently or does not meet the policy requirements.</p> Source code in <code>archipy/helpers/utils/password_utils.py</code> <pre><code>@classmethod\ndef validate_password_history(\n    cls,\n    new_password: str,\n    password_history: list[str],\n    auth_config: AuthConfig | None = None,\n    lang: LanguageType | None = None,\n) -&gt; None:\n    \"\"\"Validates a new password against the password history.\n\n    Args:\n        new_password (str): The new password to validate.\n        password_history (list[str]): A list of previous password hashes.\n        auth_config (AuthConfig | None): Optional auth configuration override. If not provided, uses the global config.\n        lang (LanguageType): The language to use for error messages. Defaults to Persian.\n\n    Raises:\n        InvalidPasswordError: If the new password has been used recently or does not meet the policy requirements.\n    \"\"\"\n    configs = auth_config or BaseConfig.global_config().AUTH\n\n    # First validate against password policy\n    cls.validate_password(new_password, configs)\n\n    # Check password history\n    if any(\n        cls.verify_password(new_password, old_password, configs)\n        for old_password in password_history[-configs.PASSWORD_HISTORY_SIZE :]\n    ):\n        raise InvalidPasswordError(requirements=[\"Password has been used recently\"], lang=lang)\n</code></pre>"},{"location":"api_reference/utils/#string_utils","title":"string_utils","text":"<p>Utilities for string operations.</p> <pre><code>from archipy.helpers.utils.string_utils import StringUtils\n\n# Convert to slug\nslug = StringUtils.slugify(\"My Article Title\")\n\n# Truncate string\ntruncated = StringUtils.truncate(\"Long text here\", length=10)\n\n# Generate random string\nrandom_str = StringUtils.generate_random_string(length=8)\n\n# Sanitize HTML\nclean_html = StringUtils.sanitize_html(\"&lt;script&gt;alert('xss')&lt;/script&gt;\")\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils","title":"<code>archipy.helpers.utils.string_utils.StringUtils</code>","text":"<p>               Bases: <code>StringUtilsConstants</code></p> <p>String utilities for text normalization, cleaning, and masking.</p> <p>This class provides methods for handling Persian and Arabic text, including normalization, punctuation cleaning, number conversion, and masking of sensitive information like URLs, emails, and phone numbers.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>class StringUtils(StringUtilsConstants):\n    \"\"\"String utilities for text normalization, cleaning, and masking.\n\n    This class provides methods for handling Persian and Arabic text, including normalization,\n    punctuation cleaning, number conversion, and masking of sensitive information like URLs,\n    emails, and phone numbers.\n    \"\"\"\n\n    @classmethod\n    def remove_arabic_vowels(cls, text: str) -&gt; str:\n        \"\"\"Removes Arabic vowels (tashkeel) from the text.\n\n        Args:\n            text (str): The input text containing Arabic vowels.\n\n        Returns:\n            str: The text with Arabic vowels removed.\n        \"\"\"\n        return text.translate(cls.arabic_vowel_translate_table)\n\n    @classmethod\n    def normalize_persian_chars(cls, text: str) -&gt; str:\n        \"\"\"Normalizes Persian characters to their standard forms.\n\n        Args:\n            text (str): The input text containing Persian characters.\n\n        Returns:\n            str: The text with Persian characters normalized.\n        \"\"\"\n        text = text.translate(cls.alphabet_akoolad_alef_translate_table)\n        text = text.translate(cls.alphabet_alef_translate_table)\n        text = text.translate(cls.alphabet_be_translate_table)\n        text = text.translate(cls.alphabet_pe_translate_table)\n        text = text.translate(cls.alphabet_te_translate_table)\n        text = text.translate(cls.alphabet_se_translate_table)\n        text = text.translate(cls.alphabet_jim_translate_table)\n        text = text.translate(cls.alphabet_che_translate_table)\n        text = text.translate(cls.alphabet_he_translate_table)\n        text = text.translate(cls.alphabet_khe_translate_table)\n        text = text.translate(cls.alphabet_dal_translate_table)\n        text = text.translate(cls.alphabet_zal_translate_table)\n        text = text.translate(cls.alphabet_re_translate_table)\n        text = text.translate(cls.alphabet_ze_translate_table)\n        text = text.translate(cls.alphabet_zhe_translate_table)\n        text = text.translate(cls.alphabet_sin_translate_table)\n        text = text.translate(cls.alphabet_shin_translate_table)\n        text = text.translate(cls.alphabet_sad_translate_table)\n        text = text.translate(cls.alphabet_zad_translate_table)\n        text = text.translate(cls.alphabet_ta_translate_table)\n        text = text.translate(cls.alphabet_za_translate_table)\n        text = text.translate(cls.alphabet_eyn_translate_table)\n        text = text.translate(cls.alphabet_gheyn_translate_table)\n        text = text.translate(cls.alphabet_fe_translate_table)\n        text = text.translate(cls.alphabet_ghaf_translate_table)\n        text = text.translate(cls.alphabet_kaf_translate_table)\n        text = text.translate(cls.alphabet_gaf_translate_table)\n        text = text.translate(cls.alphabet_lam_translate_table)\n        text = text.translate(cls.alphabet_mim_translate_table)\n        text = text.translate(cls.alphabet_nun_translate_table)\n        text = text.translate(cls.alphabet_vav_translate_table)\n        text = text.translate(cls.alphabet_ha_translate_table)\n        return text.translate(cls.alphabet_ye_translate_table)\n\n    @classmethod\n    def normalize_punctuation(cls, text: str) -&gt; str:\n        \"\"\"Normalizes punctuation marks in the text.\n\n        Args:\n            text (str): The input text containing punctuation marks.\n\n        Returns:\n            str: The text with punctuation marks normalized.\n        \"\"\"\n        text = text.translate(cls.punctuation_translate_table1)\n        text = text.translate(cls.punctuation_translate_table2)\n        text = text.translate(cls.punctuation_translate_table3)\n        text = text.translate(cls.punctuation_translate_table4)\n        text = text.translate(cls.punctuation_translate_table5)\n        text = text.translate(cls.punctuation_translate_table6)\n        text = text.translate(cls.punctuation_translate_table7)\n        text = text.translate(cls.punctuation_translate_table8)\n        text = text.translate(cls.punctuation_translate_table9)\n        text = text.translate(cls.punctuation_translate_table10)\n        text = text.translate(cls.punctuation_translate_table11)\n        text = text.translate(cls.punctuation_translate_table12)\n        return text.translate(cls.punctuation_translate_table13)\n\n    @classmethod\n    def normalize_numbers(cls, text: str) -&gt; str:\n        \"\"\"Normalizes numbers in the text to English format.\n\n        Args:\n            text (str): The input text containing numbers.\n\n        Returns:\n            str: The text with numbers normalized to English format.\n        \"\"\"\n        text = text.translate(cls.number_zero_translate_table)\n        text = text.translate(cls.number_one_translate_table)\n        text = text.translate(cls.number_two_translate_table)\n        text = text.translate(cls.number_three_translate_table)\n        text = text.translate(cls.number_four_translate_table)\n        text = text.translate(cls.number_five_translate_table)\n        text = text.translate(cls.number_six_translate_table)\n        text = text.translate(cls.number_seven_translate_table)\n        text = text.translate(cls.number_eight_translate_table)\n        return text.translate(cls.number_nine_translate_table)\n\n    @classmethod\n    def clean_spacing(cls, text: str) -&gt; str:\n        \"\"\"Cleans up spacing issues in the text, such as non-breaking spaces and zero-width non-joiners.\n\n        Args:\n            text (str): The input text with spacing issues.\n\n        Returns:\n            str: The text with spacing cleaned up.\n        \"\"\"\n        text = text.replace(\"\\u200c\", \" \")  # ZWNJ\n        text = text.replace(\"\\xa0\", \" \")  # NBSP\n\n        for pattern, repl in cls.character_refinement_patterns:\n            text = pattern.sub(repl, text)\n\n        return text\n\n    @classmethod\n    def normalize_punctuation_spacing(cls, text: str) -&gt; str:\n        \"\"\"Applies proper spacing around punctuation marks.\n\n        Args:\n            text (str): The input text with punctuation spacing issues.\n\n        Returns:\n            str: The text with proper spacing around punctuation marks.\n        \"\"\"\n        for pattern, repl in cls.punctuation_spacing_patterns:\n            text = pattern.sub(repl, text)\n        return text\n\n    @classmethod\n    def remove_punctuation_marks(cls, text: str) -&gt; str:\n        \"\"\"Removes punctuation marks from the text.\n\n        Args:\n            text (str): The input text containing punctuation marks.\n\n        Returns:\n            str: The text with punctuation marks removed.\n        \"\"\"\n        return text.translate(cls.punctuation_persian_marks_to_space_translate_table)\n\n    @classmethod\n    def mask_urls(cls, text: str, mask: str | None = None) -&gt; str:\n        \"\"\"Masks URLs in the text with a specified mask.\n\n        Args:\n            text (str): The input text containing URLs.\n            mask (str | None): The mask to replace URLs with. Defaults to \"MASK_URL\".\n\n        Returns:\n            str: The text with URLs masked.\n        \"\"\"\n        mask = mask or \"MASK_URL\"\n        return re_compile(r\"https?://\\S+|www\\.\\S+\").sub(f\" {mask} \", text)\n\n    @classmethod\n    def mask_emails(cls, text: str, mask: str | None = None) -&gt; str:\n        \"\"\"Masks email addresses in the text with a specified mask.\n\n        Args:\n            text (str): The input text containing email addresses.\n            mask (str | None): The mask to replace emails with. Defaults to \"MASK_EMAIL\".\n\n        Returns:\n            str: The text with email addresses masked.\n        \"\"\"\n        mask = mask or \"MASK_EMAIL\"\n        return re_compile(r\"\\S+@\\S+\\.\\S+\").sub(f\" {mask} \", text)\n\n    @classmethod\n    def mask_phones(cls, text: str, mask: str | None = None) -&gt; str:\n        \"\"\"Masks phone numbers in the text with a specified mask.\n\n        Args:\n            text (str): The input text containing phone numbers.\n            mask (str | None): The mask to replace phone numbers with. Defaults to \"MASK_PHONE\".\n\n        Returns:\n            str: The text with phone numbers masked.\n        \"\"\"\n        mask = mask or \"MASK_PHONE\"\n        return re_compile(r\"(?:\\+98|0)?(?:\\d{3}\\s*?\\d{3}\\s*?\\d{4})\").sub(f\" {mask} \", text)\n\n    @classmethod\n    def convert_english_number_to_persian(cls, text: str) -&gt; str:\n        \"\"\"Converts English numbers to Persian numbers in the text.\n\n        Args:\n            text (str): The input text containing English numbers.\n\n        Returns:\n            str: The text with English numbers converted to Persian numbers.\n        \"\"\"\n        table = {\n            48: 1776,  # 0\n            49: 1777,  # 1\n            50: 1778,  # 2\n            51: 1779,  # 3\n            52: 1780,  # 4\n            53: 1781,  # 5\n            54: 1782,  # 6\n            55: 1783,  # 7\n            56: 1784,  # 8\n            57: 1785,  # 9\n            44: 1548,  # ,\n        }\n        return text.translate(table)\n\n    @classmethod\n    def convert_numbers_to_english(cls, text: str) -&gt; str:\n        \"\"\"Converts Persian/Arabic numbers to English numbers in the text.\n\n        Args:\n            text (str): The input text containing Persian/Arabic numbers.\n\n        Returns:\n            str: The text with Persian/Arabic numbers converted to English numbers.\n        \"\"\"\n        table = {\n            1776: 48,  # 0\n            1777: 49,  # 1\n            1778: 50,  # 2\n            1779: 51,  # 3\n            1780: 52,  # 4\n            1781: 53,  # 5\n            1782: 54,  # 6\n            1783: 55,  # 7\n            1784: 56,  # 8\n            1785: 57,  # 9\n            1632: 48,  # 0\n            1633: 49,  # 1\n            1634: 50,  # 2\n            1635: 51,  # 3\n            1636: 52,  # 4\n            1637: 53,  # 5\n            1638: 54,  # 6\n            1639: 55,  # 7\n            1640: 56,  # 8\n            1641: 57,  # 9\n        }\n        return text.translate(table)\n\n    @classmethod\n    def convert_add_3digit_delimiter(cls, value: int) -&gt; str:\n        \"\"\"Adds thousand separators to numbers.\n\n        Args:\n            value (int): The number to format.\n\n        Returns:\n            str: The formatted number with thousand separators.\n        \"\"\"\n        return f\"{value:,}\" if isinstance(value, int) else value\n\n    @classmethod\n    def remove_emoji(cls, text: str) -&gt; str:\n        \"\"\"Removes emoji characters from the text.\n\n        Args:\n            text (str): The input text containing emojis.\n\n        Returns:\n            str: The text with emojis removed.\n        \"\"\"\n        emoji_pattern = re.compile(\n            r\"[\"\n            r\"\\U0001F600-\\U0001F64F\"  # emoticons\n            r\"\\U0001F300-\\U0001F5FF\"  # symbols &amp; pictographs\n            r\"\\U0001F680-\\U0001F6FF\"  # transport &amp; map symbols\n            r\"\\U0001F1E0-\\U0001F1FF\"  # flags\n            r\"\\U0001F900-\\U0001F9FF\"  # supplemental symbols and pictographs\n            r\"\\U0001FA00-\\U0001FA6F\"  # symbols and pictographs extended-A\n            r\"\\U00002600-\\U000026FF\"  # miscellaneous symbols (some are emojis)\n            r\"\\U00002700-\\U000027BF\"  # dingbats (some are emojis)\n            r\"\\U00002190-\\U000021FF\"  # arrows (some are emojis)\n            r\"]+\",\n            re.UNICODE,\n        )\n        return emoji_pattern.sub(r\"\", text)\n\n    @classmethod\n    def replace_currencies_with_mask(cls, text: str, mask: str | None = None) -&gt; str:\n        \"\"\"Masks currency symbols and amounts in the text.\n\n        Args:\n            text (str): The input text containing currency symbols and amounts.\n            mask (str | None): The mask to replace currencies with. Defaults to \"MASK_CURRENCIES\".\n\n        Returns:\n            str: The text with currency symbols and amounts masked.\n        \"\"\"\n        mask = mask or \"MASK_CURRENCIES\"\n        currency_pattern = re_compile(r\"(\\\\|z\u0142|\u00a3|\\$|\u20a1|\u20a6|\u00a5|\u20a9|\u20aa|\u20ab|\u20ac|\u20b1|\u20b2|\u20b4|\u20b9|\ufdfc)+\")\n        return currency_pattern.sub(f\" {mask} \", text)\n\n    @classmethod\n    def replace_numbers_with_mask(cls, text: str, mask: str | None = None) -&gt; str:\n        \"\"\"Masks numbers in the text.\n\n        Args:\n            text (str): The input text containing numbers.\n            mask (str | None): The mask to replace numbers with. Defaults to \"MASK_NUMBERS\".\n\n        Returns:\n            str: The text with numbers masked.\n        \"\"\"\n        mask = mask or \"MASK_NUMBERS\"\n        numbers = re.findall(\"[0-9]+\", text)\n        for number in sorted(numbers, key=len, reverse=True):\n            text = text.replace(number, f\" {mask} \")\n        return text\n\n    @classmethod\n    def is_string_none_or_empty(cls, text: str) -&gt; bool:\n        \"\"\"Checks if a string is `None` or empty (after stripping whitespace).\n\n        Args:\n            text (str): The input string to check.\n\n        Returns:\n            bool: `True` if the string is `None` or empty, `False` otherwise.\n        \"\"\"\n        return text is None or (isinstance(text, str) and not text.strip())\n\n    @classmethod\n    def normalize_persian_text(\n        cls,\n        text: str,\n        *,\n        remove_vowels: bool = True,\n        normalize_punctuation: bool = True,\n        normalize_numbers: bool = True,\n        normalize_persian_chars: bool = True,\n        mask_urls: bool = False,\n        mask_emails: bool = False,\n        mask_phones: bool = False,\n        mask_currencies: bool = False,\n        mask_all_numbers: bool = False,\n        remove_emojis: bool = False,\n        url_mask: str | None = None,\n        email_mask: str | None = None,\n        phone_mask: str | None = None,\n        currency_mask: str | None = None,\n        number_mask: str | None = None,\n        clean_spacing: bool = True,\n        remove_punctuation: bool = False,\n        normalize_punctuation_spacing: bool = False,\n    ) -&gt; str:\n        \"\"\"Normalizes Persian text with configurable options.\n\n        Args:\n            text (str): The input text to normalize.\n            remove_vowels (bool): Whether to remove Arabic vowels. Defaults to `True`.\n            normalize_punctuation (bool): Whether to normalize punctuation marks. Defaults to `True`.\n            normalize_numbers (bool): Whether to normalize numbers to English format. Defaults to `True`.\n            normalize_persian_chars (bool): Whether to normalize Persian characters. Defaults to `True`.\n            mask_urls (bool): Whether to mask URLs. Defaults to `False`.\n            mask_emails (bool): Whether to mask email addresses. Defaults to `False`.\n            mask_phones (bool): Whether to mask phone numbers. Defaults to `False`.\n            mask_currencies (bool): Whether to mask currency symbols and amounts. Defaults to `False`.\n            mask_all_numbers (bool): Whether to mask all numbers. Defaults to `False`.\n            remove_emojis (bool): Whether to remove emojis. Defaults to `False`.\n            url_mask (str | None): The mask to replace URLs with. Defaults to `None`.\n            email_mask (str | None): The mask to replace email addresses with. Defaults to `None`.\n            phone_mask (str | None): The mask to replace phone numbers with. Defaults to `None`.\n            currency_mask (str | None): The mask to replace currency symbols and amounts with. Defaults to `None`.\n            number_mask (str | None): The mask to replace numbers with. Defaults to `None`.\n            clean_spacing (bool): Whether to clean up spacing issues. Defaults to `True`.\n            remove_punctuation (bool): Whether to remove punctuation marks. Defaults to `False`.\n            normalize_punctuation_spacing (bool): Whether to apply proper spacing around punctuation marks. Defaults to `False`.\n\n        Returns:\n            str: The normalized text.\n        \"\"\"\n        if not text:\n            return text\n\n        # Remove emojis if requested\n        if remove_emojis:\n            text = cls.remove_emoji(text)\n\n        # Apply normalizations\n        if remove_vowels:\n            text = cls.remove_arabic_vowels(text)\n        if normalize_persian_chars:\n            text = cls.normalize_persian_chars(text)\n        if normalize_punctuation:\n            text = cls.normalize_punctuation(text)\n        if remove_punctuation:\n            text = cls.remove_punctuation_marks(text)\n        if normalize_numbers:\n            text = cls.normalize_numbers(text)\n\n        # Apply masking\n        if mask_urls:\n            text = cls.mask_urls(text, mask=url_mask)\n        if mask_emails:\n            text = cls.mask_emails(text, mask=email_mask)\n        if mask_phones:\n            text = cls.mask_phones(text, mask=phone_mask)\n        if mask_currencies:\n            text = cls.replace_currencies_with_mask(text, mask=currency_mask)\n        if mask_all_numbers:\n            text = cls.replace_numbers_with_mask(text, mask=number_mask)\n\n        if clean_spacing:\n            text = cls.clean_spacing(text)\n        if normalize_punctuation_spacing:\n            text = cls.normalize_punctuation_spacing(text)\n\n        return text.strip()\n\n    @classmethod\n    def snake_to_camel_case(cls, text: str) -&gt; str:\n        \"\"\"Converts snake_case to camelCase.\n\n        Args:\n            text (str): The input text in snake_case format.\n\n        Returns:\n            str: The text converted to camelCase format.\n        \"\"\"\n        if cls.is_string_none_or_empty(text):\n            return text\n\n        components = text.split(\"_\")\n        # First component remains lowercase, the rest get capitalized\n        return components[0] + \"\".join(x.title() for x in components[1:])\n\n    @classmethod\n    def camel_to_snake_case(cls, text: str) -&gt; str:\n        \"\"\"Converts camelCase to snake_case.\n\n        Args:\n            text (str): The input text in camelCase format.\n\n        Returns:\n            str: The text converted to snake_case format.\n        \"\"\"\n        if cls.is_string_none_or_empty(text):\n            return text\n\n        # Add underscore before each capital letter and convert to lowercase\n        s1 = re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", text)\n        return re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", s1).lower()\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.remove_arabic_vowels","title":"<code>archipy.helpers.utils.string_utils.StringUtils.remove_arabic_vowels(text)</code>  <code>classmethod</code>","text":"<p>Removes Arabic vowels (tashkeel) from the text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing Arabic vowels.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with Arabic vowels removed.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef remove_arabic_vowels(cls, text: str) -&gt; str:\n    \"\"\"Removes Arabic vowels (tashkeel) from the text.\n\n    Args:\n        text (str): The input text containing Arabic vowels.\n\n    Returns:\n        str: The text with Arabic vowels removed.\n    \"\"\"\n    return text.translate(cls.arabic_vowel_translate_table)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.normalize_persian_chars","title":"<code>archipy.helpers.utils.string_utils.StringUtils.normalize_persian_chars(text)</code>  <code>classmethod</code>","text":"<p>Normalizes Persian characters to their standard forms.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing Persian characters.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with Persian characters normalized.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef normalize_persian_chars(cls, text: str) -&gt; str:\n    \"\"\"Normalizes Persian characters to their standard forms.\n\n    Args:\n        text (str): The input text containing Persian characters.\n\n    Returns:\n        str: The text with Persian characters normalized.\n    \"\"\"\n    text = text.translate(cls.alphabet_akoolad_alef_translate_table)\n    text = text.translate(cls.alphabet_alef_translate_table)\n    text = text.translate(cls.alphabet_be_translate_table)\n    text = text.translate(cls.alphabet_pe_translate_table)\n    text = text.translate(cls.alphabet_te_translate_table)\n    text = text.translate(cls.alphabet_se_translate_table)\n    text = text.translate(cls.alphabet_jim_translate_table)\n    text = text.translate(cls.alphabet_che_translate_table)\n    text = text.translate(cls.alphabet_he_translate_table)\n    text = text.translate(cls.alphabet_khe_translate_table)\n    text = text.translate(cls.alphabet_dal_translate_table)\n    text = text.translate(cls.alphabet_zal_translate_table)\n    text = text.translate(cls.alphabet_re_translate_table)\n    text = text.translate(cls.alphabet_ze_translate_table)\n    text = text.translate(cls.alphabet_zhe_translate_table)\n    text = text.translate(cls.alphabet_sin_translate_table)\n    text = text.translate(cls.alphabet_shin_translate_table)\n    text = text.translate(cls.alphabet_sad_translate_table)\n    text = text.translate(cls.alphabet_zad_translate_table)\n    text = text.translate(cls.alphabet_ta_translate_table)\n    text = text.translate(cls.alphabet_za_translate_table)\n    text = text.translate(cls.alphabet_eyn_translate_table)\n    text = text.translate(cls.alphabet_gheyn_translate_table)\n    text = text.translate(cls.alphabet_fe_translate_table)\n    text = text.translate(cls.alphabet_ghaf_translate_table)\n    text = text.translate(cls.alphabet_kaf_translate_table)\n    text = text.translate(cls.alphabet_gaf_translate_table)\n    text = text.translate(cls.alphabet_lam_translate_table)\n    text = text.translate(cls.alphabet_mim_translate_table)\n    text = text.translate(cls.alphabet_nun_translate_table)\n    text = text.translate(cls.alphabet_vav_translate_table)\n    text = text.translate(cls.alphabet_ha_translate_table)\n    return text.translate(cls.alphabet_ye_translate_table)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.normalize_punctuation","title":"<code>archipy.helpers.utils.string_utils.StringUtils.normalize_punctuation(text)</code>  <code>classmethod</code>","text":"<p>Normalizes punctuation marks in the text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing punctuation marks.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with punctuation marks normalized.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef normalize_punctuation(cls, text: str) -&gt; str:\n    \"\"\"Normalizes punctuation marks in the text.\n\n    Args:\n        text (str): The input text containing punctuation marks.\n\n    Returns:\n        str: The text with punctuation marks normalized.\n    \"\"\"\n    text = text.translate(cls.punctuation_translate_table1)\n    text = text.translate(cls.punctuation_translate_table2)\n    text = text.translate(cls.punctuation_translate_table3)\n    text = text.translate(cls.punctuation_translate_table4)\n    text = text.translate(cls.punctuation_translate_table5)\n    text = text.translate(cls.punctuation_translate_table6)\n    text = text.translate(cls.punctuation_translate_table7)\n    text = text.translate(cls.punctuation_translate_table8)\n    text = text.translate(cls.punctuation_translate_table9)\n    text = text.translate(cls.punctuation_translate_table10)\n    text = text.translate(cls.punctuation_translate_table11)\n    text = text.translate(cls.punctuation_translate_table12)\n    return text.translate(cls.punctuation_translate_table13)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.normalize_numbers","title":"<code>archipy.helpers.utils.string_utils.StringUtils.normalize_numbers(text)</code>  <code>classmethod</code>","text":"<p>Normalizes numbers in the text to English format.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing numbers.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with numbers normalized to English format.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef normalize_numbers(cls, text: str) -&gt; str:\n    \"\"\"Normalizes numbers in the text to English format.\n\n    Args:\n        text (str): The input text containing numbers.\n\n    Returns:\n        str: The text with numbers normalized to English format.\n    \"\"\"\n    text = text.translate(cls.number_zero_translate_table)\n    text = text.translate(cls.number_one_translate_table)\n    text = text.translate(cls.number_two_translate_table)\n    text = text.translate(cls.number_three_translate_table)\n    text = text.translate(cls.number_four_translate_table)\n    text = text.translate(cls.number_five_translate_table)\n    text = text.translate(cls.number_six_translate_table)\n    text = text.translate(cls.number_seven_translate_table)\n    text = text.translate(cls.number_eight_translate_table)\n    return text.translate(cls.number_nine_translate_table)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.clean_spacing","title":"<code>archipy.helpers.utils.string_utils.StringUtils.clean_spacing(text)</code>  <code>classmethod</code>","text":"<p>Cleans up spacing issues in the text, such as non-breaking spaces and zero-width non-joiners.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text with spacing issues.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with spacing cleaned up.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef clean_spacing(cls, text: str) -&gt; str:\n    \"\"\"Cleans up spacing issues in the text, such as non-breaking spaces and zero-width non-joiners.\n\n    Args:\n        text (str): The input text with spacing issues.\n\n    Returns:\n        str: The text with spacing cleaned up.\n    \"\"\"\n    text = text.replace(\"\\u200c\", \" \")  # ZWNJ\n    text = text.replace(\"\\xa0\", \" \")  # NBSP\n\n    for pattern, repl in cls.character_refinement_patterns:\n        text = pattern.sub(repl, text)\n\n    return text\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.normalize_punctuation_spacing","title":"<code>archipy.helpers.utils.string_utils.StringUtils.normalize_punctuation_spacing(text)</code>  <code>classmethod</code>","text":"<p>Applies proper spacing around punctuation marks.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text with punctuation spacing issues.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with proper spacing around punctuation marks.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef normalize_punctuation_spacing(cls, text: str) -&gt; str:\n    \"\"\"Applies proper spacing around punctuation marks.\n\n    Args:\n        text (str): The input text with punctuation spacing issues.\n\n    Returns:\n        str: The text with proper spacing around punctuation marks.\n    \"\"\"\n    for pattern, repl in cls.punctuation_spacing_patterns:\n        text = pattern.sub(repl, text)\n    return text\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.remove_punctuation_marks","title":"<code>archipy.helpers.utils.string_utils.StringUtils.remove_punctuation_marks(text)</code>  <code>classmethod</code>","text":"<p>Removes punctuation marks from the text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing punctuation marks.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with punctuation marks removed.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef remove_punctuation_marks(cls, text: str) -&gt; str:\n    \"\"\"Removes punctuation marks from the text.\n\n    Args:\n        text (str): The input text containing punctuation marks.\n\n    Returns:\n        str: The text with punctuation marks removed.\n    \"\"\"\n    return text.translate(cls.punctuation_persian_marks_to_space_translate_table)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.mask_urls","title":"<code>archipy.helpers.utils.string_utils.StringUtils.mask_urls(text, mask=None)</code>  <code>classmethod</code>","text":"<p>Masks URLs in the text with a specified mask.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing URLs.</p> required <code>mask</code> <code>str | None</code> <p>The mask to replace URLs with. Defaults to \"MASK_URL\".</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with URLs masked.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef mask_urls(cls, text: str, mask: str | None = None) -&gt; str:\n    \"\"\"Masks URLs in the text with a specified mask.\n\n    Args:\n        text (str): The input text containing URLs.\n        mask (str | None): The mask to replace URLs with. Defaults to \"MASK_URL\".\n\n    Returns:\n        str: The text with URLs masked.\n    \"\"\"\n    mask = mask or \"MASK_URL\"\n    return re_compile(r\"https?://\\S+|www\\.\\S+\").sub(f\" {mask} \", text)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.mask_emails","title":"<code>archipy.helpers.utils.string_utils.StringUtils.mask_emails(text, mask=None)</code>  <code>classmethod</code>","text":"<p>Masks email addresses in the text with a specified mask.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing email addresses.</p> required <code>mask</code> <code>str | None</code> <p>The mask to replace emails with. Defaults to \"MASK_EMAIL\".</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with email addresses masked.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef mask_emails(cls, text: str, mask: str | None = None) -&gt; str:\n    \"\"\"Masks email addresses in the text with a specified mask.\n\n    Args:\n        text (str): The input text containing email addresses.\n        mask (str | None): The mask to replace emails with. Defaults to \"MASK_EMAIL\".\n\n    Returns:\n        str: The text with email addresses masked.\n    \"\"\"\n    mask = mask or \"MASK_EMAIL\"\n    return re_compile(r\"\\S+@\\S+\\.\\S+\").sub(f\" {mask} \", text)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.mask_phones","title":"<code>archipy.helpers.utils.string_utils.StringUtils.mask_phones(text, mask=None)</code>  <code>classmethod</code>","text":"<p>Masks phone numbers in the text with a specified mask.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing phone numbers.</p> required <code>mask</code> <code>str | None</code> <p>The mask to replace phone numbers with. Defaults to \"MASK_PHONE\".</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with phone numbers masked.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef mask_phones(cls, text: str, mask: str | None = None) -&gt; str:\n    \"\"\"Masks phone numbers in the text with a specified mask.\n\n    Args:\n        text (str): The input text containing phone numbers.\n        mask (str | None): The mask to replace phone numbers with. Defaults to \"MASK_PHONE\".\n\n    Returns:\n        str: The text with phone numbers masked.\n    \"\"\"\n    mask = mask or \"MASK_PHONE\"\n    return re_compile(r\"(?:\\+98|0)?(?:\\d{3}\\s*?\\d{3}\\s*?\\d{4})\").sub(f\" {mask} \", text)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.convert_english_number_to_persian","title":"<code>archipy.helpers.utils.string_utils.StringUtils.convert_english_number_to_persian(text)</code>  <code>classmethod</code>","text":"<p>Converts English numbers to Persian numbers in the text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing English numbers.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with English numbers converted to Persian numbers.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef convert_english_number_to_persian(cls, text: str) -&gt; str:\n    \"\"\"Converts English numbers to Persian numbers in the text.\n\n    Args:\n        text (str): The input text containing English numbers.\n\n    Returns:\n        str: The text with English numbers converted to Persian numbers.\n    \"\"\"\n    table = {\n        48: 1776,  # 0\n        49: 1777,  # 1\n        50: 1778,  # 2\n        51: 1779,  # 3\n        52: 1780,  # 4\n        53: 1781,  # 5\n        54: 1782,  # 6\n        55: 1783,  # 7\n        56: 1784,  # 8\n        57: 1785,  # 9\n        44: 1548,  # ,\n    }\n    return text.translate(table)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.convert_numbers_to_english","title":"<code>archipy.helpers.utils.string_utils.StringUtils.convert_numbers_to_english(text)</code>  <code>classmethod</code>","text":"<p>Converts Persian/Arabic numbers to English numbers in the text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing Persian/Arabic numbers.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with Persian/Arabic numbers converted to English numbers.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef convert_numbers_to_english(cls, text: str) -&gt; str:\n    \"\"\"Converts Persian/Arabic numbers to English numbers in the text.\n\n    Args:\n        text (str): The input text containing Persian/Arabic numbers.\n\n    Returns:\n        str: The text with Persian/Arabic numbers converted to English numbers.\n    \"\"\"\n    table = {\n        1776: 48,  # 0\n        1777: 49,  # 1\n        1778: 50,  # 2\n        1779: 51,  # 3\n        1780: 52,  # 4\n        1781: 53,  # 5\n        1782: 54,  # 6\n        1783: 55,  # 7\n        1784: 56,  # 8\n        1785: 57,  # 9\n        1632: 48,  # 0\n        1633: 49,  # 1\n        1634: 50,  # 2\n        1635: 51,  # 3\n        1636: 52,  # 4\n        1637: 53,  # 5\n        1638: 54,  # 6\n        1639: 55,  # 7\n        1640: 56,  # 8\n        1641: 57,  # 9\n    }\n    return text.translate(table)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.convert_add_3digit_delimiter","title":"<code>archipy.helpers.utils.string_utils.StringUtils.convert_add_3digit_delimiter(value)</code>  <code>classmethod</code>","text":"<p>Adds thousand separators to numbers.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The number to format.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The formatted number with thousand separators.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef convert_add_3digit_delimiter(cls, value: int) -&gt; str:\n    \"\"\"Adds thousand separators to numbers.\n\n    Args:\n        value (int): The number to format.\n\n    Returns:\n        str: The formatted number with thousand separators.\n    \"\"\"\n    return f\"{value:,}\" if isinstance(value, int) else value\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.remove_emoji","title":"<code>archipy.helpers.utils.string_utils.StringUtils.remove_emoji(text)</code>  <code>classmethod</code>","text":"<p>Removes emoji characters from the text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing emojis.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with emojis removed.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef remove_emoji(cls, text: str) -&gt; str:\n    \"\"\"Removes emoji characters from the text.\n\n    Args:\n        text (str): The input text containing emojis.\n\n    Returns:\n        str: The text with emojis removed.\n    \"\"\"\n    emoji_pattern = re.compile(\n        r\"[\"\n        r\"\\U0001F600-\\U0001F64F\"  # emoticons\n        r\"\\U0001F300-\\U0001F5FF\"  # symbols &amp; pictographs\n        r\"\\U0001F680-\\U0001F6FF\"  # transport &amp; map symbols\n        r\"\\U0001F1E0-\\U0001F1FF\"  # flags\n        r\"\\U0001F900-\\U0001F9FF\"  # supplemental symbols and pictographs\n        r\"\\U0001FA00-\\U0001FA6F\"  # symbols and pictographs extended-A\n        r\"\\U00002600-\\U000026FF\"  # miscellaneous symbols (some are emojis)\n        r\"\\U00002700-\\U000027BF\"  # dingbats (some are emojis)\n        r\"\\U00002190-\\U000021FF\"  # arrows (some are emojis)\n        r\"]+\",\n        re.UNICODE,\n    )\n    return emoji_pattern.sub(r\"\", text)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.replace_currencies_with_mask","title":"<code>archipy.helpers.utils.string_utils.StringUtils.replace_currencies_with_mask(text, mask=None)</code>  <code>classmethod</code>","text":"<p>Masks currency symbols and amounts in the text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing currency symbols and amounts.</p> required <code>mask</code> <code>str | None</code> <p>The mask to replace currencies with. Defaults to \"MASK_CURRENCIES\".</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with currency symbols and amounts masked.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef replace_currencies_with_mask(cls, text: str, mask: str | None = None) -&gt; str:\n    \"\"\"Masks currency symbols and amounts in the text.\n\n    Args:\n        text (str): The input text containing currency symbols and amounts.\n        mask (str | None): The mask to replace currencies with. Defaults to \"MASK_CURRENCIES\".\n\n    Returns:\n        str: The text with currency symbols and amounts masked.\n    \"\"\"\n    mask = mask or \"MASK_CURRENCIES\"\n    currency_pattern = re_compile(r\"(\\\\|z\u0142|\u00a3|\\$|\u20a1|\u20a6|\u00a5|\u20a9|\u20aa|\u20ab|\u20ac|\u20b1|\u20b2|\u20b4|\u20b9|\ufdfc)+\")\n    return currency_pattern.sub(f\" {mask} \", text)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.replace_numbers_with_mask","title":"<code>archipy.helpers.utils.string_utils.StringUtils.replace_numbers_with_mask(text, mask=None)</code>  <code>classmethod</code>","text":"<p>Masks numbers in the text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing numbers.</p> required <code>mask</code> <code>str | None</code> <p>The mask to replace numbers with. Defaults to \"MASK_NUMBERS\".</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with numbers masked.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef replace_numbers_with_mask(cls, text: str, mask: str | None = None) -&gt; str:\n    \"\"\"Masks numbers in the text.\n\n    Args:\n        text (str): The input text containing numbers.\n        mask (str | None): The mask to replace numbers with. Defaults to \"MASK_NUMBERS\".\n\n    Returns:\n        str: The text with numbers masked.\n    \"\"\"\n    mask = mask or \"MASK_NUMBERS\"\n    numbers = re.findall(\"[0-9]+\", text)\n    for number in sorted(numbers, key=len, reverse=True):\n        text = text.replace(number, f\" {mask} \")\n    return text\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.is_string_none_or_empty","title":"<code>archipy.helpers.utils.string_utils.StringUtils.is_string_none_or_empty(text)</code>  <code>classmethod</code>","text":"<p>Checks if a string is <code>None</code> or empty (after stripping whitespace).</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input string to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the string is <code>None</code> or empty, <code>False</code> otherwise.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef is_string_none_or_empty(cls, text: str) -&gt; bool:\n    \"\"\"Checks if a string is `None` or empty (after stripping whitespace).\n\n    Args:\n        text (str): The input string to check.\n\n    Returns:\n        bool: `True` if the string is `None` or empty, `False` otherwise.\n    \"\"\"\n    return text is None or (isinstance(text, str) and not text.strip())\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.normalize_persian_text","title":"<code>archipy.helpers.utils.string_utils.StringUtils.normalize_persian_text(text, *, remove_vowels=True, normalize_punctuation=True, normalize_numbers=True, normalize_persian_chars=True, mask_urls=False, mask_emails=False, mask_phones=False, mask_currencies=False, mask_all_numbers=False, remove_emojis=False, url_mask=None, email_mask=None, phone_mask=None, currency_mask=None, number_mask=None, clean_spacing=True, remove_punctuation=False, normalize_punctuation_spacing=False)</code>  <code>classmethod</code>","text":"<p>Normalizes Persian text with configurable options.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text to normalize.</p> required <code>remove_vowels</code> <code>bool</code> <p>Whether to remove Arabic vowels. Defaults to <code>True</code>.</p> <code>True</code> <code>normalize_punctuation</code> <code>bool</code> <p>Whether to normalize punctuation marks. Defaults to <code>True</code>.</p> <code>True</code> <code>normalize_numbers</code> <code>bool</code> <p>Whether to normalize numbers to English format. Defaults to <code>True</code>.</p> <code>True</code> <code>normalize_persian_chars</code> <code>bool</code> <p>Whether to normalize Persian characters. Defaults to <code>True</code>.</p> <code>True</code> <code>mask_urls</code> <code>bool</code> <p>Whether to mask URLs. Defaults to <code>False</code>.</p> <code>False</code> <code>mask_emails</code> <code>bool</code> <p>Whether to mask email addresses. Defaults to <code>False</code>.</p> <code>False</code> <code>mask_phones</code> <code>bool</code> <p>Whether to mask phone numbers. Defaults to <code>False</code>.</p> <code>False</code> <code>mask_currencies</code> <code>bool</code> <p>Whether to mask currency symbols and amounts. Defaults to <code>False</code>.</p> <code>False</code> <code>mask_all_numbers</code> <code>bool</code> <p>Whether to mask all numbers. Defaults to <code>False</code>.</p> <code>False</code> <code>remove_emojis</code> <code>bool</code> <p>Whether to remove emojis. Defaults to <code>False</code>.</p> <code>False</code> <code>url_mask</code> <code>str | None</code> <p>The mask to replace URLs with. Defaults to <code>None</code>.</p> <code>None</code> <code>email_mask</code> <code>str | None</code> <p>The mask to replace email addresses with. Defaults to <code>None</code>.</p> <code>None</code> <code>phone_mask</code> <code>str | None</code> <p>The mask to replace phone numbers with. Defaults to <code>None</code>.</p> <code>None</code> <code>currency_mask</code> <code>str | None</code> <p>The mask to replace currency symbols and amounts with. Defaults to <code>None</code>.</p> <code>None</code> <code>number_mask</code> <code>str | None</code> <p>The mask to replace numbers with. Defaults to <code>None</code>.</p> <code>None</code> <code>clean_spacing</code> <code>bool</code> <p>Whether to clean up spacing issues. Defaults to <code>True</code>.</p> <code>True</code> <code>remove_punctuation</code> <code>bool</code> <p>Whether to remove punctuation marks. Defaults to <code>False</code>.</p> <code>False</code> <code>normalize_punctuation_spacing</code> <code>bool</code> <p>Whether to apply proper spacing around punctuation marks. Defaults to <code>False</code>.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The normalized text.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef normalize_persian_text(\n    cls,\n    text: str,\n    *,\n    remove_vowels: bool = True,\n    normalize_punctuation: bool = True,\n    normalize_numbers: bool = True,\n    normalize_persian_chars: bool = True,\n    mask_urls: bool = False,\n    mask_emails: bool = False,\n    mask_phones: bool = False,\n    mask_currencies: bool = False,\n    mask_all_numbers: bool = False,\n    remove_emojis: bool = False,\n    url_mask: str | None = None,\n    email_mask: str | None = None,\n    phone_mask: str | None = None,\n    currency_mask: str | None = None,\n    number_mask: str | None = None,\n    clean_spacing: bool = True,\n    remove_punctuation: bool = False,\n    normalize_punctuation_spacing: bool = False,\n) -&gt; str:\n    \"\"\"Normalizes Persian text with configurable options.\n\n    Args:\n        text (str): The input text to normalize.\n        remove_vowels (bool): Whether to remove Arabic vowels. Defaults to `True`.\n        normalize_punctuation (bool): Whether to normalize punctuation marks. Defaults to `True`.\n        normalize_numbers (bool): Whether to normalize numbers to English format. Defaults to `True`.\n        normalize_persian_chars (bool): Whether to normalize Persian characters. Defaults to `True`.\n        mask_urls (bool): Whether to mask URLs. Defaults to `False`.\n        mask_emails (bool): Whether to mask email addresses. Defaults to `False`.\n        mask_phones (bool): Whether to mask phone numbers. Defaults to `False`.\n        mask_currencies (bool): Whether to mask currency symbols and amounts. Defaults to `False`.\n        mask_all_numbers (bool): Whether to mask all numbers. Defaults to `False`.\n        remove_emojis (bool): Whether to remove emojis. Defaults to `False`.\n        url_mask (str | None): The mask to replace URLs with. Defaults to `None`.\n        email_mask (str | None): The mask to replace email addresses with. Defaults to `None`.\n        phone_mask (str | None): The mask to replace phone numbers with. Defaults to `None`.\n        currency_mask (str | None): The mask to replace currency symbols and amounts with. Defaults to `None`.\n        number_mask (str | None): The mask to replace numbers with. Defaults to `None`.\n        clean_spacing (bool): Whether to clean up spacing issues. Defaults to `True`.\n        remove_punctuation (bool): Whether to remove punctuation marks. Defaults to `False`.\n        normalize_punctuation_spacing (bool): Whether to apply proper spacing around punctuation marks. Defaults to `False`.\n\n    Returns:\n        str: The normalized text.\n    \"\"\"\n    if not text:\n        return text\n\n    # Remove emojis if requested\n    if remove_emojis:\n        text = cls.remove_emoji(text)\n\n    # Apply normalizations\n    if remove_vowels:\n        text = cls.remove_arabic_vowels(text)\n    if normalize_persian_chars:\n        text = cls.normalize_persian_chars(text)\n    if normalize_punctuation:\n        text = cls.normalize_punctuation(text)\n    if remove_punctuation:\n        text = cls.remove_punctuation_marks(text)\n    if normalize_numbers:\n        text = cls.normalize_numbers(text)\n\n    # Apply masking\n    if mask_urls:\n        text = cls.mask_urls(text, mask=url_mask)\n    if mask_emails:\n        text = cls.mask_emails(text, mask=email_mask)\n    if mask_phones:\n        text = cls.mask_phones(text, mask=phone_mask)\n    if mask_currencies:\n        text = cls.replace_currencies_with_mask(text, mask=currency_mask)\n    if mask_all_numbers:\n        text = cls.replace_numbers_with_mask(text, mask=number_mask)\n\n    if clean_spacing:\n        text = cls.clean_spacing(text)\n    if normalize_punctuation_spacing:\n        text = cls.normalize_punctuation_spacing(text)\n\n    return text.strip()\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.snake_to_camel_case","title":"<code>archipy.helpers.utils.string_utils.StringUtils.snake_to_camel_case(text)</code>  <code>classmethod</code>","text":"<p>Converts snake_case to camelCase.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text in snake_case format.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text converted to camelCase format.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef snake_to_camel_case(cls, text: str) -&gt; str:\n    \"\"\"Converts snake_case to camelCase.\n\n    Args:\n        text (str): The input text in snake_case format.\n\n    Returns:\n        str: The text converted to camelCase format.\n    \"\"\"\n    if cls.is_string_none_or_empty(text):\n        return text\n\n    components = text.split(\"_\")\n    # First component remains lowercase, the rest get capitalized\n    return components[0] + \"\".join(x.title() for x in components[1:])\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.camel_to_snake_case","title":"<code>archipy.helpers.utils.string_utils.StringUtils.camel_to_snake_case(text)</code>  <code>classmethod</code>","text":"<p>Converts camelCase to snake_case.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text in camelCase format.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text converted to snake_case format.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef camel_to_snake_case(cls, text: str) -&gt; str:\n    \"\"\"Converts camelCase to snake_case.\n\n    Args:\n        text (str): The input text in camelCase format.\n\n    Returns:\n        str: The text converted to snake_case format.\n    \"\"\"\n    if cls.is_string_none_or_empty(text):\n        return text\n\n    # Add underscore before each capital letter and convert to lowercase\n    s1 = re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", text)\n    return re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", s1).lower()\n</code></pre>"},{"location":"api_reference/utils/#totp_utils","title":"totp_utils","text":"<p>Utilities for TOTP (Time-based One-Time Password) operations.</p> <pre><code>from archipy.helpers.utils.totp_utils import TOTPUtils\n\n# Generate TOTP\ntotp_code = TOTPUtils.generate_totp(secret_key=\"your-secret\")\n\n# Verify TOTP\nis_valid = TOTPUtils.verify_totp(totp_code, secret_key=\"your-secret\")\n\n# Generate secret key\nsecret_key = TOTPUtils.generate_secret_key()\n\n# Get TOTP URI for QR code\ntotp_uri = TOTPUtils.get_totp_uri(\n    secret_key=secret_key,\n    issuer=\"MyApp\",\n    account_name=\"user@example.com\"\n)\n</code></pre> <p>Utility module for TOTP (Time-based One-Time Password) operations.</p> <p>This module provides functionality for generating and verifying TOTP codes that are commonly used for multi-factor authentication.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/utils/#archipy.helpers.utils.totp_utils.TOTPUtils","title":"<code>archipy.helpers.utils.totp_utils.TOTPUtils</code>","text":"<p>Utility class for TOTP (Time-based One-Time Password) operations.</p> <p>This class provides methods for generating and verifying TOTP codes, as well as generating secure secret keys for TOTP initialization.</p> <p>Uses the following configuration parameters from AuthConfig: - TOTP_SECRET_KEY: Master secret key for generating TOTP secrets - TOTP_HASH_ALGORITHM: Hash algorithm used for TOTP generation (default: SHA1) - TOTP_LENGTH: Number of digits in generated TOTP codes - TOTP_TIME_STEP: Time step in seconds between TOTP code changes - TOTP_EXPIRES_IN: TOTP validity period in seconds - TOTP_VERIFICATION_WINDOW: Number of time steps to check before/after - SALT_LENGTH: Length of random bytes for secure key generation</p> Source code in <code>archipy/helpers/utils/totp_utils.py</code> <pre><code>class TOTPUtils:\n    \"\"\"Utility class for TOTP (Time-based One-Time Password) operations.\n\n    This class provides methods for generating and verifying TOTP codes, as well as generating\n    secure secret keys for TOTP initialization.\n\n    Uses the following configuration parameters from AuthConfig:\n    - TOTP_SECRET_KEY: Master secret key for generating TOTP secrets\n    - TOTP_HASH_ALGORITHM: Hash algorithm used for TOTP generation (default: SHA1)\n    - TOTP_LENGTH: Number of digits in generated TOTP codes\n    - TOTP_TIME_STEP: Time step in seconds between TOTP code changes\n    - TOTP_EXPIRES_IN: TOTP validity period in seconds\n    - TOTP_VERIFICATION_WINDOW: Number of time steps to check before/after\n    - SALT_LENGTH: Length of random bytes for secure key generation\n    \"\"\"\n\n    @classmethod\n    def generate_totp(cls, secret: str | UUID, auth_config: AuthConfig | None = None) -&gt; tuple[str, datetime]:\n        \"\"\"Generates a TOTP code using the configured hash algorithm.\n\n        Args:\n            secret: The secret key used to generate the TOTP code.\n            auth_config: Optional auth configuration override. If not provided, uses the global config.\n\n        Returns:\n            A tuple containing the generated TOTP code and its expiration time.\n\n        Raises:\n            InvalidArgumentError: If the secret is invalid or empty.\n        \"\"\"\n        if not secret:\n            raise InvalidArgumentError(\n                argument_name=\"secret\",\n            )\n\n        configs = auth_config or BaseConfig.global_config().AUTH\n\n        # Convert secret to bytes if it's UUID\n        if isinstance(secret, UUID):\n            secret = str(secret)\n\n        # Get current timestamp and calculate time step\n        current_time = DatetimeUtils.get_epoch_time_now()\n        time_step_counter = int(current_time / configs.TOTP_TIME_STEP)\n\n        # Generate HMAC hash\n        secret_bytes = str(secret).encode(\"utf-8\")\n        time_bytes = struct.pack(\"&gt;Q\", time_step_counter)\n\n        # Use the dedicated TOTP hash algorithm from config, with fallback to SHA1\n        hash_algo = getattr(configs, \"TOTP_HASH_ALGORITHM\", \"SHA1\")\n\n        hmac_obj = hmac.new(secret_bytes, time_bytes, hash_algo)\n        hmac_result = hmac_obj.digest()\n\n        # Get offset and truncate\n        offset = hmac_result[-1] &amp; 0xF\n        truncated_hash = (\n            ((hmac_result[offset] &amp; 0x7F) &lt;&lt; 24)\n            | ((hmac_result[offset + 1] &amp; 0xFF) &lt;&lt; 16)\n            | ((hmac_result[offset + 2] &amp; 0xFF) &lt;&lt; 8)\n            | (hmac_result[offset + 3] &amp; 0xFF)\n        )\n\n        # Generate TOTP code\n        totp_code = str(truncated_hash % (10**configs.TOTP_LENGTH)).zfill(configs.TOTP_LENGTH)\n\n        # Calculate expiration time\n        expires_in = DatetimeUtils.get_datetime_after_given_datetime_or_now(seconds=configs.TOTP_EXPIRES_IN)\n\n        return totp_code, expires_in\n\n    @classmethod\n    def verify_totp(cls, secret: str | UUID, totp_code: str, auth_config: AuthConfig | None = None) -&gt; bool:\n        \"\"\"Verifies a TOTP code against the provided secret.\n\n        Args:\n            secret: The secret key used to generate the TOTP code.\n            totp_code: The TOTP code to verify.\n            auth_config: Optional auth configuration override. If not provided, uses the global config.\n\n        Returns:\n            `True` if the TOTP code is valid, `False` otherwise.\n\n        Raises:\n            InvalidArgumentError: If the secret is invalid or empty.\n            InvalidTokenError: If the TOTP code format is invalid.\n        \"\"\"\n        if not secret:\n            raise InvalidArgumentError(\n                argument_name=\"secret\",\n            )\n\n        if not totp_code:\n            raise InvalidArgumentError(\n                argument_name=\"totp_code\",\n            )\n\n        if not totp_code.isdigit():\n            raise InvalidTokenError\n\n        configs = auth_config or BaseConfig.global_config().AUTH\n\n        current_time = DatetimeUtils.get_epoch_time_now()\n\n        # Use the dedicated TOTP hash algorithm from config, with fallback to SHA1\n        hash_algo = getattr(configs, \"TOTP_HASH_ALGORITHM\", \"SHA1\")\n\n        # Check codes within verification window\n        for i in range(-configs.TOTP_VERIFICATION_WINDOW, configs.TOTP_VERIFICATION_WINDOW + 1):\n            time_step_counter = int(current_time / configs.TOTP_TIME_STEP) + i\n\n            secret_bytes = str(secret).encode(\"utf-8\")\n            time_bytes = struct.pack(\"&gt;Q\", time_step_counter)\n            hmac_obj = hmac.new(secret_bytes, time_bytes, hash_algo)\n            hmac_result = hmac_obj.digest()\n\n            offset = hmac_result[-1] &amp; 0xF\n            truncated_hash = (\n                ((hmac_result[offset] &amp; 0x7F) &lt;&lt; 24)\n                | ((hmac_result[offset + 1] &amp; 0xFF) &lt;&lt; 16)\n                | ((hmac_result[offset + 2] &amp; 0xFF) &lt;&lt; 8)\n                | (hmac_result[offset + 3] &amp; 0xFF)\n            )\n\n            computed_totp = str(truncated_hash % (10 ** len(totp_code))).zfill(len(totp_code))\n\n            if hmac.compare_digest(totp_code, computed_totp):\n                return True\n\n        return False\n\n    @staticmethod\n    def generate_secret_key_for_totp(auth_config: AuthConfig | None = None) -&gt; str:\n        \"\"\"Generates a random secret key for TOTP initialization.\n\n        Args:\n            auth_config: Optional auth configuration override. If not provided, uses the global config.\n\n        Returns:\n            A base32-encoded secret key for TOTP initialization.\n\n        Raises:\n            InvalidArgumentError: If the TOTP_SECRET_KEY is not configured.\n            InternalError: If there is an error generating the secret key.\n        \"\"\"\n        try:\n            configs = auth_config or BaseConfig.global_config().AUTH\n\n            # Use secrets module instead of random for better security\n            random_bytes = secrets.token_bytes(configs.SALT_LENGTH)\n\n            # Check if TOTP secret key is configured\n            if not configs.TOTP_SECRET_KEY:\n                # Disable linter for this specific case since we're already in a try-except block\n                # and creating nested functions would reduce code readability\n                raise InvalidArgumentError(\n                    argument_name=\"TOTP_SECRET_KEY\",\n                )\n\n            master_key = configs.TOTP_SECRET_KEY.get_secret_value().encode(\"utf-8\")\n\n            # Use the dedicated TOTP hash algorithm from config, with fallback to SHA1\n            hash_algo = getattr(configs, \"TOTP_HASH_ALGORITHM\", \"SHA1\")\n\n            # Use HMAC with master key for additional security\n            hmac_obj = hmac.new(master_key, random_bytes, hash_algo)\n            return base64.b32encode(hmac_obj.digest()).decode(\"utf-8\")\n        except Exception as e:\n            # Convert any errors to our custom errors\n            raise InternalError() from e\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.totp_utils.TOTPUtils.generate_totp","title":"<code>archipy.helpers.utils.totp_utils.TOTPUtils.generate_totp(secret, auth_config=None)</code>  <code>classmethod</code>","text":"<p>Generates a TOTP code using the configured hash algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>secret</code> <code>str | UUID</code> <p>The secret key used to generate the TOTP code.</p> required <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, datetime]</code> <p>A tuple containing the generated TOTP code and its expiration time.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the secret is invalid or empty.</p> Source code in <code>archipy/helpers/utils/totp_utils.py</code> <pre><code>@classmethod\ndef generate_totp(cls, secret: str | UUID, auth_config: AuthConfig | None = None) -&gt; tuple[str, datetime]:\n    \"\"\"Generates a TOTP code using the configured hash algorithm.\n\n    Args:\n        secret: The secret key used to generate the TOTP code.\n        auth_config: Optional auth configuration override. If not provided, uses the global config.\n\n    Returns:\n        A tuple containing the generated TOTP code and its expiration time.\n\n    Raises:\n        InvalidArgumentError: If the secret is invalid or empty.\n    \"\"\"\n    if not secret:\n        raise InvalidArgumentError(\n            argument_name=\"secret\",\n        )\n\n    configs = auth_config or BaseConfig.global_config().AUTH\n\n    # Convert secret to bytes if it's UUID\n    if isinstance(secret, UUID):\n        secret = str(secret)\n\n    # Get current timestamp and calculate time step\n    current_time = DatetimeUtils.get_epoch_time_now()\n    time_step_counter = int(current_time / configs.TOTP_TIME_STEP)\n\n    # Generate HMAC hash\n    secret_bytes = str(secret).encode(\"utf-8\")\n    time_bytes = struct.pack(\"&gt;Q\", time_step_counter)\n\n    # Use the dedicated TOTP hash algorithm from config, with fallback to SHA1\n    hash_algo = getattr(configs, \"TOTP_HASH_ALGORITHM\", \"SHA1\")\n\n    hmac_obj = hmac.new(secret_bytes, time_bytes, hash_algo)\n    hmac_result = hmac_obj.digest()\n\n    # Get offset and truncate\n    offset = hmac_result[-1] &amp; 0xF\n    truncated_hash = (\n        ((hmac_result[offset] &amp; 0x7F) &lt;&lt; 24)\n        | ((hmac_result[offset + 1] &amp; 0xFF) &lt;&lt; 16)\n        | ((hmac_result[offset + 2] &amp; 0xFF) &lt;&lt; 8)\n        | (hmac_result[offset + 3] &amp; 0xFF)\n    )\n\n    # Generate TOTP code\n    totp_code = str(truncated_hash % (10**configs.TOTP_LENGTH)).zfill(configs.TOTP_LENGTH)\n\n    # Calculate expiration time\n    expires_in = DatetimeUtils.get_datetime_after_given_datetime_or_now(seconds=configs.TOTP_EXPIRES_IN)\n\n    return totp_code, expires_in\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.totp_utils.TOTPUtils.verify_totp","title":"<code>archipy.helpers.utils.totp_utils.TOTPUtils.verify_totp(secret, totp_code, auth_config=None)</code>  <code>classmethod</code>","text":"<p>Verifies a TOTP code against the provided secret.</p> <p>Parameters:</p> Name Type Description Default <code>secret</code> <code>str | UUID</code> <p>The secret key used to generate the TOTP code.</p> required <code>totp_code</code> <code>str</code> <p>The TOTP code to verify.</p> required <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the TOTP code is valid, <code>False</code> otherwise.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the secret is invalid or empty.</p> <code>InvalidTokenError</code> <p>If the TOTP code format is invalid.</p> Source code in <code>archipy/helpers/utils/totp_utils.py</code> <pre><code>@classmethod\ndef verify_totp(cls, secret: str | UUID, totp_code: str, auth_config: AuthConfig | None = None) -&gt; bool:\n    \"\"\"Verifies a TOTP code against the provided secret.\n\n    Args:\n        secret: The secret key used to generate the TOTP code.\n        totp_code: The TOTP code to verify.\n        auth_config: Optional auth configuration override. If not provided, uses the global config.\n\n    Returns:\n        `True` if the TOTP code is valid, `False` otherwise.\n\n    Raises:\n        InvalidArgumentError: If the secret is invalid or empty.\n        InvalidTokenError: If the TOTP code format is invalid.\n    \"\"\"\n    if not secret:\n        raise InvalidArgumentError(\n            argument_name=\"secret\",\n        )\n\n    if not totp_code:\n        raise InvalidArgumentError(\n            argument_name=\"totp_code\",\n        )\n\n    if not totp_code.isdigit():\n        raise InvalidTokenError\n\n    configs = auth_config or BaseConfig.global_config().AUTH\n\n    current_time = DatetimeUtils.get_epoch_time_now()\n\n    # Use the dedicated TOTP hash algorithm from config, with fallback to SHA1\n    hash_algo = getattr(configs, \"TOTP_HASH_ALGORITHM\", \"SHA1\")\n\n    # Check codes within verification window\n    for i in range(-configs.TOTP_VERIFICATION_WINDOW, configs.TOTP_VERIFICATION_WINDOW + 1):\n        time_step_counter = int(current_time / configs.TOTP_TIME_STEP) + i\n\n        secret_bytes = str(secret).encode(\"utf-8\")\n        time_bytes = struct.pack(\"&gt;Q\", time_step_counter)\n        hmac_obj = hmac.new(secret_bytes, time_bytes, hash_algo)\n        hmac_result = hmac_obj.digest()\n\n        offset = hmac_result[-1] &amp; 0xF\n        truncated_hash = (\n            ((hmac_result[offset] &amp; 0x7F) &lt;&lt; 24)\n            | ((hmac_result[offset + 1] &amp; 0xFF) &lt;&lt; 16)\n            | ((hmac_result[offset + 2] &amp; 0xFF) &lt;&lt; 8)\n            | (hmac_result[offset + 3] &amp; 0xFF)\n        )\n\n        computed_totp = str(truncated_hash % (10 ** len(totp_code))).zfill(len(totp_code))\n\n        if hmac.compare_digest(totp_code, computed_totp):\n            return True\n\n    return False\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.totp_utils.TOTPUtils.generate_secret_key_for_totp","title":"<code>archipy.helpers.utils.totp_utils.TOTPUtils.generate_secret_key_for_totp(auth_config=None)</code>  <code>staticmethod</code>","text":"<p>Generates a random secret key for TOTP initialization.</p> <p>Parameters:</p> Name Type Description Default <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A base32-encoded secret key for TOTP initialization.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the TOTP_SECRET_KEY is not configured.</p> <code>InternalError</code> <p>If there is an error generating the secret key.</p> Source code in <code>archipy/helpers/utils/totp_utils.py</code> <pre><code>@staticmethod\ndef generate_secret_key_for_totp(auth_config: AuthConfig | None = None) -&gt; str:\n    \"\"\"Generates a random secret key for TOTP initialization.\n\n    Args:\n        auth_config: Optional auth configuration override. If not provided, uses the global config.\n\n    Returns:\n        A base32-encoded secret key for TOTP initialization.\n\n    Raises:\n        InvalidArgumentError: If the TOTP_SECRET_KEY is not configured.\n        InternalError: If there is an error generating the secret key.\n    \"\"\"\n    try:\n        configs = auth_config or BaseConfig.global_config().AUTH\n\n        # Use secrets module instead of random for better security\n        random_bytes = secrets.token_bytes(configs.SALT_LENGTH)\n\n        # Check if TOTP secret key is configured\n        if not configs.TOTP_SECRET_KEY:\n            # Disable linter for this specific case since we're already in a try-except block\n            # and creating nested functions would reduce code readability\n            raise InvalidArgumentError(\n                argument_name=\"TOTP_SECRET_KEY\",\n            )\n\n        master_key = configs.TOTP_SECRET_KEY.get_secret_value().encode(\"utf-8\")\n\n        # Use the dedicated TOTP hash algorithm from config, with fallback to SHA1\n        hash_algo = getattr(configs, \"TOTP_HASH_ALGORITHM\", \"SHA1\")\n\n        # Use HMAC with master key for additional security\n        hmac_obj = hmac.new(master_key, random_bytes, hash_algo)\n        return base64.b32encode(hmac_obj.digest()).decode(\"utf-8\")\n    except Exception as e:\n        # Convert any errors to our custom errors\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/utils/#keycloak_utils","title":"keycloak_utils","text":"<p>Utilities for Keycloak integration.</p> <pre><code>from archipy.helpers.utils.keycloak_utils import KeycloakUtils\n\n# Get token\ntoken = KeycloakUtils.get_keycloak_token(\n    username=\"user\",\n    password=\"pass\",\n    client_id=\"my-client\"\n)\n\n# Validate token\nis_valid = KeycloakUtils.validate_keycloak_token(token)\n\n# Get user info\nuser_info = KeycloakUtils.get_keycloak_userinfo(token)\n\n# Check role\nhas_role = KeycloakUtils.has_keycloak_role(token, \"admin\")\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/utils/#archipy.helpers.utils.keycloak_utils.AuthContext","title":"<code>archipy.helpers.utils.keycloak_utils.AuthContext</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Authentication context passed to business logic.</p> Source code in <code>archipy/helpers/utils/keycloak_utils.py</code> <pre><code>class AuthContext(BaseModel):\n    \"\"\"Authentication context passed to business logic.\"\"\"\n\n    user_id: str\n    username: str\n    email: str\n    roles: list[str]\n    token: str\n    raw_user_info: dict[str, Any]\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.keycloak_utils.AuthContextManager","title":"<code>archipy.helpers.utils.keycloak_utils.AuthContextManager</code>","text":"<p>Manager for handling auth context in gRPC services.</p> Source code in <code>archipy/helpers/utils/keycloak_utils.py</code> <pre><code>class AuthContextManager:\n    \"\"\"Manager for handling auth context in gRPC services.\"\"\"\n\n    @staticmethod\n    def set_auth_context(auth_context: AuthContext) -&gt; None:\n        \"\"\"Set the auth context for the current request.\"\"\"\n        _auth_context_var.set(auth_context)\n\n    @staticmethod\n    def get_auth_context() -&gt; AuthContext | None:\n        \"\"\"Get the auth context for the current request.\"\"\"\n        return _auth_context_var.get()\n\n    @staticmethod\n    def clear_auth_context() -&gt; None:\n        \"\"\"Clear the auth context for the current request.\"\"\"\n        _auth_context_var.set(None)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.keycloak_utils.AuthContextManager.set_auth_context","title":"<code>archipy.helpers.utils.keycloak_utils.AuthContextManager.set_auth_context(auth_context)</code>  <code>staticmethod</code>","text":"<p>Set the auth context for the current request.</p> Source code in <code>archipy/helpers/utils/keycloak_utils.py</code> <pre><code>@staticmethod\ndef set_auth_context(auth_context: AuthContext) -&gt; None:\n    \"\"\"Set the auth context for the current request.\"\"\"\n    _auth_context_var.set(auth_context)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.keycloak_utils.AuthContextManager.get_auth_context","title":"<code>archipy.helpers.utils.keycloak_utils.AuthContextManager.get_auth_context()</code>  <code>staticmethod</code>","text":"<p>Get the auth context for the current request.</p> Source code in <code>archipy/helpers/utils/keycloak_utils.py</code> <pre><code>@staticmethod\ndef get_auth_context() -&gt; AuthContext | None:\n    \"\"\"Get the auth context for the current request.\"\"\"\n    return _auth_context_var.get()\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.keycloak_utils.AuthContextManager.clear_auth_context","title":"<code>archipy.helpers.utils.keycloak_utils.AuthContextManager.clear_auth_context()</code>  <code>staticmethod</code>","text":"<p>Clear the auth context for the current request.</p> Source code in <code>archipy/helpers/utils/keycloak_utils.py</code> <pre><code>@staticmethod\ndef clear_auth_context() -&gt; None:\n    \"\"\"Clear the auth context for the current request.\"\"\"\n    _auth_context_var.set(None)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.keycloak_utils.KeycloakUtils","title":"<code>archipy.helpers.utils.keycloak_utils.KeycloakUtils</code>","text":"<p>Utility class for Keycloak authentication and authorization in FastAPI applications.</p> Source code in <code>archipy/helpers/utils/keycloak_utils.py</code> <pre><code>class KeycloakUtils:\n    \"\"\"Utility class for Keycloak authentication and authorization in FastAPI applications.\"\"\"\n\n    @staticmethod\n    def _get_keycloak_adapter() -&gt; KeycloakAdapter:\n        return KeycloakAdapter()\n\n    @staticmethod\n    def _get_async_keycloak_adapter() -&gt; AsyncKeycloakAdapter:\n        return AsyncKeycloakAdapter()\n\n    @classmethod\n    # Synchronous decorator\n    def fastapi_auth(\n        cls,\n        resource_type_param: str | None = None,\n        resource_type: str | None = None,\n        required_roles: frozenset[str] | None = None,\n        all_roles_required: bool = False,\n        required_permissions: tuple[tuple[str, str], ...] | None = None,\n        admin_roles: frozenset[str] | None = None,\n        lang: LanguageType = DEFAULT_LANG,\n    ) -&gt; Callable:\n        \"\"\"FastAPI decorator for Keycloak authentication and resource-based authorization.\n\n        Args:\n            resource_type_param: The parameter name in the path (e.g., 'user_uuid', 'employee_uuid')\n            resource_type: The type of resource being accessed (e.g., 'users', 'employees')\n            required_roles: Set of role names that the user must have\n            all_roles_required: If True, user must have all specified roles; if False, any role is sufficient\n            required_permissions: List of (resource, scope) tuples to check\n            admin_roles: Set of roles that grant administrative access to all resources\n            lang: Language for error messages\n        Raises:\n            UnauthenticatedError: If no valid Authorization header is provided\n            InvalidTokenError: If token is invalid\n            TokenExpiredError: If token is expired\n            PermissionDeniedError: If user lacks required roles, permissions, or resource access\n            InvalidArgumentError: If resource_type_param is missing when resource_type is provided\n        \"\"\"\n\n        def dependency(\n            request: Request,\n            token: HTTPAuthorizationCredentials = Security(security),\n            keycloak: KeycloakAdapter = Depends(cls._get_keycloak_adapter),\n        ) -&gt; dict[str, Any]:\n            if token is None:\n                raise UnauthenticatedError(lang=lang)\n            token_str = token.credentials  # Extract the token string\n            # Validate token\n            if not keycloak.validate_token(token_str):\n                token_info = keycloak.introspect_token(token_str)\n                if not token_info or not token_info.get(\"active\", False):\n                    raise TokenExpiredError(lang=lang)\n\n            # Get user info from token\n            user_info = keycloak.get_userinfo(token_str)\n            if not user_info:\n                raise UnauthenticatedError(lang=lang)\n\n            token_info = keycloak.get_token_info(token_str)\n\n            # Resource-based authorization if resource type is provided\n            if resource_type and resource_type_param:\n                # Extract resource UUID from path parameters\n                resource_uuid = request.path_params.get(resource_type_param)\n                if not resource_uuid:\n                    raise InvalidArgumentError(argument_name=resource_type_param, lang=lang)\n\n                # Verify resource exists and user has access\n                user_uuid = user_info.get(\"sub\")\n\n                # Check if resource exists\n                resource_user = keycloak.get_user_by_id(resource_uuid)\n                if not resource_user:\n                    raise PermissionDeniedError(\n                        lang=lang,\n                        additional_data={\"resource_type\": resource_type, \"resource_id\": resource_uuid},\n                    )\n\n                # Authorization check: either owns the resource or has admin privileges\n                has_admin_privileges = admin_roles and keycloak.has_any_of_roles(token_str, admin_roles)\n                if user_uuid != resource_uuid and not has_admin_privileges:\n                    raise PermissionDeniedError(\n                        lang=lang,\n                        additional_data={\"resource_type\": resource_type, \"resource_id\": resource_uuid},\n                    )\n\n            # Check additional roles if specified\n            if required_roles:\n                if all_roles_required:\n                    if not keycloak.has_all_roles(token_str, required_roles):\n                        raise PermissionDeniedError(\n                            lang=lang,\n                            additional_data={\"required_roles\": required_roles},\n                        )\n                elif not keycloak.has_any_of_roles(token_str, required_roles):\n                    raise PermissionDeniedError(\n                        lang=lang,\n                        additional_data={\"required_roles\": required_roles},\n                    )\n\n            # Check permissions if specified\n            if required_permissions:\n                for resource, scope in required_permissions:\n                    if not keycloak.check_permissions(token_str, resource, scope):\n                        raise PermissionDeniedError(\n                            lang=lang,\n                            additional_data={\"required_permission\": f\"{resource}#{scope}\"},\n                        )\n\n            # Add user info to request state\n            request.state.user_info = user_info\n            request.state.token_info = token_info\n            return user_info\n\n        return dependency\n\n    @classmethod\n    def async_fastapi_auth(\n        cls,\n        resource_type_param: str | None = None,\n        resource_type: str | None = None,\n        required_roles: frozenset[str] | None = None,\n        all_roles_required: bool = False,\n        required_permissions: tuple[tuple[str, str], ...] | None = None,\n        admin_roles: frozenset[str] | None = None,\n        lang: LanguageType = DEFAULT_LANG,\n    ) -&gt; Callable:\n        \"\"\"FastAPI async decorator for Keycloak authentication and resource-based authorization.\n\n        Args:\n            resource_type_param: The parameter name in the path (e.g., 'user_uuid', 'employee_uuid')\n            resource_type: The type of resource being accessed (e.g., 'users', 'employees')\n            required_roles: Set of role names that the user must have\n            all_roles_required: If True, user must have all specified roles; if False, any role is sufficient\n            required_permissions: List of (resource, scope) tuples to check\n            admin_roles: Set of roles that grant administrative access to all resources\n            lang: Language for error messages\n        Raises:\n            UnauthenticatedError: If no valid Authorization header is provided\n            InvalidTokenError: If token is invalid\n            TokenExpiredError: If token is expired\n            PermissionDeniedError: If user lacks required roles, permissions, or resource access\n            InvalidArgumentError: If resource_type_param is missing when resource_type is provided\n        \"\"\"\n\n        async def dependency(\n            request: Request,\n            token: HTTPAuthorizationCredentials = Security(security),\n            keycloak: AsyncKeycloakAdapter = Depends(cls._get_async_keycloak_adapter),\n        ) -&gt; dict[str, Any]:\n            if token is None:\n                raise UnauthenticatedError(lang=lang)\n            token_str = token.credentials  # Extract the token string\n\n            # Validate token\n            if not await keycloak.validate_token(token_str):\n                # Handle token validation error\n                token_info = await keycloak.introspect_token(token_str)\n                if not token_info or not token_info.get(\"active\", False):\n                    raise TokenExpiredError(lang=lang)\n\n            # Get user info from token\n            user_info = await keycloak.get_userinfo(token_str)\n            if not user_info:\n                raise UnauthenticatedError(lang=lang)\n\n            token_info = await keycloak.get_token_info(token_str)\n\n            # Resource-based authorization if resource type is provided\n            if resource_type and resource_type_param:\n                # Extract resource UUID from path parameters\n                resource_uuid = request.path_params.get(resource_type_param)\n                if not resource_uuid:\n                    raise InvalidArgumentError(argument_name=resource_type_param, lang=lang)\n\n                # Verify resource exists and user has access\n                user_uuid = user_info.get(\"sub\")\n\n                # Check if resource exists\n                resource_user = await keycloak.get_user_by_id(resource_uuid)\n                if not resource_user:\n                    raise PermissionDeniedError(\n                        lang=lang,\n                        additional_data={\"resource_type\": resource_type, \"resource_id\": resource_uuid},\n                    )\n\n                # Authorization check: either owns the resource or has admin privileges\n                has_admin_privileges = admin_roles and await keycloak.has_any_of_roles(token_str, admin_roles)\n                if user_uuid != resource_uuid and not has_admin_privileges:\n                    raise PermissionDeniedError(\n                        lang=lang,\n                        additional_data={\"resource_type\": resource_type, \"resource_id\": resource_uuid},\n                    )\n\n            # Check additional roles if specified\n            if required_roles:\n                if all_roles_required:\n                    if not await keycloak.has_all_roles(token_str, required_roles):\n                        raise PermissionDeniedError(\n                            lang=lang,\n                            additional_data={\"required_roles\": required_roles},\n                        )\n                elif not await keycloak.has_any_of_roles(token_str, required_roles):\n                    raise PermissionDeniedError(\n                        lang=lang,\n                        additional_data={\"required_roles\": required_roles},\n                    )\n\n            # Check permissions if specified\n            if required_permissions:\n                for resource, scope in required_permissions:\n                    if not await keycloak.check_permissions(token_str, resource, scope):\n                        raise PermissionDeniedError(\n                            lang=lang,\n                            additional_data={\"required_permission\": f\"{resource}#{scope}\"},\n                        )\n\n            # Add user info to request state\n            request.state.user_info = user_info\n            request.state.token_info = token_info\n            if not user_info:\n                raise UnauthenticatedError(lang=lang)\n            return user_info\n\n        return dependency\n\n    @staticmethod\n    def _extract_token_from_metadata(context: ServicerContext) -&gt; str | None:\n        \"\"\"Extract Bearer token from gRPC metadata.\"\"\"\n        metadata = dict(context.invocation_metadata())\n\n        auth_keys = [\"authorization\", \"Authorization\", \"auth\", \"token\"]\n\n        for key in auth_keys:\n            if key in metadata:\n                auth_value = metadata[key]\n                # Handle both bytes and string values\n                if isinstance(auth_value, bytes):\n                    auth_value_str = auth_value.decode(\"utf-8\")\n                else:\n                    auth_value_str = str(auth_value)\n\n                if auth_value_str.startswith(\"Bearer \"):\n                    return auth_value_str[7:]\n                elif auth_value_str.startswith(\"bearer \"):\n                    return auth_value_str[7:]\n                else:\n                    return auth_value_str\n\n        return None\n\n    @classmethod\n    def grpc_auth(\n        cls,\n        required_roles: frozenset[str] | None = None,\n        all_roles_required: bool = False,\n        required_permissions: tuple[tuple[str, str], ...] | None = None,\n        resource_attribute_name: str | None = None,\n        admin_roles: frozenset[str] | None = None,\n        lang: LanguageType = DEFAULT_LANG,\n    ) -&gt; Callable[[Callable], Callable]:\n        \"\"\"Synchronous gRPC decorator for authentication and authorization.\n\n        This decorator handles:\n        1. Token validation\n        2. Role/permission checking\n        3. Passing auth context to business logic\n\n        Resource ownership is handled in the business logic layer.\n\n        Args:\n            required_roles: Set of roles, user must have at least one (or all if all_roles_required=True)\n            all_roles_required: If True, user must have all required_roles; if False, any one role is sufficient\n            required_permissions: Tuple of (resource, scope) pairs that must be satisfied\n            resource_attribute_name: Attribute name to extract resource UUID from context for ownership checking\n            admin_roles: Set of admin roles that bypass resource ownership checks\n            lang: Language for error messages\n\n        Returns:\n            Decorated function with authentication and authorization\n        \"\"\"\n\n        def decorator(func: Callable) -&gt; Callable:\n            @functools.wraps(func)\n            def wrapper(self: object, request: object, context: ServicerContext) -&gt; object:\n                try:\n                    # 1. Extract and validate token\n                    token_str = cls._extract_token_from_metadata(context)\n                    if not token_str:\n                        raise UnauthenticatedError(lang=lang)\n\n                    # 2. Get Keycloak adapter (synchronous)\n                    keycloak: KeycloakAdapter = cls._get_keycloak_adapter()\n\n                    # 3. Validate token\n                    if not keycloak.validate_token(token_str):\n                        token_info = keycloak.introspect_token(token_str)\n                        if not token_info or not token_info.get(\"active\", False):\n                            raise TokenExpiredError(lang=lang)\n\n                    # 4. Get user info from token\n                    user_info = keycloak.get_userinfo(token_str)\n                    if not user_info:\n                        raise UnauthenticatedError(lang=lang)\n\n                    # 5. Resource-based authorization if resource_attribute_name is provided\n                    if resource_attribute_name:\n                        # Extract resource UUID from context\n                        resource_uuid = getattr(request, resource_attribute_name)\n                        if not resource_uuid:\n                            raise InvalidArgumentError(argument_name=resource_attribute_name, lang=lang)\n\n                        # Verify resource exists and user has access\n                        user_uuid = user_info.get(\"sub\")\n\n                        # Check if resource exists\n                        resource_user = keycloak.get_user_by_id(resource_uuid)\n                        if not resource_user:\n                            raise PermissionDeniedError(\n                                lang=lang,\n                                additional_data={\"resource_id\": resource_uuid},\n                            )\n\n                        # Authorization check: either owns the resource or has admin privileges\n                        has_admin_privileges = admin_roles and keycloak.has_any_of_roles(token_str, admin_roles)\n                        if user_uuid != resource_uuid and not has_admin_privileges:\n                            raise PermissionDeniedError(lang=lang, additional_data={\"resource_id\": resource_uuid})\n\n                    # 6. Check roles if specified\n                    if required_roles:\n                        if all_roles_required:\n                            if not keycloak.has_all_roles(token_str, required_roles):\n                                raise PermissionDeniedError(\n                                    lang=lang,\n                                    additional_data={\n                                        \"required_roles\": list(required_roles),\n                                        \"check_type\": \"all_required\",\n                                    },\n                                )\n\n                        elif not keycloak.has_any_of_roles(token_str, required_roles):\n                            raise PermissionDeniedError(\n                                lang=lang,\n                                additional_data={\"required_roles\": list(required_roles), \"check_type\": \"any_required\"},\n                            )\n\n                    # 7. Check permissions if specified\n                    if required_permissions:\n                        for resource, scope in required_permissions:\n                            if not keycloak.check_permissions(token_str, resource, scope):\n                                raise PermissionDeniedError(\n                                    lang=lang,\n                                    additional_data={\n                                        \"required_permission\": f\"{resource}#{scope}\",\n                                        \"resource\": resource,\n                                        \"scope\": scope,\n                                    },\n                                )\n\n                    # 8. Create auth context for business logic\n                    auth_context = AuthContext(\n                        user_id=user_info.get(\"sub\"),\n                        username=user_info.get(\"preferred_username\", \"\"),\n                        email=user_info.get(\"email\", \"\"),\n                        roles=user_info.get(\"realm_access\", {}).get(\"roles\", []),\n                        token=token_str,\n                        raw_user_info=user_info,\n                    )\n\n                    # 9. Set auth context using contextvars\n                    AuthContextManager.set_auth_context(auth_context)\n\n                    # 10. Call the original method - business logic handles ownership\n                    return func(self, request, context)\n\n                except Exception as e:\n                    if isinstance(e, BaseError):\n                        e.abort_grpc_sync(context)\n                    raise InternalError(\n                        lang=lang,\n                        additional_data={\"original_error\": str(e), \"error_type\": type(e).__name__},\n                    ) from e\n\n                finally:\n                    # Clean up auth context\n                    AuthContextManager.clear_auth_context()\n\n            return wrapper\n\n        return decorator\n\n    @classmethod\n    def async_grpc_auth(\n        cls,\n        required_roles: frozenset[str] | None = None,\n        all_roles_required: bool = False,\n        required_permissions: tuple[tuple[str, str], ...] | None = None,\n        resource_attribute_name: str | None = None,\n        admin_roles: frozenset[str] | None = None,\n        lang: LanguageType = DEFAULT_LANG,\n    ) -&gt; Callable[[Callable], Callable]:\n        \"\"\"Simplified gRPC decorator for authentication and authorization.\n\n        This decorator handles:\n        1. Token validation\n        2. Role/permission checking\n        3. Passing auth context to business logic\n\n        Resource ownership is handled in the business logic layer.\n\n        Args:\n            required_roles: Set of roles, user must have at least one (or all if all_roles_required=True)\n            all_roles_required: If True, user must have all required_roles; if False, any one role is sufficient\n            required_permissions: Tuple of (resource, scope) pairs that must be satisfied\n            resource_attribute_name: Attribute name to extract resource UUID from context for ownership checking\n            admin_roles: Set of admin roles that bypass resource ownership checks\n            lang: Language for error messages\n\n        Returns:\n            Decorated function with authentication and authorization\n        \"\"\"\n\n        def decorator(func: Callable) -&gt; Callable:\n            @functools.wraps(func)\n            async def wrapper(self: object, request: object, context: AsyncServicerContext) -&gt; object:\n                try:\n                    # 1. Extract and validate token\n                    token_str = cls._extract_token_from_metadata(context)\n                    if not token_str:\n                        raise UnauthenticatedError(lang=lang)\n\n                    # 2. Get Keycloak adapter\n                    keycloak: AsyncKeycloakAdapter = cls._get_async_keycloak_adapter()\n\n                    # 3. Validate token\n                    if not await keycloak.validate_token(token_str):\n                        token_info = await keycloak.introspect_token(token_str)\n                        if not token_info or not token_info.get(\"active\", False):\n                            raise TokenExpiredError(lang=lang)\n\n                    # 4. Get user info from token\n                    user_info = await keycloak.get_userinfo(token_str)\n                    if not user_info:\n                        raise UnauthenticatedError(lang=lang)\n\n                    # 5. Resource-based authorization if resource_attribute_name is provided\n                    if resource_attribute_name:\n                        # Extract resource UUID from context\n                        resource_uuid = getattr(request, resource_attribute_name)\n                        if not resource_uuid:\n                            raise InvalidArgumentError(argument_name=resource_attribute_name, lang=lang)\n\n                        # Verify resource exists and user has access\n                        user_uuid = user_info.get(\"sub\")\n\n                        # Check if resource exists\n                        resource_user = await keycloak.get_user_by_id(resource_uuid)\n                        if not resource_user:\n                            raise PermissionDeniedError(\n                                lang=lang,\n                                additional_data={\"resource_id\": resource_uuid},\n                            )\n\n                        # Authorization check: either owns the resource or has admin privileges\n                        has_admin_privileges = admin_roles and await keycloak.has_any_of_roles(token_str, admin_roles)\n                        if user_uuid != resource_uuid and not has_admin_privileges:\n                            raise PermissionDeniedError(lang=lang, additional_data={\"resource_id\": resource_uuid})\n\n                    # 6. Check roles if specified\n                    if required_roles:\n                        if all_roles_required:\n                            if not await keycloak.has_all_roles(token_str, required_roles):\n                                raise PermissionDeniedError(\n                                    lang=lang,\n                                    additional_data={\n                                        \"required_roles\": list(required_roles),\n                                        \"check_type\": \"all_required\",\n                                    },\n                                )\n\n                        elif not await keycloak.has_any_of_roles(token_str, required_roles):\n                            raise PermissionDeniedError(\n                                lang=lang,\n                                additional_data={\"required_roles\": list(required_roles), \"check_type\": \"any_required\"},\n                            )\n\n                    # 7. Check permissions if specified\n                    if required_permissions:\n                        for resource, scope in required_permissions:\n                            if not await keycloak.check_permissions(token_str, resource, scope):\n                                raise PermissionDeniedError(\n                                    lang=lang,\n                                    additional_data={\n                                        \"required_permission\": f\"{resource}#{scope}\",\n                                        \"resource\": resource,\n                                        \"scope\": scope,\n                                    },\n                                )\n\n                    # 8. Create auth context for business logic\n                    auth_context = AuthContext(\n                        user_id=user_info.get(\"sub\"),\n                        username=user_info.get(\"preferred_username\", \"\"),\n                        email=user_info.get(\"email\", \"\"),\n                        roles=user_info.get(\"realm_access\", {}).get(\"roles\", []),\n                        token=token_str,\n                        raw_user_info=user_info,\n                    )\n\n                    # 9. Set auth context using contextvars\n                    AuthContextManager.set_auth_context(auth_context)\n\n                    # 10. Call the original method - business logic handles ownership\n                    return await func(self, request, context)\n\n                except Exception as e:\n                    if isinstance(e, BaseError):\n                        await e.abort_grpc_async(context)\n                        return None  # abort_grpc_async will terminate, but satisfy type checker\n                    await InternalError(\n                        lang=lang,\n                        additional_data={\"original_error\": str(e), \"error_type\": type(e).__name__},\n                    ).abort_grpc_async(context)\n                    return None  # abort_grpc_async will terminate, but satisfy type checker\n\n                finally:\n                    # Clean up auth context\n                    AuthContextManager.clear_auth_context()\n\n            return wrapper\n\n        return decorator\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.keycloak_utils.KeycloakUtils.fastapi_auth","title":"<code>archipy.helpers.utils.keycloak_utils.KeycloakUtils.fastapi_auth(resource_type_param=None, resource_type=None, required_roles=None, all_roles_required=False, required_permissions=None, admin_roles=None, lang=DEFAULT_LANG)</code>  <code>classmethod</code>","text":"<p>FastAPI decorator for Keycloak authentication and resource-based authorization.</p> <p>Parameters:</p> Name Type Description Default <code>resource_type_param</code> <code>str | None</code> <p>The parameter name in the path (e.g., 'user_uuid', 'employee_uuid')</p> <code>None</code> <code>resource_type</code> <code>str | None</code> <p>The type of resource being accessed (e.g., 'users', 'employees')</p> <code>None</code> <code>required_roles</code> <code>frozenset[str] | None</code> <p>Set of role names that the user must have</p> <code>None</code> <code>all_roles_required</code> <code>bool</code> <p>If True, user must have all specified roles; if False, any role is sufficient</p> <code>False</code> <code>required_permissions</code> <code>tuple[tuple[str, str], ...] | None</code> <p>List of (resource, scope) tuples to check</p> <code>None</code> <code>admin_roles</code> <code>frozenset[str] | None</code> <p>Set of roles that grant administrative access to all resources</p> <code>None</code> <code>lang</code> <code>LanguageType</code> <p>Language for error messages</p> <code>DEFAULT_LANG</code> <p>Raises:     UnauthenticatedError: If no valid Authorization header is provided     InvalidTokenError: If token is invalid     TokenExpiredError: If token is expired     PermissionDeniedError: If user lacks required roles, permissions, or resource access     InvalidArgumentError: If resource_type_param is missing when resource_type is provided</p> Source code in <code>archipy/helpers/utils/keycloak_utils.py</code> <pre><code>@classmethod\n# Synchronous decorator\ndef fastapi_auth(\n    cls,\n    resource_type_param: str | None = None,\n    resource_type: str | None = None,\n    required_roles: frozenset[str] | None = None,\n    all_roles_required: bool = False,\n    required_permissions: tuple[tuple[str, str], ...] | None = None,\n    admin_roles: frozenset[str] | None = None,\n    lang: LanguageType = DEFAULT_LANG,\n) -&gt; Callable:\n    \"\"\"FastAPI decorator for Keycloak authentication and resource-based authorization.\n\n    Args:\n        resource_type_param: The parameter name in the path (e.g., 'user_uuid', 'employee_uuid')\n        resource_type: The type of resource being accessed (e.g., 'users', 'employees')\n        required_roles: Set of role names that the user must have\n        all_roles_required: If True, user must have all specified roles; if False, any role is sufficient\n        required_permissions: List of (resource, scope) tuples to check\n        admin_roles: Set of roles that grant administrative access to all resources\n        lang: Language for error messages\n    Raises:\n        UnauthenticatedError: If no valid Authorization header is provided\n        InvalidTokenError: If token is invalid\n        TokenExpiredError: If token is expired\n        PermissionDeniedError: If user lacks required roles, permissions, or resource access\n        InvalidArgumentError: If resource_type_param is missing when resource_type is provided\n    \"\"\"\n\n    def dependency(\n        request: Request,\n        token: HTTPAuthorizationCredentials = Security(security),\n        keycloak: KeycloakAdapter = Depends(cls._get_keycloak_adapter),\n    ) -&gt; dict[str, Any]:\n        if token is None:\n            raise UnauthenticatedError(lang=lang)\n        token_str = token.credentials  # Extract the token string\n        # Validate token\n        if not keycloak.validate_token(token_str):\n            token_info = keycloak.introspect_token(token_str)\n            if not token_info or not token_info.get(\"active\", False):\n                raise TokenExpiredError(lang=lang)\n\n        # Get user info from token\n        user_info = keycloak.get_userinfo(token_str)\n        if not user_info:\n            raise UnauthenticatedError(lang=lang)\n\n        token_info = keycloak.get_token_info(token_str)\n\n        # Resource-based authorization if resource type is provided\n        if resource_type and resource_type_param:\n            # Extract resource UUID from path parameters\n            resource_uuid = request.path_params.get(resource_type_param)\n            if not resource_uuid:\n                raise InvalidArgumentError(argument_name=resource_type_param, lang=lang)\n\n            # Verify resource exists and user has access\n            user_uuid = user_info.get(\"sub\")\n\n            # Check if resource exists\n            resource_user = keycloak.get_user_by_id(resource_uuid)\n            if not resource_user:\n                raise PermissionDeniedError(\n                    lang=lang,\n                    additional_data={\"resource_type\": resource_type, \"resource_id\": resource_uuid},\n                )\n\n            # Authorization check: either owns the resource or has admin privileges\n            has_admin_privileges = admin_roles and keycloak.has_any_of_roles(token_str, admin_roles)\n            if user_uuid != resource_uuid and not has_admin_privileges:\n                raise PermissionDeniedError(\n                    lang=lang,\n                    additional_data={\"resource_type\": resource_type, \"resource_id\": resource_uuid},\n                )\n\n        # Check additional roles if specified\n        if required_roles:\n            if all_roles_required:\n                if not keycloak.has_all_roles(token_str, required_roles):\n                    raise PermissionDeniedError(\n                        lang=lang,\n                        additional_data={\"required_roles\": required_roles},\n                    )\n            elif not keycloak.has_any_of_roles(token_str, required_roles):\n                raise PermissionDeniedError(\n                    lang=lang,\n                    additional_data={\"required_roles\": required_roles},\n                )\n\n        # Check permissions if specified\n        if required_permissions:\n            for resource, scope in required_permissions:\n                if not keycloak.check_permissions(token_str, resource, scope):\n                    raise PermissionDeniedError(\n                        lang=lang,\n                        additional_data={\"required_permission\": f\"{resource}#{scope}\"},\n                    )\n\n        # Add user info to request state\n        request.state.user_info = user_info\n        request.state.token_info = token_info\n        return user_info\n\n    return dependency\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.keycloak_utils.KeycloakUtils.async_fastapi_auth","title":"<code>archipy.helpers.utils.keycloak_utils.KeycloakUtils.async_fastapi_auth(resource_type_param=None, resource_type=None, required_roles=None, all_roles_required=False, required_permissions=None, admin_roles=None, lang=DEFAULT_LANG)</code>  <code>classmethod</code>","text":"<p>FastAPI async decorator for Keycloak authentication and resource-based authorization.</p> <p>Parameters:</p> Name Type Description Default <code>resource_type_param</code> <code>str | None</code> <p>The parameter name in the path (e.g., 'user_uuid', 'employee_uuid')</p> <code>None</code> <code>resource_type</code> <code>str | None</code> <p>The type of resource being accessed (e.g., 'users', 'employees')</p> <code>None</code> <code>required_roles</code> <code>frozenset[str] | None</code> <p>Set of role names that the user must have</p> <code>None</code> <code>all_roles_required</code> <code>bool</code> <p>If True, user must have all specified roles; if False, any role is sufficient</p> <code>False</code> <code>required_permissions</code> <code>tuple[tuple[str, str], ...] | None</code> <p>List of (resource, scope) tuples to check</p> <code>None</code> <code>admin_roles</code> <code>frozenset[str] | None</code> <p>Set of roles that grant administrative access to all resources</p> <code>None</code> <code>lang</code> <code>LanguageType</code> <p>Language for error messages</p> <code>DEFAULT_LANG</code> <p>Raises:     UnauthenticatedError: If no valid Authorization header is provided     InvalidTokenError: If token is invalid     TokenExpiredError: If token is expired     PermissionDeniedError: If user lacks required roles, permissions, or resource access     InvalidArgumentError: If resource_type_param is missing when resource_type is provided</p> Source code in <code>archipy/helpers/utils/keycloak_utils.py</code> <pre><code>@classmethod\ndef async_fastapi_auth(\n    cls,\n    resource_type_param: str | None = None,\n    resource_type: str | None = None,\n    required_roles: frozenset[str] | None = None,\n    all_roles_required: bool = False,\n    required_permissions: tuple[tuple[str, str], ...] | None = None,\n    admin_roles: frozenset[str] | None = None,\n    lang: LanguageType = DEFAULT_LANG,\n) -&gt; Callable:\n    \"\"\"FastAPI async decorator for Keycloak authentication and resource-based authorization.\n\n    Args:\n        resource_type_param: The parameter name in the path (e.g., 'user_uuid', 'employee_uuid')\n        resource_type: The type of resource being accessed (e.g., 'users', 'employees')\n        required_roles: Set of role names that the user must have\n        all_roles_required: If True, user must have all specified roles; if False, any role is sufficient\n        required_permissions: List of (resource, scope) tuples to check\n        admin_roles: Set of roles that grant administrative access to all resources\n        lang: Language for error messages\n    Raises:\n        UnauthenticatedError: If no valid Authorization header is provided\n        InvalidTokenError: If token is invalid\n        TokenExpiredError: If token is expired\n        PermissionDeniedError: If user lacks required roles, permissions, or resource access\n        InvalidArgumentError: If resource_type_param is missing when resource_type is provided\n    \"\"\"\n\n    async def dependency(\n        request: Request,\n        token: HTTPAuthorizationCredentials = Security(security),\n        keycloak: AsyncKeycloakAdapter = Depends(cls._get_async_keycloak_adapter),\n    ) -&gt; dict[str, Any]:\n        if token is None:\n            raise UnauthenticatedError(lang=lang)\n        token_str = token.credentials  # Extract the token string\n\n        # Validate token\n        if not await keycloak.validate_token(token_str):\n            # Handle token validation error\n            token_info = await keycloak.introspect_token(token_str)\n            if not token_info or not token_info.get(\"active\", False):\n                raise TokenExpiredError(lang=lang)\n\n        # Get user info from token\n        user_info = await keycloak.get_userinfo(token_str)\n        if not user_info:\n            raise UnauthenticatedError(lang=lang)\n\n        token_info = await keycloak.get_token_info(token_str)\n\n        # Resource-based authorization if resource type is provided\n        if resource_type and resource_type_param:\n            # Extract resource UUID from path parameters\n            resource_uuid = request.path_params.get(resource_type_param)\n            if not resource_uuid:\n                raise InvalidArgumentError(argument_name=resource_type_param, lang=lang)\n\n            # Verify resource exists and user has access\n            user_uuid = user_info.get(\"sub\")\n\n            # Check if resource exists\n            resource_user = await keycloak.get_user_by_id(resource_uuid)\n            if not resource_user:\n                raise PermissionDeniedError(\n                    lang=lang,\n                    additional_data={\"resource_type\": resource_type, \"resource_id\": resource_uuid},\n                )\n\n            # Authorization check: either owns the resource or has admin privileges\n            has_admin_privileges = admin_roles and await keycloak.has_any_of_roles(token_str, admin_roles)\n            if user_uuid != resource_uuid and not has_admin_privileges:\n                raise PermissionDeniedError(\n                    lang=lang,\n                    additional_data={\"resource_type\": resource_type, \"resource_id\": resource_uuid},\n                )\n\n        # Check additional roles if specified\n        if required_roles:\n            if all_roles_required:\n                if not await keycloak.has_all_roles(token_str, required_roles):\n                    raise PermissionDeniedError(\n                        lang=lang,\n                        additional_data={\"required_roles\": required_roles},\n                    )\n            elif not await keycloak.has_any_of_roles(token_str, required_roles):\n                raise PermissionDeniedError(\n                    lang=lang,\n                    additional_data={\"required_roles\": required_roles},\n                )\n\n        # Check permissions if specified\n        if required_permissions:\n            for resource, scope in required_permissions:\n                if not await keycloak.check_permissions(token_str, resource, scope):\n                    raise PermissionDeniedError(\n                        lang=lang,\n                        additional_data={\"required_permission\": f\"{resource}#{scope}\"},\n                    )\n\n        # Add user info to request state\n        request.state.user_info = user_info\n        request.state.token_info = token_info\n        if not user_info:\n            raise UnauthenticatedError(lang=lang)\n        return user_info\n\n    return dependency\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.keycloak_utils.KeycloakUtils.grpc_auth","title":"<code>archipy.helpers.utils.keycloak_utils.KeycloakUtils.grpc_auth(required_roles=None, all_roles_required=False, required_permissions=None, resource_attribute_name=None, admin_roles=None, lang=DEFAULT_LANG)</code>  <code>classmethod</code>","text":"<p>Synchronous gRPC decorator for authentication and authorization.</p> <p>This decorator handles: 1. Token validation 2. Role/permission checking 3. Passing auth context to business logic</p> <p>Resource ownership is handled in the business logic layer.</p> <p>Parameters:</p> Name Type Description Default <code>required_roles</code> <code>frozenset[str] | None</code> <p>Set of roles, user must have at least one (or all if all_roles_required=True)</p> <code>None</code> <code>all_roles_required</code> <code>bool</code> <p>If True, user must have all required_roles; if False, any one role is sufficient</p> <code>False</code> <code>required_permissions</code> <code>tuple[tuple[str, str], ...] | None</code> <p>Tuple of (resource, scope) pairs that must be satisfied</p> <code>None</code> <code>resource_attribute_name</code> <code>str | None</code> <p>Attribute name to extract resource UUID from context for ownership checking</p> <code>None</code> <code>admin_roles</code> <code>frozenset[str] | None</code> <p>Set of admin roles that bypass resource ownership checks</p> <code>None</code> <code>lang</code> <code>LanguageType</code> <p>Language for error messages</p> <code>DEFAULT_LANG</code> <p>Returns:</p> Type Description <code>Callable[[Callable], Callable]</code> <p>Decorated function with authentication and authorization</p> Source code in <code>archipy/helpers/utils/keycloak_utils.py</code> <pre><code>@classmethod\ndef grpc_auth(\n    cls,\n    required_roles: frozenset[str] | None = None,\n    all_roles_required: bool = False,\n    required_permissions: tuple[tuple[str, str], ...] | None = None,\n    resource_attribute_name: str | None = None,\n    admin_roles: frozenset[str] | None = None,\n    lang: LanguageType = DEFAULT_LANG,\n) -&gt; Callable[[Callable], Callable]:\n    \"\"\"Synchronous gRPC decorator for authentication and authorization.\n\n    This decorator handles:\n    1. Token validation\n    2. Role/permission checking\n    3. Passing auth context to business logic\n\n    Resource ownership is handled in the business logic layer.\n\n    Args:\n        required_roles: Set of roles, user must have at least one (or all if all_roles_required=True)\n        all_roles_required: If True, user must have all required_roles; if False, any one role is sufficient\n        required_permissions: Tuple of (resource, scope) pairs that must be satisfied\n        resource_attribute_name: Attribute name to extract resource UUID from context for ownership checking\n        admin_roles: Set of admin roles that bypass resource ownership checks\n        lang: Language for error messages\n\n    Returns:\n        Decorated function with authentication and authorization\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        @functools.wraps(func)\n        def wrapper(self: object, request: object, context: ServicerContext) -&gt; object:\n            try:\n                # 1. Extract and validate token\n                token_str = cls._extract_token_from_metadata(context)\n                if not token_str:\n                    raise UnauthenticatedError(lang=lang)\n\n                # 2. Get Keycloak adapter (synchronous)\n                keycloak: KeycloakAdapter = cls._get_keycloak_adapter()\n\n                # 3. Validate token\n                if not keycloak.validate_token(token_str):\n                    token_info = keycloak.introspect_token(token_str)\n                    if not token_info or not token_info.get(\"active\", False):\n                        raise TokenExpiredError(lang=lang)\n\n                # 4. Get user info from token\n                user_info = keycloak.get_userinfo(token_str)\n                if not user_info:\n                    raise UnauthenticatedError(lang=lang)\n\n                # 5. Resource-based authorization if resource_attribute_name is provided\n                if resource_attribute_name:\n                    # Extract resource UUID from context\n                    resource_uuid = getattr(request, resource_attribute_name)\n                    if not resource_uuid:\n                        raise InvalidArgumentError(argument_name=resource_attribute_name, lang=lang)\n\n                    # Verify resource exists and user has access\n                    user_uuid = user_info.get(\"sub\")\n\n                    # Check if resource exists\n                    resource_user = keycloak.get_user_by_id(resource_uuid)\n                    if not resource_user:\n                        raise PermissionDeniedError(\n                            lang=lang,\n                            additional_data={\"resource_id\": resource_uuid},\n                        )\n\n                    # Authorization check: either owns the resource or has admin privileges\n                    has_admin_privileges = admin_roles and keycloak.has_any_of_roles(token_str, admin_roles)\n                    if user_uuid != resource_uuid and not has_admin_privileges:\n                        raise PermissionDeniedError(lang=lang, additional_data={\"resource_id\": resource_uuid})\n\n                # 6. Check roles if specified\n                if required_roles:\n                    if all_roles_required:\n                        if not keycloak.has_all_roles(token_str, required_roles):\n                            raise PermissionDeniedError(\n                                lang=lang,\n                                additional_data={\n                                    \"required_roles\": list(required_roles),\n                                    \"check_type\": \"all_required\",\n                                },\n                            )\n\n                    elif not keycloak.has_any_of_roles(token_str, required_roles):\n                        raise PermissionDeniedError(\n                            lang=lang,\n                            additional_data={\"required_roles\": list(required_roles), \"check_type\": \"any_required\"},\n                        )\n\n                # 7. Check permissions if specified\n                if required_permissions:\n                    for resource, scope in required_permissions:\n                        if not keycloak.check_permissions(token_str, resource, scope):\n                            raise PermissionDeniedError(\n                                lang=lang,\n                                additional_data={\n                                    \"required_permission\": f\"{resource}#{scope}\",\n                                    \"resource\": resource,\n                                    \"scope\": scope,\n                                },\n                            )\n\n                # 8. Create auth context for business logic\n                auth_context = AuthContext(\n                    user_id=user_info.get(\"sub\"),\n                    username=user_info.get(\"preferred_username\", \"\"),\n                    email=user_info.get(\"email\", \"\"),\n                    roles=user_info.get(\"realm_access\", {}).get(\"roles\", []),\n                    token=token_str,\n                    raw_user_info=user_info,\n                )\n\n                # 9. Set auth context using contextvars\n                AuthContextManager.set_auth_context(auth_context)\n\n                # 10. Call the original method - business logic handles ownership\n                return func(self, request, context)\n\n            except Exception as e:\n                if isinstance(e, BaseError):\n                    e.abort_grpc_sync(context)\n                raise InternalError(\n                    lang=lang,\n                    additional_data={\"original_error\": str(e), \"error_type\": type(e).__name__},\n                ) from e\n\n            finally:\n                # Clean up auth context\n                AuthContextManager.clear_auth_context()\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.keycloak_utils.KeycloakUtils.async_grpc_auth","title":"<code>archipy.helpers.utils.keycloak_utils.KeycloakUtils.async_grpc_auth(required_roles=None, all_roles_required=False, required_permissions=None, resource_attribute_name=None, admin_roles=None, lang=DEFAULT_LANG)</code>  <code>classmethod</code>","text":"<p>Simplified gRPC decorator for authentication and authorization.</p> <p>This decorator handles: 1. Token validation 2. Role/permission checking 3. Passing auth context to business logic</p> <p>Resource ownership is handled in the business logic layer.</p> <p>Parameters:</p> Name Type Description Default <code>required_roles</code> <code>frozenset[str] | None</code> <p>Set of roles, user must have at least one (or all if all_roles_required=True)</p> <code>None</code> <code>all_roles_required</code> <code>bool</code> <p>If True, user must have all required_roles; if False, any one role is sufficient</p> <code>False</code> <code>required_permissions</code> <code>tuple[tuple[str, str], ...] | None</code> <p>Tuple of (resource, scope) pairs that must be satisfied</p> <code>None</code> <code>resource_attribute_name</code> <code>str | None</code> <p>Attribute name to extract resource UUID from context for ownership checking</p> <code>None</code> <code>admin_roles</code> <code>frozenset[str] | None</code> <p>Set of admin roles that bypass resource ownership checks</p> <code>None</code> <code>lang</code> <code>LanguageType</code> <p>Language for error messages</p> <code>DEFAULT_LANG</code> <p>Returns:</p> Type Description <code>Callable[[Callable], Callable]</code> <p>Decorated function with authentication and authorization</p> Source code in <code>archipy/helpers/utils/keycloak_utils.py</code> <pre><code>@classmethod\ndef async_grpc_auth(\n    cls,\n    required_roles: frozenset[str] | None = None,\n    all_roles_required: bool = False,\n    required_permissions: tuple[tuple[str, str], ...] | None = None,\n    resource_attribute_name: str | None = None,\n    admin_roles: frozenset[str] | None = None,\n    lang: LanguageType = DEFAULT_LANG,\n) -&gt; Callable[[Callable], Callable]:\n    \"\"\"Simplified gRPC decorator for authentication and authorization.\n\n    This decorator handles:\n    1. Token validation\n    2. Role/permission checking\n    3. Passing auth context to business logic\n\n    Resource ownership is handled in the business logic layer.\n\n    Args:\n        required_roles: Set of roles, user must have at least one (or all if all_roles_required=True)\n        all_roles_required: If True, user must have all required_roles; if False, any one role is sufficient\n        required_permissions: Tuple of (resource, scope) pairs that must be satisfied\n        resource_attribute_name: Attribute name to extract resource UUID from context for ownership checking\n        admin_roles: Set of admin roles that bypass resource ownership checks\n        lang: Language for error messages\n\n    Returns:\n        Decorated function with authentication and authorization\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        @functools.wraps(func)\n        async def wrapper(self: object, request: object, context: AsyncServicerContext) -&gt; object:\n            try:\n                # 1. Extract and validate token\n                token_str = cls._extract_token_from_metadata(context)\n                if not token_str:\n                    raise UnauthenticatedError(lang=lang)\n\n                # 2. Get Keycloak adapter\n                keycloak: AsyncKeycloakAdapter = cls._get_async_keycloak_adapter()\n\n                # 3. Validate token\n                if not await keycloak.validate_token(token_str):\n                    token_info = await keycloak.introspect_token(token_str)\n                    if not token_info or not token_info.get(\"active\", False):\n                        raise TokenExpiredError(lang=lang)\n\n                # 4. Get user info from token\n                user_info = await keycloak.get_userinfo(token_str)\n                if not user_info:\n                    raise UnauthenticatedError(lang=lang)\n\n                # 5. Resource-based authorization if resource_attribute_name is provided\n                if resource_attribute_name:\n                    # Extract resource UUID from context\n                    resource_uuid = getattr(request, resource_attribute_name)\n                    if not resource_uuid:\n                        raise InvalidArgumentError(argument_name=resource_attribute_name, lang=lang)\n\n                    # Verify resource exists and user has access\n                    user_uuid = user_info.get(\"sub\")\n\n                    # Check if resource exists\n                    resource_user = await keycloak.get_user_by_id(resource_uuid)\n                    if not resource_user:\n                        raise PermissionDeniedError(\n                            lang=lang,\n                            additional_data={\"resource_id\": resource_uuid},\n                        )\n\n                    # Authorization check: either owns the resource or has admin privileges\n                    has_admin_privileges = admin_roles and await keycloak.has_any_of_roles(token_str, admin_roles)\n                    if user_uuid != resource_uuid and not has_admin_privileges:\n                        raise PermissionDeniedError(lang=lang, additional_data={\"resource_id\": resource_uuid})\n\n                # 6. Check roles if specified\n                if required_roles:\n                    if all_roles_required:\n                        if not await keycloak.has_all_roles(token_str, required_roles):\n                            raise PermissionDeniedError(\n                                lang=lang,\n                                additional_data={\n                                    \"required_roles\": list(required_roles),\n                                    \"check_type\": \"all_required\",\n                                },\n                            )\n\n                    elif not await keycloak.has_any_of_roles(token_str, required_roles):\n                        raise PermissionDeniedError(\n                            lang=lang,\n                            additional_data={\"required_roles\": list(required_roles), \"check_type\": \"any_required\"},\n                        )\n\n                # 7. Check permissions if specified\n                if required_permissions:\n                    for resource, scope in required_permissions:\n                        if not await keycloak.check_permissions(token_str, resource, scope):\n                            raise PermissionDeniedError(\n                                lang=lang,\n                                additional_data={\n                                    \"required_permission\": f\"{resource}#{scope}\",\n                                    \"resource\": resource,\n                                    \"scope\": scope,\n                                },\n                            )\n\n                # 8. Create auth context for business logic\n                auth_context = AuthContext(\n                    user_id=user_info.get(\"sub\"),\n                    username=user_info.get(\"preferred_username\", \"\"),\n                    email=user_info.get(\"email\", \"\"),\n                    roles=user_info.get(\"realm_access\", {}).get(\"roles\", []),\n                    token=token_str,\n                    raw_user_info=user_info,\n                )\n\n                # 9. Set auth context using contextvars\n                AuthContextManager.set_auth_context(auth_context)\n\n                # 10. Call the original method - business logic handles ownership\n                return await func(self, request, context)\n\n            except Exception as e:\n                if isinstance(e, BaseError):\n                    await e.abort_grpc_async(context)\n                    return None  # abort_grpc_async will terminate, but satisfy type checker\n                await InternalError(\n                    lang=lang,\n                    additional_data={\"original_error\": str(e), \"error_type\": type(e).__name__},\n                ).abort_grpc_async(context)\n                return None  # abort_grpc_async will terminate, but satisfy type checker\n\n            finally:\n                # Clean up auth context\n                AuthContextManager.clear_auth_context()\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api_reference/utils/#key-classes","title":"Key Classes","text":""},{"location":"api_reference/utils/#datetimeutils","title":"DateTimeUtils","text":"<p>Class: <code>archipy.helpers.utils.datetime_utils.DateTimeUtils</code></p> <p>Provides datetime operations with features:</p> <ul> <li>Timezone-aware</li> <li>Microsecond precision</li> <li>Consistent across the application</li> </ul>"},{"location":"api_reference/utils/#jwtutils","title":"JWTUtils","text":"<p>Class: <code>archipy.helpers.utils.jwt_utils.JWTUtils</code></p> <p>Provides JWT operations with features:</p> <ul> <li>Configurable expiration</li> <li>Custom payload support</li> <li>Multiple signing algorithms</li> <li>Token refresh capability</li> </ul>"},{"location":"api_reference/utils/#passwordutils","title":"PasswordUtils","text":"<p>Class: <code>archipy.helpers.utils.password_utils.PasswordUtils</code></p> <p>Provides password operations with features:</p> <ul> <li>Secure hashing algorithm</li> <li>Salt generation</li> <li>Configurable work factor</li> <li>Protection against timing attacks</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>This section contains practical examples of using ArchiPy components.</p>"},{"location":"examples/#adapters","title":"Adapters","text":"<ul> <li>PostgreSQL</li> <li>SQLite</li> <li>StarRocks</li> <li>Redis</li> <li>Email</li> <li>Keycloak</li> <li>MinIO</li> <li>Kafka</li> <li>Temporal</li> <li>Payment Gateways</li> </ul>"},{"location":"examples/#helpers","title":"Helpers","text":"<ul> <li>Decorators</li> <li>Interceptors</li> <li>Utils</li> </ul>"},{"location":"examples/#configuration","title":"Configuration","text":"<ul> <li>Configuration Management</li> </ul>"},{"location":"examples/#testing","title":"Testing","text":"<ul> <li>BDD Testing</li> </ul>"},{"location":"examples/#models","title":"Models","text":"<ul> <li>Protobuf DTOs</li> </ul>"},{"location":"examples/#error-handling","title":"Error Handling","text":"<ul> <li>Error Handling Examples</li> </ul>"},{"location":"examples/bdd_testing/","title":"BDD Testing with ArchiPy","text":"<p>This page demonstrates how to use ArchiPy's integrated BDD testing capabilities with Behave.</p>"},{"location":"examples/bdd_testing/#basic-usage","title":"Basic Usage","text":"<p>ArchiPy provides a complete BDD testing setup using Behave. Here's how to use it:</p>"},{"location":"examples/bdd_testing/#feature-files","title":"Feature Files","text":"<p>Create feature files in the <code>features</code> directory with Gherkin syntax:</p> <pre><code># features/user_management.feature\nFeature: User Management\n  As a system administrator\n  I want to manage users\n  So that I can control system access\n\n  Scenario: Create a new user\n    Given I have admin privileges\n    When I create a user with username \"john\" and email \"john@example.com\"\n    Then the user should be saved in the database\n    And the user should have default permissions\n</code></pre>"},{"location":"examples/bdd_testing/#step-implementations","title":"Step Implementations","text":"<p>Implement the steps in Python files under <code>features/steps</code>:</p> <pre><code># features/steps/user_steps.py\nfrom typing import Any\nfrom behave import given, when, then\nfrom app.models import User\nfrom app.services import UserService\nfrom archipy.models.errors import NotFoundError, DatabaseQueryError\n\n@given('I have admin privileges')\ndef step_impl(context: Any) -&gt; None:\n    context.is_admin = True\n\n@when('I create a user with username \"{username}\" and email \"{email}\"')\ndef step_impl(context: Any, username: str, email: str) -&gt; None:\n    service = UserService()\n    try:\n        context.user = service.create_user(username, email)\n    except Exception as e:\n        # Proper exception chaining\n        raise DatabaseQueryError(\n            additional_data={\"username\": username, \"email\": email}\n        ) from e\n\n@then('the user should be saved in the database')\ndef step_impl(context: Any) -&gt; None:\n    # Check user exists in DB\n    try:\n        db_user = User.query.filter_by(username=context.user.username).first()\n        assert db_user is not None\n    except Exception as e:\n        raise NotFoundError(\n            resource_type=\"user\",\n            additional_data={\"username\": context.user.username}\n        ) from e\n\n@then('the user should have default permissions')\ndef step_impl(context: Any) -&gt; None:\n    assert len(context.user.permissions) &gt; 0\n    assert 'user:read' in context.user.permissions\n</code></pre>"},{"location":"examples/bdd_testing/#running-tests","title":"Running Tests","text":"<p>Run BDD tests using the Makefile command:</p> <pre><code>make behave\n</code></pre> <p>To run a specific feature:</p> <pre><code>uv run behave features/user_management.feature\n</code></pre> <p>To run a specific scenario by line number:</p> <pre><code>uv run behave features/user_management.feature:7\n</code></pre>"},{"location":"examples/bdd_testing/#advanced-bdd-testing","title":"Advanced BDD Testing","text":""},{"location":"examples/bdd_testing/#using-context-tables","title":"Using Context Tables","text":"<p>Behave supports data tables for testing multiple scenarios:</p> <pre><code>Scenario: Create multiple users\nGiven I have admin privileges\nWhen I create the following users:\n| username | email              | role    |\n| john     | john@example.com   | user    |\n| alice    | alice@example.com  | admin   |\n| bob      | bob@example.com    | support |\nThen all users should be saved in the database\n</code></pre> <pre><code>@when('I create the following users')\ndef step_impl(context: Any) -&gt; None:\n    service = UserService()\n    context.users = []\n    for row in context.table:\n        try:\n            user = service.create_user(\n                username=row['username'],\n                email=row['email'],\n                role=row['role']\n            )\n            context.users.append(user)\n        except Exception as e:\n            raise DatabaseQueryError(\n                additional_data={\"username\": row['username'], \"email\": row['email']}\n            ) from e\n</code></pre>"},{"location":"examples/config_management/","title":"Configuration Management","text":"<p>ArchiPy provides a robust configuration management system that ensures type safety, environment variable support, and consistent access patterns across your application.</p>"},{"location":"examples/config_management/#basic-configuration","title":"Basic Configuration","text":""},{"location":"examples/config_management/#defining-a-configuration","title":"Defining a Configuration","text":"<p>Create a configuration class by inheriting from <code>BaseConfig</code>:</p> <pre><code>from archipy.configs.base_config import BaseConfig\nfrom archipy.configs.environment_type import EnvironmentType\n\nclass AppConfig(BaseConfig):\n    # Application settings\n    APP_NAME: str = \"MyService\"\n    DEBUG: bool = False\n\n    # Database settings\n    DB_HOST: str = \"localhost\"\n    DB_PORT: int = 5432\n    DB_NAME: str = \"myapp\"\n    DB_USER: str = \"postgres\"\n    DB_PASSWORD: str = \"password\"\n\n    # Redis settings\n    REDIS_HOST: str = \"localhost\"\n    REDIS_PORT: int = 6379\n\n    # Environment\n    ENVIRONMENT: EnvironmentType = EnvironmentType.DEV\n\n    # API settings\n    API_PREFIX: str = \"/api/v1\"\n\n    # Logging\n    LOG_LEVEL: str = \"INFO\"\n</code></pre>"},{"location":"examples/config_management/#using-the-configuration","title":"Using the Configuration","text":"<pre><code># Create and set as global configuration\nconfig = AppConfig()\nBaseConfig.set_global(config)\n\n# Access configuration values from anywhere in your code\nfrom archipy.configs.base_config import BaseConfig\n\ncurrent_config = BaseConfig.global_config()\ndb_url = f\"postgresql://{current_config.DB_USER}:{current_config.DB_PASSWORD}@{current_config.DB_HOST}:{current_config.DB_PORT}/{current_config.DB_NAME}\"\n</code></pre>"},{"location":"examples/config_management/#environment-variables","title":"Environment Variables","text":"<p>ArchiPy configurations automatically load values from environment variables with the same name:</p> <pre><code># .env file\nAPP_NAME = ProductionService\nDB_HOST = db.example.com\nDB_PASSWORD = secure - password\nENVIRONMENT = PRODUCTION\n</code></pre> <p>The environment variables override the default values in your configuration class:</p> <pre><code>config = AppConfig()  # Will have values from environment variables\nprint(config.APP_NAME)  # \"ProductionService\"\nprint(config.ENVIRONMENT)  # EnvironmentType.PRODUCTION\n</code></pre>"},{"location":"examples/config_management/#environment-specific-configurations","title":"Environment-Specific Configurations","text":"<p>You can create environment-specific configurations:</p> <pre><code>from archipy.configs.base_config import BaseConfig\nfrom archipy.configs.environment_type import EnvironmentType\n\nclass BaseAppConfig(BaseConfig):\n    APP_NAME: str = \"MyService\"\n    DEBUG: bool = False\n    # Common settings...\n\nclass DevelopmentConfig(BaseAppConfig):\n    DEBUG: bool = True\n    ENVIRONMENT: EnvironmentType = EnvironmentType.DEV\n    LOG_LEVEL: str = \"DEBUG\"\n\nclass ProductionConfig(BaseAppConfig):\n    DEBUG: bool = False\n    ENVIRONMENT: EnvironmentType = EnvironmentType.PRODUCTION\n    LOG_LEVEL: str = \"WARNING\"\n\n# Choose configuration based on environment\nimport os\nenv = os.getenv(\"ENVIRONMENT\", \"development\").lower()\n\nif env == \"production\":\n    config = ProductionConfig()\nelse:\n    config = DevelopmentConfig()\n\nBaseConfig.set_global(config)\n</code></pre>"},{"location":"examples/config_management/#nested-configurations","title":"Nested Configurations","text":"<p>You can use nested Pydantic models for more complex configurations:</p> <pre><code>from pydantic import BaseModel\nfrom archipy.configs.base_config import BaseConfig\n\nclass DatabaseConfig(BaseModel):\n    HOST: str = \"localhost\"\n    PORT: int = 5432\n    NAME: str = \"myapp\"\n    USER: str = \"postgres\"\n    PASSWORD: str = \"password\"\n\n    def connection_string(self) -&gt; str:\n        return f\"postgresql://{self.USER}:{self.PASSWORD}@{self.HOST}:{self.PORT}/{self.NAME}\"\n\nclass RedisConfig(BaseModel):\n    HOST: str = \"localhost\"\n    PORT: int = 6379\n    DB: int = 0\n\nclass AppConfig(BaseConfig):\n    APP_NAME: str = \"MyService\"\n    DEBUG: bool = False\n    DATABASE: DatabaseConfig = DatabaseConfig()\n    REDIS: RedisConfig = RedisConfig()\n\n# Usage\nconfig = AppConfig()\nprint(config.DATABASE.connection_string())\n</code></pre>"},{"location":"examples/config_management/#configuration-template","title":"Configuration Template","text":"<p>ArchiPy provides pre-configured templates for common configuration objects:</p> <pre><code>from archipy.configs.base_config import BaseConfig\nfrom archipy.configs.environment_type import EnvironmentType\n\nclass AppConfig(BaseConfig):\n    # Override only what you need\n    APP_NAME: str = \"MyCustomApp\"\n\n    # The BaseConfig provides default templates for common configurations like:\n    # AUTH, DATETIME, ELASTIC, EMAIL, FASTAPI, KAFKA, REDIS, etc.\n\nconfig = AppConfig()\nprint(config.ENVIRONMENT)  # Default value from BaseConfig (EnvironmentType.LOCAL)\n</code></pre>"},{"location":"examples/config_management/#configuration-in-different-components","title":"Configuration in Different Components","text":""},{"location":"examples/config_management/#with-fastapi","title":"With FastAPI","text":"<pre><code>from fastapi import FastAPI, Depends\nfrom archipy.helpers.utils.app_utils import AppUtils\nfrom archipy.configs.base_config import BaseConfig\n\n# Initialize your configuration\nconfig = BaseConfig()\nBaseConfig.set_global(config)\n\n# Create a FastAPI app with configuration\napp = AppUtils.create_fastapi_app()  # Uses global config by default\n\n# Or provide a specific configuration\n# app = AppUtils.create_fastapi_app(config)\n\n# Access config in endpoint\n@app.get(\"/config\")\ndef get_config_info():\n    config = BaseConfig.global_config()\n    return {\n        \"app_name\": config.FASTAPI.PROJECT_NAME,\n        \"environment\": config.ENVIRONMENT.value,\n        \"debug\": config.FASTAPI.RELOAD\n    }\n</code></pre>"},{"location":"examples/config_management/#with-database-adapters","title":"With Database Adapters","text":"<pre><code>from archipy.adapters.postgres.sqlalchemy.session_managers import SQlAlchemySessionManager\nfrom archipy.configs.base_config import BaseConfig\n\nconfig = BaseConfig.global_config()\n\n# Create session manager with config\nsession_manager = SQlAlchemySessionManager(\n    connection_string=config.POSTGRES_SQLALCHEMY.POSTGRES_DSN,\n    echo=config.POSTGRES_SQLALCHEMY.ECHO\n)\n</code></pre>"},{"location":"examples/config_management/#with-redis-adapters","title":"With Redis Adapters","text":"<pre><code>from archipy.adapters.redis.adapters import RedisAdapter\nfrom archipy.configs.base_config import BaseConfig\n\nconfig = BaseConfig.global_config()\n\n# Create Redis adapter with config\nredis_adapter = RedisAdapter(\n    host=config.REDIS.MASTER_HOST,\n    port=config.REDIS.PORT,\n    db=config.REDIS.DATABASE\n)\n</code></pre>"},{"location":"examples/config_management/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use meaningful defaults: Configure sensible defaults that work in local development</p> </li> <li> <p>Never hardcode secrets: Always use environment variables for sensitive information</p> </li> <li> <p>Validate configurations: Use Pydantic validators for complex validation rules</p> </li> <li> <p>Document configuration options: Add clear docstrings to your configuration classes</p> </li> <li> <p>Keep configurations centralized: Avoid creating multiple configuration sources</p> </li> </ol>"},{"location":"examples/error_handling/","title":"Error Handling Examples","text":"<p>This document provides examples of how to use the error handling system in different scenarios.</p>"},{"location":"examples/error_handling/#basic-error-handling","title":"Basic Error Handling","text":"<pre><code>from archipy.models.errors import (\n    NotFoundError,\n    InvalidArgumentError,\n    PermissionDeniedError\n)\nfrom archipy.models.types.language_type import LanguageType\n\ndef get_user(user_id: str):\n    try:\n        # Attempt to fetch user\n        user = user_repository.find_by_id(user_id)\n        if not user:\n            raise NotFoundError(\n                resource_type=\"user\",\n                error_details=f\"User with ID {user_id} not found\",\n                lang=LanguageType.EN\n            )\n        return user\n    except NotFoundError as e:\n        # Log the error\n        logger.error(f\"User not found: {e.to_dict()}\")\n        # Re-raise or handle as needed\n        raise\n\ndef update_user_permissions(user_id: str, permissions: list[str]):\n    try:\n        # Validate input\n        if not isinstance(permissions, list):\n            raise InvalidArgumentError(\n                argument=\"permissions\",\n                error_details=\"Permissions must be a list\",\n                lang=LanguageType.EN\n            )\n\n        # Check permissions\n        if not has_admin_access():\n            raise PermissionDeniedError(\n                operation=\"update_permissions\",\n                error_details=\"Admin access required\",\n                lang=LanguageType.EN\n            )\n\n        # Update permissions\n        user_repository.update_permissions(user_id, permissions)\n    except (InvalidArgumentError, PermissionDeniedError) as e:\n        logger.error(f\"Failed to update permissions: {e.to_dict()}\")\n        raise\n</code></pre>"},{"location":"examples/error_handling/#business-logic-error-handling","title":"Business Logic Error Handling","text":"<pre><code>from archipy.models.errors import (\n    InsufficientFundsError,\n    BusinessRuleViolationError,\n    InvalidStateError\n)\n\ndef process_transaction(account_id: str, amount: float):\n    try:\n        # Check account state\n        account = account_repository.find_by_id(account_id)\n        if not account.is_active:\n            raise InvalidStateError(\n                current_state=\"inactive\",\n                expected_state=\"active\",\n                error_details=\"Account must be active for transactions\"\n            )\n\n        # Check balance\n        if account.balance &lt; amount:\n            raise InsufficientFundsError(\n                error_details=f\"Required amount: {amount}, Available: {account.balance}\"\n            )\n\n        # Check business rules\n        if amount &gt; account.transaction_limit:\n            raise BusinessRuleViolationError(\n                rule=\"transaction_limit\",\n                details=f\"Amount exceeds limit of {account.transaction_limit}\"\n            )\n\n        # Process transaction\n        account_repository.process_transaction(account_id, amount)\n    except (InsufficientFundsError, BusinessRuleViolationError, InvalidStateError) as e:\n        logger.error(f\"Transaction failed: {e.to_dict()}\")\n        raise\n</code></pre>"},{"location":"examples/error_handling/#system-error-handling","title":"System Error Handling","text":"<pre><code>from archipy.models.errors import (\n    DatabaseConnectionError,\n    DeadlockDetectedError,\n    ResourceExhaustedError\n)\nfrom typing import Any\n\ndef execute_with_retry(operation: callable, max_retries: int = 3) -&gt; Any:\n    retries = 0\n    while retries &lt; max_retries:\n        try:\n            return operation()\n        except DeadlockDetectedError as e:\n            retries += 1\n            if retries == max_retries:\n                logger.error(f\"Max retries exceeded: {e.to_dict()}\")\n                raise\n            logger.warning(f\"Deadlock detected, retrying ({retries}/{max_retries})\")\n            time.sleep(1)  # Wait before retry\n        except DatabaseConnectionError as e:\n            logger.error(f\"Database connection failed: {e.to_dict()}\")\n            raise  # Don't retry connection errors\n        except ResourceExhaustedError as e:\n            logger.error(f\"Resource exhausted: {e.to_dict()}\")\n            raise  # Don't retry resource exhaustion\n\n# Usage example\ndef process_batch(items: list[dict]):\n    def batch_operation():\n        return database.batch_insert(items)\n\n    try:\n        return execute_with_retry(batch_operation)\n    except (DeadlockDetectedError, DatabaseConnectionError, ResourceExhaustedError) as e:\n        # Handle final failure\n        return {\"error\": e.to_dict()}\n</code></pre>"},{"location":"examples/error_handling/#error-response-formatting","title":"Error Response Formatting","text":"<pre><code>from fastapi import HTTPException\nfrom fastapi.responses import JSONResponse\nfrom archipy.models.errors import BaseError\nfrom archipy.models.types.language_type import LanguageType\nfrom datetime import datetime\n\ndef handle_error(error: BaseError) -&gt; dict:\n    \"\"\"Convert error to API response format.\"\"\"\n    error_dict = error.to_dict()\n    return {\n        \"status\": \"error\",\n        \"error\": error_dict,\n        \"timestamp\": datetime.utcnow().isoformat()\n    }\n\n# FastAPI error handler\n@app.exception_handler(BaseError)\nasync def error_handler(request: Request, exc: BaseError):\n    return JSONResponse(\n        status_code=exc.http_status_code or 500,\n        content=handle_error(exc)\n    )\n\n# Example usage in endpoint\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: str):\n    try:\n        user = user_service.get_user(user_id)\n        return {\"status\": \"success\", \"data\": user}\n    except NotFoundError as e:\n        # Let the exception handler handle it\n        raise\n</code></pre>"},{"location":"examples/error_handling/#error-logging-and-monitoring","title":"Error Logging and Monitoring","text":"<pre><code>from archipy.models.errors import (\n    InternalError,\n    UnknownError,\n    ConfigurationError\n)\nimport sentry_sdk\n\ndef log_error(error: BaseError, context: dict | None = None):\n    \"\"\"Log error with context and send to monitoring service.\"\"\"\n    error_dict = error.to_dict()\n\n    # Add context if provided\n    if context:\n        error_dict[\"context\"] = context\n\n    # Log to application logger\n    logger.error(\n        f\"Error occurred: {error_dict['error']}\",\n        extra={\"error\": error_dict}\n    )\n\n    # Send to monitoring service\n    if isinstance(error, (InternalError, UnknownError, ConfigurationError)):\n        sentry_sdk.capture_exception(error)\n\n# Example usage\ndef process_request(request_data: dict):\n    try:\n        # Process request\n        result = service.process(request_data)\n        return result\n    except BaseError as e:\n        log_error(e, context={\"request_data\": request_data})\n        raise\n</code></pre>"},{"location":"examples/error_handling/#exception-chaining","title":"Exception Chaining","text":"<pre><code>from archipy.models.errors import (\n    DatabaseQueryError,\n    InvalidEntityTypeError,\n    BaseEntity\n)\n\n# Good - Preserving original error context\ndef fetch_entity(entity_type: type, entity_uuid: str) -&gt; BaseEntity:\n    try:\n        result = session.get(entity_type, entity_uuid)\n        if not result:\n            raise NotFoundError(\n                resource_type=entity_type.__name__,\n                error_details=f\"Entity with UUID {entity_uuid} not found\"\n            )\n        return result\n    except Exception as e:\n        raise DatabaseQueryError() from e\n\n# Good - Type validation with specific error\ndef validate_entity(entity: object) -&gt; None:\n    if not isinstance(entity, BaseEntity):\n        raise InvalidEntityTypeError(\n            message=f\"Expected BaseEntity subclass, got {type(entity).__name__}\",\n            expected_type=\"BaseEntity\",\n            actual_type=type(entity).__name__\n        )\n</code></pre>"},{"location":"examples/error_handling/#error-recovery-strategies","title":"Error Recovery Strategies","text":"<pre><code>from archipy.models.errors import (\n    CacheMissError,\n    ServiceUnavailableError,\n    ResourceExhaustedError\n)\n\nclass ErrorRecovery:\n    @staticmethod\n    def handle_cache_miss(error: CacheMissError):\n        \"\"\"Handle cache miss by fetching from primary source.\"\"\"\n        try:\n            # Fetch from database\n            data = database.get(error.key)\n            # Update cache\n            cache.set(error.key, data)\n            return data\n        except Exception as e:\n            logger.error(f\"Failed to recover from cache miss: {str(e)}\")\n            raise  # Re-raise after logging\n\n    @staticmethod\n    def handle_service_unavailable(error: ServiceUnavailableError):\n        \"\"\"Handle service unavailability with fallback.\"\"\"\n        if error.service == \"primary\":\n            try:\n            # Try fallback service\n            return fallback_service.get_data()\n            except Exception as e:\n                # Preserve error chain\n                raise ServiceUnavailableError(\n                    service=\"fallback\",\n                    error_details=\"Both primary and fallback services unavailable\"\n                ) from e\n        raise\n\n    @staticmethod\n    def handle_resource_exhaustion(error: ResourceExhaustedError):\n        \"\"\"Handle resource exhaustion with cleanup.\"\"\"\n        if error.resource_type == \"memory\":\n            # Perform cleanup\n            gc.collect()\n            try:\n            # Retry operation\n            return retry_operation()\n            except Exception as e:\n                # Preserve error chain\n                raise ResourceExhaustedError(\n                    resource_type=\"memory\",\n                    error_details=\"Resource exhaustion persisted after cleanup\"\n                ) from e\n        raise\n\n# Example usage\ndef get_data(key: str):\n    try:\n        return cache.get(key)\n    except CacheMissError as e:\n        return ErrorRecovery.handle_cache_miss(e)\n    except ServiceUnavailableError as e:\n        return ErrorRecovery.handle_service_unavailable(e)\n    except ResourceExhaustedError as e:\n        return ErrorRecovery.handle_resource_exhaustion(e)\n</code></pre>"},{"location":"examples/adapters/","title":"Adapter Examples","text":"<p>ArchiPy provides a variety of adapters to help interface with external systems, maintaining a clean separation between your business logic and external dependencies.</p>"},{"location":"examples/adapters/#available-adapters","title":"Available Adapters","text":"Adapter Purpose Example API Reference Email Email sending interface Connect to SMTP servers for sending emails API Keycloak Authentication &amp; authorization User management and access control with Keycloak API Kafka Message streaming Event-driven architectures with Apache Kafka API Minio Object storage S3-compatible object storage for files and documents API Parsian Payment Payment gateway Process online payments with Parsian Shaparak API PostgreSQL Database access SQLAlchemy integration for PostgreSQL API SQLite Database access SQLAlchemy integration for SQLite API StarRocks Database access SQLAlchemy integration for StarRocks API Redis Key-value store Caching, pub/sub, and data storage with Redis API Temporal Workflow orchestration Durable workflow execution and activity coordination API"},{"location":"examples/adapters/#adapter-architecture","title":"Adapter Architecture","text":"<p>ArchiPy follows the ports and adapters pattern (hexagonal architecture):</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502             Domain Logic               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502 uses\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 Ports                  \u2502\n\u2502          (Abstract Interfaces)         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502 implemented by\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                Adapters                \u2502\n\u2502         (Concrete Implementations)     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502 connects to\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            External Systems            \u2502\n\u2502   (Databases, APIs, Message Queues)    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/adapters/#testing-with-mock-adapters","title":"Testing with Mock Adapters","text":"<p>Each adapter in ArchiPy comes with a corresponding mock implementation for testing:</p> <pre><code># Production code\nfrom archipy.adapters.redis import RedisAdapter\n\nredis = RedisAdapter(host=\"redis.example.com\", port=6379)\nredis.set(\"key\", \"value\")\n\n# Test code\nfrom archipy.adapters.redis import RedisMock\n\nredis_mock = RedisMock()\nredis_mock.set(\"key\", \"test_value\")\nassert redis_mock.get(\"key\") == \"test_value\"\n</code></pre>"},{"location":"examples/adapters/#creating-custom-adapters","title":"Creating Custom Adapters","text":"<p>Creating custom adapters is straightforward:</p> <ol> <li>Define a port (abstract interface)</li> <li>Implement the adapter class</li> <li>Optionally create a mock implementation</li> </ol> <p>See the Architecture guide for more details on creating custom adapters.</p>"},{"location":"examples/adapters/email/","title":"Email Adapter Examples","text":"<p>This page demonstrates how to use ArchiPy's email adapter functionality.</p>"},{"location":"examples/adapters/email/#basic-usage","title":"Basic Usage","text":"<pre><code>from archipy.adapters.email import EmailAdapter\n\n# Configure email adapter\nemail_adapter = EmailAdapter(\n    host=\"smtp.example.com\",\n    port=587,\n    username=\"your-username\",\n    password=\"your-password\",\n    use_tls=True\n)\n\n# Send an email\nemail_adapter.send_email(\n    subject=\"Test Email\",\n    body=\"This is a test email from ArchiPy\",\n    recipients=[\"recipient@example.com\"],\n    cc=[\"cc@example.com\"],\n    bcc=[\"bcc@example.com\"],\n    from_email=\"sender@example.com\"\n)\n</code></pre> <p>This documentation is being migrated from Sphinx to MkDocs format. Please check back soon for complete content.</p>"},{"location":"examples/adapters/kafka/","title":"Kafka Adapter","text":"<p>The Kafka adapter provides a clean interface for interacting with Apache Kafka, supporting both synchronous and asynchronous operations.</p>"},{"location":"examples/adapters/kafka/#features","title":"Features","text":"<ul> <li>Topic operations (create, list, delete)</li> <li>Message publishing and consuming</li> <li>Consumer group management</li> <li>Built-in error handling and retry mechanisms</li> <li>Support for both sync and async operations</li> <li>Comprehensive logging and monitoring</li> </ul>"},{"location":"examples/adapters/kafka/#basic-usage","title":"Basic Usage","text":""},{"location":"examples/adapters/kafka/#configuration","title":"Configuration","text":"<p>Configure Kafka in your application's config:</p> <pre><code>from archipy.configs.base_config import BaseConfig\n\n# Using environment variables\n# KAFKA__BOOTSTRAP_SERVERS=localhost:9092\n# KAFKA__CLIENT_ID=my-app\n# KAFKA__GROUP_ID=my-group\n</code></pre>"},{"location":"examples/adapters/kafka/#initializing-the-adapter","title":"Initializing the Adapter","text":"<pre><code>from archipy.adapters.kafka.adapters import KafkaAdapter, AsyncKafkaAdapter\n\n# Use global configuration\nkafka = KafkaAdapter()\n\n# Or provide specific configuration\nfrom archipy.configs.config_template import KafkaConfig\n\ncustom_config = KafkaConfig(\n    BOOTSTRAP_SERVERS=\"kafka1:9092,kafka2:9092\",\n    CLIENT_ID=\"custom-client\",\n    GROUP_ID=\"custom-group\"\n)\nkafka = KafkaAdapter(custom_config)\n</code></pre>"},{"location":"examples/adapters/kafka/#topic-operations","title":"Topic Operations","text":"<pre><code>import logging\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Create a topic\nkafka.create_topic(\"my-topic\", num_partitions=3, replication_factor=1)\n\n# List all topics\ntopics = kafka.list_topics()\nfor topic in topics:\n    logger.info(f\"Topic: {topic}\")\n\n# Delete a topic\nkafka.delete_topic(\"my-topic\")\n</code></pre>"},{"location":"examples/adapters/kafka/#publishing-messages","title":"Publishing Messages","text":"<pre><code>import logging\nfrom typing import Any\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Publish a simple message\nkafka.publish(\"my-topic\", \"Hello, Kafka!\")\n\n# Publish with key and headers\nheaders = {\"source\": \"my-app\", \"version\": \"1.0\"}\nkafka.publish(\"my-topic\", \"Hello, Kafka!\", key=\"message-1\", headers=headers)\n\n# Publish multiple messages\nmessages = [\n    {\"key\": \"msg1\", \"value\": \"Message 1\"},\n    {\"key\": \"msg2\", \"value\": \"Message 2\"}\n]\nkafka.publish_batch(\"my-topic\", messages)\n</code></pre>"},{"location":"examples/adapters/kafka/#consuming-messages","title":"Consuming Messages","text":"<pre><code>import logging\nfrom typing import Any\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Consume messages with a callback\ndef process_message(message: dict[str, Any]) -&gt; None:\n    logger.info(f\"Received message: {message['value']}\")\n\n# Start consuming\nkafka.consume(\"my-topic\", process_message)\n\n# Consume with specific partition and offset\nkafka.consume(\"my-topic\", process_message, partition=0, offset=0)\n\n# Consume with timeout\nkafka.consume(\"my-topic\", process_message, timeout_ms=5000)\n</code></pre>"},{"location":"examples/adapters/kafka/#async-operations","title":"Async Operations","text":"<pre><code>import asyncio\nimport logging\nfrom typing import Any\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\nasync def async_example():\n    # Create async Kafka adapter\n    async_kafka = AsyncKafkaAdapter()\n\n    # Publish message asynchronously\n    await async_kafka.publish(\"my-topic\", \"Async message\")\n\n    # Consume messages asynchronously\n    async def process_async(message: dict[str, Any]) -&gt; None:\n        logger.info(f\"Received async message: {message['value']}\")\n\n    await async_kafka.consume(\"my-topic\", process_async)\n\n# Run the async example\nasyncio.run(async_example())\n</code></pre>"},{"location":"examples/adapters/kafka/#error-handling","title":"Error Handling","text":"<p>The KafkaAdapter uses ArchiPy's domain-specific exceptions for consistent error handling:</p> <pre><code>import logging\nfrom archipy.models.errors import (\n    AlreadyExistsError,\n    InternalError,\n    InvalidArgumentError,\n    NotFoundError,\n    PermissionDeniedError,\n)\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\ntry:\n    kafka.create_topic(\"existing-topic\")\nexcept AlreadyExistsError:\n    logger.warning(\"Topic already exists\")\nexcept PermissionDeniedError:\n    logger.exception(\"Permission denied to create topic\")\nexcept InvalidArgumentError as e:\n    logger.exception(f\"Invalid argument: {e}\")\nexcept InternalError as e:\n    logger.exception(f\"Internal error: {e}\")\n</code></pre>"},{"location":"examples/adapters/kafka/#consumer-group-management","title":"Consumer Group Management","text":"<pre><code>import logging\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# List consumer groups\ngroups = kafka.list_consumer_groups()\nfor group in groups:\n    logger.info(f\"Group: {group['group_id']}, State: {group['state']}\")\n\n# Describe consumer group\ngroup_info = kafka.describe_consumer_group(\"my-group\")\nlogger.info(f\"Group members: {group_info['members']}\")\n\n# Delete consumer group\nkafka.delete_consumer_group(\"my-group\")\n</code></pre>"},{"location":"examples/adapters/kafka/#integration-with-web-applications","title":"Integration with Web Applications","text":""},{"location":"examples/adapters/kafka/#fastapi-example","title":"FastAPI Example","text":"<pre><code>from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\n\nfrom archipy.adapters.kafka.adapters import KafkaAdapter\nfrom archipy.models.errors import InternalError\n\napp = FastAPI()\nkafka = KafkaAdapter()\n\nclass Message(BaseModel):\n    content: str\n    key: str | None = None\n\n@app.post(\"/publish/{topic}\")\nasync def publish_message(topic: str, message: Message):\n    try:\n        kafka.publish(topic, message.content, key=message.key)\n        return {\"message\": \"Message published successfully\"}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/topics\")\nasync def list_topics():\n    try:\n        topics = kafka.list_topics()\n        return {\"topics\": topics}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre>"},{"location":"examples/adapters/kafka/#testing-with-bdd","title":"Testing with BDD","text":"<p>The Kafka adapter comes with BDD tests to verify functionality. Here's a sample feature file:</p> <pre><code>Feature: Kafka Operations Testing\n  As a developer\n  I want to test Kafka messaging operations\n  So that I can ensure reliable message delivery\n\n  Scenario: Publishing and consuming messages\n    Given I have a Kafka topic \"test-topic\"\n    When I publish a message \"Hello, Kafka!\" to \"test-topic\"\n    Then I should be able to consume the message from \"test-topic\"\n</code></pre>"},{"location":"examples/adapters/keycloak/","title":"Keycloak Adapter Usage Guide","text":"<p>The Keycloak adapter provides an interface for interacting with Keycloak's API to manage authentication and authorization. ArchiPy offers both synchronous and asynchronous implementations.</p> <p>For full API reference, see the Keycloak Adapters API Documentation.</p>"},{"location":"examples/adapters/keycloak/#configuration","title":"Configuration","text":"<p>First, configure your Keycloak settings in your application config:</p> <pre><code>from archipy.configs.base_config import BaseConfig\nfrom archipy.configs.config_template import KeycloakConfig\n\nclass AppConfig(BaseConfig):\n    # Keycloak configuration\n    KEYCLOAK = KeycloakConfig(\n        SERVER_URL=\"https://keycloak.example.com\",\n        REALM_NAME=\"my-realm\",\n        CLIENT_ID=\"my-client\",\n        CLIENT_SECRET_KEY=\"client-secret\",  # Optional, required for admin operations\n        VERIFY_SSL=True,\n        TIMEOUT=10\n    )\n</code></pre>"},{"location":"examples/adapters/keycloak/#synchronous-adapter","title":"Synchronous Adapter","text":"<p>The synchronous adapter provides a blocking API for Keycloak operations.</p> <pre><code>from archipy.adapters.keycloak.adapters import KeycloakAdapter\n\n# Using global configuration\nkeycloak = KeycloakAdapter()\n\n# Or with custom configuration\ncustom_config = KeycloakConfig(\n    SERVER_URL=\"https://keycloak.example.com\",\n    REALM_NAME=\"another-realm\",\n    CLIENT_ID=\"another-client\",\n    CLIENT_SECRET_KEY=\"client-secret\"\n)\nkeycloak = KeycloakAdapter(custom_config)\n\n# Authentication\ntry:\n    # Get token with username/password\n    token = keycloak.get_token(\"username\", \"password\")\n    access_token = token[\"access_token\"]\n    refresh_token = token[\"refresh_token\"]\n\n    # Refresh an existing token\n    new_token = keycloak.refresh_token(refresh_token)\n\n    # Validate a token\n    is_valid = keycloak.validate_token(access_token)\n\n    # Get user info from token\n    user_info = keycloak.get_userinfo(access_token)\n\n    # Get token using client credentials\n    client_token = keycloak.get_client_credentials_token()\n\n    # Logout (invalidate refresh token)\n    keycloak.logout(refresh_token)\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n\n# User operations (requires admin privileges)\ntry:\n    # Get user by ID\n    user = keycloak.get_user_by_id(\"user-uuid\")\n\n    # Get user by username\n    user = keycloak.get_user_by_username(\"johndoe\")\n\n    # Get user by email\n    user = keycloak.get_user_by_email(\"john@example.com\")\n\n    # Create a new user\n    user_data = {\n        \"username\": \"newuser\",\n        \"email\": \"newuser@example.com\",\n        \"enabled\": True,\n        \"firstName\": \"New\",\n        \"lastName\": \"User\",\n        \"credentials\": [{\n            \"type\": \"password\",\n            \"value\": \"initial-password\",\n            \"temporary\": True\n        }]\n    }\n    user_id = keycloak.create_user(user_data)\n\n    # Update a user\n    update_data = {\"firstName\": \"Updated\", \"email\": \"updated@example.com\"}\n    keycloak.update_user(user_id, update_data)\n\n    # Reset password\n    keycloak.reset_password(user_id, \"new-password\", temporary=True)\n\n    # Search for users\n    users = keycloak.search_users(\"john\", max_results=10)\n\n    # Clear all user sessions\n    keycloak.clear_user_sessions(user_id)\n\n    # Delete a user\n    keycloak.delete_user(user_id)\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n\n# Role operations\ntry:\n    # Get user roles\n    roles = keycloak.get_user_roles(user_id)\n\n    # Get client roles for user\n    client_roles = keycloak.get_client_roles_for_user(user_id, \"client-id\")\n\n    # Check if user has role\n    has_role = keycloak.has_role(access_token, \"admin\")\n\n    # Check if user has any of the specified roles\n    has_any = keycloak.has_any_of_roles(access_token, {\"admin\", \"manager\"})\n\n    # Check if user has all specified roles\n    has_all = keycloak.has_all_roles(access_token, {\"user\", \"viewer\"})\n\n    # Assign realm role\n    keycloak.assign_realm_role(user_id, \"admin\")\n\n    # Remove realm role\n    keycloak.remove_realm_role(user_id, \"admin\")\n\n    # Assign client role\n    keycloak.assign_client_role(user_id, \"client-id\", \"client-admin\")\n\n    # Remove client role\n    keycloak.remove_client_role(user_id, \"client-id\", \"client-admin\")\n\n    # Get realm roles\n    all_roles = keycloak.get_realm_roles()\n\n    # Get a specific realm role\n    role = keycloak.get_realm_role(\"admin\")\n\n    # Create a realm role\n    new_role = keycloak.create_realm_role(\"new-role\", \"A new role description\")\n\n    # Delete a realm role\n    keycloak.delete_realm_role(\"new-role\")\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n\n# Client operations\ntry:\n    # Get client ID from name\n    client_id = keycloak.get_client_id(\"client-name\")\n\n    # Get client secret\n    secret = keycloak.get_client_secret(client_id)\n\n    # Get service account ID\n    service_account_id = keycloak.get_service_account_id()\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n\n# System operations\ntry:\n    # Get public key for token verification\n    public_key = keycloak.get_public_key()\n\n    # Get well-known OpenID configuration\n    config = keycloak.get_well_known_config()\n\n    # Get JWT certificates\n    certs = keycloak.get_certs()\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n\n# Authorization\ntry:\n    # Exchange authorization code for token\n    token = keycloak.get_token_from_code(\"auth-code\", \"https://my-app.example.com/callback\")\n\n    # Check permissions\n    has_permission = keycloak.check_permissions(access_token, \"resource-name\", \"view\")\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n</code></pre>"},{"location":"examples/adapters/keycloak/#asynchronous-adapter","title":"Asynchronous Adapter","text":"<p>The asynchronous adapter provides a non-blocking API using <code>async/await</code> syntax:</p> <pre><code>import asyncio\nfrom archipy.adapters.keycloak.adapters import AsyncKeycloakAdapter\n\nasync def main():\n    # Initialize with global config\n    keycloak = AsyncKeycloakAdapter()\n\n    try:\n        # Get token\n        token = await keycloak.get_token(\"username\", \"password\")\n        access_token = token[\"access_token\"]\n\n        # Get user info\n        user_info = await keycloak.get_userinfo(access_token)\n        print(f\"Logged in as: {user_info.get('preferred_username')}\")\n\n        # Check if user has role\n        if await keycloak.has_role(access_token, \"admin\"):\n            print(\"User has admin role\")\n\n        # Search for users\n        users = await keycloak.search_users(\"john\")\n        print(f\"Found {len(users)} users matching 'john'\")\n\n        # Create a new user\n        user_data = {\n            \"username\": \"async_user\",\n            \"email\": \"async@example.com\",\n            \"enabled\": True,\n        }\n        user_id = await keycloak.create_user(user_data)\n        print(f\"Created user with ID: {user_id}\")\n\n        # Delete the user\n        await keycloak.delete_user(user_id)\n    except ValueError as e:\n        print(f\"Keycloak error: {e}\")\n\n# Run the async function\nasyncio.run(main())\n</code></pre>"},{"location":"examples/adapters/keycloak/#caching","title":"Caching","text":"<p>Both adapters use TTL (Time-To-Live) caching for appropriate operations to improve performance. Cache durations are configured for each method based on how frequently the data typically changes:</p> <ul> <li>Public keys and certificate information: 1 hour</li> <li>User information from tokens: 30 seconds</li> <li>User details and role information: 5 minutes</li> </ul> <p>You can clear all caches if needed:</p> <pre><code># Sync adapter\nkeycloak = KeycloakAdapter()\nkeycloak.clear_all_caches()\n\n# Async adapter\nasync_keycloak = AsyncKeycloakAdapter()\nasync_keycloak.clear_all_caches()\n</code></pre>"},{"location":"examples/adapters/keycloak/#security-considerations","title":"Security Considerations","text":"<ul> <li>Token validation is performed without caching to ensure security.</li> <li>The adapter automatically refreshes admin tokens before they expire.</li> <li>Write operations (like user creation/updates) automatically clear relevant caches.</li> <li>For production use, prefer the authorization code flow over direct username/password authentication.</li> </ul>"},{"location":"examples/adapters/minio/","title":"Minio Adapter","text":"<p>The Minio adapter provides a clean interface for interacting with MinIO and S3-compatible object storage services.</p>"},{"location":"examples/adapters/minio/#features","title":"Features","text":"<ul> <li>Bucket operations (create, list, delete)</li> <li>Object operations (upload, download, delete)</li> <li>Presigned URL generation</li> <li>Bucket policy management</li> <li>Built-in caching for performance optimization</li> <li>Comprehensive error handling with domain-specific exceptions</li> </ul>"},{"location":"examples/adapters/minio/#basic-usage","title":"Basic Usage","text":""},{"location":"examples/adapters/minio/#configuration","title":"Configuration","text":"<p>Configure MinIO in your application's config:</p> <pre><code>from archipy.configs.base_config import BaseConfig\n\n# Method 1: Using environment variables\n# MINIO__ENDPOINT=localhost:9000\n# MINIO__ACCESS_KEY=minioadmin\n# MINIO__SECRET_KEY=minioadmin\n\n# Method 2: Direct configuration\nBaseConfig.global_config().MINIO.ENDPOINT = \"localhost:9000\"\nBaseConfig.global_config().MINIO.ACCESS_KEY = \"minioadmin\"\nBaseConfig.global_config().MINIO.SECRET_KEY = \"minioadmin\"\nBaseConfig.global_config().MINIO.SECURE = False  # Set to True for HTTPS\n</code></pre>"},{"location":"examples/adapters/minio/#initializing-the-adapter","title":"Initializing the Adapter","text":"<pre><code>from archipy.adapters.minio.adapters import MinioAdapter\n\n# Use global configuration\nminio = MinioAdapter()\n\n# Or provide specific configuration\nfrom archipy.configs.config_template import MinioConfig\n\ncustom_config = MinioConfig(\n    ENDPOINT=\"play.min.io:9000\",\n    ACCESS_KEY=\"your-access-key\",\n    SECRET_KEY=\"your-secret-key\",\n    SECURE=True\n)\nminio = MinioAdapter(custom_config)\n</code></pre>"},{"location":"examples/adapters/minio/#bucket-operations","title":"Bucket Operations","text":"<pre><code>import logging\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Check if bucket exists\nif not minio.bucket_exists(\"my-bucket\"):\n    # Create bucket\n    minio.make_bucket(\"my-bucket\")\n    logger.info(\"Bucket created successfully\")\n\n# List all buckets\nbuckets = minio.list_buckets()\nfor bucket in buckets:\n    logger.info(f\"Bucket: {bucket['name']}, Created: {bucket['creation_date']}\")\n\n# Remove bucket\nminio.remove_bucket(\"my-bucket\")\n</code></pre>"},{"location":"examples/adapters/minio/#working-with-objects","title":"Working with Objects","text":"<pre><code>import logging\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Upload a file\nminio.put_object(\"my-bucket\", \"document.pdf\", \"/path/to/local/document.pdf\")\n\n# Download an object\nminio.get_object(\"my-bucket\", \"document.pdf\", \"/path/to/download/document.pdf\")\n\n# List objects in a bucket\nobjects = minio.list_objects(\"my-bucket\", prefix=\"documents/\", recursive=True)\nfor obj in objects:\n    logger.info(f\"Object: {obj['object_name']}, Size: {obj['size']} bytes\")\n\n# Get object metadata\nmetadata = minio.stat_object(\"my-bucket\", \"document.pdf\")\nlogger.info(f\"Content type: {metadata['content_type']}\")\nlogger.info(f\"Last modified: {metadata['last_modified']}\")\n\n# Remove an object\nminio.remove_object(\"my-bucket\", \"document.pdf\")\n</code></pre>"},{"location":"examples/adapters/minio/#generating-presigned-urls","title":"Generating Presigned URLs","text":"<pre><code>import logging\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Generate a presigned URL for downloading (valid for 1 hour by default)\ndownload_url = minio.presigned_get_object(\"my-bucket\", \"document.pdf\")\nlogger.info(f\"Download URL: {download_url}\")\n\n# Generate a presigned URL for uploading (with custom expiry time in seconds)\nupload_url = minio.presigned_put_object(\"my-bucket\", \"new-document.pdf\", expires=7200)  # 2 hours\nlogger.info(f\"Upload URL: {upload_url}\")\n</code></pre>"},{"location":"examples/adapters/minio/#managing-bucket-policies","title":"Managing Bucket Policies","text":"<pre><code>import logging\nimport json\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Set a read-only policy for a bucket\npolicy = {\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Principal\": {\"AWS\": \"*\"},\n            \"Action\": [\"s3:GetObject\"],\n            \"Resource\": [f\"arn:aws:s3:::my-bucket/*\"]\n        }\n    ]\n}\nminio.set_bucket_policy(\"my-bucket\", json.dumps(policy))\n\n# Get bucket policy\npolicy_info = minio.get_bucket_policy(\"my-bucket\")\nlogger.info(f\"Bucket policy: {policy_info['policy']}\")\n</code></pre>"},{"location":"examples/adapters/minio/#error-handling","title":"Error Handling","text":"<p>The MinioAdapter uses ArchiPy's domain-specific exceptions for consistent error handling:</p> <pre><code>import logging\nfrom archipy.models.errors import (\n    AlreadyExistsError,\n    InternalError,\n    InvalidArgumentError,\n    NotFoundError,\n    PermissionDeniedError,\n)\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\ntry:\n    minio.make_bucket(\"existing-bucket\")\nexcept AlreadyExistsError:\n    logger.warning(\"Bucket already exists\")\nexcept PermissionDeniedError:\n    logger.exception(\"Permission denied to create bucket\")\nexcept InvalidArgumentError as e:\n    logger.exception(f\"Invalid argument: {e}\")\nexcept InternalError as e:\n    logger.exception(f\"Internal error: {e}\")\n</code></pre>"},{"location":"examples/adapters/minio/#performance-optimization","title":"Performance Optimization","text":"<p>The MinioAdapter includes TTL caching for frequently accessed operations:</p> <pre><code># Check if bucket exists (cached for 5 minutes)\nminio.bucket_exists(\"my-bucket\")\n\n# List buckets (cached for 5 minutes)\nminio.list_buckets()\n\n# Clear all caches if needed\nminio.clear_all_caches()\n</code></pre>"},{"location":"examples/adapters/minio/#integration-with-web-applications","title":"Integration with Web Applications","text":""},{"location":"examples/adapters/minio/#fastapi-example","title":"FastAPI Example","text":"<pre><code>from fastapi import FastAPI, File, UploadFile, HTTPException\nfrom fastapi.responses import RedirectResponse\nimport tempfile\nimport os\n\nfrom archipy.adapters.minio.adapters import MinioAdapter\nfrom archipy.models.errors import NotFoundError, PermissionDeniedError\n\napp = FastAPI()\nminio = MinioAdapter()\n\n@app.post(\"/upload/{bucket_name}\")\nasync def upload_file(bucket_name: str, file: UploadFile):\n    try:\n        # Save uploaded file to temporary location\n        with tempfile.NamedTemporaryFile(delete=False) as temp:\n            content = await file.read()\n            temp.write(content)\n            temp_path = temp.name\n\n        # Upload to MinIO\n        try:\n            minio.put_object(bucket_name, file.filename, temp_path)\n            return {\"message\": f\"File {file.filename} uploaded successfully\"}\n        finally:\n            os.unlink(temp_path)  # Clean up temp file\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/download/{bucket_name}/{object_name}\")\nasync def download_file(bucket_name: str, object_name: str):\n    try:\n        # Generate presigned URL\n        url = minio.presigned_get_object(bucket_name, object_name, expires=3600)\n        return RedirectResponse(url)\n    except NotFoundError:\n        raise HTTPException(status_code=404, detail=\"File not found\")\n    except PermissionDeniedError:\n        raise HTTPException(status_code=403, detail=\"Permission denied\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre>"},{"location":"examples/adapters/minio/#testing-with-bdd","title":"Testing with BDD","text":"<p>The Minio adapter comes with BDD tests to verify functionality. Here's a sample feature file:</p> <pre><code>Feature: MinIO Operations Testing\n  As a developer\n  I want to test MinIO storage operations\n  So that I can ensure reliable object storage functionality\n\n  Background:\n    Given a configured MinIO adapter\n\n  Scenario: Create and verify a bucket\n    When I create a bucket named \"test-bucket\"\n    Then the bucket \"test-bucket\" should exist\n    And the bucket list should include \"test-bucket\"\n\n  Scenario: Upload and retrieve object\n    Given a bucket named \"test-bucket\" exists\n    When I upload a file \"test.txt\" with content \"Hello World\" to bucket \"test-bucket\"\n    Then the object \"test.txt\" should exist in bucket \"test-bucket\"\n    And downloading \"test.txt\" from \"test-bucket\" should return content \"Hello World\"\n</code></pre>"},{"location":"examples/adapters/parsian_payment/","title":"Parsian Shaparak Payment Gateway","text":"<p>This example demonstrates how to use the Parsian Shaparak payment gateway adapter to process online payments in Iran.</p>"},{"location":"examples/adapters/parsian_payment/#configuration","title":"Configuration","text":"<p>First, configure the Parsian Shaparak settings in your environment or configuration file:</p> <pre><code>from pydantic import BaseModel\nfrom archipy.configs.base_config import BaseConfig\nfrom archipy.configs.config_template import ParsianShaparakConfig\n\nclass MyAppConfig(BaseConfig):\n    # Other configuration settings\n\n    # Parsian Shaparak Configuration\n    PARSIAN_SHAPARAK: ParsianShaparakConfig = ParsianShaparakConfig(\n        LOGIN_ACCOUNT=\"your_merchant_login_account\",\n        # Optionally specify custom WSDL URLs if needed\n        # PAYMENT_WSDL_URL=\"https://custom.url/to/payment/wsdl\",\n        # CONFIRM_WSDL_URL=\"https://custom.url/to/confirm/wsdl\",\n        # REVERSAL_WSDL_URL=\"https://custom.url/to/reversal/wsdl\",\n        # Optionally specify proxy settings\n        # PROXIES={\"http\": \"http://proxy:port\", \"https\": \"https://proxy:port\"}\n    )\n</code></pre>"},{"location":"examples/adapters/parsian_payment/#initializing-the-adapter","title":"Initializing the Adapter","text":"<pre><code>from archipy.adapters.internet_payment_gateways.ir.parsian.adapters import (\n    ParsianShaparakPaymentAdapter,\n    PaymentRequestDTO,\n    ConfirmRequestDTO,\n    ConfirmWithAmountRequestDTO,\n    ReverseRequestDTO\n)\n\n# Initialize the payment adapter\npayment_adapter = ParsianShaparakPaymentAdapter()\n</code></pre>"},{"location":"examples/adapters/parsian_payment/#processing-payments","title":"Processing Payments","text":""},{"location":"examples/adapters/parsian_payment/#initiating-a-payment","title":"Initiating a Payment","text":"<p>To start a payment transaction:</p> <pre><code># Create payment request\npayment_request = PaymentRequestDTO(\n    amount=10000,  # Amount in IRR (10,000 Rials)\n    order_id=12345,  # Your unique order ID\n    callback_url=\"https://your-app.com/payment/callback\",  # URL to redirect after payment\n    additional_data=\"Optional additional data\",  # Optional\n    originator=\"Optional originator info\"  # Optional\n)\n\n# Send payment request\npayment_response = payment_adapter.initiate_payment(payment_request)\n\n# Check response\nif payment_response.status == 0:  # 0 means success in Parsian API\n    # Redirect user to payment page\n    payment_url = f\"https://pec.shaparak.ir/NewIPG/?Token={payment_response.token}\"\n    # Use this URL to redirect the user to the payment gateway\nelse:\n    # Handle error\n    print(f\"Payment initiation failed: {payment_response.message}\")\n</code></pre>"},{"location":"examples/adapters/parsian_payment/#confirming-a-payment","title":"Confirming a Payment","text":"<p>After the user completes the payment and returns to your callback URL, confirm the payment:</p> <pre><code># Get the token from query parameters in your callback handler\ntoken = 123456789  # This would come from the callback request\n\n# Create confirm request\nconfirm_request = ConfirmRequestDTO(token=token)\n\n# Confirm payment\nconfirm_response = payment_adapter.confirm_payment(confirm_request)\n\nif confirm_response.status == 0:  # 0 means success\n    # Payment successful\n    reference_number = confirm_response.rrn\n    masked_card = confirm_response.card_number_masked\n\n    # Process the successful payment in your system\n    print(f\"Payment confirmed! Reference: {reference_number}, Card: {masked_card}\")\nelse:\n    # Handle failed confirmation\n    print(f\"Payment confirmation failed with status: {confirm_response.status}\")\n</code></pre>"},{"location":"examples/adapters/parsian_payment/#confirming-with-amount-verification","title":"Confirming with Amount Verification","text":"<p>For enhanced security, you can confirm with amount verification:</p> <pre><code># Create confirm with amount request\nconfirm_with_amount_request = ConfirmWithAmountRequestDTO(\n    token=123456789,\n    order_id=12345,\n    amount=10000\n)\n\n# Confirm payment with amount verification\nconfirm_response = payment_adapter.confirm_payment_with_amount(confirm_with_amount_request)\n\nif confirm_response.status == 0:  # 0 means success\n    # Payment successful with amount verification\n    print(f\"Payment confirmed with amount verification!\")\nelse:\n    # Handle failed confirmation\n    print(f\"Payment confirmation failed with status: {confirm_response.status}\")\n</code></pre>"},{"location":"examples/adapters/parsian_payment/#reversing-a-payment","title":"Reversing a Payment","text":"<p>If needed, you can reverse (refund) a successful payment:</p> <pre><code># Create reverse request\nreverse_request = ReverseRequestDTO(token=123456789)\n\n# Request payment reversal\nreverse_response = payment_adapter.reverse_payment(reverse_request)\n\nif reverse_response.status == 0:  # 0 means success\n    # Reversal successful\n    print(f\"Payment reversal successful!\")\nelse:\n    # Handle failed reversal\n    print(f\"Payment reversal failed: {reverse_response.message}\")\n</code></pre>"},{"location":"examples/adapters/parsian_payment/#error-handling","title":"Error Handling","text":"<p>The adapter uses ArchiPy's error system to provide consistent error handling:</p> <pre><code>from archipy.models.errors import UnavailableError, InternalError\n\ntry:\n    payment_response = payment_adapter.initiate_payment(payment_request)\nexcept UnavailableError as e:\n    # Handle service unavailable error\n    print(f\"Payment service unavailable: {e}\")\nexcept InternalError as e:\n    # Handle unexpected error\n    print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"examples/adapters/parsian_payment/#complete-example","title":"Complete Example","text":"<p>Here's a complete example integrating the payment flow into a FastAPI application:</p> <pre><code>from fastapi import FastAPI, Request, Depends, HTTPException, status\nfrom fastapi.responses import RedirectResponse\nfrom pydantic import BaseModel\nfrom typing import Annotated\n\nfrom archipy.adapters.internet_payment_gateways.ir.parsian.adapters import (\n    ParsianShaparakPaymentAdapter,\n    PaymentRequestDTO,\n    ConfirmRequestDTO\n)\nfrom archipy.models.errors import UnavailableError, InternalError\n\napp = FastAPI()\npayment_adapter = ParsianShaparakPaymentAdapter()\n\n# Create order model\nclass OrderCreate(BaseModel):\n    amount: int\n    order_id: int\n    description: str = None\n\n# Payment routes\n@app.post(\"/payments/create\")\nasync def create_payment(order: OrderCreate):\n    try:\n        payment_request = PaymentRequestDTO(\n            amount=order.amount,\n            order_id=order.order_id,\n            callback_url=f\"https://your-app.com/payments/callback\",\n            additional_data=order.description\n        )\n\n        response = payment_adapter.initiate_payment(payment_request)\n\n        if response.status != 0:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=f\"Payment initiation failed: {response.message}\"\n            )\n\n        # Return payment URL or token\n        return {\n            \"token\": response.token,\n            \"payment_url\": f\"https://pec.shaparak.ir/NewIPG/?Token={response.token}\"\n        }\n\n    except UnavailableError as e:\n        raise HTTPException(\n            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n            detail=\"Payment service unavailable\"\n        )\n    except InternalError as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Internal server error\"\n        )\n\n@app.get(\"/payments/callback\")\nasync def payment_callback(token: int, request: Request):\n    try:\n        confirm_request = ConfirmRequestDTO(token=token)\n        confirm_response = payment_adapter.confirm_payment(confirm_request)\n\n        if confirm_response.status == 0:\n            # Payment successful - update your database\n            return {\n                \"status\": \"success\",\n                \"reference_number\": confirm_response.rrn,\n                \"card\": confirm_response.card_number_masked\n            }\n        else:\n            return {\n                \"status\": \"failed\",\n                \"message\": \"Payment verification failed\"\n            }\n\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": str(e)\n        }\n</code></pre>"},{"location":"examples/adapters/postgres/","title":"PostgreSQL Adapter","text":"<p>This example demonstrates how to use the PostgreSQL adapter for database operations.</p>"},{"location":"examples/adapters/postgres/#basic-usage","title":"Basic Usage","text":"<pre><code>from typing import Any\nfrom uuid import UUID\n\nfrom archipy.adapters.postgres.sqlalchemy.adapters import PostgresSQLAlchemyAdapter\nfrom archipy.models.entities.sqlalchemy.base_entities import BaseEntity\nfrom sqlalchemy import Column, String\n\n\n# Define a model\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n    username = Column(String(100), unique=True)\n    email = Column(String(255), unique=True)\n\n\n# Create adapter\nadapter = PostgresSQLAlchemyAdapter()\n\n# Create tables\nBaseEntity.metadata.create_all(adapter.session_manager.engine)\n\n# Basic operations\ntry:\n    # Get session\n    session = adapter.get_session()\n\n    # Create\n    user = User(username=\"john_doe\", email=\"john@example.com\")\n    session.add(user)\n    session.commit()\n\n    # Read\n    user = session.query(User).filter_by(username=\"john_doe\").first()\n    print(user.email)  # john@example.com\n\n    # Update\n    user.email = \"john.doe@example.com\"\n    session.commit()\n\n    # Delete\n    session.delete(user)\n    session.commit()\nexcept Exception as e:\n    # The adapter's SQLAlchemyExceptionHandlerMixin will handle\n    # and convert common exceptions to application-specific ones\n    # These will already preserve the original error context with `from e`\n    raise\n</code></pre>"},{"location":"examples/adapters/postgres/#using-transactions","title":"Using Transactions","text":"<pre><code>from archipy.helpers.decorators.sqlalchemy_atomic import postgres_sqlalchemy_atomic_decorator\nfrom archipy.models.errors import DatabaseQueryError, AlreadyExistsError\n\n\n@postgres_sqlalchemy_atomic_decorator\ndef create_user_with_profile(username: str, email: str, profile_data: dict[str, Any]) -&gt; User:\n    \"\"\"Create a user and associated profile in a transaction.\n\n    If any part fails, the entire transaction is rolled back.\n\n    Args:\n        username: User's username\n        email: User's email\n        profile_data: Dictionary of profile data\n\n    Returns:\n        User: The created user object\n\n    Raises:\n        DatabaseQueryError: If a database error occurs\n        AlreadyExistsError: If the user or profile already exists\n    \"\"\"\n    try:\n        # Create user\n        user = User(username=username, email=email)\n        adapter.create(user)\n\n        # Create profile with user's UUID\n        profile = Profile(user_id=user.uuid, **profile_data)\n        adapter.create(profile)\n\n        return user\n    except Exception as e:\n        # The decorator will automatically handle the transaction,\n        # rolling back on error and converting exceptions\n        raise\n</code></pre>"},{"location":"examples/adapters/postgres/#async-operations","title":"Async Operations","text":"<pre><code>import asyncio\nfrom typing import Any\nfrom uuid import UUID\n\nfrom archipy.adapters.postgres.sqlalchemy.adapters import AsyncPostgresSQLAlchemyAdapter\nfrom archipy.helpers.decorators.sqlalchemy_atomic import async_postgres_sqlalchemy_atomic_decorator\nfrom archipy.models.errors import DatabaseConnectionError, DatabaseQueryError\n\n\nasync def main() -&gt; None:\n    adapter = AsyncPostgresSQLAlchemyAdapter()\n\n    @async_postgres_sqlalchemy_atomic_decorator\n    async def create_user_async(username: str, email: str) -&gt; User:\n        \"\"\"Create a user asynchronously within a transaction.\n\n        Args:\n            username: User's username\n            email: User's email\n\n        Returns:\n            User: The created user object\n\n        Raises:\n            DatabaseQueryError: If a database error occurs\n            DatabaseConnectionError: If a connection error occurs\n        \"\"\"\n        user = User(username=username, email=email)\n        return await adapter.create(user)\n\n    try:\n        user = await create_user_async(\"jane_doe\", \"jane@example.com\")\n        print(user.username)  # jane_doe\n    except (DatabaseConnectionError, DatabaseQueryError) as e:\n        print(f\"Database error: {e}\")\n</code></pre>"},{"location":"examples/adapters/postgres/#error-handling","title":"Error Handling","text":"<pre><code>from archipy.models.errors import (\n    AlreadyExistsError,\n    NotFoundError,\n    DatabaseConnectionError,\n    DatabaseQueryError\n)\nfrom typing import Optional\nfrom uuid import UUID\n\n\ndef get_user_by_id(user_id: UUID) -&gt; Optional[User]:\n    \"\"\"Get a user by their UUID.\n\n    Args:\n        user_id: User UUID to look up\n\n    Returns:\n        User or None: The found user or None if not found\n\n    Raises:\n        NotFoundError: If user doesn't exist\n        DatabaseConnectionError: If database connection fails\n        DatabaseQueryError: For other database errors\n    \"\"\"\n    try:\n        user = adapter.get_by_uuid(User, user_id)\n        if not user:\n            raise NotFoundError(\n                resource_type=\"user\",\n                additional_data={\"user_id\": str(user_id)}\n            )\n        return user\n    except AlreadyExistsError as e:\n        # This would be unlikely for a get operation but included for example\n        print(f\"User already exists: {e}\")\n        raise\n    except (DatabaseConnectionError, DatabaseQueryError) as e:\n        # The adapter's exception handler will have already\n        # converted common exceptions with proper chaining\n        print(f\"Database error: {e}\")\n        raise\n</code></pre>"},{"location":"examples/adapters/redis/","title":"Redis Adapter Examples","text":"<p>This guide demonstrates how to use the ArchiPy Redis adapter for common caching and key-value storage patterns.</p>"},{"location":"examples/adapters/redis/#basic-usage","title":"Basic Usage","text":""},{"location":"examples/adapters/redis/#installation","title":"Installation","text":"<p>First, ensure you have the Redis dependencies installed:</p> <pre><code>pip install \"archipy[redis]\"\n# or\nuv add \"archipy[redis]\"\n</code></pre>"},{"location":"examples/adapters/redis/#synchronous-redis-adapter","title":"Synchronous Redis Adapter","text":"<pre><code>from archipy.adapters.redis.adapters import RedisAdapter\nfrom archipy.models.errors import CacheError\n\ntry:\n    # Create a Redis adapter with connection details\n    redis = RedisAdapter(\n        host=\"localhost\",\n        port=6379,\n        db=0,\n        password=None  # Optional\n    )\n\n    # Set and get values\n    redis.set(\"user:123:name\", \"John Doe\")\n    name = redis.get(\"user:123:name\")\n    print(f\"User name: {name}\")  # Output: User name: John Doe\n\n    # Set with expiration (seconds)\n    redis.set(\"session:456\", \"active\", ex=3600)  # Expires in 1 hour\n\n    # Delete a key\n    redis.delete(\"user:123:name\")\n\n    # Check if key exists\n    if redis.exists(\"session:456\"):\n        print(\"Session exists\")\nexcept CacheError as e:\n    print(f\"Redis operation failed: {str(e)}\")\n</code></pre>"},{"location":"examples/adapters/redis/#asynchronous-redis-adapter","title":"Asynchronous Redis Adapter","text":"<pre><code>import asyncio\nfrom typing import Optional\n\nfrom archipy.adapters.redis.adapters import AsyncRedisAdapter\nfrom archipy.models.errors import CacheError\n\n\nasync def main() -&gt; None:\n    try:\n        # Create an async Redis adapter\n        redis = AsyncRedisAdapter(\n            host=\"localhost\",\n            port=6379,\n            db=0\n        )\n\n        # Async operations\n        await redis.set(\"counter\", \"1\")\n        await redis.incr(\"counter\")  # Increment\n        count = await redis.get(\"counter\")\n        print(f\"Counter: {count}\")  # Output: Counter: 2\n\n        # Cleanup\n        await redis.close()\n    except CacheError as e:\n        print(f\"Redis operation failed: {str(e)}\")\n\n\n# Run the async function\nasyncio.run(main())\n</code></pre>"},{"location":"examples/adapters/redis/#caching-patterns","title":"Caching Patterns","text":""},{"location":"examples/adapters/redis/#function-result-caching","title":"Function Result Caching","text":"<pre><code>import json\nimport time\nfrom functools import wraps\nfrom typing import Any, Callable, TypeVar, cast\n\nfrom archipy.adapters.redis.adapters import RedisAdapter\nfrom archipy.models.errors import CacheError, CacheMissError\n\n# Define a type variable for generic function types\nT = TypeVar('T', bound=Callable[..., Any])\n\n# Create a Redis adapter\nredis = RedisAdapter(host=\"localhost\", port=6379, db=0)\n\n\ndef cache_result(key_prefix: str, ttl: int = 300) -&gt; Callable[[T], T]:\n    \"\"\"Decorator to cache function results in Redis.\n\n    Args:\n        key_prefix: Prefix for the Redis cache key\n        ttl: Time-to-live in seconds (default: 5 minutes)\n\n    Returns:\n        Decorated function with Redis caching\n    \"\"\"\n\n    def decorator(func: T) -&gt; T:\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            # Create a cache key with function name and arguments\n            cache_key = f\"{key_prefix}:{func.__name__}:{hash(str(args) + str(kwargs))}\"\n\n            try:\n                # Try to get from cache\n                cached = redis.get(cache_key)\n                if cached:\n                    return json.loads(cached)\n\n                # Execute function and cache result\n                result = func(*args, **kwargs)\n                redis.set(cache_key, json.dumps(result), ex=ttl)\n                return result\n            except CacheMissError:\n                # Execute function if not in cache\n                result = func(*args, **kwargs)\n                try:\n                    redis.set(cache_key, json.dumps(result), ex=ttl)\n                except CacheError as e:\n                    # Log but don't fail if caching fails\n                    print(f\"Failed to cache result: {e}\")\n                return result\n            except CacheError as e:\n                # Execute function if Redis fails\n                print(f\"Redis error: {e}\")\n                return func(*args, **kwargs)\n\n        return cast(T, wrapper)\n\n    return decorator\n\n\n# Example usage\n@cache_result(\"api\", ttl=60)\ndef expensive_api_call(item_id: int) -&gt; dict[str, Any]:\n    \"\"\"Simulate an expensive API call.\n\n    Args:\n        item_id: ID of the item to fetch\n\n    Returns:\n        Item data dictionary\n    \"\"\"\n    print(\"Executing expensive operation...\")\n    time.sleep(1)  # Simulate expensive operation\n    return {\"id\": item_id, \"name\": f\"Item {item_id}\", \"data\": \"Some data\"}\n\n\n# First call will execute the function\nresult1 = expensive_api_call(123)\nprint(\"First call:\", result1)\n\n# Second call will retrieve from cache\nresult2 = expensive_api_call(123)\nprint(\"Second call:\", result2)\n</code></pre>"},{"location":"examples/adapters/redis/#mock-redis-for-testing","title":"Mock Redis for Testing","text":"<p>ArchiPy provides a Redis mock for unit testing that doesn't require a real Redis server:</p> <pre><code>import unittest\nfrom typing import Optional\n\nfrom archipy.adapters.redis.adapters import RedisAdapter\nfrom archipy.adapters.redis.mocks import RedisMock\nfrom archipy.models.errors import CacheError, CacheMissError\n\n\nclass UserService:\n    def __init__(self, redis_adapter: RedisAdapter) -&gt; None:\n        self.redis = redis_adapter\n\n    def get_user(self, user_id: int) -&gt; str:\n        \"\"\"Get user data, either from cache or backend.\n\n        Args:\n            user_id: User ID to look up\n\n        Returns:\n            User data as a string\n\n        Raises:\n            CacheError: If Redis operation fails\n        \"\"\"\n        try:\n            cache_key = f\"user:{user_id}\"\n            cached = self.redis.get(cache_key)\n            if cached:\n                return cached\n\n            # In real code, we'd fetch from database if not in cache\n            user_data = f\"User {user_id} data\"\n            self.redis.set(cache_key, user_data, ex=300)\n            return user_data\n        except CacheMissError:\n            # Handle cache miss\n            user_data = f\"User {user_id} data\"\n            try:\n                self.redis.set(f\"user:{user_id}\", user_data, ex=300)\n            except CacheError:\n                pass  # Ignore error setting cache\n            return user_data\n\n\nclass TestUserService(unittest.TestCase):\n    def setUp(self) -&gt; None:\n        # Use the RedisMock instead of a real Redis connection\n        self.redis_mock = RedisMock()\n        self.user_service = UserService(self.redis_mock)\n\n    def test_get_user(self) -&gt; None:\n        # Test first fetch (not cached)\n        user_data = self.user_service.get_user(123)\n        self.assertEqual(user_data, \"User 123 data\")\n\n        # Test that it was cached\n        self.assertEqual(self.redis_mock.get(\"user:123\"), \"User 123 data\")\n\n        # Change the cached value to test cache hit\n        self.redis_mock.set(\"user:123\", \"Modified data\")\n\n        # Test cached fetch\n        user_data = self.user_service.get_user(123)\n        self.assertEqual(user_data, \"Modified data\")\n\n\n# Run the test\nif __name__ == \"__main__\":\n    unittest.main()\n</code></pre>"},{"location":"examples/adapters/redis/#advanced-redis-features","title":"Advanced Redis Features","text":""},{"location":"examples/adapters/redis/#publishsubscribe","title":"Publish/Subscribe","text":"<pre><code>import threading\nimport time\nfrom typing import Dict, Any\n\nfrom archipy.adapters.redis.adapters import RedisAdapter\nfrom archipy.models.errors import CacheError\n\n\n# Subscriber thread\ndef subscribe_thread() -&gt; None:\n    try:\n        subscriber = RedisAdapter(host=\"localhost\", port=6379, db=0)\n        pubsub = subscriber.pubsub()\n\n        def message_handler(message: Dict[str, Any]) -&gt; None:\n            if message[\"type\"] == \"message\":\n                print(f\"Received message: {message['data']}\")\n\n        pubsub.subscribe(**{\"channel:notifications\": message_handler})\n        pubsub.run_in_thread(sleep_time=0.5)\n\n        # Keep thread running for demo\n        time.sleep(10)\n        pubsub.close()\n    except CacheError as e:\n        print(f\"Redis subscription error: {e}\")\n\n\ntry:\n    # Start subscriber in background\n    thread = threading.Thread(target=subscribe_thread)\n    thread.start()\n\n    # Wait for subscriber to initialize\n    time.sleep(1)\n\n    # Create publisher\n    redis = RedisAdapter(host=\"localhost\", port=6379, db=0)\n\n    # Publish messages\n    for i in range(5):\n        message = f\"Notification {i}\"\n        redis.publish(\"channel:notifications\", message)\n        time.sleep(1)\n\n    # Wait for thread to complete\n    thread.join()\nexcept CacheError as e:\n    print(f\"Redis publisher error: {e}\")\nexcept Exception as e:\n    print(f\"General error: {e}\")\n</code></pre>"},{"location":"examples/adapters/redis/#pipeline-for-multiple-operations","title":"Pipeline for Multiple Operations","text":"<pre><code>from typing import List\n\nfrom archipy.adapters.redis.adapters import RedisAdapter\nfrom archipy.models.errors import CacheError\n\ntry:\n    redis = RedisAdapter(host=\"localhost\", port=6379, db=0)\n\n    # Create a pipeline for atomic operations\n    pipe = redis.pipeline()\n    pipe.set(\"stats:visits\", 0)\n    pipe.set(\"stats:unique_users\", 0)\n    pipe.set(\"stats:conversion_rate\", \"0.0\")\n    pipe.execute()  # Execute all commands at once\n\n    # Increment multiple counters atomically\n    pipe = redis.pipeline()\n    pipe.incr(\"stats:visits\")\n    pipe.incr(\"stats:unique_users\")\n    results: List[int] = pipe.execute()\n    print(f\"Visits: {results[0]}, Unique users: {results[1]}\")\nexcept CacheError as e:\n    print(f\"Redis pipeline error: {e}\")\n</code></pre>"},{"location":"examples/adapters/sqlite/","title":"SQLite Adapter","text":"<p>This example demonstrates how to use the SQLite adapter for database operations.</p>"},{"location":"examples/adapters/sqlite/#basic-usage","title":"Basic Usage","text":"<pre><code>from archipy.adapters.sqlite.sqlalchemy.adapters import SQLiteSQLAlchemyAdapter\nfrom archipy.models.entities.sqlalchemy.base_entities import BaseEntity\nfrom sqlalchemy import Column, String\n\n# Define a model\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n    username = Column(String(100), unique=True)\n    email = Column(String(255), unique=True)\n\n# Create adapter\nadapter = SQLiteSQLAlchemyAdapter()\n\n# Create tables\nBaseEntity.metadata.create_all(adapter.session_manager.engine)\n\n# Basic operations\nwith adapter.session() as session:\n    # Create\n    user = User(username=\"john_doe\", email=\"john@example.com\")\n    session.add(user)\n    session.commit()\n\n    # Read\n    user = session.query(User).filter_by(username=\"john_doe\").first()\n    print(user.email)  # john@example.com\n\n    # Update\n    user.email = \"john.doe@example.com\"\n    session.commit()\n\n    # Delete\n    session.delete(user)\n    session.commit()\n</code></pre>"},{"location":"examples/adapters/sqlite/#using-transactions","title":"Using Transactions","text":"<pre><code>from archipy.helpers.decorators.sqlalchemy_atomic import sqlite_sqlalchemy_atomic_decorator\n\n@sqlite_sqlalchemy_atomic_decorator\ndef create_user_with_profile(username, email, profile_data):\n    user = User(username=username, email=email)\n    adapter.create(user)\n\n    profile = Profile(user_id=user.test_uuid, **profile_data)\n    adapter.create(profile)\n\n    return user\n</code></pre>"},{"location":"examples/adapters/sqlite/#async-operations","title":"Async Operations","text":"<pre><code>from archipy.adapters.sqlite.sqlalchemy.adapters import AsyncSQLiteSQLAlchemyAdapter\nfrom archipy.helpers.decorators.sqlalchemy_atomic import async_sqlite_sqlalchemy_atomic_decorator\n\nasync def main():\n    adapter = AsyncSQLiteSQLAlchemyAdapter()\n\n    @async_sqlite_sqlalchemy_atomic_decorator\n    async def create_user_async(username, email):\n        user = User(username=username, email=email)\n        return await adapter.create(user)\n\n    user = await create_user_async(\"jane_doe\", \"jane@example.com\")\n    print(user.username)  # jane_doe\n</code></pre>"},{"location":"examples/adapters/sqlite/#error-handling","title":"Error Handling","text":"<pre><code>from archipy.models.errors import (\n    AlreadyExistsError,\n    NotFoundError,\n    InternalError\n)\n\ntry:\n    user = adapter.get_by_id(User, user_id)\n    if not user:\n        raise NotFoundError(resource_type=\"user\")\nexcept AlreadyExistsError as e:\n    print(f\"User already exists: {e.message}\")\nexcept InternalError as e:\n    print(f\"Database error: {e.message}\")\n</code></pre>"},{"location":"examples/adapters/starrocks/","title":"StarRocks Adapter","text":"<p>This example demonstrates how to use the StarRocks adapter for database operations.</p>"},{"location":"examples/adapters/starrocks/#basic-usage","title":"Basic Usage","text":"<pre><code>from archipy.adapters.starrocks.sqlalchemy.adapters import StarrocksSQLAlchemyAdapter\nfrom archipy.models.entities.sqlalchemy.base_entities import BaseEntity\nfrom sqlalchemy import Column, String, Integer, DateTime\n\n# Define a model\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n    username = Column(String(100), unique=True)\n    email = Column(String(255), unique=True)\n    age = Column(Integer)\n    created_at = Column(DateTime)\n\n# Create adapter\nadapter = StarrocksSQLAlchemyAdapter()\n\n# Create tables\nBaseEntity.metadata.create_all(adapter.session_manager.engine)\n\n# Basic operations\nwith adapter.session() as session:\n    # Create\n    user = User(\n        username=\"john_doe\",\n        email=\"john@example.com\",\n        age=30,\n        created_at=datetime.now()\n    )\n    session.add(user)\n    session.commit()\n\n    # Read\n    user = session.query(User).filter_by(username=\"john_doe\").first()\n    print(user.email)  # john@example.com\n\n    # Update\n    user.age = 31\n    session.commit()\n\n    # Delete\n    session.delete(user)\n    session.commit()\n</code></pre>"},{"location":"examples/adapters/starrocks/#using-transactions","title":"Using Transactions","text":"<pre><code>from archipy.helpers.decorators.sqlalchemy_atomic import starrocks_sqlalchemy_atomic_decorator\n\n@starrocks_sqlalchemy_atomic_decorator\ndef create_user_with_profile(username, email, age, profile_data):\n    user = User(username=username, email=email, age=age)\n    adapter.create(user)\n\n    profile = Profile(user_id=user.test_uuid, **profile_data)\n    adapter.create(profile)\n\n    return user\n</code></pre>"},{"location":"examples/adapters/starrocks/#async-operations","title":"Async Operations","text":"<pre><code>from archipy.adapters.starrocks.sqlalchemy.adapters import AsyncStarrocksSQLAlchemyAdapter\nfrom archipy.helpers.decorators.sqlalchemy_atomic import async_starrocks_sqlalchemy_atomic_decorator\n\nasync def main():\n    adapter = AsyncStarrocksSQLAlchemyAdapter()\n\n    @async_starrocks_sqlalchemy_atomic_decorator\n    async def create_user_async(username, email, age):\n        user = User(username=username, email=email, age=age)\n        return await adapter.create(user)\n\n    user = await create_user_async(\"jane_doe\", \"jane@example.com\", 28)\n    print(user.username)  # jane_doe\n</code></pre>"},{"location":"examples/adapters/starrocks/#error-handling","title":"Error Handling","text":"<pre><code>from archipy.models.errors import (\n    AlreadyExistsError,\n    NotFoundError,\n    InternalError\n)\n\ntry:\n    user = adapter.get_by_id(User, user_id)\n    if not user:\n        raise NotFoundError(resource_type=\"user\")\nexcept AlreadyExistsError as e:\n    print(f\"User already exists: {e.message}\")\nexcept InternalError as e:\n    print(f\"Database error: {e.message}\")\n</code></pre>"},{"location":"examples/adapters/starrocks/#advanced-queries","title":"Advanced Queries","text":"<pre><code># Complex filtering\nusers = adapter.query(User).filter(\n    User.age &gt; 25,\n    User.created_at &gt;= datetime.now() - timedelta(days=30)\n).all()\n\n# Aggregation\nfrom sqlalchemy import func\nage_stats = adapter.query(\n    func.avg(User.age).label('avg_age'),\n    func.max(User.age).label('max_age'),\n    func.min(User.age).label('min_age')\n).first()\n\n# Joins\nfrom sqlalchemy import join\nuser_profiles = adapter.query(User).join(\n    Profile,\n    User.test_uuid == Profile.user_id\n).all()\n</code></pre>"},{"location":"examples/adapters/starrocks/#batch-operations","title":"Batch Operations","text":"<pre><code># Batch insert\nusers = [\n    User(username=f\"user{i}\", email=f\"user{i}@example.com\", age=20+i)\n    for i in range(100)\n]\nadapter.bulk_create(users)\n\n# Batch update\nadapter.query(User).filter(User.age &lt; 30).update(\n    {\"age\": User.age + 1},\n    synchronize_session=False\n)\n</code></pre>"},{"location":"examples/adapters/starrocks/#configuration","title":"Configuration","text":"<pre><code>from archipy.configs.config_template import StarrocksConfig\n\n# Configure StarRocks connection\nconfig = StarrocksConfig(\n    HOST=\"localhost\",\n    PORT=9030,\n    USER=\"root\",\n    PASSWORD=\"password\",\n    DATABASE=\"test_db\"\n)\n\n# Create adapter with custom config\nadapter = StarrocksSQLAlchemyAdapter(config=config)\n</code></pre>"},{"location":"examples/adapters/temporal/","title":"Temporal Adapter","text":"<p>This example demonstrates how to use the Temporal adapter for workflow orchestration and activity execution.</p>"},{"location":"examples/adapters/temporal/#basic-usage","title":"Basic Usage","text":"<pre><code>from typing import Any\nfrom archipy.adapters.temporal import TemporalAdapter, BaseWorkflow, BaseActivity\nfrom archipy.configs.config_template import TemporalConfig\nfrom temporalio import workflow, activity\n\n# Configure Temporal connection with all available settings\ntemporal_config = TemporalConfig(\n    # Connection settings\n    HOST=\"localhost\",\n    PORT=7233,\n    NAMESPACE=\"default\",\n    TASK_QUEUE=\"my-task-queue\",\n\n    # TLS settings (optional - for secure connections)\n    TLS_CA_CERT=\"/path/to/ca.crt\",\n    TLS_CLIENT_CERT=\"/path/to/client.crt\",\n    TLS_CLIENT_KEY=\"/path/to/client.key\",\n\n    # Workflow timeout settings (in seconds)\n    WORKFLOW_EXECUTION_TIMEOUT=300,  # Maximum total workflow execution time\n    WORKFLOW_RUN_TIMEOUT=60,         # Maximum single workflow run time\n    WORKFLOW_TASK_TIMEOUT=30,        # Maximum workflow task processing time\n\n    # Activity timeout settings (in seconds)\n    ACTIVITY_START_TO_CLOSE_TIMEOUT=30,  # Maximum activity execution time\n    ACTIVITY_HEARTBEAT_TIMEOUT=10,       # Activity heartbeat timeout\n\n    # Retry configuration for failed activities\n    RETRY_MAXIMUM_ATTEMPTS=3,        # Maximum number of retry attempts\n    RETRY_BACKOFF_COEFFICIENT=2.0,   # Backoff multiplier between retries\n    RETRY_MAXIMUM_INTERVAL=60        # Maximum interval between retries\n)\n\n# Create adapter\ntemporal = TemporalAdapter(temporal_config)\n\n\n# Define a simple workflow\nclass MyWorkflow(BaseWorkflow[dict, str]):\n    @workflow.run\n    async def run(self, workflow_input: dict) -&gt; str:\n        \"\"\"Main workflow logic.\n\n        Args:\n            workflow_input: Input data for the workflow\n\n        Returns:\n            Result message from the workflow\n        \"\"\"\n        self._log_workflow_event(\"workflow_started\", {\"input\": workflow_input})\n\n        # Execute an activity - configuration is automatically applied from TemporalConfig\n        result = await self._execute_activity_with_retry(\n            process_data_activity,\n            workflow_input\n            # start_to_close_timeout, heartbeat_timeout, retry_policy, task_queue\n            # are automatically set from TemporalConfig if not provided\n        )\n\n        self._log_workflow_event(\"workflow_completed\", {\"result\": result})\n        return f\"Workflow completed: {result}\"\n\n\n# Define a simple activity function\n@activity.defn\nasync def process_data_activity(data: dict) -&gt; str:\n    \"\"\"Process data in an activity.\n\n    Args:\n        data: Input data to process\n\n    Returns:\n        Processed result\n    \"\"\"\n    # Simulate processing\n    import time\n    time.sleep(1)\n    return f\"Processed {len(data)} items\"\n\n\n# Execute workflow\nasync def main():\n    try:\n        # Execute workflow and wait for result\n        result = await temporal.execute_workflow(\n            MyWorkflow,\n            {\"items\": [\"a\", \"b\", \"c\"]},\n            workflow_id=\"my-workflow-123\",\n            task_queue=\"my-task-queue\"\n        )\n        print(f\"Workflow result: {result}\")\n    finally:\n        await temporal.close()\n\n# Run the workflow\nimport asyncio\nasyncio.run(main())\n\n\n## Configuration Override Examples\n\n```python\nfrom datetime import timedelta\nfrom temporalio.common import RetryPolicy\n\nclass ConfigOverrideWorkflow(BaseWorkflow[dict, str]):\n    @workflow.run\n    async def run(self, workflow_input: dict) -&gt; str:\n        \"\"\"Workflow showing how to override default configurations.\"\"\"\n\n        # Override activity timeout for a long-running activity\n        long_result = await self._execute_activity_with_retry(\n            long_running_activity,\n            workflow_input,\n            start_to_close_timeout=timedelta(minutes=10),  # Override default 30 seconds\n            heartbeat_timeout=timedelta(seconds=30)        # Override default 10 seconds\n        )\n\n        # Override retry policy for a critical activity\n        critical_result = await self._execute_activity_with_retry(\n            critical_activity,\n            workflow_input,\n            retry_policy=RetryPolicy(\n                maximum_attempts=10,        # Override default 3 attempts\n                backoff_coefficient=1.5,   # Override default 2.0\n                maximum_interval=timedelta(seconds=30)  # Override default 60 seconds\n            )\n        )\n\n        # Use custom task queue\n        special_result = await self._execute_activity_with_retry(\n            special_activity,\n            workflow_input,\n            task_queue=\"special-workers\"  # Override default task queue\n        )\n\n        # Execute child workflow with custom timeout\n        child_result = await self._execute_child_workflow(\n            ChildWorkflow,\n            {\"parent_data\": workflow_input},\n            execution_timeout=timedelta(minutes=15)  # Override default 5 minutes\n        )\n\n        return f\"All results: {long_result}, {critical_result}, {special_result}, {child_result}\"\n\n\n@activity.defn\nasync def long_running_activity(data: dict) -&gt; str:\n    \"\"\"Activity that takes a long time to complete.\"\"\"\n    # Simulate long-running work\n    await asyncio.sleep(300)  # 5 minutes\n    return f\"Long work completed: {data}\"\n\n\n@activity.defn\nasync def critical_activity(data: dict) -&gt; str:\n    \"\"\"Critical activity that needs more retry attempts.\"\"\"\n    # Simulate critical operation that might fail\n    if random.random() &lt; 0.8:  # 80% failure rate for demo\n        raise Exception(\"Critical operation failed\")\n    return f\"Critical work completed: {data}\"\n\n\n@activity.defn\nasync def special_activity(data: dict) -&gt; str:\n    \"\"\"Activity that runs on special workers.\"\"\"\n    return f\"Special work completed: {data}\"\n\n\nclass ChildWorkflow(BaseWorkflow[dict, str]):\n    @workflow.run\n    async def run(self, workflow_input: dict) -&gt; str:\n        \"\"\"Child workflow with its own logic.\"\"\"\n        return f\"Child workflow processed: {workflow_input['parent_data']}\"\n</code></pre>"},{"location":"examples/adapters/temporal/#environment-based-configuration","title":"Environment-Based Configuration","text":"<p><pre><code>import os\nfrom archipy.configs.config_template import TemporalConfig\n\n# Production configuration\nproduction_config = TemporalConfig(\n    HOST=os.getenv(\"TEMPORAL_HOST\", \"temporal.production.com\"),\n    PORT=int(os.getenv(\"TEMPORAL_PORT\", \"7233\")),\n    NAMESPACE=os.getenv(\"TEMPORAL_NAMESPACE\", \"production\"),\n    TASK_QUEUE=os.getenv(\"TEMPORAL_TASK_QUEUE\", \"production-queue\"),\n\n    # Production TLS settings\n    TLS_CA_CERT=os.getenv(\"TEMPORAL_TLS_CA_CERT\"),\n    TLS_CLIENT_CERT=os.getenv(\"TEMPORAL_TLS_CLIENT_CERT\"),\n    TLS_CLIENT_KEY=os.getenv(\"TEMPORAL_TLS_CLIENT_KEY\"),\n\n    # Production timeout settings (longer timeouts)\n    WORKFLOW_EXECUTION_TIMEOUT=1800,  # 30 minutes\n    WORKFLOW_RUN_TIMEOUT=600,         # 10 minutes\n    ACTIVITY_START_TO_CLOSE_TIMEOUT=120,  # 2 minutes\n\n    # Production retry settings (more aggressive)\n    RETRY_MAXIMUM_ATTEMPTS=5,\n    RETRY_BACKOFF_COEFFICIENT=1.5,\n    RETRY_MAXIMUM_INTERVAL=300  # 5 minutes\n)\n\n# Development configuration\ndevelopment_config = TemporalConfig(\n    HOST=\"localhost\",\n    PORT=7233,\n    NAMESPACE=\"development\",\n    TASK_QUEUE=\"dev-queue\",\n\n    # Development timeout settings (shorter timeouts for faster feedback)\n    WORKFLOW_EXECUTION_TIMEOUT=120,  # 2 minutes\n    WORKFLOW_RUN_TIMEOUT=60,         # 1 minute\n    ACTIVITY_START_TO_CLOSE_TIMEOUT=30,  # 30 seconds\n\n    # Development retry settings (fewer retries for faster failures)\n    RETRY_MAXIMUM_ATTEMPTS=2,\n    RETRY_BACKOFF_COEFFICIENT=2.0,\n    RETRY_MAXIMUM_INTERVAL=30  # 30 seconds\n)\n\n# Select config based on environment\nconfig = production_config if os.getenv(\"ENV\") == \"production\" else development_config\ntemporal = TemporalAdapter(config)\n</code></pre> <pre><code>## Using Atomic Activities\n\nActivities can use atomic transactions for database operations:\n\n```python\nfrom archipy.adapters.temporal import AtomicActivity\nfrom archipy.helpers.decorators.sqlalchemy_atomic import postgres_sqlalchemy_atomic_decorator\nfrom archipy.models.errors import DatabaseQueryError, DatabaseConnectionError\n\n\n# Define an activity with atomic transaction support\nclass UserCreationActivity(AtomicActivity[dict, dict]):\n    def __init__(self, user_service):\n        \"\"\"Initialize with your business logic service.\n\n        Args:\n            user_service: Service containing business logic and repository access\n        \"\"\"\n        super().__init__(user_service, db_type=\"postgres\")\n\n    async def _do_execute(self, activity_input: dict) -&gt; dict:\n        \"\"\"Create user with atomic transaction.\n\n        Args:\n            activity_input: User data to create\n\n        Returns:\n            Created user information\n\n        Raises:\n            DatabaseQueryError: If database operation fails\n            DatabaseConnectionError: If database connection fails\n        \"\"\"\n        try:\n            # Execute business logic with atomic transaction\n            user = await self._call_atomic_method(\"create_user\", activity_input)\n\n            # Additional database operations within the same transaction\n            profile = await self._call_atomic_method(\n                \"create_user_profile\",\n                user.uuid,\n                activity_input.get(\"profile\", {})\n            )\n\n            return {\n                \"user_id\": str(user.uuid),\n                \"username\": user.username,\n                \"profile_id\": str(profile.uuid)\n            }\n        except Exception as e:\n            self._log_activity_event(\"user_creation_failed\", {\n                \"error\": str(e),\n                \"input\": activity_input\n            })\n            raise\n\n\n# Use in workflow\nclass UserOnboardingWorkflow(BaseWorkflow[dict, dict]):\n    @workflow.run\n    async def run(self, workflow_input: dict) -&gt; dict:\n        \"\"\"User onboarding workflow.\n\n        Args:\n            workflow_input: User registration data\n\n        Returns:\n            Onboarding result\n        \"\"\"\n        self._log_workflow_event(\"onboarding_started\")\n\n        # Execute atomic user creation activity\n        user_result = await self._execute_activity_with_retry(\n            UserCreationActivity.execute_atomic,\n            workflow_input[\"user_data\"],\n            start_to_close_timeout=timedelta(seconds=60)\n        )\n\n        # Execute welcome email activity\n        email_result = await self._execute_activity_with_retry(\n            send_welcome_email_activity,\n            {\n                \"user_id\": user_result[\"user_id\"],\n                \"email\": workflow_input[\"user_data\"][\"email\"]\n            }\n        )\n\n        self._log_workflow_event(\"onboarding_completed\", {\n            \"user_id\": user_result[\"user_id\"]\n        })\n\n        return {\n            \"user\": user_result,\n            \"email_sent\": email_result\n        }\n</code></pre></p>"},{"location":"examples/adapters/temporal/#async-operations-with-workers","title":"Async Operations with Workers","text":"<pre><code>from archipy.adapters.temporal import TemporalWorkerManager\nfrom archipy.models.errors.temporal_errors import WorkerConnectionError, WorkerShutdownError\n\n\nasync def run_worker():\n    \"\"\"Start a Temporal worker to execute workflows and activities.\"\"\"\n    worker_manager = TemporalWorkerManager()\n\n    try:\n        # Start worker with workflows and activities\n        worker_handle = await worker_manager.start_worker(\n            task_queue=\"my-task-queue\",\n            workflows=[MyWorkflow, UserOnboardingWorkflow],\n            activities=[UserCreationActivity, process_data_activity, send_welcome_email_activity],\n            max_concurrent_workflow_tasks=10,\n            max_concurrent_activities=20\n        )\n\n        print(f\"Worker started: {worker_handle.identity}\")\n\n        # Keep worker running\n        await worker_handle.wait_until_stopped()\n\n    except WorkerConnectionError as e:\n        print(f\"Failed to start worker: {e}\")\n        raise\n    except WorkerShutdownError as e:\n        print(f\"Worker shutdown error: {e}\")\n        raise\n    finally:\n        # Graceful shutdown\n        await worker_manager.shutdown_all_workers()\n\n\n# Activity with business logic integration\n@activity.defn\nasync def send_welcome_email_activity(data: dict) -&gt; bool:\n    \"\"\"Send welcome email activity.\n\n    Args:\n        data: Email data containing user_id and email\n\n    Returns:\n        True if email sent successfully\n    \"\"\"\n    # This would integrate with your email service\n    print(f\"Sending welcome email to {data['email']}\")\n    return True\n</code></pre>"},{"location":"examples/adapters/temporal/#error-handling","title":"Error Handling","text":"<pre><code>from archipy.models.errors.temporal_errors import (\n    TemporalError,\n    WorkerConnectionError,\n    WorkerShutdownError\n)\nfrom archipy.models.errors import (\n    DatabaseQueryError,\n    DatabaseConnectionError,\n    NotFoundError\n)\n\n\nasync def robust_workflow_execution():\n    \"\"\"Example of proper error handling with Temporal operations.\"\"\"\n    temporal = TemporalAdapter()\n\n    try:\n        # Start workflow with error handling\n        workflow_handle = await temporal.start_workflow(\n            UserOnboardingWorkflow,\n            {\n                \"user_data\": {\n                    \"username\": \"john_doe\",\n                    \"email\": \"john@example.com\",\n                    \"profile\": {\"age\": 30, \"city\": \"New York\"}\n                }\n            },\n            workflow_id=\"user-onboarding-001\",\n            execution_timeout=300,  # 5 minutes\n            run_timeout=120         # 2 minutes per run\n        )\n\n        # Wait for result with timeout\n        result = await workflow_handle.result()\n        print(f\"User onboarded successfully: {result}\")\n\n    except WorkerConnectionError as e:\n        print(f\"Worker connection failed: {e}\")\n        # Handle worker connectivity issues\n        raise\n    except WorkerShutdownError as e:\n        print(f\"Worker shutdown error: {e}\")\n        # Handle worker shutdown issues\n        raise\n    except TemporalError as e:\n        print(f\"Temporal operation failed: {e}\")\n        # Handle other temporal-specific errors\n        raise\n    except (DatabaseQueryError, DatabaseConnectionError) as e:\n        print(f\"Database error in workflow: {e}\")\n        # Handle database errors from activities\n        raise\n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n        raise\n    finally:\n        # Always cleanup\n        await temporal.close()\n\n\n# Activity-level error handling\nclass RobustUserActivity(AtomicActivity[dict, dict]):\n    def __init__(self, user_service, db_type: str = \"postgres\"):\n        super().__init__(user_service, db_type)\n\n    async def _do_execute(self, activity_input: dict) -&gt; dict:\n        \"\"\"Execute with comprehensive error handling.\"\"\"\n        try:\n            return await self._execute_with_atomic(\"process_user_data\", activity_input)\n        except DatabaseQueryError as e:\n            self._log_activity_event(\"database_query_failed\", {\n                \"error\": str(e),\n                \"query_type\": \"user_creation\"\n            })\n            # Re-raise to let Temporal handle retries\n            raise\n        except DatabaseConnectionError as e:\n            self._log_activity_event(\"database_connection_failed\", {\n                \"error\": str(e)\n            })\n            # This might be retryable\n            raise\n        except NotFoundError as e:\n            self._log_activity_event(\"resource_not_found\", {\n                \"error\": str(e)\n            })\n            # This is likely not retryable\n            raise\n        except Exception as e:\n            self._log_activity_event(\"unexpected_error\", {\n                \"error\": str(e),\n                \"error_type\": type(e).__name__\n            })\n            raise\n\n    async def _handle_error(self, activity_input: dict, error: Exception) -&gt; None:\n        \"\"\"Custom error handling for this activity.\"\"\"\n        # Log specific error details\n        self._log_activity_event(\"activity_error_handler\", {\n            \"error_type\": type(error).__name__,\n            \"input_username\": activity_input.get(\"username\", \"unknown\"),\n            \"retry_attempt\": getattr(error, \"attempt_count\", \"unknown\")\n        })\n\n        # Call parent error handler\n        await super()._handle_error(activity_input, error)\n</code></pre>"},{"location":"examples/adapters/temporal/#advanced-configuration","title":"Advanced Configuration","text":"<pre><code>from archipy.adapters.temporal import TemporalAdapter\nfrom temporalio.client import TLSConfig\n\n\nasync def configure_temporal_with_tls():\n    \"\"\"Configure Temporal with TLS and advanced settings.\"\"\"\n    # TLS Configuration (files should exist)\n    temporal_config = TemporalConfig(\n        HOST=\"temporal.example.com\",\n        PORT=7233,\n        NAMESPACE=\"production\",\n        TASK_QUEUE=\"production-queue\",\n        TLS_CA_CERT=\"/path/to/ca.crt\",\n        TLS_CLIENT_CERT=\"/path/to/client.crt\",\n        TLS_CLIENT_KEY=\"/path/to/client.key\",\n        # Retry configuration\n        RETRY_MAXIMUM_ATTEMPTS=5,\n        RETRY_BACKOFF_COEFFICIENT=2.0,\n        RETRY_MAXIMUM_INTERVAL=60,\n        # Timeout configuration\n        WORKFLOW_EXECUTION_TIMEOUT=1800,  # 30 minutes\n        WORKFLOW_RUN_TIMEOUT=600,         # 10 minutes\n        WORKFLOW_TASK_TIMEOUT=30          # 30 seconds\n    )\n\n    temporal = TemporalAdapter(temporal_config)\n\n    try:\n        # Query workflow status\n        workflow_handle = await temporal.get_workflow_handle(\"user-onboarding-001\")\n        description = await workflow_handle.describe()\n\n        print(f\"Workflow status: {description.status}\")\n        print(f\"Started at: {description.start_time}\")\n\n        # Send signal to workflow\n        await temporal.signal_workflow(\n            \"user-onboarding-001\",\n            \"update_user_status\",\n            {\"status\": \"verified\"}\n        )\n\n        # Query workflow for information\n        result = await temporal.query_workflow(\n            \"user-onboarding-001\",\n            \"get_current_status\"\n        )\n        print(f\"Current status: {result}\")\n\n    finally:\n        await temporal.close()\n</code></pre>"},{"location":"examples/adapters/temporal/#testing-with-mocks","title":"Testing with Mocks","text":"<pre><code>import pytest\nfrom unittest.mock import AsyncMock, MagicMock\nfrom archipy.adapters.temporal import TemporalAdapter\n\n\nclass MockTemporalAdapter(TemporalAdapter):\n    \"\"\"Mock Temporal adapter for testing.\"\"\"\n\n    def __init__(self):\n        # Skip the real initialization\n        self.config = MagicMock()\n        self._client = AsyncMock()\n\n    async def execute_workflow(self, workflow, arg=None, **kwargs):\n        \"\"\"Mock workflow execution.\"\"\"\n        # Simulate workflow execution\n        if workflow == UserOnboardingWorkflow:\n            return {\n                \"user\": {\"user_id\": \"test-123\", \"username\": \"test_user\"},\n                \"email_sent\": True\n            }\n        return \"mock_result\"\n\n\n@pytest.mark.asyncio\nasync def test_user_onboarding_workflow():\n    \"\"\"Test user onboarding workflow with mock adapter.\"\"\"\n    mock_temporal = MockTemporalAdapter()\n\n    result = await mock_temporal.execute_workflow(\n        UserOnboardingWorkflow,\n        {\n            \"user_data\": {\n                \"username\": \"test_user\",\n                \"email\": \"test@example.com\"\n            }\n        }\n    )\n\n    assert result[\"user\"][\"username\"] == \"test_user\"\n    assert result[\"email_sent\"] is True\n\n\n# Mock activity for testing\nclass MockUserActivity(AtomicActivity[dict, dict]):\n    def __init__(self):\n        # Initialize with mock logic\n        mock_service = MagicMock()\n        super().__init__(mock_service)\n\n    async def _do_execute(self, activity_input: dict) -&gt; dict:\n        \"\"\"Mock activity execution.\"\"\"\n        return {\n            \"user_id\": \"mock-user-123\",\n            \"username\": activity_input[\"username\"]\n        }\n\n\n@pytest.mark.asyncio\nasync def test_atomic_activity():\n    \"\"\"Test atomic activity with mock.\"\"\"\n    activity = MockUserActivity()\n\n    result = await activity.execute({\n        \"username\": \"test_user\",\n        \"email\": \"test@example.com\"\n    })\n\n    assert result[\"username\"] == \"test_user\"\n    assert \"user_id\" in result\n</code></pre>"},{"location":"examples/adapters/temporal/#best-practices","title":"Best Practices","text":"<ol> <li>Workflow Design: Keep workflows as coordinators - let activities handle business logic</li> <li>Error Handling: Use specific error types and proper error chains</li> <li>Transactions: Use <code>AtomicActivity</code> for database operations requiring consistency or use Atomic decorators</li> <li>Testing: Mock adapters and activities for unit testing</li> <li>Configuration: Use environment-specific configurations for different deployments</li> <li>Monitoring: Leverage workflow logging and error tracking</li> <li>Timeouts: Set appropriate timeouts for workflows and activities</li> <li>Retries: Configure retry policies based on error types and business requirements</li> </ol>"},{"location":"examples/helpers/","title":"Helper Examples","text":"<p>ArchiPy provides a variety of helper utilities to simplify common development tasks.</p>"},{"location":"examples/helpers/#available-helpers","title":"Available Helpers","text":"Helper Type Purpose Example Decorators Function and method enhancements Timing, retry, deprecation Interceptors Communication layer handlers gRPC tracing, rate limiting Metaclasses Custom class behavior Singletons, registries Utils General-purpose utilities Date/time, file, string handlers <p>This documentation is being migrated from Sphinx to MkDocs format. Please check back soon for complete content.</p>"},{"location":"examples/helpers/decorators/","title":"Decorator Examples","text":"<p>This page demonstrates how to use ArchiPy's decorators for common cross-cutting concerns.</p>"},{"location":"examples/helpers/decorators/#retry-decorator","title":"Retry Decorator","text":"<p>The retry decorator automatically retries a function when it encounters specific exceptions.</p> <pre><code>from typing import Any\nimport random\nfrom archipy.helpers.decorators.retry import retry_decorator\nfrom archipy.models.errors import ResourceExhaustedError\nfrom archipy.models.types.language_type import LanguageType\n\n\n# Retry a function that might fail temporarily\n@retry_decorator(\n    max_retries=3,\n    delay=1,\n    retry_on=(ConnectionError, TimeoutError),\n    ignore=(ValueError,),\n    resource_type=\"API\",\n    lang=LanguageType.EN\n)\ndef unreliable_api_call(item_id: int) -&gt; dict[str, Any]:\n    \"\"\"Make an API call that might fail temporarily.\n\n    Args:\n        item_id: The ID of the item to fetch\n\n    Returns:\n        API response data\n\n    Raises:\n        ResourceExhaustedError: If retries are exhausted\n        ValueError: If input validation fails (not retried)\n    \"\"\"\n    if item_id &lt; 0:\n        # This error won't be retried because it's in the ignored list\n        raise ValueError(\"Item ID must be positive\")\n\n    # Simulate random failures\n    if random.random() &lt; 0.7:\n        # This will be retried because ConnectionError is in retry_on\n        raise ConnectionError(\"Temporary network issue\")\n\n    # Success case\n    return {\"id\": item_id, \"name\": f\"Item {item_id}\"}\n\n\ntry:\n    # This call might succeed after retries\n    result = unreliable_api_call(42)\n    print(f\"Request succeeded: {result}\")\nexcept ResourceExhaustedError as e:\n    # This happens when all retries fail\n    print(f\"All retry attempts failed: {e}\")\nexcept ValueError as e:\n    # This happens for input validation failures (not retried)\n    print(f\"Validation error: {e}\")\n</code></pre>"},{"location":"examples/helpers/decorators/#timeout-decorator","title":"Timeout Decorator","text":"<p>The timeout decorator ensures a function doesn't run longer than a specified duration.</p> <pre><code>import time\nfrom typing import Any\nfrom archipy.helpers.decorators.timeout import timeout_decorator\nfrom archipy.models.errors import DeadlineExceededError\n\n\n# Set a timeout for a potentially long-running function\n@timeout_decorator(3)  # 3 seconds timeout\ndef slow_operation(duration: float) -&gt; str:\n    \"\"\"A function that might take too long.\n\n    Args:\n        duration: How long to run in seconds\n\n    Returns:\n        Completion message\n\n    Raises:\n        DeadlineExceededError: If function takes longer than the timeout\n    \"\"\"\n    time.sleep(duration)  # Simulate work\n    return \"Operation completed\"\n\n\ntry:\n    # This will succeed because it completes within the timeout\n    result = slow_operation(2)\n    print(result)  # \"Operation completed\"\n\n    # This will raise a DeadlineExceededError because it exceeds the timeout\n    result = slow_operation(5)\n    print(\"This won't be reached\")\nexcept DeadlineExceededError as e:\n    print(f\"Operation timed out: {e}\")\n</code></pre>"},{"location":"examples/helpers/decorators/#timing-decorator","title":"Timing Decorator","text":"<p>The timing decorator measures and logs the execution time of functions.</p> <pre><code>import time\nfrom typing import List\nfrom archipy.helpers.decorators.timing import timing_decorator\n\n\n# Measure and log how long a function takes to execute\n@timing_decorator\ndef process_data(items: List[int]) -&gt; int:\n    \"\"\"Process a list of items with time measurement.\n\n    Args:\n        items: List of items to process\n\n    Returns:\n        Sum of processed items\n    \"\"\"\n    time.sleep(0.1)  # Simulate processing time\n    return sum(items)\n\n\n# This will log the execution time before returning\nresult = process_data(list(range(100)))\nprint(f\"Result: {result}\")  # Output: Result: 4950\n# The decorator will log something like:\n# INFO - Function 'process_data' executed in 0.103 seconds\n</code></pre>"},{"location":"examples/helpers/decorators/#cache-decorator","title":"Cache Decorator","text":"<p>The TTL cache decorator caches function results with automatic expiration.</p> <pre><code>import time\nfrom typing import Any, Dict\nfrom archipy.helpers.decorators.cache import ttl_cache_decorator\n\n\n# Cache the results of an expensive function\n@ttl_cache_decorator(ttl_seconds=60, maxsize=100)\ndef fetch_user_data(user_id: int) -&gt; Dict[str, Any]:\n    \"\"\"Fetch user data from a slow source with caching.\n\n    Args:\n        user_id: User ID to fetch\n\n    Returns:\n        User data dictionary\n    \"\"\"\n    print(f\"Fetching data for user {user_id}...\")\n    time.sleep(1)  # Simulate slow API call\n    return {\n        \"id\": user_id,\n        \"name\": f\"User {user_id}\",\n        \"email\": f\"user{user_id}@example.com\"\n    }\n\n\n# First call - will execute the function and cache the result\nstart = time.time()\ndata1 = fetch_user_data(123)\nprint(f\"First call took {time.time() - start:.3f} seconds\")\n\n# Second call with same arguments - will use the cached result\nstart = time.time()\ndata2 = fetch_user_data(123)\nprint(f\"Second call took {time.time() - start:.3f} seconds\")\n\n# Different arguments - will execute the function\nstart = time.time()\ndata3 = fetch_user_data(456)\nprint(f\"Different user call took {time.time() - start:.3f} seconds\")\n\n# Clear the cache if needed\nfetch_user_data.clear_cache()\n</code></pre>"},{"location":"examples/helpers/decorators/#sqlalchemy-transaction-decorators","title":"SQLAlchemy Transaction Decorators","text":"<p>These decorators automatically manage database transactions.</p> <pre><code>from typing import Optional\nfrom uuid import UUID\nfrom archipy.helpers.decorators.sqlalchemy_atomic import postgres_sqlalchemy_atomic_decorator\nfrom archipy.models.errors import DatabaseQueryError, DatabaseConnectionError\n\n\n@postgres_sqlalchemy_atomic_decorator\ndef create_user(username: str, email: str) -&gt; User:\n    \"\"\"Create a user in a database transaction.\n\n    All database operations are wrapped in a transaction that\n    will be automatically committed on success or rolled back on error.\n\n    Args:\n        username: User's username\n        email: User's email address\n\n    Returns:\n        The created user object\n\n    Raises:\n        DatabaseQueryError: If the database operation fails\n        DatabaseConnectionError: If the database connection fails\n    \"\"\"\n    try:\n        user = User(username=username, email=email)\n        # Get session from the adapter injected by the decorator\n        session = adapter.get_session()\n        session.add(user)\n        return user\n    except Exception as e:\n        # The decorator handles rolling back the transaction\n        # and converting exceptions to appropriate types\n        raise\n\n\n# For async operations\nfrom archipy.helpers.decorators.sqlalchemy_atomic import async_postgres_sqlalchemy_atomic_decorator\n\n\n@async_postgres_sqlalchemy_atomic_decorator\nasync def update_user_email(user_id: UUID, new_email: str) -&gt; Optional[User]:\n    \"\"\"Update a user's email in an async transaction.\n\n    Args:\n        user_id: UUID of the user\n        new_email: New email address\n\n    Returns:\n        Updated user or None if not found\n\n    Raises:\n        DatabaseQueryError: If the database operation fails\n    \"\"\"\n    try:\n        # Get async session from the adapter injected by the decorator\n        session = adapter.get_session()\n        user = await session.get(User, user_id)\n        if not user:\n            return None\n\n        user.email = new_email\n        return user\n    except Exception as e:\n        # The decorator handles the error conversion and rollback\n        raise\n</code></pre>"},{"location":"examples/helpers/interceptors/","title":"Interceptor Examples","text":"<p>This page demonstrates how to use ArchiPy's interceptors for cross-cutting concerns like logging, tracing, and error handling.</p>"},{"location":"examples/helpers/interceptors/#grpc-interceptors","title":"gRPC Interceptors","text":""},{"location":"examples/helpers/interceptors/#tracing-interceptor","title":"Tracing Interceptor","text":"<p>The tracing interceptor adds request/response tracking to gRPC services:</p> <pre><code>import grpc\nfrom concurrent import futures\nfrom typing import Any, Callable\n\nfrom archipy.helpers.interceptors.grpc.trace import GrpcServerTraceInterceptor\nfrom archipy.models.errors import InternalError\n\n\n# Create a gRPC server with tracing\ndef create_grpc_server(max_workers: int = 10) -&gt; grpc.Server:\n    \"\"\"Create a gRPC server with tracing interceptor.\n\n    Args:\n        max_workers: Maximum worker threads for the server\n\n    Returns:\n        Configured gRPC server instance\n    \"\"\"\n    try:\n        # Initialize the tracing interceptor\n        trace_interceptor = GrpcServerTraceInterceptor()\n\n        # Create the server with the interceptor\n        server = grpc.server(\n            futures.ThreadPoolExecutor(max_workers=max_workers),\n            interceptors=[trace_interceptor]\n        )\n        return server\n    except Exception as e:\n        raise InternalError(error_details=\"Failed to create gRPC server\") from e\n\n\n# Usage\nserver = create_grpc_server()\n# Add your services to the server\n# my_service.add_to_server(server)\n# server.add_insecure_port('[::]:50051')\n# server.start()\n</code></pre>"},{"location":"examples/helpers/interceptors/#fastapi-interceptors","title":"FastAPI Interceptors","text":""},{"location":"examples/helpers/interceptors/#request-logging","title":"Request Logging","text":"<p>Log all incoming requests and responses:</p> <pre><code>from fastapi import FastAPI, Request\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom typing import Awaitable, Callable\n\nfrom archipy.helpers.interceptors.fastapi.logging import RequestLoggingMiddleware\nfrom archipy.helpers.utils.app_utils import AppUtils\nfrom archipy.configs.base_config import BaseConfig\n\n# Create a FastAPI app with request logging\napp = AppUtils.create_fastapi_app()\n\n# Add the logging middleware\napp.add_middleware(RequestLoggingMiddleware)\n\n\n# Example endpoint\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    return {\"item_id\": item_id}\n</code></pre>"},{"location":"examples/helpers/interceptors/#performance-monitoring","title":"Performance Monitoring","text":"<p>Monitor endpoint performance:</p> <pre><code>from fastapi import FastAPI\nfrom typing import Awaitable, Callable, Dict, Any\n\nfrom archipy.helpers.interceptors.fastapi.performance import PerformanceMonitoringMiddleware\nfrom archipy.helpers.utils.app_utils import AppUtils\nfrom archipy.configs.base_config import BaseConfig\n\n# Create a FastAPI app\napp = AppUtils.create_fastapi_app()\n\n# Add the performance monitoring middleware\napp.add_middleware(PerformanceMonitoringMiddleware)\n\n\n# Example endpoint\n@app.get(\"/process\")\nasync def process_data(query: str) -&gt; Dict[str, Any]:\n    # Some processing here\n    return {\"query\": query, \"result\": \"processed\"}\n\n# The middleware will log performance metrics for each request\n# Example log: \"Endpoint GET /process completed in 123.45ms\"\n</code></pre>"},{"location":"examples/helpers/interceptors/#using-multiple-interceptors","title":"Using Multiple Interceptors","text":"<p>Combining multiple interceptors together:</p> <pre><code>import grpc\nfrom concurrent import futures\nfrom fastapi import FastAPI\n\nfrom archipy.helpers.interceptors.grpc.trace import GrpcServerTraceInterceptor\nfrom archipy.helpers.interceptors.fastapi.logging import RequestLoggingMiddleware\nfrom archipy.helpers.interceptors.fastapi.performance import PerformanceMonitoringMiddleware\nfrom archipy.helpers.utils.app_utils import AppUtils\n\n\n# Create a FastAPI app with multiple interceptors\ndef create_fastapi_app() -&gt; FastAPI:\n    app = AppUtils.create_fastapi_app()\n\n    # Add middlewares in order (last added = first executed)\n    app.add_middleware(PerformanceMonitoringMiddleware)\n    app.add_middleware(RequestLoggingMiddleware)\n\n    return app\n\n\n# Create a gRPC server with the tracing interceptor\ndef create_grpc_server() -&gt; grpc.Server:\n    server = grpc.server(\n        futures.ThreadPoolExecutor(max_workers=10),\n        interceptors=[GrpcServerTraceInterceptor()]\n    )\n\n    return server\n</code></pre>"},{"location":"examples/helpers/metaclasses/","title":"Metaclass Examples","text":"<p>This page demonstrates how to use ArchiPy's metaclasses.</p>"},{"location":"examples/helpers/metaclasses/#basic-usage","title":"Basic Usage","text":"<pre><code>from archipy.helpers.metaclasses.singleton import Singleton\n\n# Create a singleton class\nclass Database(metaclass=Singleton):\n    def __init__(self, connection_string=None):\n        self.connection_string = connection_string\n        # Initialize connection\n\n    def query(self, sql):\n        # Execute query\n        pass\n\n# Usage\ndb1 = Database(\"postgresql://localhost:5432/mydb\")\ndb2 = Database()  # No new instance created\n\nprint(db1 is db2)  # True - same instance\nprint(db2.connection_string)  # \"postgresql://localhost:5432/mydb\"\n</code></pre> <p>This documentation is being migrated from Sphinx to MkDocs format. Please check back soon for complete content.</p>"},{"location":"examples/helpers/utils/","title":"Utilities","text":"<p>Examples of ArchiPy's utility functions:</p>"},{"location":"examples/helpers/utils/#datetime_utils","title":"datetime_utils","text":"<p>Work with dates and times consistently:</p> <pre><code>from archipy.helpers.utils.datetime_utils import DatetimeUtils\n\n# Get current UTC time\nnow = DatetimeUtils.get_datetime_utc_now()\n\n# Format for storage/transmission\ndate_str = DatetimeUtils.get_string_datetime_from_datetime(now)\n\n# Parse date string\nparsed = DatetimeUtils.get_datetime_from_string_datetime(date_str)\n\n# Convert to Jalali (Persian) calendar\njalali_date = DatetimeUtils.convert_to_jalali(now)\n\n# Check if date is a holiday in Iran\nis_holiday = DatetimeUtils.is_holiday_in_iran(now)\n</code></pre>"},{"location":"examples/helpers/utils/#jwt_utils","title":"jwt_utils","text":"<p>Generate and verify JWT tokens:</p> <pre><code>import logging\nfrom archipy.helpers.utils.jwt_utils import JWTUtils\nfrom uuid import uuid4\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Generate a user access token\nuser_id = uuid4()\naccess_token = JWTUtils.create_access_token(user_id)\n\n# Generate a refresh token with additional claims\nadditional_claims = {\"user_role\": \"admin\", \"permissions\": [\"read\", \"write\"]}\nrefresh_token = JWTUtils.create_refresh_token(user_id, additional_claims=additional_claims)\n\n# Verify a token\ntry:\n    payload = JWTUtils.verify_access_token(access_token)\n    logger.info(f\"Token valid for user: {payload['sub']}\")\nexcept (InvalidTokenError, TokenExpiredError) as e:\n    logger.exception(f\"Invalid token: {e}\")\n\n# Get token expiration time\nexpiry = JWTUtils.get_token_expiry(access_token)\nlogger.debug(f\"Token expires at: {expiry}\")\n\n# Extract user UUID from token payload\nuser_uuid = JWTUtils.extract_user_uuid(payload)\n</code></pre>"},{"location":"examples/helpers/utils/#password_utils","title":"password_utils","text":"<p>Secure password handling:</p> <pre><code>import logging\nfrom archipy.helpers.utils.password_utils import PasswordUtils\nfrom archipy.models.types.language_type import LanguageType\nfrom archipy.models.errors import InvalidPasswordError\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Hash a password\npassword = \"SecureP@ssword123\"\nhashed = PasswordUtils.hash_password(password)\n\n# Verify password\nis_valid = PasswordUtils.verify_password(password, hashed)\nlogger.info(f\"Password valid: {is_valid}\")\n\n# Generate a secure password that meets policy requirements\nsecure_password = PasswordUtils.generate_password()\nlogger.info(f\"Generated password: {secure_password}\")\n\n# Validate a password against policy\ntry:\n    PasswordUtils.validate_password(password, lang=LanguageType.EN)\n    logger.info(\"Password meets policy requirements\")\nexcept InvalidPasswordError as e:\n    logger.warning(f\"Invalid password: {e.requirements}\")\n\n# Check password against history\npassword_history = [hashed]  # Previous password hashes\ntry:\n    PasswordUtils.validate_password_history(\"NewSecureP@ssword123\", password_history)\n    logger.info(\"Password not previously used\")\nexcept InvalidPasswordError as e:\n    logger.warning(\"Password has been used recently\")\n</code></pre>"},{"location":"examples/helpers/utils/#file_utils","title":"file_utils","text":"<p>Handle files securely:</p> <pre><code>import logging\nfrom archipy.helpers.utils.file_utils import FileUtils\nfrom archipy.models.errors import InvalidArgumentError, OutOfRangeError\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Create a secure link to a file with expiration\ntry:\n    link = FileUtils.create_secure_link(\"/path/to/document.pdf\", minutes=60)\n    logger.info(f\"Secure link: {link}\")\nexcept (InvalidArgumentError, OutOfRangeError) as e:\n    logger.exception(f\"Error creating link: {e}\")\n\n# Validate file name against allowed extensions\ntry:\n    is_valid = FileUtils.validate_file_name(\"document.pdf\")\n    logger.info(f\"File is valid: {is_valid}\")\nexcept InvalidArgumentError as e:\n    logger.exception(f\"Error validating file: {e}\")\n</code></pre>"},{"location":"examples/helpers/utils/#base_utils","title":"base_utils","text":"<p>Validate and sanitize data:</p> <pre><code>import logging\nfrom archipy.helpers.utils.base_utils import BaseUtils\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Sanitize phone number\nphone = BaseUtils.sanitize_iranian_landline_or_phone_number(\"+989123456789\")\nlogger.info(f\"Sanitized phone: {phone}\")  # 09123456789\n\n# Validate Iranian national code\ntry:\n    BaseUtils.validate_iranian_national_code_pattern(\"1234567891\")\n    logger.info(\"National code is valid\")\nexcept Exception as e:\n    logger.exception(f\"Invalid national code: {e}\")\n</code></pre>"},{"location":"examples/helpers/utils/#error_utils","title":"error_utils","text":"<p>Standardized exception handling:</p>"},{"location":"examples/helpers/utils/#app_utils","title":"app_utils","text":"<p>FastAPI application utilities:</p> <pre><code>from archipy.helpers.utils.app_utils import AppUtils, FastAPIUtils\nfrom archipy.configs.base_config import BaseConfig\n\n# Create a FastAPI app with standard config\napp = AppUtils.create_fastapi_app(BaseConfig.global_config())\n\n# Add custom exception handlers\nFastAPIUtils.setup_exception_handlers(app)\n\n\n# Set up CORS\nFastAPIUtils.setup_cors(\n    app,\n    allowed_origins=[\"https://example.com\"]\n)\n</code></pre>"},{"location":"examples/helpers/utils/#string_utils","title":"string_utils","text":"<p>String manipulation utilities:</p>"},{"location":"examples/helpers/utils/#keycloak_utils","title":"keycloak_utils","text":"<p>Authentication and authorization utilities with Keycloak integration:</p> <pre><code>if __name__ == '__main__':\n    import uvicorn\n    from uuid import UUID\n    from archipy.configs.base_config import BaseConfig\n    from archipy.helpers.utils.app_utils import AppUtils\n    from archipy.helpers.utils.keycloak_utils import KeycloakUtils\n    from archipy.models.types.language_type import LanguageType\n    from fastapi import Depends\n\n    # Initialize your app configuration\n    config = BaseConfig()\n    BaseConfig.set_global(config)\n    app = AppUtils.create_fastapi_app()\n\n    # Resource-based authorization for users with role and admin access\n    @app.get(\"/users/{user_uuid}/info\")\n    def get_user_info(user_uuid: UUID, user: dict = Depends(KeycloakUtils.fastapi_auth(\n        resource_type_param=\"user_uuid\",\n        resource_type=\"users\",\n        required_roles={\"user\"},\n        admin_roles={\"superusers\", \"administrators\"},\n        lang=LanguageType.EN,\n    ))):\n        return {\n            \"message\": f\"User info for {user_uuid}\",\n            \"username\": user.get(\"preferred_username\")\n        }\n\n    # Async version for employees with multiple acceptable roles\n    @app.get(\"/employees/{employee_uuid}/info\")\n    async def get_employee_info(employee_uuid: UUID, employee: dict = Depends(KeycloakUtils.async_fastapi_auth(\n        resource_type_param=\"employee_uuid\",\n        resource_type=\"employees\",\n        required_roles={\"employee\", \"manager\", \"user\"},\n        all_roles_required=False,  # User can have any of these roles\n        admin_roles={\"hr_admins\", \"system_admins\"},\n        lang=LanguageType.FA,\n    ))):\n        return {\n            \"message\": f\"Employee info for {employee_uuid}\",\n            \"username\": employee.get(\"preferred_username\")\n        }\n\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre>"},{"location":"examples/helpers/utils/#additional-resources","title":"Additional Resources","text":"<p>For more examples and detailed documentation:</p> <ul> <li>Helpers Overview</li> <li>Utils API Reference</li> <li>Configuration Examples</li> <li>Keycloak Adapter</li> </ul> <p>Note: This page contains examples of using ArchiPy's utility functions. For API details, see the Utils API Reference.</p>"},{"location":"examples/models/protobuf_dtos/","title":"Protobuf DTOs","text":"<p>This guide demonstrates how to use the <code>BaseProtobufDTO</code> class to create Data Transfer Objects that can seamlessly convert between Pydantic models and Google Protocol Buffer messages.</p>"},{"location":"examples/models/protobuf_dtos/#overview","title":"Overview","text":"<p>The <code>BaseProtobufDTO</code> provides a bridge between Pydantic DTOs and Protocol Buffers, enabling:</p> <ul> <li>Bidirectional Conversion: Convert from protobuf messages to Pydantic DTOs and vice versa</li> <li>Type Safety: Maintain type safety throughout the conversion process</li> <li>Dependency Management: Graceful handling when protobuf dependencies are not available</li> <li>Validation: Leverage Pydantic's validation capabilities with protobuf data</li> </ul>"},{"location":"examples/models/protobuf_dtos/#prerequisites","title":"Prerequisites","text":"<p>To use <code>BaseProtobufDTO</code>, you need to install the protobuf extra:</p> <pre><code>pip install archipy[protobuf]\n</code></pre> <p>Or install the protobuf dependency directly:</p> <pre><code>pip install google-protobuf\n</code></pre>"},{"location":"examples/models/protobuf_dtos/#basic-usage","title":"Basic Usage","text":""},{"location":"examples/models/protobuf_dtos/#1-define-your-protobuf-message","title":"1. Define Your Protobuf Message","text":"<p>First, define your protobuf message (e.g., <code>user.proto</code>):</p> <pre><code>syntax = \"proto3\";\n\npackage user;\n\nmessage User {\n  string id = 1;\n  string username = 2;\n  string email = 3;\n  string first_name = 4;\n  string last_name = 5;\n  bool is_active = 6;\n  int64 created_at = 7;\n}\n</code></pre>"},{"location":"examples/models/protobuf_dtos/#2-generate-python-code","title":"2. Generate Python Code","text":"<p>Generate the Python protobuf code:</p> <pre><code>protoc --python_out=. user.proto\n</code></pre> <p>This creates <code>user_pb2.py</code> with your <code>User</code> message class.</p>"},{"location":"examples/models/protobuf_dtos/#3-create-your-dto","title":"3. Create Your DTO","text":"<pre><code>from datetime import datetime\nfrom typing import ClassVar\n\nfrom archipy.models.dtos.base_protobuf_dto import BaseProtobufDTO\nfrom user_pb2 import User as UserProto\n\n\nclass UserProtobufDTO(BaseProtobufDTO):\n    \"\"\"User DTO that can convert to/from protobuf messages.\"\"\"\n\n    # Specify the protobuf message class\n    _proto_class: ClassVar[type[UserProto] | None] = UserProto\n\n    id: str\n    username: str\n    email: str\n    first_name: str\n    last_name: str\n    is_active: bool\n    created_at: datetime\n</code></pre>"},{"location":"examples/models/protobuf_dtos/#4-convert-between-formats","title":"4. Convert Between Formats","text":"<pre><code># Create a protobuf message\nproto_user = UserProto(\n    id=\"123\",\n    username=\"john_doe\",\n    email=\"john@example.com\",\n    first_name=\"John\",\n    last_name=\"Doe\",\n    is_active=True,\n    created_at=int(datetime.now().timestamp())\n)\n\n# Convert protobuf to DTO\nuser_dto = UserProtobufDTO.from_proto(proto_user)\nprint(f\"User: {user_dto.first_name} {user_dto.last_name}\")\nprint(f\"Email: {user_dto.email}\")\n\n# Convert DTO back to protobuf\nconverted_proto = user_dto.to_proto()\nassert converted_proto.id == proto_user.id\n</code></pre>"},{"location":"examples/models/protobuf_dtos/#advanced-usage","title":"Advanced Usage","text":""},{"location":"examples/models/protobuf_dtos/#custom-field-mapping","title":"Custom Field Mapping","text":"<p>You can customize field mapping by overriding the conversion methods:</p> <pre><code>from datetime import datetime\nfrom typing import ClassVar\n\nfrom archipy.models.dtos.base_protobuf_dto import BaseProtobufDTO\nfrom user_pb2 import User as UserProto\n\n\nclass UserProtobufDTO(BaseProtobufDTO):\n    \"\"\"User DTO with custom field mapping.\"\"\"\n\n    _proto_class: ClassVar[type[UserProto] | None] = UserProto\n\n    id: str\n    username: str\n    email: str\n    first_name: str\n    last_name: str\n    is_active: bool\n    created_at: datetime\n\n    @classmethod\n    def from_proto(cls, request: UserProto) -&gt; \"UserProtobufDTO\":\n        \"\"\"Custom conversion from protobuf with field mapping.\"\"\"\n        # Convert timestamp to datetime\n        created_at = datetime.fromtimestamp(request.created_at)\n\n        return cls(\n            id=request.id,\n            username=request.username,\n            email=request.email,\n            first_name=request.first_name,\n            last_name=request.last_name,\n            is_active=request.is_active,\n            created_at=created_at\n        )\n\n    def to_proto(self) -&gt; UserProto:\n        \"\"\"Custom conversion to protobuf with field mapping.\"\"\"\n        return UserProto(\n            id=self.id,\n            username=self.username,\n            email=self.email,\n            first_name=self.first_name,\n            last_name=self.last_name,\n            is_active=self.is_active,\n            created_at=int(self.created_at.timestamp())\n        )\n</code></pre>"},{"location":"examples/models/protobuf_dtos/#nested-dtos","title":"Nested DTOs","text":"<p>For complex nested structures:</p> <pre><code>from typing import ClassVar, List\n\nfrom archipy.models.dtos.base_protobuf_dto import BaseProtobufDTO\nfrom user_pb2 import User as UserProto, UserList as UserListProto\n\n\nclass UserProtobufDTO(BaseProtobufDTO):\n    \"\"\"User DTO.\"\"\"\n\n    _proto_class: ClassVar[type[UserProto] | None] = UserProto\n\n    id: str\n    username: str\n    email: str\n\n\nclass UserListProtobufDTO(BaseProtobufDTO):\n    \"\"\"List of users DTO.\"\"\"\n\n    _proto_class: ClassVar[type[UserListProto] | None] = UserListProto\n\n    users: List[UserProtobufDTO]\n    total_count: int\n\n    @classmethod\n    def from_proto(cls, request: UserListProto) -&gt; \"UserListProtobufDTO\":\n        \"\"\"Convert from protobuf with nested DTOs.\"\"\"\n        users = [UserProtobufDTO.from_proto(user) for user in request.users]\n\n        return cls(\n            users=users,\n            total_count=request.total_count\n        )\n\n    def to_proto(self) -&gt; UserListProto:\n        \"\"\"Convert to protobuf with nested DTOs.\"\"\"\n        users = [user.to_proto() for user in self.users]\n\n        return UserListProto(\n            users=users,\n            total_count=self.total_count\n        )\n</code></pre>"},{"location":"examples/models/protobuf_dtos/#error-handling","title":"Error Handling","text":"<p>The <code>BaseProtobufDTO</code> includes built-in error handling:</p> <pre><code># When protobuf is not installed\ntry:\n    user_dto = UserProtobufDTO(id=\"123\", username=\"test\")\nexcept RuntimeError as e:\n    print(f\"Protobuf not available: {e}\")\n    # Handle gracefully - maybe use regular DTOs\n\n# When _proto_class is not set\nclass IncompleteProtobufDTO(BaseProtobufDTO):\n    id: str\n    # Missing _proto_class\n\ntry:\n    dto = IncompleteProtobufDTO(id=\"123\")\n    proto = dto.to_proto()  # Raises NotImplementedError\nexcept NotImplementedError as e:\n    print(f\"Proto class not configured: {e}\")\n</code></pre>"},{"location":"examples/models/protobuf_dtos/#best-practices","title":"Best Practices","text":""},{"location":"examples/models/protobuf_dtos/#1-always-set-_proto_class","title":"1. Always Set <code>_proto_class</code>","text":"<pre><code>class GoodProtobufDTO(BaseProtobufDTO):\n    _proto_class: ClassVar[type[YourProto] | None] = YourProto\n    # ... fields\n\nclass BadProtobufDTO(BaseProtobufDTO):\n    # Missing _proto_class - will raise NotImplementedError\n    pass\n</code></pre>"},{"location":"examples/models/protobuf_dtos/#2-handle-optional-dependencies","title":"2. Handle Optional Dependencies","text":"<pre><code>try:\n    from archipy.models.dtos.base_protobuf_dto import BaseProtobufDTO\n    PROTOBUF_AVAILABLE = True\nexcept ImportError:\n    PROTOBUF_AVAILABLE = False\n\nif PROTOBUF_AVAILABLE:\n    BaseClass = BaseProtobufDTO\nelse:\n    BaseClass = BaseDTO  # Fallback to regular DTO\n</code></pre>"},{"location":"examples/models/protobuf_dtos/#3-use-type-annotations","title":"3. Use Type Annotations","text":"<pre><code>from typing import ClassVar\n\nclass UserProtobufDTO(BaseProtobufDTO):\n    _proto_class: ClassVar[type[UserProto] | None] = UserProto\n    # Always use proper type annotations\n</code></pre>"},{"location":"examples/models/protobuf_dtos/#4-validate-data","title":"4. Validate Data","text":"<pre><code>from pydantic import Field\n\nclass UserProtobufDTO(BaseProtobufDTO):\n    _proto_class: ClassVar[type[UserProto] | None] = UserProto\n\n    id: str = Field(..., description=\"User unique identifier\")\n    email: str = Field(..., description=\"User email address\")\n\n    # Pydantic validation will run during conversion\n</code></pre>"},{"location":"examples/models/protobuf_dtos/#integration-with-services","title":"Integration with Services","text":""},{"location":"examples/models/protobuf_dtos/#grpc-service-example","title":"gRPC Service Example","text":"<pre><code>from typing import ClassVar\n\nfrom archipy.models.dtos.base_protobuf_dto import BaseProtobufDTO\nfrom user_pb2 import User as UserProto\n\n\nclass UserProtobufDTO(BaseProtobufDTO):\n    _proto_class: ClassVar[type[UserProto] | None] = UserProto\n\n    id: str\n    username: str\n    email: str\n\n\nclass UserService:\n    def create_user(self, user_dto: UserProtobufDTO) -&gt; UserProtobufDTO:\n        # Convert DTO to protobuf for gRPC call\n        proto_user = user_dto.to_proto()\n\n        # Make gRPC call\n        response_proto = self.grpc_client.CreateUser(proto_user)\n\n        # Convert response back to DTO\n        return UserProtobufDTO.from_proto(response_proto)\n\n    def get_user(self, user_id: str) -&gt; UserProtobufDTO:\n        # Make gRPC call\n        proto_user = self.grpc_client.GetUser(user_id)\n\n        # Convert to DTO\n        return UserProtobufDTO.from_proto(proto_user)\n</code></pre>"},{"location":"examples/models/protobuf_dtos/#testing","title":"Testing","text":""},{"location":"examples/models/protobuf_dtos/#unit-tests","title":"Unit Tests","text":"<pre><code>import pytest\nfrom datetime import datetime\n\nfrom archipy.models.dtos.base_protobuf_dto import BaseProtobufDTO\nfrom user_pb2 import User as UserProto\n\n\nclass TestUserProtobufDTO:\n    def test_from_proto(self):\n        # Arrange\n        proto_user = UserProto(\n            id=\"123\",\n            username=\"test_user\",\n            email=\"test@example.com\"\n        )\n\n        # Act\n        user_dto = UserProtobufDTO.from_proto(proto_user)\n\n        # Assert\n        assert user_dto.id == \"123\"\n        assert user_dto.username == \"test_user\"\n        assert user_dto.email == \"test@example.com\"\n\n    def test_to_proto(self):\n        # Arrange\n        user_dto = UserProtobufDTO(\n            id=\"123\",\n            username=\"test_user\",\n            email=\"test@example.com\"\n        )\n\n        # Act\n        proto_user = user_dto.to_proto()\n\n        # Assert\n        assert proto_user.id == \"123\"\n        assert proto_user.username == \"test_user\"\n        assert proto_user.email == \"test@example.com\"\n\n    def test_round_trip_conversion(self):\n        # Arrange\n        original_dto = UserProtobufDTO(\n            id=\"123\",\n            username=\"test_user\",\n            email=\"test@example.com\"\n        )\n\n        # Act\n        proto_user = original_dto.to_proto()\n        converted_dto = UserProtobufDTO.from_proto(proto_user)\n\n        # Assert\n        assert converted_dto.id == original_dto.id\n        assert converted_dto.username == original_dto.username\n        assert converted_dto.email == original_dto.email\n</code></pre>"},{"location":"examples/models/protobuf_dtos/#troubleshooting","title":"Troubleshooting","text":""},{"location":"examples/models/protobuf_dtos/#common-issues","title":"Common Issues","text":"<ol> <li>ImportError: No module named 'google.protobuf'</li> <li> <p>Install the protobuf dependency: <code>pip install google-protobuf</code></p> </li> <li> <p>NotImplementedError: Class is not mapped to a proto class</p> </li> <li> <p>Set the <code>_proto_class</code> attribute in your DTO</p> </li> <li> <p>TypeError: ClassVar parameter cannot include type variables</p> </li> <li> <p>Use concrete types instead of type variables in <code>ClassVar</code></p> </li> <li> <p>Validation errors during conversion</p> </li> <li>Ensure your protobuf message fields match your DTO fields</li> <li>Check field types and required/optional status</li> </ol>"},{"location":"examples/models/protobuf_dtos/#debug-tips","title":"Debug Tips","text":"<pre><code># Enable debug logging\nimport logging\nlogging.basicConfig(level=logging.DEBUG)\n\n# Check protobuf availability\nfrom archipy.models.dtos.base_protobuf_dto import PROTOBUF_AVAILABLE\nprint(f\"Protobuf available: {PROTOBUF_AVAILABLE}\")\n\n# Validate DTO structure\nuser_dto = UserProtobufDTO(id=\"123\", username=\"test\")\nprint(user_dto.model_dump())\n</code></pre>"}]}